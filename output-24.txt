I actually already use VCSCommand, and it's definitely been more reliable than scmdiff for getting diffs (eg if I'm in a directory of checked out code that I got to through a symlink from another set of checked out code), however, so I guess I need to combine the methods from VCSCommand for getting diffs with the methods from scmdiff for displaying them... I definitely agree on using aliases (I was led to believe by a guy working at Informix that there's a performance increase in this even when there's only one table in the query).However, omitting the join to customerkey will only always result in the same rows returned iff contact_history.customerkey cannot be null. If it's nullable, then the original query would only return contact_history rows that are linked to a row in customers; the suggested replacement would return all rows in contact_history. It is up to Shalma which is correct for this situation. Because it caught me out, I'd like to add my $0.02:the important step is to unset $IFS before printing $FOOJOINIf you fail to do so, you still get whitespace separation. If your system is POSIX compliant, you can substitute `-not` with `!`Further, if the string you are seeking is always surrounded by non-word characters (including newline), you may be able to use the `-w` switch to grep [NB: this switch is not specified by POSIX, so YMMV]. I'd also use the `-H` flag for grep to ensure it prints the filename:`find . ! -iname "*.jpeg" ! -iname "*.jpg" ! -iname "*.png" -exec grep -Hw B206 {} \;` WRT running `git status` to ensure you're within a repository: this has one gotcha: if you have the environment variable $GIT_DIR set in your current shell, git will ignore your current location and use the repository at $GIT_DIR. I should know, I lost an hour to that yesterday. `find -L / -iname macports -type d` should do the trick, no? Awesome question! I learnt a lot answering this. You're right -- that will leave COMP_WORDBREAKS in that state. I'll find a solution and update. I've not forgotten about this! I've not had a proper chance to crack it yet, but I've got some ideas. Thanks for awarding my as-yet incomplete answer -- as soon as I find the right solution it will be on here. What you can do is always work on a local-only branch in git, then you can cherry-pick commits from that branch onto the git branch that tracks your svn branch. I've used this exact workflow in the past. The $COMP_WORDBREAKS variable isn't used by readline, but is an variable used by the bash-completion module's inner workings; as such, it's only really relevant to what goes on inside _get_cword and _get_pword. @UsAaR33 : the more I look into this, the more I'm coming to the conclusion that there is no trivial way to do this, without completely replacing the inner workings of bash-completion. I've done some much deeper digging but cannot find why, if you ensure that $COMP_WORDBREAKS is re-set at the end of the custom completion function, it will not split on the @. I did not know this! Thanks for the tip! If any sub-directories (or files) happen to contain $BASE, sed will also remove that... Like in the given example... Mind: blown. Thanks! The answer [here](http://stackoverflow.com/questions/1063497/hidden-features-of-erlang) is really useful for a list of some shell commands I've never seen documented anywhere else... Could you give us more details of why you want to use quickfix list? It has a fairly specific purpose... Your suggested replacement will not work as `cat` will wait indefinitely for an `EOF` on its `stdin`, which it will not receive. Also, your explanation isn't quite right - the LHS of the **pipe** is executed in a subshell. Otherwise, `{ mkdir dir; cd dir; pwd; } | {cat; pwd;}` would result in the same `$PWD` for both `pwd` invocations. If you're just using vim to view the output of another command, might I be so bold as to suggest using `less -R`? This will use less as a pager, allowing you to capture the output and page back/forwards and, with the `-R` flag, will display ANSI colour sequences (the extra characters you are seeing) Just a general comment @BABUK: it's much better, if you answer your own question, to post the answer rather than edit the question. It's clearer for others who may have the same question how to solve it and you get more points for it! It's perfectly reasonable to accept your own answer... The question is unclear - could you provide some sample values for the variables/records here please? Sorry, but I'm still unclear on what you are trying to do here. Is `sched_ents` a variable? Perhaps you mean something like: `[ X || X <- Sched_ents, X#l1_dl_se.dci =:= l1_format0 ]` which will return only the elements in Sched_ents which have the `dci` field with value `'l1_format0'`. If `#l1_dl_se.dci` is an actual record (not the name of a record) then you can use `is_record(X#l1_dl_se.dci, l1_format0)` If it fixes the problem, could you accept the answer please? :-) Where has this command been all my life?! `-name` takes a glob match, not a regular expression. An important distinction... Do you have any plugins installed? Prompting for input for simply opening a file is not, as far as I'm aware, standard (g)vim behaviour. Ah, then it definitely won't work for you. Guess the `$(REPO_PATH)` variable format should have clued me in... Incidentally (and almost entirely unrelated), `:g/pattern/do something` is where `grep` got its name: `g/regular-expression/print` -> `g/re/p`. +1 The erlang/thrift mashup is a vile, hateful scourge upon this earth. Incidentally, if you're learning erlang, I can't recommend http://learnyousomeerlang.com/content enough. It's an invaluable and informative guide to learn from. FWIW, you can include newline in a character class with `\_` prefix, e.g. `:%s/^#if GGSDEBUG\_.\{-}#endif//g` is equivalent. <3 vimgolf You also asked for resources: try LearnYouSomeErlang.com (Lists section: http://learnyousomeerlang.com/starting-out-for-real#lists) You don't mention this in your question: is a file a match if it contains all of the words, or is it a match even if only contains any one of them? @fedorqui: also you'd then have to split out the filenames and sizes before the for loop... Ah yes, that might also help... You're right, although in this case the ±4KB difference becomes negligible as we're only dealing with files over 100MB... ;-) I'm genuinely surprised `zsh` doesn't have this as a built-in option! @CharlesDuffy: you're right! I've obviously been using `zsh` for too long... You're welcome! @chim which `-x` switch? Thanks for the edit @Greg FWIW, if you're dealing with a 2m line logfile, VIM might not be what you want. Try a pager such as `less`. TIL for 12 years I've been doing this wrong! I propose a second anti-pattern: UUoX...`find . -name "*.c" -exec wc -l {} +` will correctly cater for whitespace-containing filenames and pass *all* filenames to `wc -l`, giving you per-file sum and grand total at the end. TIL 32000 file argument limit to `-exec cmd {} +` For more advanced information on the topic of how erlang is used to build massive chat systems, check out Rick Reed's (from Whatsapp) from Erlang Factory San Francisco 2014: http://www.erlang-factory.com/sfbay2014/rick-reed (slides and video linked from here) Hi @Ivã, I'm glad you found my answer useful! Putting together scripts to simplify repetitive tasks is a great way to learn programming. Keep going, don't be afraid to experiment and, above all, enjoy it! Is there anything in particular you'd like some help with in my answer? @Zen did you manage to find the problem in the end? @Zen thanks for the bounty! What about a folder owned by user 'SteveTheDog' but containing files owned by 'BobTheCat'? The size of those files would be missed by this, would it not? Just to be safe, you probably want to do `| grep 'total$'` instead of `| tail -1`. Find has an args-list length limit which, if breached, will cause find to split the list of matching directories and execute multiple times. Might not be relevant if there are not many directories, but if it's a large filesystem, it could yield unexpected results. Further to `Vi%:` you can do e.g. `Vi{`, `Vi(` to pick *which* matching brackets you select between (if you have nested structures). Also works with quotes. @dwanderson you're right - I meant *reset*. If you skip the `IFS=$OLD_IFS` step, `echo $foojoin` will give you `a b c`. @AndreasGrech `ZZ` is synonymous with `:x`, not `:wq`. Nit-picky, I know, but the difference is important if you ever need to care about last-modified timestamps of files, as `:x` (and `ZZ`) will only modify the file if it changed. `:wq` forces a write. @void-pointer every aspect of what is displayed in terminal vim's tab header is controlled by the `tabline` setting. See `:h setting-tabline` for full details. *NB:* This does not control the GUI tabline. @MartinKonecny `less` may be more, but `less` is not [`more`](https://en.wikipedia.org/wiki/More_(command)) let alone [`most`](https://en.wikipedia.org/wiki/Most_(Unix)) Turtles all the way down! @JonathanM. you're very welcome! Follow-up with working example: http://stackoverflow.com/questions/32200352/buffer-size-in-erlang-golang-port-example You can also set the environment variable LESSI use LESS=-Ri, so that I can pump colorized output from grep into it, and maintain the ANSI colour sequences.Another little used feature of less that I found is starting it with +F as an argument (or hitting SHIFT+F while in less). This causes it to follow the file you've opened, in the same way that tail -f &lt;file&gt; will. Very handy if you're watching log files from an application, and are likely to want to page back up (if it's generating 100's of lines of logging every second, for instance). I've always wanted to be able to get a reasonably elegant way of getting vimdiff to work with a CVS controlled file. I've found numerous (somewhat hacky) scripts around the internet (best example here) that basically check out the file you are editing from CVS to a temp file, and vimdiff the two. None of these take into account branches, and always assume you're working from MAIN, which for me is completely useless. So, my question is this: has anyone out there found a decent solution for this that does more than this script?Or failing that, does anyone have any ideas of how they would implement this, or suggestions for what features you would consider vital for something that does this? My intention is that, if no one can suggest an already built solution to either use or build from, we start building one from here.  @Greg Hewgill:thanks for the script! I had a couple of issues with it though, so here's what I'd change:line 21:&lt; map &lt;silent&gt; &lt;C-d&gt; :call &lt;SID&gt;scmToggle()&lt;CR&gt;--&gt; map &lt;silent&gt; &lt;C-h&gt; :call &lt;SID&gt;scmToggle()&lt;CR&gt;I use Ctrl-d for page-down (too lazy to move all that way over to PdDn), so had to switch to Ctrl-h.line 112:&lt; let cmd = 'cd ' . g:scmBufPath . ' &amp;&amp; ' . g:scmDiffCommand . ' diff ' . g:scmDiffRev . ' ' . expand('%:p') . ' &gt; ' . tmpdiff--&gt; if g:scmDiffUseAbsPaths &gt; let cmd = 'cd ' . g:scmBufPath . ' &amp;&amp; ' . g:scmDiffCommand . ' diff ' . g:scmDiffRev . ' ' . expand('%:p') . ' &gt; ' . tmpdiff&gt; else&gt; let cmd = g:scmDiffCommand . ' diff ' . g:scmDiffRev . ' ' . bufname('%') . ' &gt; ' . tmpdiff&gt; endifI had issues with not being able to use absolute paths with CVS. I don't know if this is a weirdness of our local set up here, or if it's a global CVS thing. So, I've made a configurable variable that you can put in your .vimrc to use relative path instead.It now seems to work exactly how I wanted, so I'll keep bashing away and see if I can find anything else that breaks, posting fixes as I go.Edit: Forgot to add: please feel free to add these changes to your script on github if you feel they're worthwhile. Simple Answer:Informix has built in casting, which you can use like this:SELECT telnumberFROM numbers nWHERE n.telnumber::integer BETWEEN 1234 AND 9999;Further:However, as Jonathan Leffler pointed out previously, it sounds like your dataset contains values which aren't necessarily cast-able to integer.If that's so, then perhaps this isn't the ideal schema for your purposes?If you absolutely need to have non-numeric characters in here (eg I suspect you'll end up with one of '-', '(' or ')'), you could try excluding rows that match non-numeric chars:SELECT telnumberFROM numbers nWHERE n.telnumber not matches "*[0-9]*"AND n.telnumber::integer BETWEEN 1234 AND 9999;Alternatively, you could maybe try using a stored procedure, utilising an ON EXCEPTION block? (Character to numeric conversion error is errno 1213).Further reading on using 'ON EXCEPTION': http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.sqls.doc/sqls946.htmFurther reading on defining and using stored procedures: http://publib.boulder.ibm.com/infocenter/idshelp/v10/index.jsp?topic=/com.ibm.sqls.doc/sqls906.htm Unless I've overlooked something, the -path switch to find compares the pattern given to the path including the filename.Ergo, your -path "\.?.*" switch will match the hidden files ".t1" etc.FWIW: in the version of find that I have (v4.4.2), the argument to -path is a shell pattern, not a regex. However, I use bash and have never used csh, so perhaps that makes a difference too.EDIT: I tried to add this as a comment, but it keeps destroying the formatting.You could use this to achieve what (I think) you are trying to achieve:find . \( \( -path "\.?.*" -type d \) -o -path "*normal*" \) -prune -o \( -type f \) -print As Mattias Ahnberg pointed out, this use of find will generate the entire list of matching files before zip gets invoked. If you're doing this over 50,000 files, that will take some time. Perhaps a more suitable approach would be to use find's -exec &lt;cmd&gt; {} \; feature:find "$DIR" -name "$USERINPUT" -exec /usr/bin/zip -1 {} \;This way, find invokes zip itself on each matching file. You should achieve the same end result as your original version, but if the sheer number of files is your bottleneck (which, if the files are all small, is most likely), this will kick off running zip as soon as it starts finding matches, rather than when all matches have been found.NB: I recommend reading the man page for find for details of this option. Note that the semi-colon must be escaped to prevent your shell interpreting it rather than passing it to find. find has an -exec switch, allowing you to pass any matched filenames to an external command:find $1 -name $2 -type -mmin +$3 -exec ls -1t [-r] {} +With this, find will pass all of the matching files at once to ls and allow that to do the sorting for you. With the optional -r flag, files will be printed in order of oldest to newest; without, in order of newest to oldest. As pointed out by Hans Passant and schlenk, you cannot catch an exception from an external application.As you have already observed, catch { cmd } will only inspect return codes.What you can do with catch, however, is capture all the output in a variable by doing:catch {exec asdf.exe args} err_msgThis will set the output from the command as variable $err_msg.catch also conveniently returns a 1 iff the command returns a non-zero code, allowing you to do the following:if {[catch {exec asdf.exe args} err_msg]} { # inspect your output in $err_msg here;} else { # successful execution aftermath here;}[NB: Incidentally, should the command return a 0, $err_msg still contains the output from the command.]Assuming your external application prints something sensible on exception, you should be able to inspect what gets printed and react accordingly. In order to achieve this, you could add the following to your .vimrc (a simple-minded modification from the example found by running :h diffexpr within vim):set diffexpr=MyDiff()function! MyDiff() let opt = "" if exists("g:diffignore") &amp;&amp; g:diffignore != "" let opt = "-I " . g:diffignore . " " endif if &amp;diffopt =~ "icase" let opt = opt . "-i " endif if &amp;diffopt =~ "iwhite" let opt = opt . "-b " endif silent execute "!diff -a --binary " . opt . v:fname_in . " " . \ v:fname_new . " &gt; " . v:fname_outendfunctionIt's noteworthy that the functionality provided by the -I (or --ignore-matching-lines=) switch for diff will ONLY ignore any changed lines where the line in BOTH (or all) files matches this expression.See man diff for more details on the --ignore-matching-lines=RE switch and :h diffexpr within vim for more details on this.EDIT: Added the optional variable g:diffignore to control what pattern to use. Also used function! to force replacement on definition. As mentioned in comments, you can use dp or do to move the diff the cursor is on between the buffers.You can also use the commands :[range]diffget and :[range]diffput, meaning if you've already reviewed all differences in the whole file, you can do :1,$diffput or :1,$diffget to move all diffs from or to, respectively, the current buffer. DISCLAIMER: I've not used perforce, so I've had to make an assumption: that when multiple files have uncommitted changes, it will behave like a lot of VCS's and run the configured diff command (in this case, vimdiff) on each changed file in turn (I'm thinking this is what you meant by "opens one by one vimdiff of all changed files").If this is the case, then vim won't have any references to any of the remaining files when viewing the changes for any particular file, so no amount of trickery within a single vim session is going to help you.If you are willing to change your workflow at all, you may be able to do something with this vim script I found: http://www.vim.org/scripts/script.php?script_id=240It claims to be modelled after the P4 GUI, so hopefully could fit neatly into your usage. From the overview of the script, it sounds like it should be able to show you a summary of which files have changed and allow you to view the changes.If none of this is suitable for you, you could always try the old favourite Ctrl-C immediately after closing a vimdiff session for a file. So, this intrigued me, so I've been reading through the bash completion source (available at /etc/bash_completion).I came across this variable: ${COMP_WORDBREAKS}, which appears to allow control over what characters are used to delimit words.I also came across this function, _get_cword and the complementary _get_pword, both recommended for use in place of ${COMP_WORDS[COMP_CWORD]} and ${COMP_WORDS[COMP_CWORD-1]} respectively.So, putting all this together, I did some testing and here's what I've come up with: this seems to work for me, at least, hopefully it will for you too:# maintain the old value, so that we only affect ourselves with thisOLD_COMP_WORDBREAKS=${COMP_WORDBREAKS}COMP_WORDBREAKS="${COMP_WORDBREAKS}@"cur="$(_get_cword)"prev="$(_get_pword)"if [[ "$cur" == '=@' ]]; then COMPREPLY=( $(compgen -f ${cur:2}) ) # restore the old value COMP_WORDBREAKS=${OLD_COMP_WORDBREAKS} return 0fiif [[ "$prev" == '=@' ]]; then COMPREPLY=( $(compgen -f ${cur}) ) # restore the old value COMP_WORDBREAKS=${OLD_COMP_WORDBREAKS} return 0fiNow, I'll admit that the split if cases are a little dirty, there's definitely a better way to do it but I need more caffeine.Further, for whatever it's worth to you I also discovered along the way the -P &lt;prefix&gt; argument to compgen, which would prevent you from having to loop over the $COMPREPLY[*]} array after calling compgen, like soCOMPREPLY=( $(compgen -P @ -f ${cur:1}) )That's a little redundant in the face of a full solution, though. For grabbing the text from the HTML into a file:If your version of grep supports it, the -o switch tells it to only print the matched portion of the line.With this in mind, 2 grep invocations should sort you out (provided you can identify uniquely ONLY the lines you wish to grab the text for); something like this: grep -Rn "var topicName =" html/ | grep -o '"[^"]*"' &gt; topicNames.datIf it's unacceptable to leave the " symbols in there, you could pass it via sed after the second grep:grep -Rn "var topicName =" html/ | grep -o '"[^"]*"' | sed 's/"//g' &gt; topicNames.dat There's nothing wrong with a simplefind ~/test -mindepth 1Similarly, this will have the same effect:find ~/test/*as it matches everything contained within ~/test/ but not ~/test itself.As an aside, you'll almost certainly find that find will complain about the -mindepth n option being after any other switches, as ordering is normally important but the -(min|max)depth n switches affect overall behaviour. I also use the same vimerl plugin for erlang development in vim. However, I had to make a small change to it to make some improvements to the way it compiles for checking.Once I'd made these changes, writing the file (e.g. with :w) caused vimerl to compile that source file and put the warnings/errors in the quickfix list (exactly the same way that :make would do if you had a Makefile in place).FWIW, I also have the following configuration in my vimrc:let g:erlangHighlightErrors = 1let g:erlangHighlightBif = 1let g:erlangCompletionDisplayDoc = 1let g:erlangWranglerPath = "/usr/local/share/wrangler"let g:erlangRefactoring = 1 I use the following in my $PS1: PS1="\`if [ \$? = 0 ]; then echo \[\e[33m\]^_^\[\e[0m\]; else echo \[\e[31m\]\$? O_O\[\e[0m\]; fi\`"Src: https://github.com/sanmiguel/dotfiles/blob/master/bash/bash_functions.symlink#L63 Based on the comments, I think you're looking for something like this:case [ X || X &lt;- Sched_ents, is_record(X, l1_dl_se), is_record(X#l1_dl_se.dci, l1_format0)] of [] -&gt; 2; %% none found _List -&gt; 1 %% One or more foundendThe list comprehension gives you a list of strictly only those elements in Sched_ents which are a #l1_dl_se record, and which contain a #l1_format0 record. You can solve this with parentheses:find "DIRECTORY" -type f \( -name \*.jpg -o -name \*.html \) -mtime +95find operators are evaluated in order of precedence. From the manual: ( expr ) Force precedence. Since parentheses are special to the shell, you will normally need to quote them. Many of the examples in this manual page use backslashes for this purpose: `\(...\)' instead of `(...)'. expr1 expr2 Two expressions in a row are taken to be joined with an implied "and"; expr2 is not evaluated if expr1 is false. expr1 -o expr2 Or; expr2 is not evaluated if expr1 is true. If you want more than just the last few lines of output, as well as following, you can invoke:less +F $file(or press Shift-F while viewing the file in less).While following the file in less, press Ctrl-C to stop following but keep the file open, then Shift-F to follow again. As an alternative, if you're using bash, you could turn on extglob mode.shopt -s extglobThis would allow you to do (from within $(REPO_DIR)):find !(.git) -type dSee this answer for full details: https://stackoverflow.com/a/217017/24 You can almost certainly do this with powerline. It's a hugely configurable utility that can be used in vim to give you a really powerful statusline, as well as in bash/zsh for powerful prompt display.Here's what mine looks like (stock configuration), showing the following info:{normal mode active} | BR: {current git branch} | {filename}I'm certain there'll be a way to get status for the current buffer's file in there... From man zshoptions: BANG_HIST (+K) Perform textual history expansion, csh-style, treating the character `!' specially.Putting setopt -K after the source $ZSH/oh-my-zsh.sh line in your .zshrc should prevent it from expanding any !~ sequences (or any other ! sequence) in commands. appmon looks to have been removed, in favour of the new observer application. See the note here. There seems to be precious little online documentation on why, but presumably the docs included in your erlang installation would at least help you find how to use it. What happened to lists:zipwith/2?Assumptions:lists are the same lengthlists contain the same keys in the same orderlists:zipwith(fun({X, Y}, {X, Z}) -&gt; {X, [Y, Z]} end, L1, L2). You should simply be able to pass $file_list to du:du -ch $file_list | tail -1 | cut -f 1du options:-c display a total-h human readable (i.e. 17M)du will print an entry for each file, followed by the total (with -c), so we use tail -1 to trim to only the last line and cut -f 1 to trim that line to only the first column. Assuming your version of grep supports -o:grep -o '^[0-9.]\+' data.inNB: This will match any sequence of digits and decimal points at the start of the line. Not directly with bash, but xmllint is fairly widely available.xmllint --format "${xmlfile}"This will exit with non-zero status (hint: $? in bash gets you the exit code of the last command) if the xml file is invalid. Simple answer based on the answer you linked (for a given directory, $DIR):find -L $DIR -maxdepth 1 -type l -delete Looks like you'll need to change the 'sessionoptions' value. From :h 'sessionoptions': Changes the effect of the :mksession command. It is a comma separated list of words. Each word enables saving and restoring something: localoptions options and mappings local to a window or buffer (not global values for local options)Ergo::set sessionoptions+=localoptions If you're using vim on OSX, you can add the following to your .vimrc:set clipboard+=unnamedOnce you have done this, vim will use the system clipboard to read from by default for pasting. This means that, instead of having to enter insert mode first you can simply use p to paste. It also means that if you yank within vim, it's available to paste elsewhere.I haven't tested this on any other OS, so if anyone has please feel free to add a comment... For whatever it's worth, I've never found a succinct way to do this using ack, but the following works:ack --type-add foo:is:search-this-one.html --foo my-search-stringExplanation:--type-add foo:is:search-this-one.html : this adds (for the duration of this one command) a new type, foo, defined as all files whose name is search-this-one.html--foo : search only files of the type fooAlso, further to @fedorqui et al, you can instead use the -exec cmd {} + option to find, which puts all the matched filenames into the command before running it, eschewing the need for the -H flag:find . -name search-this-one.html -type f -exec grep "my-search-string" {} + As always, in vi there are many ways to skin this particular cat. As has already been stated, a simple solution to exactly this problem is::%s/HERE.*//However, to answer your more general question:  I have done search and replace things in vi, but am not sure how to do a search then run a command.you want the :g[lobal] command: :[range]g[lobal]/{pattern}/[cmd] Execute the Ex command [cmd] (default ":p") on the lines within [range] where {pattern} matches.This would actually be more long-winded for your exact example, but for tasks such as deleting lines that match a specific pattern, it is considerably more concise.e.g. if you wanted to instead delete all lines that contain HERE, you would run::g/HERE/dFactoid: this command form is the origin of grep's name: g/re/p, shorthand for global/{regex}/print. Further to the other answers, if the first thing you do when you open the logfile is jump to the end, have vim open the file straight at the end with:vim /path/to/logfile +Alternatively, as in my comment above, try opening it in a pager such as less if you're not actually editing the file. Again, you can jump straight to the end of the file from the command line:less +G /path/to/logfileMore generally, both these forms (with the + argument) allow you to specify a command to run on startup.vim defaults to jumping to the end of the file if no command is given, whereas less requires you to specify the G command. Both less and vim support searching for a specific string (e.g. a date) on opening the file with:vim +/2014-02-28 /path/to/logfileless +/2014-02-28 /path/to/logfile Try using the following in your vimrc:set background=darkbefore you activate the colorscheme.EDIT: have just reread your question and realised you already do this. Apologies! If you're happy with using a custom script to kick off playing the media, why not just put the last-played filename in a (predictably-named, hidden) file? e.g.echo $now_playing &gt; .last-playedAssuming you always want to play files in the order Oldest, ..., Newest you can use ls -tr to get the filenames in the appropriate order, and use the contents of .last-played to track which file you played last.EDIT: Here's an example of what I mean. It's hideous but seems to workHINT: Change play function to do whatever you wish with the file to play.#!/bin/bashT=./.last-playedplay () { echo "$@" &gt; $T echo "mplayer $@"}# if we find no tracking data, this will be our default: the oldest filenext=$(ls -tr1 | head -1) if [ -f "${T}" ]; then # Found a tracking file: does it have a valid filename? lastplayed=$(cat ${T}) if [ -f "$lastplayed" ]; then # It was a real file: find the next-oldest one lastf="" while read line; do if [ "x$lastplayed" = "x$line" ]; then next=$lastf break else lastf=$line fi done &lt;&lt;&lt;"$(ls -tr1)" fifiif [ "x" = "x$next" ]; then echo "Finished!" exitfiplay $next If it's fewer keystrokes you're after, with the cursor on the offending word, press * followed by :%s//Identifier/g.Short of writing a special function to prompt for the replacement then replace all occurrences of the word under the cursor, I can't think of a more succinct way to do this. The mechanism by which vim finds a tag and jumps to it is, roughly, this:foreach tagfile in &amp;tags search for $tag in $tagfile if found: get filename from $tagfile foreach dir in &amp;path: if $filename in $dir: open $filename to $tagWith that in mind, there are 2 points at which I think you could be hitting a delay:Opening $tagnameChecking for $filename in $dirsimply because both of these involve filesystem access.Check the contents of both the &amp;tags and &amp;path options (with :set tags and :set path) and make sure that there's nothing in either of those that sits on a networked or slow drive. It looks like you've asked this question elsewhere and may have found the answer: this was broken in some versions of Spotify, but what you had was basically about right.I've extended it below, as (at least in v1.0.20.94.g8f8543b3) the volume wraps to 0 if you set it to a value above 100. Similarly it will wrap around to 100 if you try to set it below 0.tell application "Spotify" set currentvol to get sound volume -- volume wraps at 100 to 0 if currentvol &gt; 90 then set sound volume to 100 else set sound volume to currentvol + 10 end ifend tell Posting this answer based on @Justin's follow-up question here, which contains a slightly different but working answer.echo.go:package mainimport ( "bufio" "os")func main() { for{ reader := bufio.NewReader(os.Stdin) bytes, _ := reader.ReadBytes('\n') os.Stdout.Write(bytes) }}complex1.erl:-module(complex1).-export([start/1, stop/0, init/1]).-export([send/1]).start(ExtPrg) -&gt; spawn_link(?MODULE, init, [ExtPrg]).stop() -&gt; complex ! stop.send(Y) -&gt; call_port({msg, Y}).call_port({msg, Msg}) -&gt; complex ! {call, self(), Msg}, receive {complex, Result} -&gt; Result end.init(ExtPrg) -&gt; register(complex, self()), process_flag(trap_exit, true), Port = open_port({spawn, ExtPrg}, []), loop(Port).loop(Port) -&gt; receive {call, Caller, Msg} -&gt; Port ! {self(), {command, Msg++[10]}}, Data = receive_all(Port, 100), Caller ! {complex, Data}, loop(Port); stop -&gt; Port ! {self(), close}, receive {Port, closed} -&gt; exit(normal) end; {'EXIT', Port, Reason} -&gt; exit({port_terminated, Reason}) end.receive_all(Port, Timeout) -&gt; receive_all(Port, Timeout, []).receive_all(Port, Timeout, Buffer) -&gt; receive {Port, {data, Data}} -&gt; receive_all(Port, Timeout, [Data | Buffer]) after Timeout -&gt; lists:flatten(lists:reverse(Buffer)) end.$ erlErlang R16B02_basho8 (erts-5.10.3) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]Eshell V5.10.3 (abort with ^G)1&gt; c(complex1).{ok,complex1}2&gt; complex1:start("go run echo.go").&lt;0.40.0&gt;3&gt; complex1:send("asdhadlsjahdslahjdlhd")."asdhadlsjahdslahjdlhd"4&gt; complex1:send("aksdghjakdsgalkdgaldsagdlkagdlkadg")."aksdghjakdsgalkdgaldsagdlkagdlkadg"  