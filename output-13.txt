I don't recommend this approach in general, because it overrides _all_ imap connections to be imaps. Sometimes choice is a good thing, especially if the program is to be used for connecting to just Gmail.However, if you think plain IMAP is outright wrong, then this approach is acceptable. :-) ...used for connecting to _more than_ just Gmail, I meant. :-P A good compiler can tail-call optimise that one! :-P I love this answer, well done! Still waiting for more entries before I select a best answer. :-) Very nice, similar in spirit to my answer. How many bytes of object code does it create? Like Niyaz's answer, this can also be tail-call optimised too! Lucky for you, Python doesn't do tail-call optimisation; otherwise, it'd be disqualified like two other answers so far. :-P Much better! I have my own little contribution coming up, too. :-P Isn't this one of a (small) number of circumstances where the .NET JIT compiler can tail-call optimise? :-P Any sensible human brain will tail-call optimise the interpretation of this one too, and not blow up. :-P That's not a real stack overflow!! However, I'll upvote you for originality. :-P Hmm, will the .NET verifier accept that? For JVM, you have to specify the maximum stack usage, and the verifier will enforce it, so code like the above (iconst_0; goto loop) will get rejected. Nice, that's the best defence I've heard today. :-P Bonus! Meta stack overflow! With some compiler flags, this can also be tail-call optimised. :-) Yay, Perl golf entry! Another excellent one, keep up the good work! Eh, with Perl golf at least, command-line options count towards the character count. :-P Oi, this is only funny once, and GateKiller had that answer already. :-P Blech! That's undefined, because you have an implicit int return, with no actual return value. If you declared main as void (for some reason), then tail call optimisation can apply. So, nope. :-P Nice, Andrew; it did get optimised to a jump too! Which language is this? If it's a dynamic language, then tail-call optimisation can apply; if it's C, and you're relying on implicit int, the lack of a return value is undefined behaviour. Using "return a()" and "return b()" would also be subject to tail call optimisation. :-P Does c(N)->c(N+1)+c(N+1) work? Is there any publicly available documentation on how Clarion works? It's 3 bytes in 32-bit mode. Nice answer, considering it'll fill the stack much faster than my answer! Okay, fine, I'll let you have this one, since you wanted a version with main. :-) There are three types of jmp, short, near, and far. Short jmp (using 0xEB opcode) is two bytes. Destination must be between -128 and 127 bytes away from the next instruction. :-) @Anders: "" instanceof String[] => false Same error here on my Perl 5.8.8. :-( Wait, you have to say "Call so.bat". Running a batch file without call is like using exec, if I remember right. :-P Stack underflow for the win! Here in New Zealand we have Burger Wisconsin, where they use big but thin patties. I'm sure you can stack more than 4 of those if you want to; it'll be a very expensive burger though! Under certain conditions, I'm given to understand that the .NET JIT compiler can tail-call optimise that one! Hehehe, very neat! Mmmm, eval.... Hmm, does the HC11 not allow you to jsr straight away? Why is the nop necessary? Wow. Very impressive. You might just win the prize this time. :-P Hahaha, nice try. I think to get away with this, you'd have to set the int 3 vector address to something suitable first, and that'd cost you some code bytes too. :-P For the record, Shin's golf server allows you to send object code to be judged, although it will count all your ELF headers too. Hmm.... See, e.g., http://golf.shinh.org/p.rb?FizzBuzz#x86 for some examples of this. (I honestly don't know how people can make 99-byte ELF binaries, though.) :-P The f()*f() isn't a bad idea, however: apparently (this isn't about Lua anymore BTW) GCC can tail-call optimise 1+f() too, on the premise that f() isn't expected to return, or something. See the comments on #62221 for more details. :-P Do you happen to know if jchar's byte ordering is compatible with the Win32 wchar_t one? It should be, but probably good to be sure. :-) @Jon: I leave you to fight with aku over whether the stackoverflow tag is appropriate. :-D (See revision history.) Did you just invent this language just for the purpose of this question? :-P I think you meant to say this instead: /recurse {1 recurse} def recurse The recursive acronym in your language's name hasn't escaped my notice; I appreciated that. :-) Nice, I like this one because, like my Y combinator version, it doesn't require you to give a name to the function. Good stuff! Nice. Similar theme to one of aku's solutions (except there it was a property getter, and here it's a property setter). +1! Very nice, and there's a good symmetry to it too. Also, to use the (lambda (x) (x x)) formulation: ((Y (lambda (x) (x x))) #f) is a lot of fun too! Browsers won't show tabs very well to begin with, and Markdown just completely obliterates it. I'll paste in what I can see (editing privileges for the win!) in my next comment. SP SP SP TAB NL NLSP SP SP TAB SP SP SP SP TAB TAB NLTAB SP SP SP NLSP TAB SP TAB SP SP SP SP TAB TAB NL NL NL For people who just look at the top answer, $$ is not fine for even a single file if writing to a publicly-writable directory (e.g., /tmp). It's easy to litter /tmp with symlinks that will cause your script to write somewhere undesirable. mktemp is much better. Hehe, funny. Related to conversations, the idea of the "echo chamber effect" is quite interesting, too. Not quite stack overflow-inducing, but still. Yes, you do need the semi-colon unless your "do" is on a new line. Also, $IFS must contain a space for this to work. Thanks for feedback! Fixed. I believe [this submission](#67749) uses the same concepts, but nice try anyway. :-) My third solution would be to use SFINAE. Since yrp's answer already mentions it, I won't go into it (because I'm still researching on it: I know the idea, but the devil is in the details), unless his solution doesn't work for you in the end. :-) Are we keeping the first of duplicates, or last, or somewhere in the middle? e.g., [1,2,3,2,3,1], does that become [1,2,3], or [2,3,1], or something else? If you're going to use a struct with extra info, you may as well store the functors as hash values, and the GUID/whatever as hash keys. :-) I think a hash (std::tr1::unordered_map) is a better choice for this sort of thing. Unless it's important to call listeners in the order of registration, in which case the key type should include/be a serial number. Yes, it's important to see the forest despite the trees, so to speak. Thanks for writing the answer that I wish I had stepped back to think of! Or, perhaps, "do $0"? *goes and tries* I was going to leave your answer be, however, you've edited it enough times that I should speak. :-P What some posters have mentioned is that this is more a process-table overflow, than a stack overflow as such. Some people have posted fork bombs in this thread too, which may interest you. :-) I'm not sure what you mean by the number of digits in usec varying. As far as I know, all values in it are meant to be between 0 and 999,999, corresponding to 0 ms and 999.999 ms respectively. "Most significant three digits" to me meant you wanted the millisecond count. Did I read something wrong? GeoTrust EV == $899, for the record: http://www.geotrust.com/products/ssl_certificates/true_businessid_ev.asp BTW, I think it's very rich that you have a username of "chicken" and are questioning the value of Scheme! http://www.call-with-current-continuation.org/ Fastest Gun in the West, much? :-P I dare say that anytime you use 2 ** x in an integer context, it's probably more idiomatic to write 1 << x, instead. :-P It will, if the number is below 0x80. True, but then you'd have to use eval, and most Schemers will tell you that normal programs shouldn't use eval. Good point---sorry I took that for granted. :-) I wonder why the FAQ doesn't address the issue of atomicity. It should; I've gone to the trouble of looking at the implementation of iptables-restore just to make sure it's atomic. It's important to the OP here, and I've had a project that required it too. Yes, you can restore a single chain. :-) It's not just on the surface, I have two VPSs with them, and I'm very satisfied. Glad you liked. I revised my entry to support removing _all_ instances of "a", not just the first. :-) Try this: look "$input" Re your comment: It's okay, you'll get used to it soon. :-) I posted my post because I didn't want readers to get the idea that elements can be removed from the result of Arrays.asList() (it's an immutable list), so I thought an example could take care of that. :-) Uh, I meant un-resizeable list (add() and remove() do not work). :-P It still has a usable set() method. :-) Yes, creating an expression tree is exactly the way to go. :-) The way I had was to convert to prefix first, but maybe there are direct-to-infix methods available. The link talks about how to convert infix to postfix, not the other way around.... "Their"? Do people really not vet their error messages? That's, like, Error'd material! :-P C++'s precedence is not customisable, hence "default" is redundant. Yay for perfect hash generators! Cody: You should post that so I can +1 your comment. :-) This only work under Java 1.5+'s memory model. The C++ standard does not address threading, and volatile does not guarantee memory coherency between processors. You do need a memory barrier for this. Some of the comments hinted at using interlocked/atomic variables. That's fine: you use compare-and-set functions to work with those, and they can be tricky to use. Otherwise, for maximum ease of use, use a lock. Thanks for a good response from a member of the Perl community! I had no votes left, but once the day ticks over (in 15 minutes' time) I'll vote you up. :-) And non-experts can screw up the OTP generation! :-P From what I gather there're a lot of subtleties involved in generating cryptographically secure random numbers, and again, it's not something for non-experts to try to make production products of. :-) GHad: Have you read my Edit2 above? It addresses exactly what you mentioned, and it was posted before your post. Nice try, but no cigar. I posted an edit on exactly this topic, way before you made your post. So, although you're "technically correct", I don't appreciate your trying to get people to displace my post. I just thought you should know that. That may be, but the vt that gets assigned to a local X session is distribution-dependent. @Jim: Point. :-) Thanks, I'm glad it helped! How is 6 instructions supposed to be faster than 1 instruction?! My timing tests (for a billion runs, 5 trials) were: my version = (4.38, 4.48, 5.03, 4.10, 4.18), your version = (5.33, 6.21, 5.62, 5.32, 5.29). So, we're looking at a 20% speed improvement. Isn't that "much faster"? @Tommy: No, it doesn't. It just uses a slot on the execution stack, which doesn't count as "allocation". Yes, good point, thank you! I'll edit my post now. :-) Errors can be avoided if people read my whole post (including both addenda). If people just cut and paste code without thinking, then they deserve everything they get. Programmers get paid what they do because they exercise their brains...I hope. [continues] [continued] Your code is "dangerous" too if people aren't cognisant of the fact that by using a hash, the items become disordered. Of course, _thinking_ programmers realise this, but if you call my code dangerous because people cut and paste without thinking, it's only fair to say the same of yours. Figuring out whether to use time.timezone or time.altzone is the hard part. :-) I can't speak for Matt but I think he means, pick smarter people to work with. AFAIK, there are ways to extend UTF-8 to support 32 bits fully. With UTF-16, the limit of U+10FFFF is hard-wired and cannot be overcome without completely changing the way surrogate pairs work. Did you #include ? It may be included in STLPort, but it's still not "standard", as the question sought after. There is no _standard_ class called hash_map; it's called unordered_map instead, and it's in TR1. It may be widely supported, but it's not "standard", as the questioner asked for. Only the TR1 facilities can be considered standard. In GCC, you have to use header names  and  instead. It's a GCC quirk. :-) Thanks, Ferruccio! I've incorporated your fix. (I apologise for misspelling your name in the edit comment, but I don't believe I now have a way to fix that.) Yay for Boost providing _maximal portability_ once again. :-) See http://stackoverflow.com/questions/131445 for another instance of this. Probably because they can use fractional dates too. I won't speak for the OP, but chances are good that he's using mktime for that purpose. There's another thread about implementing a mkgmtime on top of mktime, but it's ugly: http://stackoverflow.com/questions/130074 For non-Python people: time.timezone is the non-DST time delta. time.altzone is the DST time delta. To my knowledge, there is no real way to tell whether a timestamp falls on DST, short of calling localtime(). I just edited the post to reflect what the OP meant. :-) OJ: What has this got to do with UTF-8? @OJ: Ah, gotcha. Heh, I originally wrote a response to this thinking that it must work, but then I tested it and it didn't. D'oh! Yes, I deleted my post: there's no point leaving misinformation around for people to stumble on, only to realise it doesn't work. :-| Only go the custom-comparator path if you have very, very tight memory requirements, otherwise the decrease in code clarity is unlikely to be worth it. The "don't use low bits" advice, as far as I know, applies mostly to linear congruential generators (such as rand()), where low bits are not very random. rand_s(), from what I understand, is not an LCG, and this doesn't apply. Well, if your code is called by C (or other language) code, you need to make sure that no exceptions "escape" back into C/other anyway, so this advice is tautological. :-P Yes, that works. Otherwise, some code (in the Java class library, mainly) store a static instance of String[0] (and other similar zero-sized arrays), and pass the static instances in instead of newing one each time. :-) Thanks for that. I've added a whole section on how to prevent heap littering, too, that you may be interested in. See source for java.util.EnumSet for an example of this usage. SoloBold: Because it's more extensible. If you use "if" statements, you have to edit all of them when you add another class that should also resemble Foo. Well, then, my solution of AbstractFoo is perfect! You just need a List, and you can add both Foo and Bar to it. rand() is not thread-safe, because its internal state in static, like phjr mentioned. rand_s() should be thread-safe, however. Thanks, Simucal, and Jeff! Heat Miser: You keep reading until read() returns 0. Sorry, that wasn't very well phrased. I meant: you have to do your reads in a loop. Each time through the loop, you process what's in the buffer (even if only to append its content to a string). The loop finishes when read() returns 0. Heh, after seeing /u not work, I'd be the last one to refer to the documentation for anything. :-P I'll see if I can spend some time on IDA figuring out what dir does in Unicode mode.... Yeah, that's strange. I downloaded the GNU sed source code, and it doesn't use any wide characters at all. :-( But never mind! I have a sed solution, which doesn't require wide character support. :-P Unfortunately, assigning to argv[0] doesn't do anything. That would, indeed, be my first preference. And yes, it definitely is a buffer overflow. More serious ways to accomplish this (setproctitle() in util-linux, for example) actually relocate the environment to somewhere safe before overwriting it. Of course! Set up your VM to have two hard drives, then "format /fs:fat d:" inside your virtual machine. (Your mileage may vary. It's been a long time since I've used Windows 98 so I don't fully remember the format command-line options.) Also, if you like something free, you might like to consider Microsoft Virtual PC instead of VMware. http://www.microsoft.com/windows/products/winfamily/virtualpc/ According to java.util.Random you need 53 bits, not 54. Read the comments on the nextDouble() method to see why. Otherwise, you're exactly on the right track. Although the Java approach doesn't use a union for that purpose, it just makes a large 53-bit number, then divides it by (1 << 53). Tested moving the struct out, and works. While you're moving the struct out to global level, feel free to also make it inherit from std::unary_function too. :-) Greg: I've reverted your change. You never have to escape HTML characters in your code, if you're willing to use Markdown code blocks (indent each line 4 spaces). Just highlight the code, and click the "010 101" button. Incidentally, this is not how I format code (I prefer "foo& bar", not "foo &bar"), but I thought I should leave it alone, just for people who think that such edits "might make a difference". Robert: http://stackoverflow.com/questions/147391#147438 It makes the functors more composable. i.e., it provides some typedefs that make building other functors out of your functor easier. Let me hunt down a link for you.... Oh, but there _are_ rules, even if most people never violate them. :-) I can't find an online article, however, in Effective STL, Item 40 ("Make functor classes adaptable") talks about this. *nods* Sure. But ouch, with the UTF-16 representation of console codes, as opposed to Unicode code points! That's seriously wrong.... No, remember that when waiting on the condvar, the lockobj is released (this is done automatically and atomically by the way condition variables work). It's reacquired before the waiting thread regains execution, however. See http://www.opengroup.org/onlinepubs/009695399/functions/pthread_cond_wait.html on the mutex-releasing behaviour. No, 1 mutex is enough for that. See my comment (about the mutex-releasing behaviour of pthread_cond_wait) about why this works. (event_wait_reset can use the same mutex.) In 1.8, scm_string_to_number actually unpacks the SCM values and passes them to scm_c_locale_stringn_to_number, so it should handle bignums too. Yes, you get different results for big-endian systems vs little-endian ones. It's definitely a quick-and-hacky solution, on the same order as: "@numbers = unpack 'S4', pack 'Q', $number;" in Perl I was going to disagree with your complicated approach, but once I read through the whole thing it actually made some sense. Although I'm not an expert at any of this, so my opinion shouldn't count. :-P I 100% agree that this solution is not portable at all. Perhaps I should amend the answer to use inttypes.h. :-) Incidentally, the standard C++ library is not called STL; the STL is just a small subsection of the standard C++ library. In this case, I believe you are asking for functionality in the standard C++ library, and I've answered accordingly. onebyone: Hear, hear! Documenting the "interface" is the way to go, works much the same way as with dynamic languages. *nods* Also, remember to do the check using a while loop, not an if statement. There are rare occasions (called "spurious wakeups", in the link above on pthread_cond_wait) where your waiting thread gets woken up by, umm, outside circumstances. Thanks, Jonathan! I'll fix my program right away. Ow! That means default-constructing a string for every call, when `default` (a keyword, by the way) is not specified. That, or have overloaded versions, one with your version (but no default value), and one with mine. :-) My above suggestion is overkill for the question, mind you. :-P BTW, the only reason why the function returns V, and not V const&, is because if returning the default V(), we don't want to return a dangling reference. If you are prepared to guarantee that the item exists, simply do "return iter->second;" (undefined behaviour if item doesn't exist). xtofl: I agree, that's why I upvoted janm's entry too. :-) I think your solution does have one benefit: you can return by T const& (useful if T is expensive to copy, for example). So yes, I've upvoted your entry too (aside from its greater generality). :-) My upvote is for valarray, not necessarily to make a custom matrix type. Well, custom matrix type could work, but should still be based off valarray instead of vector (valarray supports slicing, which makes getting a column just as easy as getting a row). janm: Indeed, I like your solution best. I agree about the NULL argument, too. You can, for example, say check_equal("foo", "") and have it return true only if map["foo"] exists and is empty. get(map, "foo") == "" says something different. Hahahah, nice. I took that one for granted, I thought most C coders knew that, but I suppose some take C99 semantics for granted too. :-P You can inherit "not-designed-for-inheritance" classes if you're using _private_ inheritance, if I understand correctly. e.g., class matrix : private std::valarray or the like. Essentially you're not relying on any virtual behaviour. Public or protected inheritance of "not-designed-for-inheritance" classes is a no-no, however. janm: Agree! I think your answer or Matt's one should be accepted instead, however, in the meantime I will edit my entry to take these into account. :-) I've tested my implementation with both std::map and std::tr1::unordered_map and they both work. Of course I was super-pedantic and put "typename" across everything that required it. :-P I've edited my answer, due to your argument, and to janm's one about being container-agnostic. Incidentally the end result is a lot like yours (I wrote my own implementation, but I guess there just aren't _that_ many ways to write it). :-P Thanks! I amended the entry with something even golfier, but probably more indecipherable too. :-P The Unix way is that all text files end with a newline. Thus, you never read a line with no newline at the end, unless your file is stuffed. This goes double for files like the ones in /etc. :-) comdef.h comes with Visual C++/Visual Studio (part of the compiler's "built-in COM support"). There is no relationship to the Platform SDK as far as I know. Perl has a lot of "implicit stuff", to make programs succinct (Python people hate that, hence Python's rule is to be explicit). chop uses $_ by default, as does split, as does pattern matching. [continues] [continued] The -n option (see line 1) makes Perl read lines (from stdin if no arguments, otherwise each named file) into $_, and the whole program is really in a while loop. That's why the "next" statement (equivalent to "continue" in C) works. I'd say that it's more idiomatic to do list assignment: e.g., ($ip, $hostname) = ($1, $2) in the first case, or ($ip, $hostname) = (split ' ', $line)[0,1] in the second. (The 0,1 is just in case people want to use other numbers. If not, ($ip, $hostname) = split ' ', $line will work just fine. Heh, I saw your earlier answer. This is probably the best compromise there is; I was discussing this on IRC and have come to conclude that a typedef referring to itself is probably a "too hard" problem. Though, in the inner boost::function0, don't you have to provide a return type, and have that recurse again? Doesn't it just! Argh, static typing can be a pain sometimes, if you ask me.... Wow, this problem is much, much harder than meets the eye, in my view. There are all sorts of ways to solve it if you're willing to break full type-safety, but otherwise...wow. Yeah, that's a "break type-safety" approach as I mentioned in the question comments. It's too bad, really. I do wish there's a way to solve this cleanly. Maybe C++0x will provide a way? Glad to be of help! I believe the OP was asking for comments on style, and in that department there are some things that could be talked about, such as what's in my post. :-) I think code should optimise clarity first, performance second. However, I'm willing to accept that reasonable people can disagree on this. :-) P.S. I see you on #scheme (though you seem to keep getting logged out)! Small world! Bummer about your ISP. Yes, it's nice to know there's a good handful of Schemers out here on the Internet.... :-) But, return is not a function call, unless you're a Schemer. :-P Tooony: I want to know why people put unnecessary brackets for sizeof, too! ysth: The question concerns Unix as far as I can tell, and Unix text files are always meant to end with a newline. This goes double for files supposedly in /etc. I used to religiously use chomp, for many years, but have come to the conclusion that it's unnecessary (for many purposes) and that's why chop is there in the first place. Ah hahaha! Well, I guess that goes to show either one can be implemented in terms of the other! :-) Of the current process? Or a foreign process? I think your approach would be good for bignum exponentiation, but isn't quite as applicable to floating point exponentiation, for which there is a constant-time way to calculate this. The code doesn't call log2 or exp or exp2. It implements all those things inline. Martin: Hear, hear! (s/does/doesn't/, I presume?) Okay, here's my first cut at it; let me know what you think. :-) No, it shouldn't. It's Guile-specific. AFAIK, that _only_ works on PLT Scheme. :-) On the gripping hand---I've experienced MSXML code that doesn't obey the NULL == empty rule, and exhibits different behaviour for the two. But that was 5 years ago (MSXML 3, if I remember right), and hopefully they've fixed this by now. :-) It _is_ virtual functions. Strategy Pattern, in my understanding, is just a very specific use of virtual functions, namely using interfaces (in the Java sense) to access functionality rather than concrete classes. You should click: "repeat the search with omitted results". The quote is from: http://discuss.fogcreek.com/joelonsoftware/default.asp?cmd=show&ixPost=31402 I agree with Cody, I really don't know what Rich was thinking there. Except it stresses nothing of the sort, and in fact allows 0 or 1 inputs (unless specified otherwise in documentation, in which case the variadic form is just as good). @monoxide: No, both forms generate equivalent calling bytecode, both forms require building an array to pass. The second form is simply syntactic sugar for the first. So, fooMethod(new Foo(1), new Foo(2)) is here identical to fooMethod(new Foo[] {new Foo(1), new Foo(2)}) Java warns you about this, and asks you to either write (Object) array (for variadic mode) or (Object[]) array (for non-variadic mode). :-) True, sorry I took that for granted (since I see clear() as a special case of resize()). :-) Thanks for the correction! :-) Thanks for your correction---I've updated my entry too. :-) The last two don't have the desired effect, at least under the default implementation of std::swap. :-) False, True, FileNotFound. :-) They are, if you do the join in the thread that task3 is being run from (and different from t1 and t2). As far as I understand it, the question is about how you would do it in a server-side environment (using JavaScript, rather than something like PHP, for the server logic), so it's not client-side at all. :-) Wouldn't that suggest that the cast to T is actually done by the caller, not by the method itself? I just want to put in my recommendation for Nathan Sanders's answer, it's definitely a better use of SRFIs than the other submissions. Besides, that would have been the answer I'd have written. :-) You don't want to do that. Java has SASL support built in, and it's much, much better to use Java's built-in implementation than to hand-code one. The trick is to make JavaMail support SASL for SMTP, not CRAM-MD5 as such. Thanks! I just added a bit stating that people should read on, in the quoted article; it explains the rationale even better, and how, were it not for compatibility, char const* const[] would have been vastly more preferable. I've upped your answer. You don't normally want to use msvcrt.dll, and the DDK approach is undocumented and unsupported as far as I know. Hence the "you didn't hear this from me". :-) I agree with your point. I won't edit my post, mostly out of posterity, however, I've upped your post, and other readers should read it too. :-) *nods* Fair enough, yes, I can imagine how much of a pain it would be to implement these by hand. Mwahahaha about SPA/NTLM, that's one I've had to battle with too (thanks to people using clients that only do SPA and not CRAM-*). @Nelson: Exactly why I disagree with having all code in .h files. The .inl (or .tcc, in GNU libstdc++) is a Best Practice, in my opinion. +1! You should read Cody's whole post. The stuff about macros and metaprogramming is vital. Ah. Thanks for pointing that out (I'm not a .NET person). The analogies I use are call => invokespecial, and callvirt => invokevirtual, in JVM bytecode. In the case of the JVM, both instructions check "this" for nullness (I just wrote a test program to check). I like your answer even better than mine, which is not something I say often. Good job! +1 I disagree. Not having a performance difference would not eliminate the raison d'etre of the call (or invokespecial) instruction. Usually the .so symlink is provided in the development package in most distributions (e.g., libxaw-dev). Could this be your case? I retracted my answer because this one is now more general, and sounds like a very sensible approach to me. :-) Great suggestion to look at dlmalloc, it's definitely industrial-strength. :-) +1 And no worries, I actually got the link from Googling dlmalloc as you suggested. :-P @S.Lott: In Unix programming there are some attacks that are well known, and I believe the OP is trying to cover suitable bases here. I should add: some attacks are especially well known when attacking setuid programs. @S.Lott: Shell with elevated privileges is indeed possible. Suppose the PQR program runs scripts in $PQRHOME. If an attacker can, via a symlink attack, reroute this to be a script containing 'exec /bin/sh' or the like, they win. :-) The environment variable sets where the support files are read from, just like $JAVA_HOME for JDK. However, unlike the JDK, PQR is setuid. This makes (security) things infinitely more interesting. It seems from http://www.sgi.com/tech/stl/Iterators.html that forward iterators are assignable. std::list's iterators are bidirectional iterators (http://www.sgi.com/tech/stl/List.html, http://www.sgi.com/tech/stl/ReversibleContainer.html), and are thus also forward iterators. :-) Implementation inheritance, while not ideal, can be forgiveable if it's private inheritance only. :-) @S.Lott: *sigh* I know what the question is asking. If what you're saying is that the question should make this more explicit, I'm sure the OP can come up with something. To me, the question is a valid one. scoped_ptr has its use, namely single-ownership that doesn't require transfer. In those cases, it should take the place of auto_ptr. However, where single-ownership, transfer semantics is appropriate, auto_ptr should still be used. :-) It's _based_ on Dinkumware, however, it is actually quite different from the product that Dinkumware sells. On many Unix platforms, wchar_t is 32 bits, so this is easy. On platforms where wchar_t is 16 bits, yes, UTF-16 would be the way to go. Don't say "for r in $*"; prefer to say "for r" instead. The latter allows you to specify arguments with spaces or other IFS characters. For lurkers and archives: `for r` is equivalent to `for r in "$@"`, for those unfortunate enough to use a shell not supporting the shorter form. I think the question should be rephrased as, "What goes into making an aesthetically appealing desktop UI?" or something, that asks much of the same thing about pushing on people's buttons. I can imagine some disgruntled person closing this post out of spite. :-P @Jonathan: Like my answer said, you can use setenv("PQRHOME", sanitised_path, 1) if your OS supports it. Do that at the start of every program if necessary. As for getting program path, I know in Linux you can resolve /proc/self/exe, but I don't know how this translates to other Unixes. @Martin: vptr/vtbl are the terms used in Bjarne Stroustrup's book, The C++ Programming Language. :-) I agree it's an implementation detail, but it's one I've found actually helps people understand how virtual functions are meant to work. :-) Ick! Not hashtable of method names! That sounds like IDispatch late binding (or whatever it's called, I'm referring to the one that looks up function pointers by method names, rather than DispIDs). Apologies if you've never played with OLE Automation and don't know what I'm talking about. :-P You can't dynamic_cast from an integer! (In fact you can't dynamic_cast from void* either, you have to start from a pointer/reference of a type that has some relation to the type you're casting to.) So my point is that with a random address like reinterpret_cast(0x12345678) you're in undefined behaviour zone no matter what. :-P @Pax Diablo: Yes, it uses the correct _compiler_, however, g++ passes libstdc++ to the linker whereas gcc doesn't. :-P If GetItemData returns a void*, you can avoid C-style casts by using a static_cast instead. :-) Some people I know are quite dogmatic about avoiding C-style casts, because they can be quite a blunt tool (can cause reinterpret_cast in unintended cases, for example). On the other hand, if GetItemData returns an int, then reinterpret_casting it to a pointer is not 64-bit safe, in which case I'd probably use a map. :-) Thanks for explaining "why not" better than me! +1 auto_ptr is counter-intuitive, so don't use it unless you know exactly what it does. shared_ptr is recommended for normal use. I think you meant shared_ptr, not auto_ptr. auto_ptr does not do reference counting, it does ownership-transfer semantics, which is not what most people want. :-) I agree with Igor. auto_ptr can indeed be used for returning arguments (or passing arguments, if you are in fact relinquishing ownership of the object being passed in), and you can then transfer ownership to a shared_ptr should you need to. @Blue Tuxedo: Those are good points, and you should write a post that says so! I'll upvote you then. :-) @Blue Tuxedo: I don't feel good about updating the question without OP's permission, so I can't do that. And there's no point editing my answer; your point, while good, has nothing to do with my answer as such. The best I can do is write a new answer with your point in it. :-P There's nothing magical about "aux"; they're simply the 'a', 'u', and 'x' options specified together. So, you can merge the two 'w' options in too. :-) It's an answer now! Thanks, Matthow; I've done the edit now. :-) On good operating systems (e.g., OpenBSD), there is a daily email telling you what changes have been made to various important files, such as the password database (as well as the auditing script itself). :-) That auditing script also alerts you to any new setuid programs, by the way. Don't quote me on this, but I remember that sudoers can be stored in LDAP too, which is super-cool when you have tons of servers that are to be centrally managed. :-) +1 Because there's a big endian variety where the NUL byte comes first. :-) So on that note, you should revise your post to say that the NUL byte actually follows the "real" byte, not precedes it. :-) I agree that whitespace in usernames should be allowed. In fact, you can use whitespace in your Stack Overflow username; take advantage of it! :-D Heh, I'd say standard practice is to keep the earlier one. :-P I followed through on my own advice. If you want, feel free to reopen it and close it yourself so it's got your name attached to the closing message instead. :-P pax supports both tar and cpio archives. If not, it'd be useless for mainstream archiving purposes! -z is not standard pax, but it's not standard tar either (and it's not supported on native Solaris, say). So by habit I've always done "gunzip -c ... | tar xf -" or "gunzip -c ... | pax -r". :-) Now, Jörg Schilling's tar, "star", has a complementary program called "spax". Both star and spax support -z and -bz options for doing gzip and bzip2 compression, respectively. (Yes, I know, it's not -j like GNU tar; but I never liked -j very much anyway.) Passing in a _seriously_ bogus object may even cause undefined behaviour, but perhaps the function checks for those cases. :-P @Davide: This is on Unix (Windows has no setuid). However, your wrapper must be a binary (even if a very light one written in 5 lines of C), not a script, especially if it intends to be setuid. (setuid scripts == evil!) Thanks! Yes, XPath rocks. :-) Well, it depends on what you want to exclude, but in general, yes, you can. Feel free to edit your question to elaborate on what you'd like to exclude. :-) The name needs to be interned in the "KEYWORD" package to be a keyword. e.g., (intern "FOO" "KEYWORD") In my answer, I've packaged it up into a neat little function, which you may enjoy. :-) @Ziggy: Yes, if one function calls another function, which calls yet another function, and so on, after many levels, your program will have a stack overflow. [continues] [...continued] In Java, you can't directly allocate memory from the stack (whereas in C, you can, and this would then be something to watch for), so that's unlikely to be the cause. In Java, all direct allocations come from the heap, by using "new". Is your project open-source? If so, just make a Sourceforge or github account, and upload all your code there. :-) Second what Mike said. You only need <, not ==. This question is about sets, not vectors. Also for vectors, I debate about the noticing the difference in speed: vectors are supposed to grow exponentially (usually double each time), so the number of allocations are amortised. Remember, in Java, you can't do `<` comparisons on pointers, only `==` or `!=`. So as long as they're distinct, that's good enough to compare by pointer. :-) I'll see if I can write a C++ implementation sometime. Yep, totally agree! :-) It's on that page linked to in my post. I do assume, for that site, that unless specifically mentioned otherwise, operations do not cause invalidation. See http://www.sgi.com/tech/stl/Vector.html (for example) where all the invalidation cases are mentioned. (I picked vector specifically because that's a data type that has (seemingly) more cases of invalidation than any other.) \0 is NUL, not NULL. Thus, I reverted to the OP's original revision. A buffer of size 256 is _way_ overkill for this purpose. Even though the number can overflow 7 chars (which Isak's answer deals with, by using snprintf), still, no int I know of takes up 256 chars. :-P I've combed through the AMD64 manual and still have no idea what R stands for, except "register"---just to be in line with their R8--R15. (BTW, I have no idea why, with their fixation with numbers, they don't just rename all the existing general registers too. :-P) i.e., R0 => RAX, R1 => RCX, R2 => RDX, R3 => RBX, R4 => RSP, R5 => RBP, R6 => RSI, R7 => RDI. :-) (BTW it's a pet peeve of mine when people get the register ordering wrong; the order is AX, CX, DX, BX, SP, BP, SI, DI. :-P) That's a form of double-checked locking, and thus: 1. This only works with Java 5 or later. 2. "service" should be declared volatile. Reference: http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html I agree with the getOSName function, on the basis of OAOO (once and only once); however, the caching is totally redundant given the speed of hash lookups. @ffpf: :-P came after the list terminator, the full stop (or period, if you're American, or dot, if you're a mathematician); thus, it doesn't count. :-) Luckily with strings you don't need to use iterators, most functions have a form that takes an index instead. Still, like you say, even with indexed erasure it should still be done "back to front". I'm not saying that *value++ is different from *(value++), just that your sample code above lacked it. But it's good that your actual code (which you should paste, by the way) has it. :-) Yes, I've now made the function return a tuple, the first element of which is the tag name, and the second element of which is the result. I know the OP doesn't live near Auckland, but the note at the bottom applies to anybody else reading this who does. :-) I upvoted the answer because I think in theory it's right. However, integer overflow does cause the end result to be skewed. Slow is relative. i.e., profile your program and see if it impacts things. If it does, write a custom allocator, optimised for allocating doubles (and objects of size `sizeof (double)`). I bet you my Golfscript implementation is faster than any of yours, for large N. Not because Golfscript is fast (it's quite slow, in fact), but because my solution doesn't do recursion. :-P You wanna talk about "right tool"? See the winning entry for http://stackoverflow.com/questions/62188 :-) You can convert to HTML on the server end, and store both HTML and Markdown in your database. That's how Stack Overflow does it, I believe. To avoid lots of repeat sanitisations, I believe that SO also sanitises the HTML'd version before storing that in the DB. (I believe there is a SO blog entry that mentions this, but don't quote me on it.) With the latest revision, you can now specify 0 as the rate. Technically, it doesn't wait "forever" (as it should, mathematically); rather, it waits until the end of time_t (January 2038, on platforms with a 32-bit time_t). That's still quite a while to wait, though. :-D I deliberately used write() with no buffering so the data is guaranteed to come at a constant rate. To use buffering, change the write() call to putchar(*argv[2]). :-) I'll see what I can do about public revision control.... Also, if you're using something small for the rate like 100 (as in your original question), most of the time will be taken by the sleep, not by the write. I wrote the sleeptill() function expressly to avoid "time slippage" due to the time taken, such as by the write. A correspondent has commented to me that using a pipe to netcat could mean that the pipe could be a limiting factor. It's thus more reliable to write directly to the socket at the rate you seek. Okay, this isn't github or anything like it, however it'll hopefully do the trick: http://refactormycode.com/codes/566-writing-characters-to-stdout-at-a-specified-rate At the very least, you would need to talk about what ciphers you're using, what modes you're using your ciphers in, etc. Maybe it'll help if you post some code describing your question in more specifics. @Kip: Again, see that Josh Bloch talk to see why generics was _deliberately_ designed so that Foo does _not_ extend from Foo, even if Derived itself extends from Base. :-) auto funcptr = std::tr1::bind(&Foo::Bar, this, _1, _2); This declares "funcptr" to be of the same type as "bind" returns (which is a seriously complicated type; in old days, you'd wrap it up in a std::tr1::function template, but with auto you don't need to do that anymore). Thanks! Yes, border-spacing is indeed special. Most other margin/border-like properties do allow specifying four values, not just two, but obviously this one is different. It _is_ like different languages! Boost is what makes C++ worth using, to me. :-P Not using Boost is like not using SRFIs when writing Scheme code. :-P Yours is the answer I wished I wrote myself; I hope the OP accepts your answer. Good stuff! +1 (well I would +5, but the site doesn't allow that) Ahh, the power of simple, obvious solutions! :-P I still think adjacent_find is the simplest solution of the lot, but yes. I suppose I come from the Java school of thought, which says that everything should be in a package (unless you're writing a trivial application, I suppose). In Java, classes in the unnamed package have second-class status compared to classes in a named package. I agree there are cases where busy waiting is indeed appropriate and implemented in-kernel. e.g., spin-locking. So I suppose my answer should be, "in real OSs, sleeping doesn't _usually_ cause a busy wait". :-) As I mentioned in one of the other comments, be aware of how return-value optimisation and named return-value optimisation work. While sometimes you must return by value for correctness, knowing when RVO and NRVO applies means you can sometimes eliminate the copying overhead. @Nicola: As I'm not too au fait with C++0x, I think you should write a post mentioning how the move constructor works, and I'll upvote you. :-) Yay! Well, hopefully your updated answer gets accepted as the best answer. :-) Why bother when the reflection layer already does this caching? Read the source code for java.lang.Class and see for yourself; it even handles invalidating the cache when a class gets reloaded. You _could_ use keyed hashing, that way the secret is with you. So, HMAC-MD5 or HMAC-SHA1, possibly truncated. I don't know about the security of this truncation, mind you. Of course, keyed hashing means that the key used to sign needs to be with the verifier too (symmetric). Oh well. Maybe there is a way to do asymmetric keyed hashing. :-P I almost upped your answer, except that the OP might actually be trying to implement a message queue here. :-P Admittedly, it's probably better not to hand-roll one, but still. I wouldn't recommend a fixed buffer; instead, use a dynamically-allocated buffer (e.g., std::vector), expanding as necessary (when WideCharToMultiByte tells you your string is too small). As the tags indicate, this is for a native project, so assemblies do not apply. -S implies -d. You don't need to specify both. :-P c_str() does not return a null pointer, even if the string is empty. That's right, telnet is not designed for non-interactive uses. :-P What I want to know is why the script is sending a `Refresh` header field, when it could be using a 302 response instead. As I've explained to other people before, the default package is a second-class citizen in the Java world. Just Don't Do That. :-) I've reopened it. :-) Hehehe, yep! Anyway, my comment about New Zealand is this, as of last year daylight savings was moved from first Sunday of October to last Sunday of September. Since Java 5 has been around a while, the zone files may indeed need updating. @David: No, often people ask questions they already know the answer for, just to provide more useful content for SO. isReachable only tests that you can reach the site, not that the site is actually running (e.g., returning 200 rather than 500 or the like). Also, unit tests are required more to be thorough, than efficient. :-P You can use toString() or toExternalForm() to get the external form, and compare those. Preliminary testing here shows it doesn't access DNS. I just upvoted Bill's answer. Just call toURI() on your URL objects. @Tom: em is relative to the current font size. Not officially documented, but read hotspot/src/os/{linux,solaris,win32}/vm/os_{linux,solaris,win32}.cpp in the OpenJDK source (search for java_to_os_priority) for the values. :-) This question relates to SQL, not C++; but I'm not an SQL expert, so I'll let others actually answer the question. :-) Hahaha, you'll see in the first version of my answer, that's what I thought as well. However, read http://www.opengroup.org/onlinepubs/009695399/functions/setsockopt.html and you'll see that the timeout values use timeval, not int. Technically, a member object isn't so different from a reference as far as instantiation-at-construction goes, so no loss there. :-) As long as you're not using SIGKILL, you can make your Perl program ignore the signal you're sending. Read perlipc (search for "process group"). Try the __objclass__ attribute and see if that works. If it does, then your function is unbound. I didn't know about jarray until you asked your question. :-P I found it here: http://www.jython.org/Project/userguide.html But, if that's the case, why 16, instead of 20 ((4 + 1) * 4) or 32 ((4 + 4) * 4)? _Strongly_ disagree. This approach does not defend against exceptions caused in the ctor itself, that may happen after your impl object is created. When this happens, the dtor is not called, and your impl object is leaked. That reminds me, if your class does intend to be copyable (e.g., for use in STL containers), then either shared_ptr is required (if you want to share the impl), or else a deep copy of the impl. Heh, from the top question in the "Related" list, http://stackoverflow.com/questions/59327/what-online-brokers-offer-apis it sounds like this question has been asked and answered quite satisfactorily before. :-P shared_ptr and scoped_ptr _are_ in the standard libraries...of TR1. :-) I just remembered, in this case you're not choosing between standard library versus Boost, you're choosing between pre-TR1 and TR1 standard libraries. :-) I'm surprised that the compiler didn't bite the OP's head off over using a raw type. Or perhaps the OP has a habit of ignoring warnings, in which case they deserve what they get. :-P I believe David's point is that by making it a static member, it introduces a possibility of a bottleneck, if lots of threads are expected to call that method. Testing for $TERM is not the best way to test for interactive mode. Instead, test whether stdin is a tty (test -t 0). I say also add 2>&1 to the end of that, just so stderr gets caught too. :-) In other words: if [ ! -t 0 ]; then exec >somefile 2>&1; fi ADSs can be used to hide all kinds of "lovely stuff". :-) I look at them rather like resource forks (using a MacOS analogy); in fact, in the MS implementation of Apple file sharing, ADSs are indeed used to hold resource forks. This answer should be discouraged. See Effective STL, Item 5: Too many STL programmers overuse `copy`, so the advice I just gave bears repeating: Almost all uses of `copy` where the destination range is specified using an insert iterator should be replaced with calls to range member functions. What I mean is this: if you have a piece of code that can't deal with an exception (i.e., you want your caller to handle it instead), you have two choices: 1. don't catch it; 2. catch it, log it somewhere, then rethrow it. By rethrowing, it appears to the caller as if it were never caught at all. It "works", but you lose compile-time type safety. Obviously, the OP went to great lengths to make their code compile-time type-safe. If you're using Windows, the only way to write Unicode characters to the console is WriteConsoleW: http://msdn.microsoft.com/en-us/library/ms683458.aspxJava's source code (OpenJDK 6) contains no references to WriteConsole, therefore writing Unicode chars to the console from Java is impossible. Like other posters have said, though, the char is still valid, just will always show up as ? on the console. Okay, I see you're on a Mac. Well the above comments can stay for other readers, but I'll write you an answer to your comment if others don't beat me to it. :-) Why use your own functor when you can use equal_to? :-P http://www.sgi.com/tech/stl/equal_to.html Re for_each and transform: I know some coders who avoid it because they feel that making a functor class is too clunky. With C++0x closures (or Boost.Lambda, though that was rather new technology back when I was having this discussion), that situation would be much, much improved. I guess part of the phone screen could be about whether they mention Boost.Lambda or closures! :-P Extending a concrete class like ArrayList is serious ick. I would prefer to implement List, and forward all operations to an ArrayList that's contained as a member of FooList. Or, you can extend AbstractList. JNI has a standard way to get access to the bytes in a Java string (GetStringUTFChars if I remember right), which means it comes out as UTF-8. Thus, if it handles any non-ASCII at all (including your name, I see), then it should handle CJK characters just fine. One oddity I've known (I don't know if it's still the case) is that the JVM UTF-8 support doesn't handle 4-byte sequences (for code points outside BMP) directly. Instead, it uses two 3-byte sequences corresponding to the UTF-16 surrogate pair representation. It's seriously ick. The latter representation is called CESU: http://www.unicode.org/reports/tr26/ Agree, I neglected to see the bit in the question about MBCS API. I do think, then, that using the Unicode API is more ideal, but in any case, the OP should use GetStringChars (not GetStringUTFChars), then either use it straight (Unicode API) or use WideCharToMultiByte to convert it (MBCS API). It's like opening /dev/console in Unix. :-) Try `flags & ~O_NONBLOCK`. i.e., &, not |. Sure. Read my comment to your question too. Namely, unless you had a typo in your edit, you must use & to clear flags, not |. Unsetting all flags is a bit overkill if you just want to unset the nonblocking flag. :-) Your IDE should also warn about using = in a condition. :-) For example, GCC with warnings turned on would insist that you write "if ((x = 1))" to signal your intent to actually use = instead of ==. Yes, those functions are called expm1 and log1p, and I totally agree with using them when the quantities are small enough to make a difference. My question was more of a joke question, but it does lead to some serious topics; thanks for expanding on them. Yes, I totally agree with the "going symbolic" route, that if you are doing serious trig, then numbers should be maintained with coefficients of 1, i, and π (and e, in some cases). I'm not enough of a mathematician to say if more cases need covering. :-) Your point elaborates my point (see my comment dated Aug 25) better than other responses, so I'm going to accept your answer as "best". http://www-cs-faculty.stanford.edu/~knuth/mmix.html Some text editors, like vi, tell you how many bytes are in the file. Or, you can use wc. No comments about what tools are available in non-Unix platforms though. :-P You can throw out the range check too, and just say that the program works only for 1..3999, which is what my Perl one says, and the Common Lisp submission. :-P DCL does work since Java 5 (see Jon Skeet's comment, though he didn't talk about exactly what you must do to make it work). You need: 1. Java 5. 2. DCL reference declared volatile (or atomic in some way, e.g., using AtomicReference). See the "Under the new Java Memory Model" section in http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html Does Perl actually guarantee left-to-right execution order? I know it "works in this implementation", but is it actually guaranteed (e.g., Java guarantees it)? Curious. For example, in C, the right-hand pop is just as likely as the left-hand one to be executed first. STLfilt for the win. :-) I've been looking at this for a while too, and have come to conclude that there is no better way. Obviously you can't derive from xs:date, but then, you don't get any of the magicalness of xs:date either, so in this case, you'll have to parse the date manually. :-( Parsing DSLs? I thought with Lisp macros and the like, DSLs are implemented _as_ macros, not something to be parsed by Lisp programs. YMMV with non-Lisp languages. :-P But, it doesn't look like it's open-source, and furthermore, it looks quite pricey! That's the runtime-type-checking option. For a compile-time-type-checking option, there's also boost::variant (use with visitor pattern for a watertight static type-checked solution). BTW, a std::map is not a hash table; it's usually implemented as a red-black tree, but in any case, the keys are kept in order. There is std::tr1::unordered_map, which is usually implemented as a hash table. sudo can be configured to not ask for a password. I think it's called NOPASSWD, but read the sudoers manpage to be sure. _Strongly_ disagree. (Bloch, not Block, by the way.) The problem with "assert false" is that if you have assertions turned off, the assertion will fail to be thrown. People should find assertions by looking for AssertionError as well as assert. I also strongly disagree with CantInstantiateUtilityClass as an exception type: first, it doesn't contain the word Exception or Error at the end, and second, AssertionError allows you to give an error message, and that should be used in terms of hinting people as to what happened. Hehe, declare it "throws Throwable", and throw an AssertionError anyway. :-) In C++, NULL is defined to be 0, so the "i = NULL makes it clear that i is a pointer" is not enforced by the compiler. C++0x has nullptr, and that is indeed enforced. I agree with cletus's comments here, the stacktrace is invaluable, and exception chaining is the best feature since sliced bread, because it allows you to preserve the stack trace far and wide. :-) Nice, you win. :-) Well, where are you drawing the line at what level of power you need? :-) If you care about performance, then you should download the Rhino engine from https://scripting.dev.java.net/ (since Rhino has a bytecode compiler---but the version bundled with JDK has the compiler stripped out). BTW it's easy to write your own engine, just use the code from that site as a template (go to the CVS section, and check out the code using user "guest"---no password needed). I thought MathML is just for marking up mathematical expressions, not evaluating them. Just set the sun.reflect.inflationThreshold property to the number you prefer. ...use trigraphs? :-P :-P :-P (Clearly a facetious comment, because there is no trigraph or digraph that makes the  characters---but there are ones that _use_ those characters! :-P) @Chuck: Read Ates's comment more carefully. They said: "Test& that = *this; that.isVal = str;" meaning that "that" is a _reference_ to (not a new copy of) this. But what about `@matches = 'I had a sandwich for lunch' =~ m/([aeiou])([nrs])/g`? Sure, you get a flattened array, but then you can splice that off two apiece (in this case). :-) ...by accident. :-P const_cast can easily override. You're a brave one for venturing into PHP again after all those years.... :-P @Ben: I disagree with that article. The author of the article, from what I read from page 1, has no idea how Unix processes work. Of course you have to wait for a process before you get the return value! (It's also not the Unix way to wait automatically; the program has to ask for it.) @Ben: The 2nd and 3rd pages are better, in talking about the need to handle any input and output the program requires/generates. Those obviously should be set up (perhaps in a separate thread) before waiting. @Ben: Overall the article to me seems to touch on Windows programming only. On page 4, the pitfalls about using shell commands and redirections are known to many Unix programmers, who would/should use ['sh', '-c', cmdstring] whenever shell functionality is required. Mind you, I will say that for Windows programmers using Java, that article is indeed very useful and should be recommended. So, my comments about its inapplicability to Unix should not in any way be seen to disparage the article in general. I prefer my spelling of it, but of course your answer is just as correct. :-) Can you show us some code to describe what you want to do? Personally I hate shell metacharacter quoting badly enough, just with shell scripts; when I have to do the same with calling system/exec in other languages, I feel the need to rip my eyes out. :-P Hence, I usually prefer the option to specify the argv values explicitly. :-) As an example of what happens when you don't use -DPURIFY, see http://www.metasploit.com/users/hdm/tools/debian-openssl/ (I'm not saying that running valgrind without -DPURIFY directly caused the bug, but it did cause people to take actions that ended up causing the bug). :-P True, and when you do need fully-restricted networking, you can use LAN segments with teams. (AFAIK, host-only networking is like a big LAN segment made up of all running VMs on the same host. Teams allows you to specify which VMs are allowed in.) Why SIG_DFL? Signal 0 has no name, and should (to my knowledge) be written as 0, not as SIG_DFL (which does not have a mandated value, and can stand for some other value on other systems). Very nice. :-) I can't accept two answers, so I've just +1'd your answer, and hope everyone else does the same and bump it up. :-P cos(-1), or acos(-1)? :-P That (the latter) is one of the test cases in my original code. It's among my preferred (along with atan2(0, -1), which really is the same as acos(-1), except that acos is usually implemented in terms of atan2), but some compilers optimise for 4 * atan(1)! True, that's a good point (just wrote a test to test this too), if the package is different then accessibility is required too. Thanks! For lurkers and archives: "accessibility is required" means it's as secure as Java can make it. With accessibility, you can break encapsulation whatever way you want, e.g., access private fields, etc. That implies that delegate pattern (or anything else) is defenceless against it. +1 for comparison with C++ (which has protected and private inheritance). Thanks Derek, I'll update my entry. :-) See also: http://docs.python.org/tutorial/controlflow.html#for-statements +1 Yay for seeing forests instead of trees! I like your answer so much, I'm nuking mine. :-P Okay, I'll bring my post back. :-) I agree with your comment totally. @Logan: You need a way to serialise your objects into a byte stream, which you send, via the OutputStream, to be received by the Player class. This then needs to deserialise ("reconstitute") the bytes in the stream back into the objects. Use the -m option to jar. Read http://java.sun.com/docs/books/tutorial/deployment/jar/manifestindex.html for more details. Do you mean to say "sort \&sort_hash_by_count_key, values %hash2" instead of what you currently have? aJ: No, not just for convenience. Read the two other comments (including mine). The code snippet both for my answer, and for my comment to your answer, work for me when tested (even with -w and "use strict"). The 0+ is supposed to coerce the value to a numeric, however,  already does that, so the 0+ really is redundant. :-P @holydiver: Use $b->{count}  $a->{count} for descending order (i.e., swap a and b). Scheme-relative? :-P You can also bypass const using the much safer const_cast. Personally, I'd outright ban C-style casts in my code. 2 can be circumvented with a Flash interpreter too (e.g., Gnash). The code has _no_ error checking, but I hope you get the idea anyway. :-D I've also updated my answer to describe _what_ a PMF is. Hopefully this makes it easier for you to compare against plain jane function pointers. :-) Why not just: return rhs < lhs Only if the method contains "using", and only for the objects mentioned in the "using". meandmycode: Yes, but that's not good enough; you want the connection to be disposed of (straight away) when you're done. Agree. Although well-written finalizers will do what dispose is supposed to do. This probably doesn't apply in your case, but on IPv6-capable computers, localhost also maps to [::1]. But, the OP was asking about graphical designer tools. The user doesn't have to code the XSL by hand; the tool comes prepackaged with powerful stylesheets, and the program spits out XML files that use them. So, it's not that annoying given the use case. You will need to convert all the / and + characters to, say, _ and - characters instead. @Darren: Using HTML as a presentation language == yuck. That was the OP's point, actually. Oh, very nice, I just learnt something new. SequenceInputStream is essentially identical to my CatInputStream, but using legacy Enumerations instead of, say, a LinkedList. :-) As a hack to the first part of your answer, it's hard to solve in the general case but for specific cases of FileInputStream (and maybe sockets too?) you can instanceof/cast and create a channel out of it. (The other streams can use Channels.newChannel to create a consistent interface, but won't have the non-blocking qualities required.) As a facetious suggestion, consider the entries in http://golf.shinh.org/ :-) @Dan: I believe Dinkumware and STLport both have a debug STL that caught all sorts of client non-compliance issues (and would emit warning messages). But I may be remembering things wrong. NIO2 ftw; it will feature asynchronous I/O too, which will make implementing this merged-channel business much more fun (a callback on any input channel causes a callback to the merged channel). :-) Sorry, but tackline suggested SequenceInputStream first (and I +1'd him for that). In SO, the earliest good answer wins; you never know if later answers are plagiarisms. Also, read my comment on tackline's answer for a comparison between SequenceInputStream and CatInputStream (I do take his point about using Collections.enumeration). If the person who downvoted my answer did so because of my last comment, I apologise; I should explain better: if I write an answer that turns out to be a duplicate (or subset) of an earlier-posted answer, I usually delete it, knowing that I will never receive any points for it. On SO, it really is "Fastest Gun in the West" (search for that question title). If you have GNU userland (e.g., GNU/Linux system), a more robust solution (which handles filenames with whitespace characters) is: grep -lZ "..." *.dbg | xargs -0 ls -ltr Hah, what a small world. :-D Alan Bateman got in touch with me late last year, regarding my efforts to port NIO2 to IcedTea (I even have an SO question about it); sadly on that front, I since got a full-time job and never found the time to return to it. But, the good news is that the work's not wasted; GNU/Andrew from Red Hat (who does a lot of work with IcedTea) has since picked it up: http://blog.fuseyism.com/index.php/2008/11/21/icedtea-18-released/ No, if the client were open source, it's still no easier to remove the DRM checks, because it'd still violate DMCA. (But I'm not a lawyer.) Thanks, I've updated my answer. Also, a Matcher in Java can have multiple matches. (Think of the /g flag for Perl matches.) The first index allows you to specify the match you care about. Any bits where JRuby/Jython's relative immaturity could cause problems could be remedied by routing those bits to Java-language (or Groovy) code. And you still get to keep the widely-used Java-platform libraries. :-) Jython and new versions of JRuby both compile to bytecode too, so the OP's mention of "interpret" does not mean what you think it means. :-) Right, I see what you're saying. Thanks for clarifying. No, a shallow copy occurs. i.e., any references and pointers in the object will point to the same objects as the original. _However_, the original object (as created in getData()) is still leaked, in this case. @Duck: What Snazzer wants is something that will seek and read in one atomic operation. Nice. I wonder why the JDK doesn't (appear to) use that.... And yes, you can write that statement as a JOIN, but personally I find this way easier to read. Do you have some log files to look at? Just the bottom 10 lines or so will do. Thanks for your compliment! Much appreciated. @James: That would require permission to use a custom classloader, wouldn't it? And if your SecurityManager doesn't prohibit _that_, then you've lost already. (Hint: private inner/nested classes are still, in Java's permissions system, package-private; reflection can be used to get at the concrete type, if known, and if the calling class is in the right package.) Xfig (http://www.xfig.org/). :-) Agree. Of course, in the Java world, once you cross into Sun territory you'll be using Mercurial, which makes life that much more interesting. :-P By "interesting", I mean that Mercurial has a whole plugin/extension architecture, which I haven't seen in other VCSs yet. Which makes your workflow that much more customisable. Java does, but you must specify whether you're doing covariance or contravariance. Effective Java introduces the "PECS" concept: producer extends, consumer super. What that means is this (if you're dealing with type T): if an incoming container is used for getting items out of (container used as producer), you specify this as "Collection"; if it's used for putting items into (container used as consumer), then you specify this as "Collection". Obviously, if a function needs to take a collection both to get items out of it, and to put items back in, then the type would be invariant ("Collection"). :-P "for" variable scoping, and wchar_t != short are two examples I can think of. All I can think of is, if character data is stored in a hash (e.g., each player has a runtime-assigned GUID as hash key), you're going to have _lots_ of fun locating which bucket to go for. :-P Of course Groovy supports named parameters to blocks. :-) My comment is that in Groovy, if your block takes one parameter, naming it is optional---whereas in Ruby it's mandatory. See: http://stackoverflow.com/questions/62188/stack-overflow-code-golf/62195#62195 See: http://stackoverflow.com/questions/62188/stack-overflow-code-golf/62244#62244 :-) +1 Agree. I don't want to take credit for your comment, so I'll leave the post as is. Thanks! SilentGhost: True in general, but in this case will yield a result outside [0, 2π).andygeers: That's an open invitation to edit my post accordingly, if you wish. If you're trying to compare inheritance and JavaBeans, you're comparing apples with squids (not even oranges). :-P Closing the logging file for each log line means that you have to reopen for each log line. This is going to be a serious performance hit. You should consider using flush(), if the aim is to make sure the logging data hits the disk; that still carries some performance penalty, but not as much.However, if you still insist on closing the file after every line, then you don't have to worry about closing it elsewhere. The map can be left to release automatically, yes. Using the filename as key could be fine, as long as clients refer to the file names via string constant fields only, rather than as direct string literals. This reduces the effect that typos might have, and means that your file names are kept in one place only, making them easy to change should that be required. But, why does this matter? Unless you have a  or something inside your list (or unless you have some postprocessing code that subsequently converts all newlines to  tags), the document won't be any different. You may want to explain it in terms of static single assignment (SSA) form, which then removes the need to think about what value "hash" has at any given point in time. :-) <3 Thanks for (more or less) writing out CookieOfFortune's answer in SSA form. Much appreciated! Trying to match email addresses with regexes will lead you down a long path of pain. For the love of all that's sane, don't do it. But they are the same. Why would they not be? Now, if you replaced the "wow, not the same" with new String("wow, not the same"), then they wouldn't be the same. It's okay to compare strings with the == operator if you know that you're comparing string constants with string constants (or otherwise interned strings). :-) But yeah, that's not a trick for the faint of heart. a.equals(b) is fine as long as you ensure that a is not null first. int a = 300, b = 300;Integer c = 300, d = 300;assert a == b; assert c != d; Don't use wait/notify, they're antiquated compared to the java.util.concurrent classes available with Java 5. Many cases of wait and notify are used by people who want a blocking queue; in such cases, use the queue implementations provided by Java. No, if you want a thread-safe HashMap, use ConcurrentHashMap, not Hashtable (which, like Vector, is slightly obsolete). In fact, ConcurrentHashMap was designed as a straight drop-in replacement for Hashtable. Also, the Collections.synchronizedMap wrapper (similar exist for list and set too) is your friend when you want thread safety for general containers and don't mind locking. @Joshua: Read Item 52 of Effective Java 2nd ed. You'll see why using the interface type is usually the best choice. @mmyers: Correct, that's why I picked 300 and not 1. :-) However, the point is that int and long values between -128 and 127 get cached (return the same object when boxed), as do all boolean and byte values, and all ASCII characters. Maybe some other types too. z == t is always false. Two separately-newed objects have different object identity. On the other hand, if you said Integer.valueOf(5) in both cases, then they'd be the same object: values between -128 and 127 are supposed to be cached values. If x == z or 5 == z is true, it's because of auto-_unboxing_ on the z, not of any sort of auto-boxing. Integer.valueOf(5) != new Integer(5) (remembering my previous comment about a new object having different identity to any other separately newed object). Using SRFI-1's unfold-right: (define (iota n) (unfold-right zero? 1- 1- n)) (where 1- is defined the usual way: (define (1- x) (- x 1))) Build in reverse order then reverse: (define (iota n) (reverse (unfold zero? 1- 1- n))) (qrsvar (uryyb znk y) (svygre (ynzoqn (k) (> znk k)) y)) :-P To help your answer a bit, have you learnt about closures yet? This problem is not really solvable without using closures. @Svante: The "lambda inside a function which sees things in the function's scope" _is_ a closure. :-) @Ben: You work around that by using a closure. Example: (lambda (foo) (lambda (bar) (+ foo bar))). The inner lambda can access the "foo" in the outer lambda. Hope that helps! Thank you for agreeing with me about what a closure is. :-) It's for compatibility with C, Java, and most other C-derived languages. By removing octal numbers, you'd confuse most of the programmers from the C/Java world. :-P @dirkgently: I think if you said "implemented _with_ pointers" (i.e., iterator class contains a pointer to which they ultimately delegate), that would go over a bit better than saying "implemented _as_ pointers" (i.e., iterator class is-a pointer, using the standard OO definition of "is-a"). No, you don't need a space. It doesn't affect the code's correctness at all. How are you writing this? Using DOM? SAX? Direct writes? :-P I personally prefer the DOM approach; you just access the Errors node and call appendChild(). Yeah, you'd probably use a global variable. If you just create a new .cpp file with just that global variable, and arrange to link it into your program, you don't have to modify any other code. In other words, "exit 1". :-P It's more portable to use "sizeof _TCHAR" insetad of 2. :-D Read: http://www.intel.com/design/processor/applnots/241618.htm (short answer: yes). All bets are off if the CPU is too old to support cpuid, but no modern system has this issue. johannix's answer is technically correct, but you should not write your own program, when existing tools like grep already exist: grep '^cow ' infile.txt > outfile.txt Bleh, all the world's an x86/x64! :-P (Just kidding.) It's a "semantic" issue. Basically, because you've preallocated an array, the VM sees that. It knows nothing about the "logical" size of your container. Say you have an ArrayList of size 10, backed by a 16-element array. The VM can't know that items 10..15 aren't actually used; if those slots have contents, they will not be freed. Nope, my answer isn't based on yours. However, I _am_ guilty of writing a one-sentence answer just to get in a first shot, then expanding it within the 5-minute grace. Unknown, don't claim credit for musicfreak's answer or mine. If my post was the only one you commented on that way, I'd let it go; I'm sure enough of my answer to know I copied off nobody. But musicfreak is a newbie to SO; you've got to be better to other users than that. Falsely accusing them of copying you is just...thinking too highly of yourself. :-P Thanks, Tom, you win; I agree with you totally. (I just replaced my last comment to Unknown with something more sarcastic, just because his picking on other poor users just made me irate.) @Unknown: You don't get it, do you? To get "first post" often (some) people post a simple one-liner answer and edit it afterwards, exploiting the 5-minute grace to do so. If you didn't answer at all (e.g., if you took a holiday from SO, which I guarantee will reduce your blood pressure :-)), the same answer would have resulted. Trust me on that one. To think that you're the only person who could have come up with the answer, and that everyone must be copying you, that's the sense of self-importance I'm talking about. Stop thinking you're Einstein, and your life will go a lot easier, seriously. To be honest, I wish Jeff would implement my favourite feature; once implemented, you can never accuse anyone of copying your answers anymore: http://stackoverflow.uservoice.com/pages/general/suggestions/69272-implement-a-twit-filter- For the avoidance of doubt, this is because && has higher precedence than ||. Associativity is, in both cases, left-to-right. I mention this because otherwise this post would lead to the question of, why (A || (B && C)) as opposed to ((A || B) && C). Do you have some code you can paste into the question here? *lol* @ no references to Joda Time, nicely played. (Would have been my first answer, too.) I haven't seen any DateBuilders myself, but I figured I shouldn't post a non-answer, so I'm commenting a non-answer instead. :-P I presume that's exactly what the OP was planning to do, if there are no standard libraries that provide equivalent functionality. (In other words, this is a non-answer, IMO.) Jitterbit isn't exactly a standard library, is it? Nice try though. @mmyers: Not sure I understand your comment correctly...if the OP wants to have no Joda Time, there isn't really a way to request this except by referring to Joda Time. So the "please no references to Joda Time" doesn't apply to the question itself. :-P @dfa: Because, as far as I know, it does not have a compatible API to the original Date/Calendar classes, meaning that if you had interfaces that used the latter, you'd have to change all of those too. That's not feasible in a mature project. I'd love to be corrected, though. Gleb: There's no "in FileNotFound", it's a TDWTF in-joke: http://thedailywtf.com/Articles/What_Is_Truth_0x3f_.aspx Right, especially if, say, there was one of those array allocations earlier, which was freed by, say, scalar delete instead of array delete. I used to have the first paragraph of this answer as a comment (thanks to the lovely person who upvoted it!), but I figured it'd be more useful as an answer, now that I've expanded on it a bit. :-) http://www.parashift.com/c++-faq-lite/operator-overloading.html#faq-13.15 Usual implementation of postincrement: T operator++(int) {T result(*this); operator++(); return result;} @Matthew: C++ allows operator overloading, where you can define the behaviour of ++ (both pre- and post-increment). Because of this, for consistency, standard practice is that one is implemented in terms of the other. Because the post-increment must return the old value, it's usually done by saving the old value, calling the pre-increment operator, then returning the saved value. Hope this helps. :-) @Matthew: Sure, I'll edit my post to clarify this. Was the misspelling of "miss-spelling" intended? @Matthew: I believe Lou is talking about overloaded increment operators in C++. As is my post. :-D @Matthew: Point taken. :-) However, from the compiler's perspective, it is possible to implement most operators (even for primitives) as (inline) functions; certainly, it's reasonable to logically think of all operators as functions of a sort, even if not a "formal" function with parameters and function body and the lot. Re the assembly (and comments about exaggeration): The compiler is certainly free to optimise the generated code however it likes, and in the case of primitive types, that's trivial. In the case of inlined overloaded operators (or even non-inlined ones, with whole program analysis), optimising postincrement ++ to have the same performance to preincrement ++ is possible too. But, in contexts where it doesn't matter whether pre or post is to be used, I'd say that it's prudent not to gratuitously use the version that's "sometimes" slower. @Matthew: I agree that with primitives, the difference is not worth thinking about. That means in Java and C#, it's not worth thinking about, full stop. In C++, when using primitive types only, again it doesn't matter. But when writing generic code (i.e., code which doesn't know/care about the types of its inputs), it's easier to consistently use preincrement, than to test whether the inputs are primitive or not. :-D In other words, I think we're agreeing on the same thing, pretty much. :-P When I wrote that, I didn't know that C# has overloaded ++ (I do know it has overloaded operators in general). I thought about correcting my post when I saw your comment to the other post, though. Well, let's do it here, retrospectively. :-) *lol* I went whole hog and avoided any use of + at all, but that's just my preference. :-P Hope of breaking out of the C/assembly hegemony, of course. :-) See the post I made above. It's full of neat links from Cody. @Alphaneo: Wrong, managed code can be compiled dynamically, whereas usually C or assembly code is too static for that. By "dynamically", I mean the code could be optimised based on runtime metrics. Look at how Java's performance is (or .NET's for that matter) compared to more static systems. That's because assembly language is unmaintainable (in general) to write whole kernels with. Raise the level of abstraction is the way. Yes, unless your assembly code has some way to recompile itself based on runtime metrics. I'm talking about long-running processes, by the way (which kernels are), where you can collect statistics along the way. Some parts need to use assembly, yes. But as little as possible; you want to use a higher-level language for as much of the system as you can. Huh, that's a neat way to look at it! I guess my problem is that I haven't dealt with any language (managed or not) that deals with privileged instructions (excluding any inline assembly that may be written in). @nickf3: Yes, Cody is referring to the dynamic compiler (JIT is such an old-fashioned term, in my opinion). Static compilation is just so old-school. :-) Your answer is distinctly a C-style answer, with no C++ qualities to it (except for the use of the overloaded > operator for strings). If this were a C question (and you changed the string comparison to be strcmp), your answer would be useful, but the way it is, it's not useful for the question at all. For starters, in C++ style, sorting should be using std::sort, not qsort. (BTW, even in using qsort, your comparison function must handle the case when two elements are equal, and return 0.) Use -pthread, not -lpthread. The -pthread option sets all flags necessary for threading, no matter what platform you're on. Using -lpthread would only link in libpthread, which may not be enough for some platforms. (e.g., OpenBSD used to not have libpthread---it used libc_r instead.) What do you want to do when one queue exhausts sooner than the other one? Stop? Keep going, ignoring any missing elements from the short queue? Keep going, putting null elements in place of the missing elements? A quick way to see what -pthread does on your platform is to run "gcc -dumpspecs". Agree about not having containers of whole structures, to make the sort less expensive. I can't speak about idiomatic use of arrays in C++, but it's discouraged to use (bare) pointers in STL containers, because object lifetime is harder to track that way. (shared_ptr is recommended when pointers are desired, e.g., to avoid slicing, or to prevent lots of object copying (like this case), or when used with an uncopyable type.) Actually, on that note, AFAIK qsort is usable only with POD types (the standard seems to be silent on this topic, but Googling "can qsort be used with non-pod types" is revealing). The OP's example uses some non-POD types (std::string, in particular) in the struct, so this is another argument in favour of holding pointers instead of whole objects. (However, smart pointers like shared_ptr are not POD types either, so using qsort is generally not recommended, regardless.) For reference: Later revisions of the C++ standard are not so silent on whether qsort is usable with non-POD types: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2062.html This "annoying function" prevents you from getting trojaned. I say forcing a specific $PATH is a feature, not a bug---it makes you write out the full path to a program that's outside the $PATH. It's not closed anymore. Anyone who types in alt.sysadmin.recovery can use Server Fault now, without needing 100 points on SO. The fact that _com_error is being caught means that the OP is not using ATL, but instead using the "builtin COM support" (_com_ptr_t) if I remember right. +1 for seeing the forest, not just the trees. :-D In general, you can use anonymous array/hash reference constructors whenever you want to have references of an array/hash. e.g., my ($scalarref, $arrayref, $hashref) = (\'foo', ['foo', 'bar'], {foo => 'bar'}); -1 Use modf if you're actually decomposing a floating-point number. +1 for mention of strtok_r. :-) Thanks all for helpful comments! I've incorporated Matt's and Michael's changes (though in perhaps unexpected ways :-P). Chas: Personally for my own code I'd rather work with the hash reference directly than shallow-copy even the first layer, but given the OP's original question (which passed the hashes directly into the arglist), this replicates the behaviour a little more "faithfully", for whatever _that_'s worth (in the context of this post). :-P This is something you will have to measure yourself, however, I wrote a test case using Benchmark.pm (and using "map {$_ + 1} 1..1000000"), and my approach is about 25% faster than yours. :-) So, does it have overhead? Who knows. But it certainly has less overhead than the other approach. I added my profiling script here: http://stackoverflow.com/questions/942437/change-context-of-return-of-map/947019#947019 Very, very standardised. :-P *shakes head* Is that difference even worth bothering about? You can _never_ have addresses appear the same way across all platforms---e.g., in 16-bit real-mode DOS programs, addresses are usually printed in xxxx:yyyy format. (You can't remove the colon "just to be consistent between platforms"---that would be very misleading, because the address space in real mode DOS programs is not flat.) e.g., 0x11110000 and 0x11120000, in flat addressing model, is 0x10000 bytes apart. However, in 16-bit real-mode DOS programs, 1111:0000 and 1112:0000 are 16 bytes apart. poll, not select! :-P (Okay, if you're using WinSock, select is probably more portable, but you can also use WSAWaitForMultipleEvents in that case, which is like poll. :-P) +1 Although this question isn't a Java question, it lends itself really, really well to using Executors in Java, which implements pretty much the model you've described in your linked post. It's apparently an "X/Open System Interfaces Extension": http://www.opengroup.org/onlinepubs/009695399/functions/poll.html In that sense, select is probably "more standard": http://www.opengroup.org/onlinepubs/009695399/functions/select.html (However, I still support using poll, for platforms that support it.) And for Java programmers, the equivalent is called the "Lazy Initialization Holder Class" idiom, described in Item 71 of Effective Java 2nd ed. :-) SIGKILL doesn't dump core! It's not SIGQUIT (which does dump core by default). If you download the XHTML 1.1 and XHTML Modularization 1.1 tarballs, you will find directories inside called "SCHEMA". Put all the .xsd files in the same directories. Some of the .xsd files will also import http://www.w3.org/2001/xml.xsd; you will want to adjust the locations appropriately if you don't want the file downloaded each time you run xjc. [cont] [cont] The specific part of the .xsd that specifies the content of a  is, in this case, in xhtml11-model-1.xsd, under the xhtml.head.content group. In any case, nobody is pointing a gun to your head saying you must use ObjectFactory (although I find it handy to use), but when you come across a case where it's genuinely useful, you will know it. :-) Any so-called duplicate question that doesn't feature Comeau (or any EDG-based compiler, e.g., Intel; I'm not picky) as an answer is not worth linking to. :-P I always maintain that for closing questions inappropriate to SO, one reason should be: "belongs on refactormycode.com". @samoz: Nah, people talk about Stack Overflow clones here all the time, I mean CNProg (http://code.google.com/p/cnprog/) is one of those. :-P $a and $b are filled in by the sort function. All your function needs to do, for any two items in your list, is return -1 if $a should sort before $b, 1 if $b should sort before $a, and 0 otherwise. sort will handle the rest. Just to clarify (because you asked "how you programatically go through all the entries"): sort will call your function many times, each time with two values from your list (but in no specific order). Targeting Jasmin is about equivalent to targeting ASM/BCEL (as in J-16's answer), so meh. :-P Plan B: Download the OpenJDK, and hack up the Java compiler in it to support goto. :-P You must be a closed-source programmer ("move along, nothing to look at"), not used to the idea of people actually wanting to know what goes on "under the covers". Enough said. :-P +1 The idea is on the right track. However, the process method should be abstract, and LEFT and RIGHT should each provide an implementation of it. For faster searching, I'd use -F too, since it's just a fixed string. Write the code in C, compile it, and submit the compiler output. :-P Based in kevindtimm's feedback, I now suggest to compile the program, statically link it, then submit the disassembly of the whole program. I'm not held responsible if your marker flunks you with "tl;dr". :-P +1 for static duck typing reference. :-) It doesn't provide you the _current_ terminal size, if someone resizes the terminal during the program's execution. Do your tables _all_ have at least 4 cells? If not, your hard-coded [3] reference would be invalid. Do you have some code to show us? See John Kugelman's answer. :-) !Gsort does work in nvi. What does vim say? Wait, it works in vim too! :-P (At least my version thereof.) @John: If you're doing the !motion thing, don't type the colon! You have to put the ! in vi mode, not ex mode! (The latter expects a range.) @ojblass: I'm using vim 7.2 that comes with Ubuntu 9.04. I think when people ask about a memmove equivalent (as opposed to a memcpy equivalent), usually case (b) applies. Nonetheless, good answer. @jalf: As Jherico mentioned in the answer, copyOf and copyOfRange both create new arrays, and cannot be used for copying stuff to the same array. Do you have some code on hand that I can test with? I'm really curious about this now. Thanks for that. I also, too, wrote my own implementation (before your last comment), and I've observed the same (with SIGSEGV, in my case): http://codepad.org/ifh53S3R So, I guess further kernel exploration is required.... +1 on mention of jump table (for dense values). Or a binary search, if the values are sparse. :-) switches are _not_ usually translated to if-else sequences. See qrdl's answer. :-) @OB OB: Order doesn't matter if "best practice" of no-fallthrough is used. @qrdl: Actually, on your point about the programmer knowing the "more likely path", some compilers (e.g., gcc) allow you to specify that, and it will provide branch prediction hints to the CPU. :-P akf's answer is correct, but if you hate declaring new methods, you can also use static blocks to initialise your static variables; you can have try/catches within static blocks. Lest others misread my last comment as an endorsement of the static-block approach: I prefer creating new methods. I just suggested an alternative for those who don't. :-) The article you linked to contradicts your point. :-) GPL3 does not consider delivering a SaaS app (assuming no code transfer) to be conveyance, so it's not prohibited. AGPL does require source to be available if you use AGPL code in your SaaS, however, GPL != AGPL, and the question isn't about AGPL. Or Eine (Eine is not Emacs), or Zwei (Zwei was Eine initially). :-P @Dinah: One of the constraints of my contest was that tail-call optimisation doesn't count as recursion; it's just an iterative loop. If you only wrote o() once, that can be tail-call optimised into something like this (by a competent compiler): "o: jmp o". With 2 calls of o, the compiler has to use something like: "o: call o; jmp o". It's the recursive "call" instruction that makes the stack overflow. Sure, however, as long as the OP is careful not to use any AGPL code, then they won't get stung by this. For item 8, would a solution based on JSR-223 (javax.script) be accepted? :-P (Admittedly the use of that is completely overkill, but some people would rather do that than use, say, java.util.Scanner.) In C++, I'd give bonus points for any "functional" solutions that don't involve a hand-written loop. e.g., "return equal(str.begin(), str.end(), str.rbegin());" or (for speed freaks) "return equal(str.begin(), str.begin() + str.size() / 2, str.rbegin());" Of course, upon seeing such an answer, I'd also ask the candidate to explain the working of the code. They can't get a leg up just by copying my answer above! :-P No. 1. = is not comparison, it's assignment. 2. Do "if ($var) {...}". @BlueWaldo: Yes, that works. $var will (IIRC) be either 0 or 1, in this case. @kevinadc: That "sometimes" is usually in the comparator of a sort invocation. :-) I suggest this as a better solution (yes, blowing my own trumpet, but I feel it should be said for the record :-P): http://stackoverflow.com/questions/32001/resettable-java-timer/32057#32057 Thanks for the heads-up! I seldom come back to check for other people's answers, so it's good that there is a clearly more superior answer given. Also, just for the record, it's very unusual to encrypt a string with a public key as such. The standard thing to do is randomly generate a "session key" to use with a symmetric cipher (using a secure random source, e.g., /dev/random), encrypt your message using the symmetric cipher, and then encrypt the session key using the public key. There's also posix_spawn: https://www.opengroup.org/onlinepubs/9699919799/functions/posix_spawn.html :-P Sure, there's a better way...stylistically. Use execlp and you won't need the separate array. :-) @Richie: No, it's not. Even when encrypting emails (say, with gpg), the protocol described above is used. Think about the scenario if you're encrypting an email to 5 people, any one of whom can read it. The email is not encrypted 5 times! A session key is generated, which is used to encrypt the email (via a symmetric cipher), and then the session key is encrypted 5 times, each time to a different recipient. Even the ezPyCrypto library you linked to uses session keys "behind the scenes", even if not directly exposed through the API. (The line "Choose between RSA and ElGamal for public key, and IDEA, DES3, Blowfish, ARC4, IDEA for session key" on their page hints at the existence of session keys.) You're expected to change that to the real location where you want to save to, e.g., L"C:\\Documents and Settings\\Owner\\My Documents\\Some Document.xml". The .* matches everything ("any number of any character"). It's greedy, and will match as much as possible. The \S+ matches all the non-space characters ("at least one non-space character"); also being greedy, this means that in practice, the \S+ will match the last token only, because the .* will have taken all the preceding tokens. (Remember that \S doesn't match spaces, and so the \S+ can't span more than one token.) Actually is jQuery.fn = jQuery.prototype, not jQuery.fn = {}, as jQuery.fn and jQuery.prototype are supposed to be aliased. Here's a generic answer: in the absence of special compiler options (-target), usually the version you compiled with is the lowest required version. So, compiling with Java 6 will result in binaries that also require Java 6 to run. Phi! That's a nice number to use. I should start using it from now on. Thanks! +1 @Jason: phi makes for a Fibonacci sequence, so the next allocation size is the sum of the current size and the previous size. This allows for moderate rate of growth, faster than 1.5 but not 2 (see my post as to why >= 2 is not a good idea, at least for unmanaged languages). If that claim is correct, then phi (== (1 + sqrt(5)) / 2) is indeed the optimal number to use. @Jason: Also, according to a commenter to my post, any number > phi is in fact a bad idea. I haven't done the math myself to confirm this, so take it with a grain of salt. On non-contiguous arrays to receive/send: readv and writev also allow that. Yay for scatter/gather I/O! Well, I actually assumed (unlike aJ) that the iterator is used as an output iterator, in which case, the ending iterator is superfluous. :-P Oh wait, the OP says it's an input iterator. Point taken. :-P @noselasd: The iterators do not derive from a common base class, if that's what you mean. So they _are_ polymorphic (via static duck typing), just not in the way you might think of polymorphism in, say, Java. You mean that isn't reason enough? :-) I think it's a sign that Perl programmers on this site think undef > 0 in this instance. :-P +1 Thank you for backing up what I'm trying to say myself. :-) Combine your answer and mine, and you get: /\<\\word :-) The question title made specific reference to backslash, so it wouldn't just be "word". A TreeHashMap? Isn't that an oxymoron? A map is usually implemented either as a hash table (HashMap), or a red-black tree (TreeMap), not both. :-) @Aaron: I read it as "can", as in the OP currently does it that way but wants a better one. Smart pointers are useful when you have objects that have to live for a long time, and need to have shared and/or transferable ownership. References are fine and good if ownership is constrained to a single place. The error, as noted, is not a compilation error; it's a linking error, and happens because s2::aa is not defined anywhere. See Nick Meyer's answer for an example of how such a variable is defined. Of course, the error message the OP posted says it all. :-) Although, in this case, the "= 0" is optional; IIRC (on some platforms), static data that are at default values can be allocated in .bss, whereas initialized data would be in .data. Is that the PATH from Hudson, or from the command-line? Just trying to see if I'm barking up the right tree. :-) Technically, linked lists have O(1) access times...if you're accessing the front or back element only. :-P However, vectors do have O(1) random access. :-) ("Linked list" as described above refer to doubly-linked lists. Singly-linked lists have O(1) access to the front element only. :-P) Thanks for making the edits! :-) I will edit my post to say, vectors can be _made into_ seqs, via the seq function. :-) While you're on freenode, come to the dark side and join #stackoverflow! :-P @Edouard: No extrapolation was intended by my answer. The take-home message, if any, is that one should _measure_, not make wild guesses. (I did not actually say that copying stuff willy-nilly is okay; it's not, even in managed environments.) Usual questions: What did you do? What results did you expect? In what ways do the actual results disagree with your expectations? "Seems like it bombs" does not tell the reader anything at all. There is a questions feed on SO. Just set your RSS reader to it. :-) @Casey: I've removed sq, for that reason.@John: You're probably right, but I'm really unfamiliar with list comprehensions, because I'm much more used to languages with map (Perl, Scheme, etc.). But thanks for the tip! The Brent method wasn't posted by me; it was posted by Andrea, and I just happened to be the last person who edited the post. :-) But I agree, that post deserves an upvote. Given (to my understanding) that `get` is asynchronous, wouldn't the `log` be printing `undefined` every time? Because of the "special exception" for the MySQL client, libmysql++'s LGPL licence isn't necessarily pointless, as long as the program using it is within the list of allowed licences (which are not all GPL-compatible). If I remember right, if you don't want to fork out any money, Eclipse has no capabilities for using GroupLayout; NetBeans has support for GroupLayout out of the box. Adding methods does not break upwards compatibility, only downwards (which is allowed for major releases, like Java 6). su? That's yuck, because it requires a root password instead of your own password. Why not go whole hog and suggest getting the home directory out of the password database? HOME=$(getent passwd $SUDO_UID | cut -d: -f6) Have you tried: split /\s*;\s*/, $file_data @ysth: Eh, what I meant was, "given what you say you want to do, this is probably a good way to go". Not necessarily saying that people should use threads willy-nilly, or anything like that. @JS Bangs: That's true, however, I thought that Ruby, being designed for Unix originally, has features coded in to ensure some Unix compatibility, such as not throwing an exception when File.size is called on a directory. :-P @jason: Surely that's filesystem dependent. Try: File.size('/lost+found'). Also try: File.size('/proc'). :-P I agree; however (just to be a devil's advocate) there are people who are used to loosely-typed systems where they can just start using an undefined string variable and it be treated as empty. I wouldn't know how to do it in Java, but in Perl that's easy peasy. :-P $foo = '12 54 1 65'; $foo =~ s/(\d{1,2})/$1 * 3/eg; @Imagist: Agree with you in this instance, however, Jeff mentioned that he still wanted people to be rewarded for quick answers when that's all a question's poster wants, which is why answers can be accepted straight away if that's what the poster wants to do. What? I thought both Swing and AWT work off of the Event Dispatch Thread. But strdup does, on systems that support it. :-) Or, if you want to avoid having to deal with escaping entirely, you should use parameters: SELECT * FROM table WHERE name LIKE ?, where the first parameter has value "%$search%" or the like. It's not about being smart or not. The Java language specification has very specific rules about the order of evaluation, namely that it must be left-to-right when the operators are all of the same precedence. So, although "foo" + "bar" + baz does become new StringBuilder("foobar").append(baz), foo + "bar" + "baz" cannot be compiled into new StringBuilder().append(foo).append("barbaz") without breaking the order-of-evaluation rule. You don't need to use `map`; arrays can be indexed by another array, that contains the indices to get. :-) @daotoad: I doubly love hash slices: @foobar{qw(foo bar baz qux)} :-) @Sinan: Agree, and the "rollback" link is staring at me, tempting. :-) (BTW I like your approach too and I +1'd it; but I love list/hash slices too much to not use this approach. :-P) I will say that I would never run an application that required me to switch off xauth, so I understand the whole "uproar amongst security-conscious users". Okay. Here's a compromise that probably won't make sysadmins want to kill you. Maybe. Use xhost and enable access from a private IP (e.g., 127.1.2.3). Get the sysadmin to set up firewall rules that only allow connections to 127.1.2.3 if the socket belongs to root (or whatever). Done. You might invoke webmin as root, but it may drop privileges (e.g., by switching to a "webmin" user). You should check which userid the process runs as. That link talks about a "median of medians", or in other words, an approximation of the "true" median. I'm not sure that's what the OP is asking for. -1 for the "extra braces for style"; otherwise your post was a good one. +1 for making excellent point about removing redundant allocation. @Neil: Yay for coding style holy wars! :-P WRT adding another line after the `for`: I come from the school of thought that says that your indentation should match the intention of the code, and yes, when there is a second statement added, then braces should be added at the same time. One then mentally learns to read "multiple indented lines without braces" as just as much of a WTF as "switch cases not followed by break (or return, continue, throw, etc.)". Adding braces to single-line statements greatly increases their bulk. @Neil: The downvote isn't because I disagree with their programming style, but the way that it's being pushed, with the whole "note my holier-than-thou style" thing (which is how I read the "note the extra braces for style" line). Perhaps I'm just misreading things, in which case I'm happy to retract my downvote (if SO will let me). Some code I know uses `\b` to "backspace out" the bits to replace, rather than replacing the whole line with `\r`. @Isharyan: `\r` puts the cursor at the start of the line ("for most terminals"), so anything you append after it will appear at the start of the line. Except, they demonstrate that (by virtue of all of them being in a managed language) it's not necessary to write an OS in C or assembly, and that it can be written (in some cases including the initial booting stage) entirely in a managed language. SharpOS and Cosmos are written in C#. Renraku is, last I heard, written in Boo. The other ones, you'll have to find out yourself. :-P It's probably too late to undo the downvote (you only have a smallish window of time to undo a vote, to prevent people from gaming the system), but I'll edit the post anyway. Wow, that's a winning answer. +1 This is exactly the answer I'd have given. +1 :-) +1 for using XPath, which is full of win. :-D I'll try to come up with a way to word the problem that doesn't violate Google's copyright. :-D Darn CL and its pop function! :-P Scheme, sadly (for code golfing), doesn't have such succinct means to modify a list. You can't use doubles to represent rational numbers with precision. Instead, you have to have two integers (possibly longs), to represent the numerator and denominator independently. As for roundtripping, you should serialise your double in binary form, not decimal. No, you won't get an infinite number of decimal digits. Why? Because no ratio where the denominator is a power of two ever gives a recurring decimal representation. It may be high, but if all you care about is roundtripping, print your digits in hex. Seriously, you will lose a lot less precision that way. 29/2/1900 => fail, nonexistent date :-P See http://www.joelonsoftware.com/items/2006/06/16.html for one area where this fail has had lasting consequences, to this day. (Go Lotus!) +1 for actually providing a good pack-based answer, even if I like the idea of using regexes more. :-) @sth: I agree with your comment. However, in cases where one might want to use the string to be mutable, and have changes visible to all references that see it, then a `shared_ptr` is still useful. :-) @cletus: Then there's `LinkedHashMap`. :-P Actually, since the invention of GolfScript, there have been many a contest where the winning solution was a GolfScript one. :-P That's cool. I'm still giving you a C alternative in case you don't want to code with Delphi. :-) (Well, change the initializers from `uint_t value(1)` to `uint_t value = 1` for C (my C++ habits are getting to me), but yeah. :-P) Did you check the figure for your Cached field? Writing to a file could certainly add to your cache. This will reduce the MemFree, but can be reclaimed as necessary, so you haven't lost any memory as such. Have you tried using `%.15Lf` as your format string? The problem with using `pow(x, 1./3)` is that 1/3 does not have an exact representation in floating point, so you're not "really" getting the cube root. C99 onwards has `cbrt`, which should do a better job of getting the cube root. The original answer I had in my mind used return `n / root == root`, but I ended up using a different approach. Thanks for pointing out! Will edit answer. @Adam: Do you have a case where an "integral" result from `sqrt` or `cbrt` would end up to be "epsilon less than the root"? Remember we're not dealing with fractions here, so (assuming that the root isn't so big that it can't be represented exactly by a floating point number, in which case we've lost already), how will this be a problem? I'm happy to use `round()` though. @Mark: You can dislike it all you want, but it's the "more-standard" initialisation style in C++; I think it's called "constructor syntax" or something like that. i.e., if you are constructing an object that, say, takes more than one constructor parameter, you'd have to use that syntax anyway. I don't like to make a special exception for numeric types, so I use constructor syntax for them too. @Kip: Actually, I'd recommend using `HashCodeBuilder`, `EqualsBuilder`, and `CompareToBuilder` from Apache Commons Lang. :-) You should link to the overload that takes a `Comparator`. :-D You basically create a `Function` object that calls your `computeResult` function. The Google object will take care of calling that function and caching its value, when you get the appropriate item from the map. :-) Well, because "" is not a valid file name, whereas "." is (and refers to the current directory). So, the fact that "" even partially works is, in my view, purely accidental. +1 Yay for looking at the big picture! :-D I reread this answer just now, and agree that I like it too. +1 I also agree with what MSalters said, and even though I wrote the `shared_ptr` answer, I would have no problems if the OP chose this answer or Jerry's answer, both of which are excellent. :-) Huh, I didn't know that `Time::Local` was bundled with Perl! Learn something new every day. +1 `mktime` is a standard C function, so it should be available on Windows too. Well, you can always add the fractional part to the timestamp "after the fact". My testing with `mktime` also indicates a second granularity too. :-) +1 I would state that more strongly: most programmers' expectations (especially if coming from, say, Java) are that `int` is signed by default. It would be weird to see `int` in the code and for it to show unsigned behaviour. One thing to be aware of, when using `Time::Local` versus using mktime, is that `Time::Local` interprets years differently to mktime. (Month is still 0-based though, i.e., 0 == January, 11 == December.) IMHO, the year handling in `Time::Local` is "too automagic", but this is a matter of personal taste. :-) But, `cmp` won't tell you how many milliseconds elapsed between `t1` and `t2`.... Well, zero means `(char) 0`, not `'0'`. But I hear what you're saying. I don't like using "null-terminated" because it causes people to mix up NULL (pointer) and NUL (the character), and start writing NULL instead of 0 when they meant NUL, which is seriously uncool in my opinion. Suggestions welcome. @aJ: Mostly correct, but also have to use the array form of delete for deleting `new_args[i]`. :-) You should find out if the position is a C position, or a C++ position. These require very different skills. @jlech: It is a programming question, in that the OP wants their program to show their company's name instead of "unidentified". @sylvanaar: And why would users run a program with an untrusted certificate? We train users not to put in their sensitive information into websites with untrusted certificates, etc. @sylvanaar: If you want your program to "look and smell" like the ones that come with Vista, it's gotta be signed by a reputable CA. If you're deploying apps internally only, just add your own corporate CA to the list of trusted CAs for your domain. If you're delivering the app to the general public, a well-known CA is the only way to go. But but but...`for` and `if` are part of R's syntax, so you can't just inspect them; they're built-in. (i.e., they're not functions per se, despite the visual similarity.) You can shorten it further by using `js` (lowercase) as the engine name. But but but...`cond` provides an implicit `progn` in every branch, so the use of `progn` here is superfluous. Well, I'm talking about Common Lisp, anyway. Who knows about other dialects of Lisp. :-P The trouble with using `instanceof` is it's asymmetric if you're comparing an object one class A with an object of class B, where B subclasses A. But to do "class equality" comparison is even worse; then subclasses are never considered equal to superclass instances, even when substitutability says that they should be equal. i.e., `instanceof` is the lesser of two evils. @silky: I brought it up first and you didn't acknowledge me? That's it, eat another -1. (Just kidding; not wasting my rep point over this.) :-P @silky: *lol* I normally never kick up a fuss about it, but given that my conclusion is the opposite of Steve's (namely, that substitutability is more important to uphold than symmetry), I felt that my point should be heard too. :-P @silky: Incidentally I agree that using Apache Commons EqualsBuilder is the best approach too, so have a +1 for that. :-P I prefer to use Apache Commons EqualsBuilder for this reason: it is less maintenance to use when you're adding new fields. However, you _can_ argue that you'd simply get IDEA to regenerate `equals` each time you add fields, and that'd be a fair point too. To each their own. :-P @silky: Thanks for correcting the spelling of my name. :-P `EqualsBuilder`, at least for the version I have, doesn't do `getClass` comparison unless two arrays are being compared, which is actually fair game (in most cases). +1 Very ingenious answer. :-) I was gonna say it doesn't provide indexed access, but if you use the index as the key, that actually could work and be decent. That answer is correct, though with implementations supporting SRFI 6, you can just make an output string port, and `write` to it. You can always use the `toString` or the `name` methods of the enum, surely? :-) [Dirk's answer](http://stackoverflow.com/questions/1693181/scheme-implementing-n-argument-compose-using-fold/1693202#1693202) (since deleted) had the right idea: just use `values` instead of `identity`. This is actually the method my implementation of `compose` exploits: `(compose)` simply returns `values`. Not a fan of generics? Wow. Functional Java was obviously designed with code golfing (or obfuscation :-P) in mind...package name `fj`, with functor type `F`, with method named `f`. I like the idea behind the library, but I'd not have chosen those names. :-P I've developed a way to sort-of fake `values` and `call-with-values`: new post coming up. :-) @Jonathan: It's likely that the OP is running on Windows, using the `cmd` shell. As far as I remember, `cmd` does not do wildcard expansion as Unix shells do. @steven: No, it doesn't. It's a programming question. Agree with Adam. Show me the code! (Apologies to Jerry Maguire.) +1 for the golfed solution. :-P +1 for the golfed solution. :-) String interning applies to: 1. string constants, and 2. strings where intern() has been called. But where you use `new`, the object inequality will still apply: `String a = new String("foo"), b = new String("foo"); assert a != b; assert a.equals(b);` Also: `assert a.intern() == "foo"; assert b.intern() == "foo";` @Pavel: +1, also for other readers, http://en.wikipedia.org/wiki/Lorem_ipsum for more info. You should write a timing harness and figure this out. Time running the operation 1,000,000 times and see where you get for each operation. :-) @seh: What the OP wants is to be able to create a `T[][][][]` (for example) out of a `List>>>`, for any reference type `T`. Instead, he's getting `Object[][][][]`. @erik: Not all languages have a built-in constant like `M_PI`. I was trying to find an "authoritative" way to get a (floating-point) value of pi that (in theory) works across a variety of languages (and/or their built-in libraries). My current preferred method is using `atan2(0, -1)`, but perhaps there are better ways. @gahooa: It toggles that place, as well as the four lights directly adjacent to it. Not quite. The cells are "virtual" in the case of a custom table model. When the table wants to display a cell, it calls your `getValueAt` method. At that point, access your object's relevant field. You cannot "really" prevent people from decompiling any program. Your security model had better take that into account. :-) You should read up on reflection. It will fulfil the second part of your question. As for the first part, don't use fields `a`, `b`, and `c` directly, but instead use methods `getA`, `getB`, and `getC` that you override in subclasses. @Joshua: On distros designed for disabled-root, like Ubuntu and Debian, this is true. I don't believe this is true in general, so distros that don't support it, you'd have to patch your `sulogin` with the Ubuntu patches first. If an object was initially created as `const`, then you can't (shouldn't) `const_cast` it to a non-`const`; that's undefined behaviour. If an object was initially created as non-`const`, you can `const_cast` back and forth as you please. On some implementations, writing to a `const` object can crash your program, if the object's contents resides in a read-only section (e.g., `.rodata` as opposed to `.data`, where non-`const` data sits). @Graeme: No, the OP wants a way to make the `const` stick, i.e., to guarantee that people can't `const_cast` the `const`ness away from their objects. This is stated in the last line of the question. That seems contrary to what section 12.4 (see Keith's excellent answer) says. Right, and if you're not initialising with null, then you have to call a constructor or factory method, both of which call cause the class to get loaded. In Java, iterators are not iterable. You can only use for-each on iterables, not iterators. @BlueRaja: `continue` has useful behaviour inside a `switch` (as does `break`), so overloading either of those words to mean either "fall through" or "leave the `switch`" is, in my opinion, a bad idea. +1 for referring to the language as Issue 9. :-D `sizeof` is an operator, not a function. You can't take the address of `sizeof` (whereas you can take the address of functions). :-P @R Samuel: Or just `sizeof *b`. `sizeof` is an operator not requiring brackets, except that type names have to be surrounded by brackets, similar to casting syntax. Why do you need to? What's so bad about just trying to open it, and letting it fail? @elcuco: (Re revision comment.) So, who's the n00b again? This is a perfectly valid C program: `int main(int argc, char** argv) {return sizeof *argv;}`. Trust me, `sizeof` needs no brackets when referring to expressions (as opposed to type names). Aside: Seeing `sizeof` used "as a function" is a serious peeve of mine. It's not a function; it's an operator. If you declare `int i`, both `sizeof i` and `sizeof (int)` should yield identical results. (I make a point to put a space after `sizeof` so nobody thinks it's a function, just as I do after `if`, `while`, or `for`.) Well, arrays certainly aren't primitive. Except, in Java, arrays do not have any extra methods, except `clone` (which has the correct covariant return type, is public, and has no checked exceptions). They also have an extra field, `length`. Beyond that, no extra methods or fields beyond what's provided with `Object` are available. In Java, the default `hashCode` and `toString` implementations are used (namely, identity hash code, and `[LFooBar;@deadbeef`) for arrays, so they're not really very useful in general. :-P Arrays are not comparable using natural order, but of course you're free to write a `Comparator` that works with them. So, how is JSAP better than Commons CLI? The only differences I see are: 1. Extensible type handlers (Commons CLI plans to make them extensible, but currently only a fixed set is supported), 2. ability to default values from configuration files. It's pretty much accepted that `std::vector` is contiguous (I think future versions of C++ will specify so), and that `&vec[0]` should be usable as an array of size `vec.size()`. But, doing `memcpy` on non-POD types like `std::pair` is risky, yes. See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2001/n1292.html item 69. In C++98, implementations are allowed to use a different layout for non-POD types versus POD types. In C++0x, if I remember right, there is a special designation for types that have constructors, but have no base classes, virtual functions, or nontrivial members. I can't remember its name, but the idea is that such types are simple enough to be `memcpy`able. @Steve: Thanks for explaining! Much clearer than anything I could have written. :-) @Michael: Only if `struct foo` is a POD type. :-P (Which, for this question, means that `T1` and `T2` also are.) Does `find` return different `errorlevel` values depending on whether the string is found? If so, there's your solution right there. Normally, I'd say that you should measure both approaches and see which one is faster. However, this is more useful/realistic if you either have access to the CPUs you want to target, or if you have simulators for them. Or, `arp -n $IP`, to filter to just the desired IP address. That's a bashism, and I know from the error message posted that the OP is not using bash. :-P Bellard pioneered in many, many ways...first there was LZEXE, quite possibly the first executable compressor (think what UPX does, then flip back in time to the '80s), and of course now, both QEMU and FFMPEG are widely used. Oh, and his IOCCC entry.... :-P I just worked them backwards from your formulae for sec, csc, and cot. At the JVM level, boolean, byte, short, char, and int are all treated as ints, and boolean is indeed represented as 0 and 1. So the "not implicitly convertible" is at the Java language level only. @Andrzej, @sleske: I'm only talking about runtime. Say you get the object via reflection, and invoke its `add` method (again, via reflection). Will the system reject a non-`String` object straight away, or only when casting the result of `get`? +1 for the `case` suggestion. 100% agree! Thanks for the vote of confidence! Much appreciated. Java 7 will also have method handles, which are even more direct. :-P Hey Kevin, good bumping into you. Thanks for looking into the Executors2 thing, much appreciated. :-) Also, feel free to look at my revised entry to "A very average puzzle"; I'd be keen to see what the "official" answer is, and whether my approach is considered "cheating". :-P You _could_ inspect the `User-Agent` field, and ignore referrals that don't appear to be a web browser. However, if they're smart, they'd know how to forge `User-Agent` fields too! @skaffman: An object's class's methods. How about that? This is an important distinction: if you have an anonymous class instance, you can't refer to the class by name, only via calling `getClass` on the instance. By using reflection, you can access other methods that you normally can't access via the base interface/class/enum. :-P I use Java's `String.format` a lot. In C++, I use Boost.Format a lot, which is iostreams-friendly but also somewhat `printf`-compatible. Have you ever worked with an object-oriented language? If so, have you heard of the Decorator Pattern? Each of the lambdas are basically decorating your collector with one more layer. How is it more work for the developer? You don't have to add tons of boilerplate annotations/attributes to methods, for starters. @svintus: In normal usage, you only broadcast your MAC to the local network, not outside of it. @Shawn: I didn't intend my solutions to be ones that people would implement on first reading, but rather what they might like to implement given a certain amount of Scheme experience. Besides, adventurous first readers might use such a solution as a basis for learning about parts of Scheme (and SRFIs) that aren't covered in the book. Some compilers implement comparisons using the `SETcc` instructions rather than the `Jcc` instructions, in which case no branching is involved and you don't get the branch misprediction penalty. @Woot4Moo: Wrong. There is a Java framework/platform (going by the names of Java Standard Edition, Java Enterprise Edition, and Java Mobile Edition), as well as the Java language. They have similar names, but are totally different concepts. :-D People usually call it the Java platform. However, if you're coming from the .NET world where the word "framework" is usually used, you'll notice that they're more or less equivalent. @David: R5RS and its descendants (I'm thinking ERR5RS) are pretty minimal, yes. The others, well, depending on whom you talk to, are either non-minimal or non-existent. :-P http://www.xkcd.com/566/ @Steve: A JIT is a dynamic compiler, as opposed to traditional static compilers. For dynamic fans, dynamic compilers are even more of a "real compiler" than static compilers, because of the greater opportunities for optimisation. Yes---I just edited my question to say that if the OP wanted to avoid JNI because of the need to avoid writing stubs, then JNA is a good alternative (as it handles the stubs for you). Yes, the `instance = ...` stuff is pretty much how the `@donothing` decorator gets used, internally. @PP: Suppose your `word` is not passed anywhere else inside the loop (or only passed to a function taking `char const *`), and your code is presumed single-threaded, and that there is no aliasing involved (either because the function is unary, or because the pointer is declared `restricted`). In that case, I'd say that it's a pretty safe assumption that the data won't change. The point I'm trying to make is that a good compiler actually looks at the code to see what it does, not simply what types variables have. @Steve: +1 for excellent points. I mentioned unary because I thought that `restrict` arguments are only non-aliased with respect to other arguments, not that no aliases ever exist for said argument---in which case, like you say, you're still stuffed without whole-program analysis if a global pointer is held somewhere. @Thomas: As I said in an earlier comment: "a good compiler actually looks at the code to see what it does, not simply what types variables have". As jamesdlin says, compilers have the discretion to do that, and if you see the link in my post, some compilers do exercise it. I upvoted your one because I think it's a more correct answer than trying to subclass `TreeMap` or the like. However, you can also iterate a map's entries too, which is often the most useful way to iterate through a map. The double brackets make them easy to "macro out" (`#define __attribute__(x)`). If you have multiple attributes, e.g., `__attribute__((noreturn, weak))`, it'd be hard to "macro out" if there were only one set of brackets. Fixnum isn't exactly synonymous with number per se. A fixnum is, roughly, a non-bignum integer, i.e., one that fits within your machine's word size. Try `100000000.class` versus `1000000000000000000000000.class`. The main reason for the distinction is that a fixnum can fit in your stack, whereas a bignum would most likely live in your heap. On my 64-bit machine, running MRI, all integers in [-2^62, 2^62) are fixnums. This is normal; usually an implementation would reserve the top few bits (2, in MRI's case) for "tagging" whether the rest of the word specifies a fixnum, or whether it's an address to a heap object, or whether it's free, etc. +1 for "I do find it odd how many people refuse to read any documentation at all". :-P +1 Yay for `StringBuilder`! You don't need to call `toString` if calling `PrintWriter` methods; it handles that for you. :-) What's the point of doing a Caesar cipher? That's trivial to break. :-P XOR is a "harder" cipher? Seriously?! :-P Here I was thinking you might be considering implementing AES, and then people would just tell you to use what's built into the .NET Framework. Really, that's the only way to go unless you're a crypto expert. :-P @Richard: Why 10240? That's not a power of 2. @Platinum Azure: You're not alone. Many programmers I know also find powers of 2 more logical to work with. @eSKay: If you're using an Intel CPU, which means basically any personal computer nowadays, you will never get a bus error from misaligned access. If you're using PowerPC, SPARC, etc., then you can cause a bus error that way. I have an even better idea. Create a group policy that sets the computers to use Dvorak, and have that setting locked-down. :-P I think I need to clarify what exactly I'm answering. :-P I'll update my answer to show my counterexample, because I think your updated answer is still answering a different question to the one I'm answering. :-) BTW: I'm not referring to the `Time.parse(params[:task][:completed_at])` function call; of course that generates an extra access. I'm only comparing how many accesses the `&&=` form makes versus the `= ... && ...` form. I think the OP mentioned "free" too. :-P Thanks! I edited it to use `typedef`s, so it's even more readable. :-) If you want to take optimisation to the nth degree, use `std::partial_sort` instead of `std::sort`, which requires only the first N entries (where N is the number of entries you want to save) to be sorted. :-P @Steve: Yes, you're right. Okay, I'll edit my entry appropriately. (I also like Kornel's idea of using a vector and a (partial) sort afterwards.) @Kornel: Oh, I agree, which is why I said in my comment that I like your vector/(partial) sort solution too. :-) @Steve: I was quite amused by your comment, but isn't `insert` O(n) for vector (where n is the distance of the insertion point from the end of the vector), if it's not at the end? That would argue for a insert-first, sort-afterwards approach. @Steve: Yes, fair call, it does totally depend on the usage scenario. +1 @Gautam: While in many cases composition is more ideal for has-a, in some cases, non-public inheritance can be used instead. Of course, public inheritance must model is-a. I prototype out of habit, but yes, it's optional. I don't know if the -1 is from you, and if it's over the prototype, but if so, a retraction of the downvote would be most appreciated. (If it's for something else, I'd love to hear about it.) :-) @Sinan: Thanks, much appreciated! That's a QoI (quality of implementation) issue. Some C++ compilers implement "precompiled headers", which makes the build much, much faster. By the way, you can't have `id="src"` in more than one place. Each `id` value must be unique across the whole document. If you run each of those two tasks it its own single-threaded executor, you can just put 1000 copies of the task into the executor. :-) Okay, on the topic of bulletproof: what's your current plan for dealing with tasks that get into deadlock or other liveness failures? Just because you can make restart over and over again doesn't mean that it'll keep running, if those issues can hold them up indefinitely. `localtime` returns a static instance. So, it's not thread-safe or reentrant. There's also `localtime_r` for more robustness. My answer slightly compensates for it by copying its contents straight away, but still doesn't make it thread-safe by any means. It'd better not be `tm*`, because `localtime` returns a static instance. Java Concurrency In Practice is the book I'm currently reading, and which I highly recommend. Cygwin cannot be used with proprietary software without a special licence (which you have to pay for). In that case, it sounds like ActiveState Perl isn't compatible with Screen (or Cygwin ptys in general) then. :-( You don't have to worry about endianness unless you're trying to `memcpy` some random bytes into your `wchar_t` array. @Andy: I just did a grep for `_REENTRANT` in `/usr/include`; I'm sure there are other examples of its use. @Pascal: Thanks for the link. It goes a bit above my head at the moment, but it seems that the central point is that threading cannot just be "tacked on", but instead must be designed in as part of the memory model. I completely agree with that. There does not need to be any other reason than compatibility. Compatibility has been cited as the primary reason to squash many otherwise "better" things in Java; for example, using erasure-based generics instead of reified generics is totally a concession to compatibility. I'm fairly certain that if that really optimises anything, it'd have been built-into the class. Generally, prefer to do the simplest thing that works. Just edit your post, don't actually make a new post. :-P You need to make your function recursive. Have an argument that specifies how many nested loops are still left to run. When it's zero, do its "thang". :-P I'll be happy to help further once I see your first attempt at this. :-) @rok: +1 for mentioning Apache Commons; I just learnt of yet another new Apache Commons library. :-D What is "packaged" binary? ECB doesn't use IVs; maybe you meant CBC or some other mode? Heh, if you're chopping out _both_ string2 and string3 and everything in between, it's easy in sed: `/string2/,/string3/d` I presume that's Perl, right? Cuz it doesn't look like either "awk or sed" (as the question states) to me. :-P Basically, is it likely that the original author is going to try to claim ownership of the rest? The crux of it is that you need to have _full_ copyright ownership of the code before you can use a non-GPL licence. To add to what Wim says, if it's just for the purpose of line-wrapping, don't bother: as far as I know, you can wrap your line at any character whatsoever. If you use the `-d` option (highly recommended, so binaries live in a different place from the source), then in theory, your source does not have to follow that hierarchy. Is shaving one extra indirection worth _all_ the hackishness this would entail? That sounds quite hardcore. I can think of two ways to do it: 1. Patch all calls to the virtual function with the resolved address, in the loaded-in object code. You may be able to hack the linker to do this for you. 2. Use trampolines. But I don't know if that would have the same overhead as function pointers, or even more. Try both, and measure and see. :-P As a final addendum to my answer, you definitely should read through Java Concurrency in Practice if you haven't already. All the ideas in my answer came from that book (or personal experience, but the book matches up with my experiences). Each time you schedule a `Runnable`, a new `ScheduledFutureTask` is created for it. Exactly my point. :-) @Potatoswatter: Sure. So just make cv void usable for composition only if the receiving function is nullary. (I know C++ doesn't currently work that way, but it's something to think about.) In fact, if the language had built-in support for tuples (as opposed to `std::tr1::tuple`), C++ could then allow compositions with multiple-value returns, and it'd call the receiving function with multiple arguments.Oh, did I just describe `call-with-values`? I sure did! :-P @Steve: I totally agree (+1); this is totally purely food-for-thought material. +1 Excellent answer. One problem with such a flag is that another function that requires random numbers, but using a different flag, will cause problems too. I think it's best if functions needing random numbers just get random numbers, and are decoupled from the generator initialisation. Really, seeding should just be done at the top of `main`. :-) Exactly. Really, it'd be best for libraries to do what Perl does in this regard, and do the initialisation itself (with a sensible seed of course) if the program itself hasn't done so. I mean, it's too late for that now, in that standard C libraries can't do it without violating the standard, but you know what I mean. :-) @fa: True, that stops generators from stepping on each other, but, if these different functions are all initially run too closely together, you still run into the same problem. Unless you're using the numbers for cryptographic purposes, reading straight off `/dev/random` (except to use as a seed to another PRNG) is wasteful. @BlueRaja: Right, you do have to use the right tool for the job: either you want anti-tampering (then use SHA-2 or better), or corruption detection (in which case CRC-32 is pretty much good enough). In neither of those cases is MD5 particularly useful. :-P Do you have some actual code we can look at? Generics is something that's very much "the devil's in the details". I wasn't the person who downvoted you, but, what kind of overflow/underflow are you talking about? Arithmetic? Stack? Something else? -1 100 / 0 actually returns infinity, not a NaN. Also, an arithmetic underflow (denormal) just returns 0. @Ravi: There is no `BufferOverflowException` or anything like that. Arrays are accessed by index, which, when the index becomes invalid, causes an `IndexOutOfBoundsException`. @Paolo: I think subtracting one from `Integer.MIN_VALUE` is considered an overflow too. But maybe I'm splitting hairs here. :-) Oh! Overflowing a `ByteBuffer`. That's something else entirely. Lemme edit my answer. :-P @Ravi: Wow, I'd be hard-pressed to give you specific references at the moment, because a lot of this actually came from personal experience (I've programmed in Java for over 5 years). Hmm. You can (and should) try to read the Java Language Specification, if you're interested in the nitty-gritty. Good start, though, that's not O(1) insertion/removal. :-P But maybe it'll suit the OP's purposes well enough. @Gumbo: I don't think Python's builtin lists are deques, so it's not O(1) for insertions/removals at the beginning of the list. @OP: the tricky part of writing your own linked list library is that you need to create an iteration interface (since I don't think Python's lists have it by default). :-) +1 Very good, you beat me to my answer. I'd personally make `sorter` derive from `std::binary_function`, but that's optional here. Don't you mean `bind(SortFunction, _1, _2, type)`? +1 for the idea, though I think you meant to say `template ` rather than `template `. Using a smart pointer is recommended to simplify your destructor a little. :-) If one class is using `shared_ptr`, the other should be a `weak_ptr`, to avoid circular references. @Binary Worrier: Is "casted" even a word? I thought the past participle (or whatever) of "cast" is "cast". @Binary Worrier: Upcasts are very safe. Downcasts require `dynamic_cast`. (D -> B = upcast; B -> D = downcast) On a completely different note, it reminds me of questions where people ask how to escape strings so they're safe for use as an SQL string literal...the correct answer is "don't"; prepared statements are the correct way to go. In the same way, the correct way to make strings safe as program arguments is to not let them near the shell. :-P ASP != ASP.NET. :-P @Serge: Thank you! I'm going to fix my post. In C++98, you have to write a space between the `>>`, or else there's a parse error. In C++0x, the space is optional. @koal: You should learn C++. As Omnifarious's answer notes, some parts are not easily converted to C. No, I'm saying that you cannot have multiple for-each loops that all refer to the same iterator object; it'd have been exhausted (even if only partially, if the loop has a `break` or the like) after the first for-each loop. +1 You have the right idea, though these days, using MD5 is definitely not recommended (nor SHA-1 anymore, for that matter). Use at least SHA-256. Yes, I downvoted you. I wasn't talking about runtime type checking---of course that's impossible in Java---but the OP's question wasn't asking about that. Because you didn't answer the OP's question. The OP's question asked: how can you ensure that with a type `Bar` that implemented `Foo`, it could only implement `Foo`, and not `Foo` (for example). This is possible, and is done with `java.util.Enum`, for example. @GMan: I'm not sure I agree with that. In C, 0 is false, and everything else is true. Hence, 2 is true, 03 is true, etc. So, even though the question is underspecified, it's reasonable to assume that everything that's not zero is true. That's false, but that's why Kornel's solution is teh win. :-P @UncleBens: More likely, its value would be FileNotFound. :-P But but but..."DEADBEEF" would be treated as false! :-P @Andreas: The C tradition is that 0 is false, and everything else is true. Ideally I'd like to throw an exception in that case, but if that's not an option, then true is "less wrong" than false, in my view. You're right, thanks for the counterexample. I'll update my answer. There still is a difference between using `` versus ``, but that is just hair-splitting at this point and doesn't substantially change the character of the answer. Please, don't take Schildt's books without a grain of salt. Google for the term "Bullschildt" and see for yourself. More seriously, read reviews of Schildt's books on ACCU; most of them are not favourable. @Kevin: Out of curiosity, does your wrapper also enforce the one-use constraint, or otherwise document that such a wrapper can only be iterated through once? [continues] [continued] At work, we have an implementation that goes to some pain to ensure this (with unit tests to enforce this one-use quality): the wrapper class keeps a static set of (weak references to) objects it's already seen, and throws if you try to create a wrapper with an already-seen object; also, the wrapper itself has a `used` flag, ensuring that `iterator()` can only be called once. @Potatoswatter: Write a test program and see. On Boost 1.38 (which is what I tested with), 0, 00, etc. => false; 1, 01, etc. => true; anything else I've tested ("", 2, 3, true, false) throws a `boost::bad_lexical_cast`. It's a pointer-to-member. :-) +1 Yes, interfaces are better than using reflection most of the time. :-) Also John Rose's blog, http://blogs.sun.com/jrose/, has a _lot_ of information in JSR-292. This is platform-dependent. On Unix, text-mode does nothing special, so it still won't handle `\r\n` as `\n`. @Kevin: We use Google Collections' `MapMaker` to construct the uniqueness set, with weak keys. As you may or may not be aware, this is a customised version of `ConcurrentHashMap`, so the contention is very low. I very much doubt that it's "a lot of overhead". Also, there is no proxy on `next`, only on `Iterable.iterator`. Once the for-each loop gets the iterator, it has the raw iterator from that point on. Don't you mean to say `while (*s++); --s;`? Obligatory reference: http://stackoverflow.com/questions/1732454 :-P Which, here, translates to `execlp("cmd", "/c", batchfile, static_cast(0))`. @Johannes: No worries. If you're curious, read http://www.opengroup.org/onlinepubs/9699919799/functions/exec.html for more info on the various `exec*` functions. The `static_cast(0)` is the C++ way of expressing `(char *) 0` which is listed in their documentation. @Venkat: You may have to use `cmd.exe`, yes. I haven't done enough Windows programming to tell you one way or the other. (Cygwin will automatically do `.exe` resolution for you, but can't speak about other Windows programming environments.) @Johannes: Huh, how interesting (that `exec*` can execute shell builtins, at least for the OP's environment). I certainly do not expect the same to work in Unix; there, using `sh -c ...` is required. :-P You can downvote all you like, but really, none of the answers really call "`printf` in `main`" either, so. :-P There's only one little flaw with this idea. On modern operating systems, executable pages are not writable. So, self-modifying code is not very likely to work. @Jason: I'm not sure how you can pull off the stack corruption in a way that will make it work on modern operating systems. I'd love to see someone write some demonstration code. What?! I thought the undefined behaviour comes about when your _source file_ does not end in a newline, not when the program's output doesn't end in a newline. @Graham, @Chris: Yes, that works. Extra arguments to `printf` are ignored. @corgrath: Programmers don't like to be forced to do anything, especially something with such a high maintainability cost (you have to change existing code everywhere) and comparatively little gain. If you do that to your team, they will lynch you. @Will: I think you're talking about C++, not Java. :-P In Java, creating the exception has the cost, and throwing/catching it is cheap. See http://blogs.oracle.com/jrose/entry/longjumps_considered_inexpensive. @Adamski: In the latter case there is an exception for that, called `SQLException`. I'm perfectly happy to see `SQLException` declared in the throws clause if that actually comes from the database. @corgrath: If you're wanting to throw a real exception, then yes, the cost is there. If you're using exceptions as a control-transfer mechanism, you create one exception object and store it, then throw the same object around. Since it's just used for control-transfer, you don't care about the accuracy of the backtrace information, so this works. @Adamski: I agree with that. My sentiment is that there should be an exception type that is, in spirit, alike to an `SQLException` (but in the business tier, if you like :-)), that is used to signal that the storage provider has failed, as opposed to if there is no data. Those two cases are vital to distinguish between. +1 Nice, you beat me to my answer. :-P One upside to doing manual loading is that your DLL doesn't have to be registered to be usable. No, assigning a floating-point number to an integer _still_ truncates. Of course, the rest of your point, about how integer division never results in anything floating-point to begin with, is still valid. "Belongs on plzsendtehcodez.com". :-P (Sorry, couldn't resist after seeing the "please include your tests" reference; I'd expect that you'd write your own tests to validate other people's implementations.) If the caller uses `undefined` as the 3rd argument, I'd take that to signal that they'd like the function to be treated as though only two were passed in. I don't really see any other legitimate purpose for passing in `undefined`. And the great thing about bcrypt? It contradicts silly assertions like storing the salt separately from the hash.... :-P (+1 for mentioning bcrypt; I 100% agree.) @unknown: If you're talking about maximum login trials, you're looking at the wrong threat model. The right threat model is that a cracker has just downloaded your whole user/password table, and wants to crack as many passwords as they can. @Timmay: Yes, bcrypt is the best way to go. Don't use MD5 or SHA1; that sort of advice is outdated by at least 20 years (so to speak). See: http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html @unknown: Perhaps. But all this talk about maximum trials is _completely orthogonal_ to the purpose of using salted password hashing (which is the OP's question); the former is aimed at online password guessing attacks, whereas the latter is aimed at offline cracking attacks. See http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html on why SHA-1 (or SHA-2, or anything else) is _not_ a "more secure hashing algorithm", for password hashing. @Andrew: If it means your attacker has to employ 1000x more botnet nodes to crack the password, that just upped the ante quite a lot. (And the 1000x refers just to PHK's algorithm, which is 1000 iterations of MD5; bcrypt is even slower than that.) @Andrew: No, security through slowness _is_ the best defence you have; you've got to slow down the brute force cracking as much as you can. If you say it's no defence, then that's equivalent to saying that any encryption is useless too, because people can brute-force it. :-P @Timmay: Yes, exactly, and that's where the win is. @Andrew: You clearly haven't read up on bcrypt, then. bcrypt's win is that it's _tunable_. At the moment, if you use, say, 12 log-rounds, you can later up it to, say, 15 log-rounds. Each extra log-round doubles the amount of rounds used to compute a password trial. And I can bet you that right now, a 15-log-round salt will take _far longer_ than 2 seconds to try. @Timmay: Use a random salt. You will (marginally) increase security that way, for most algorithms. In the specific case of bcrypt, the number of log-rounds used is coded into the salt, so by using a different salt for each password, you can incrementally upgrade to stronger and stronger hashing. @Timmay: According to the link that Rich posted, this is a reasonable implementation of bcrypt in PHP (if below 5.3.0): http://www.openwall.com/phpass/ (They say that 5.3.0+ already have it builtin.) @Timmay: The risk is that your attacker can access _all_ your site's code as well as _all_ the tables in the database. If you think of security from a "worst case scenario" point of view, then you've got everything covered (as well as possible, anyway). @Timmay: If you use bcrypt, the salt is stored with the hashed password. The library takes care of all that for you automatically. @juraj: The random salt is stored (in the clear) _with_ the hashed password. The salt doesn't really need to be kept secret, if it's unique per password. @Andrew: Security by obscurity won't help you. Assume that your attacker can download a full copy of your source code, then decide if using "encrypted email address" is any better than just storing a random salt in the clear with your hashed password. @Andrew: There are ways to obtain a web application's source code that doesn't involve getting full "game-over" root access, or even access to modify said code (which would, like you say, admit much easier attacks like logging all the passwords entered). @juraj: Wrong. Secure software does not depend on the secrecy of its source code for its security. Its security comes from being well-coded in the first place. You know, people can reverse-engineer all aspects of closed-source products; where do you think all the Microsoft security advisories come from? (Hint: IDA Pro.) @Robin: Based on your question edit, am I to take it that the "salt" here refers to the timestamp you're sending to the client, which you are expecting it to send back verbatim? If so, one way to verify the hash is to use something like HMAC-MD5, and use your timestamp as the HMAC key. @Robin: In that case, using HMAC-MD5 (with your constant as the HMAC key), and hashing the timestamp, is definitely the right way to go. I'll update my answer with a code example (in Java, but easy enough to adapt to Groovy). @Laurence: I know, I love your answer and was probably the first person to upvote it. :-) My comment came about before your answer was posted, and two people decided to downvote me. :-P In relation to your edit: in my OMGWTF (http://omg.thedailywtf.com/) submission, my "internal representation" is called CalcEval, which is a class with member variables `state`, `result`, `memory`, `funcmap`, `buffer`, `visitor`, `display_text`, and `stack`. You probably won't need all of that for your program though; I was trying to make mine over the top, for the contest. :-P `state` is the state machine state, `result` is the calculation result, `buffer` is where the digits get entered into, `memory` implements "M+", "M-", etc., `funcmap` defines what all the buttons do (can be static), `visitor` is used to implement the Visitor Pattern (don't ask; I was trying to make the submission gnarly), `display_text` is an event object used to trigger the view's display of the result (MVC for the win!), and `stack` is for implementing operator precedence (because I decided I wanted that too :-P). So, you choose which ones you want to use for yours. :-P @Phil: No, I don't recommend it per se; I was just answering the OP's question. But, I think there are occasional uses for it, like when you're wanting to test an internal development COM component that you have multiple versions of, that you don't want to reregister all the time. @corgrath: On a completely unrelated note (but put here so you can see it), yes, I saw your ping on IRC. I was out for the last couple of hours, but feel free to check in again, as you please. :-) Yes, throwing an exception from the constructor is the standard way to abort the creation of an object. @Robin: Oh, oh! Did I forget to mention, that once you call `doFinal`, the state of the MAC is reset, and you can start hashing your new batch of data---it will automatically use the same key. Very handy, since you have a fixed key---you just need one `Mac` object per thread. Your answer is right, but it's probably best not to give a direct answer to a "homework" problem. One very important assumption: C has to be greater than 1. :-P +1 Yay for an answer that catches both cases of C's value. :-P I'd personally like to factor `sysconf(_SC_PAGESIZE)` into a variable, rather than calling `sysconf` 5 times. :-P Are you generating your JNI stubs using `javah`? If not, you should be. :-P @Kimvais: On my computer, the top row is...VirtualBox. :-P No, that _is_ a `SELECT` statement, just without the `SELECT` keyword. It works on the version of DB2 we have (LUW 9.1), but your mileage may vary with other editions/versions. That's the complete statement. See my post edit to see how it gets used as a (fullselect). It may be a LUW-only feature, which would be a shame in your case. @finnw: It does not use reflection! (See implementation of `EnumSet.getUniverse`.) It uses something very much like @axtavt's answer (`getEnumConstants`), but in a more magical way (`SharedSecrets.getJavaLangAccess().getEnumConstantsShared`). +1 Thanks, I learnt something new about how to access enumeration members! Anyway, axtavt's answer is better than mine, so I encourage everyone to upvote that instead. :-P Some people call a `bool?` a tristate. :-) +1 for Asio reference. :-) @silverburgh: GCC 3.4 onwards, so I hear, has `__gnu_cxx::stdio_filebuf`, which you can use for that. This article is worth paying attention to: http://www.synflood.at/blog/index.php?/archives/456-One-word-of-warning-about-stdio_filebuf.html +1, also, Boost.Random has some good random number generators to go with it, if you want something higher-quality than the RNG used by default. :-P @Partial: It also needs more brackets. :-P Do I have a way to access the debug information without having to sign up for an account on rt.cpan.org? I'd love to look at it but hate having to register for things. +1 I like your more-comprehensive answer. Question: when/why would one use MessageDigest.isEqual over Arrays.equals? @Jeremy: In C, `char` is usually 8 bits, and is most often the correct type to use. Certainly, nobody should be using an array of `bool`! I see. (Apparently it required cookies; my default policy was cookies disabled, and requesting attachments caused me to be sent to a login page instead. :-P) Even for compilers that allow it, this violates ODR, and results in undefined behaviour. :-P See, if they tested `rounds` (at this point -2^31) using `rounds != 0` instead of `rounds > 0`, then it would still have worked correctly! :-P +1 And in fact, once you implement the Euclidean algorithm, it's very, very unlikely that hand-written assembly will beat what the compiler generates, unless you compile with optimisations turned off. :-P @reinier: If the little functions map very cleanly into a higher-level language, there is no reason why the compiler can't make optimal code. It's where the mapping is imperfect, that humans have a chance with custom assembly. :-P Incidentally, the "31 log-rounds integer overflow" bug also exists in jBCrypt (thanks to your post, I filed a bug report with jBCrypt's maintainer). So, doing a comparison between the two wouldn't have located that issue. :-) Yes, it was fixed to use UTF-8 instead of US-ASCII to convert the chars in the passphrase to bytes. In Java, if a character can't be encoded, it is replaced with ?, rather than throwing an exception. @David: Thankfully it seems BCrypt.NET already does the Right Thing in that department, so you have no worries. :-D @mtpettyp: It will be allowed in Java 7: http://blogs.sun.com/darcy/entry/project_coin_final_five In particular, the `String[]` parameter is not optional. @GMan: What more do you need? @dma_k: In Java, apparently you have to bind to port 0 to achieve that (counter-intuitive, I know). If you don't bind at all, you won't be able to listen on it. :-P @jldupont: No, in C code, if you simply don't bind before listening, then a port will be chosen for you. If you do the same thing in Java, it will throw a hissy fit at you. @Bedwyr: GUI updates (or anything that causes it, such as updating models) _must_ happen on the EDT, and no other thread, or you risk undefined behaviour. So, "safer" is a serious understatement. :-) More specifically, it's a conversion operator for converting to type `string`. You can create conversion operators targeting other types too. +1 for referring to it by its proper name, conversion operator. @Bill: +1 for articulating what the UB bogeyman looks like. :-) @sbi: No, I'm not myself confused about the two, but I was trying to think of a way to answer the OP's question. But thanks for your thoughts (and your downvote). :-P @Amokrane: The build path lists jars for building. You also need the same jar in the classpath, so that it's available at run time. :-) @Amokrane: You also have to specify it in the classpath when you _run_ your program. Specifying the classpath when you compile it does not "bake" it into the program, sorry. :-( Generally, this is done with a Flash applet. I hear that playlist.com has a good one for that. :-P Is this just a learning experience, or do people _really_ still write shopping carts from scratch? *scratches head* (pun intended) You should write the programs and test for yourself. :-P The timing tests I've done suggest that the difference is negligible. @Andy: Well, in terms of choosing the right algorithms, etc., then yes, you have to be aware of which ones to choose so you don't end up seriously pessimising your program. But generally, after writing the program in the clearest way possible (possibly doing refactorings that could wipe out any premature optimisations done), your profiler will do a very good job of telling you what needs fixing then. +1 for posting about the spurious wakeup...the "wait in a loop" is a standard idiom for conditions, so I wonder why they haven't done it here to begin with. Yep! :-) So, you now just need to read up on Fisher-Yates shuffle, and you're all set. :-) Where "preceding" is of a non-strict variety (i.e., each iteration can cause an item to swap with itself). :-P @Stephano: If you don't specify a `Random` object, it will use `new java.util.Random()`. (This is not specified; just how the OpenJDK version works.) @John: The code that it'll be assembled is no surprise; it's all in one giant opaque (to gcc) asm block. :-P Whereas, splitting it into many small asm statements (like my post) would give gcc more latitude to do something different. @jtbandes: Cool. In that case, feel free to test out my version and let me know what needs fixing. :-) +1 Yes, it seems the *l versions will work. The snippet I posted, when disassembled, have the *l suffix too. (Obviously, in my case I just chose to let gcc do all the hard work, by using constraints rather than manually coding in the load/store instructions.) @Marius: I'll update my answer to respond to your comment. :-) This question is actually a legit point-scoring question, and making it community-wiki will discourage legit answers. :-) (i.e., I think people don't prefer to answer "real" questions if it won't help them gain rep.) @Tim: +1 <3 LLVM (and other dynamic compilation systems). But seriously, even the higher-end editions of Visual C++ will do whole-program optimisations for you. Nope, once a post becomes CW there is no way to un-CW it, by design. See: http://meta.stackexchange.com/questions/11740/what-are-community-wiki-posts-on-stack-overflow Another link, on the "politics of CW", which I found fascinating: http://meta.stackexchange.com/questions/10390/why-has-community-wiki-transmuted-from-the-original-intent I would point you to Wikipedia, but its articles on RTTI and `dynamic_cast` are very skimpy. :-P Just play with it yourself until you get the hang of it. :-) @Trueblood: No, there is not, at least not accessible in a portable way. You can, as a rough guide, use the size of the directory, but if (say) you put a million files in a directory (so it grows to size) then delete those files again, the directory isn't required to shrink back. In some filesystems, the enlarged size stays forever. :-) @jtbandes: `+` means in/out (used when the instruction reads and writes to the same register), and `t` means `st(0)`. Read the "Machine Constraints" section of the GCC manual: http://gcc.gnu.org/onlinedocs/gccint/Machine-Constraints.html :-) @Lothar: You're 100% correct, although I didn't expect anyone to call me on my little slight-of-hand. :-P Sorry about my last comment, my PDF search facility is broken. See section 7.16 for more info on `__bool_true_false_are_defined`. Re "overrated": In C++, `bool` is a separate type so it can participate in function overloading, for much of the same reason why character constants are of type `char` in C++. Of course, this doesn't apply in C, which has no function overloading. +1 for noting that this is for _non-static_ members. :-) In theory, no. In practice, yes. Read up on drive-by downloads: http://en.wikipedia.org/wiki/Drive-by_download If you want to reverse the order, don't use -1 times the comparison; just swap the `str1` and `str2` around in the call to `strcasecmp`. (On a related topic: Multiplication by -1 is a serious peeve of mine, no matter what. That's what unary negation is for.) In other words: Best: `strcasecmp(str2, str1)`. Okay: `-strcasecmp(str1, str2)`. Lousy: `-1 * strcasecmp(str1, str2)`. Just for the record: the customary format used in the US is actually 01/30/2010 (for the date posted in the question): see http://www.catb.org/~esr/jargon/html/M/middle-endian.html In my book, 0.7 seconds difference out of 17 seconds _is_ negligible, but like you say, I suppose it depends on context. :-) @Jitendra: Ah, I see. I think using `boldText` for a class is pointless, because it's not describing a "what". Even using `` for "(required)" or "ACME Corp" is wrong. It should be something like `` and `` respectively, which describes what those strings are; they're not "a bold", whatever that is. :-) As for "ducks", that's what `` is for. :-) Style it with bold if you prefer, but seriously, I wouldn't use wiki markup as the model of "right markup". To me, `` is not semantic (I disagree with the "accepted answer"; fine print can have its own class, and it's not called "small"), but, I understand that reasonable people disagree about this. I would still avoid using ``. To your first point, I agree that `` is less evil than ``. But to whatever extent the class can be amended to specify a "what", even better. @Andrew: `` itself is not semantic. It's the classes you attach to it that's semantic. The point of `` and `` is that they're (supposed to be) free of overloaded presentational assumptions. @Jitendra: In my opinion, both of those are fine too (although some will disagree with me); this provides compatibility with non-CSS-capable browsers. This would allow stylesheets to freely choose how to render the "fine-print" and "important" classes (yes, even negating the bold/small if that's somehow inappropriate for the device being targeted). @Andrew: If it's "simply part of the text", when why does it need to be bold? _What_ does its boldness add? Encapsulate this "what-ness" in the class. @Andrew: Sometimes something that's "important" may be different from "strong emphasis". What if "important" text is required to have a warning sign on the margin whenever it appears? It seems overkill to do the same for ``, though of course it's possible to achieve. As for ``, as I said, reasonable people can disagree, but I stand by my stance. @Jitendra: From your list (and more :-P), I'd say: `b`, `i`, `u`, `tt`, `strike`, `font`, `center`, `blink`, `marquee`, `big`, and `small` are presentational. (Yes, the last one is disputed, but whatever. :-)) @Andrew: How about using `our-company` as the class. @Jitendra: I added `tt` (sorry, missed first time). `sub` and `sup` are used in some chemical and mathematical contexts that are hard to call anything but subscripts and superscripts. As for `hr`, well, I don't know; I think it has semantic value (it separates two sections of text; even screen readers can do a Big Pause when it sees an `hr`), but reasonable people can disagree. @Andrew: Sure, I agree, one could/should use `` or something, using the presence of the `important` class to determine which/whether any icons should appear, for example. @Andrew: `` having any semantic value is about as hard for me to believe as ``. :-P @Andrew: I hear you already about `` and how HTML 5 thinks it's semantic. I agree that reasonable people can disagree about that, and, for the record, I still disagree. I also think using `` for Morse code is iffy, too. You can do `` or something, but `` standalone...no. @Jitendra: I think both `` and `` have a place in structural markup. (Line breaks are used for flowing poetry a certain way, for example. Think of how one lays out a haiku.) I try to use them very sparingly, though. @Jitendra: Personally, I think that stylesheets should specify images' sizes, using relative terms. Sometimes, in order to avoid unsightly scaling (pixelation, for example), you have to use pixel measurements; in that case, `width` and `height` attributes are acceptable, with full understanding that if the image size changes on you, that you'll have to update those pixel measurements too. I don't think that the `bgcolor` and `fgcolor` attributes of `` should be used, though, nor `border` attributes of `` and `` (and the like). @Andrew: Just so you know that I'm not always out to disagree with you, I actually agree with your last giant comment, and am now +1'ing both parts of them. No, double quotes are `char[]` (a bunch of characters), single quotes is a single `char`. Method parameters should be using `Map`, not `HashMap`. Caveat: If the URL ends up running a script that doesn't know how to handle OPTIONS (e.g., most PHP scripts :-P), the results may be unpredictable. :-) `` is very MSVC-specific...in Unix, `write` is declared in ``. :-P But yes, whether or not you include `` or the like, the fact is that `write` is defined in libc, and making one's own implementation of `write`, especially one that's incompatible with the system one, is not wise. @Bill: Actually, the recommended replacement (as of Java 5) for `Hashtable` is `ConcurrentHashMap` (in `java.util.concurrent`), but for code that targets 1.4 or older, I suppose synchronized `HashMap` is reasonable for most uses. I'm having difficulty finding this header file in any old version of Unix that I'm looking at (Google isn't having any luck either when searching for `"io.h" Unix`): the versions I'm looking at are in http://minnie.tuhs.org/Archive/PDP-11/Trees/ from the Unix Heritage Society. Note that in neither V6 nor V7 is there an `io.h`; system calls were made directly. The 2.11BSD tree features `unistd.h`. Your post looks incomplete...cut-and-paste error? Yuck, whoever wrote that doesn't know C++ style, which is that one should aim to initialise variables straight away---`ios::fmtflags f(cout.flags())`---instead of the two-step "initialisation" as shown above. I'm criticising whoever wrote it, not you. :-D Using `(void)` for nullary functions is not usual C++ style; unlike C, in C++ `()` is always nullary. But yes, I acknowledge a strict reading of the C++ standard does require writing `int main(void)` and that `int main()` is non-conforming. Oh well. :-P @BillyONeal: No, using manipulators has the same effect as changing the format flags manually. :-P @Frank: I agree, and usually for people with homework questions I go to great lengths to avoid giving explicit answers. But you can see from the OP's responses that they don't even know where to begin. Asking them to try to find it using a debugger would just...not get anywhere useful. :-( The same server? Or a different one? Also, strip out all mentions of `File` from your code, if you haven't already done so. @darkporter: That's perfectly good with me. Your vocal "vote" of confidence is very much appreciated. :-) @Chinmay: The usual program execution system calls, at least in Unix (`execve` and its siblings) and Windows (`CreateProcess`), all trim strings off at NUL. So, that's at the OS level, not just library. :-) GD seems to be under its own licence, which is similar to the ISC licence. Of course, actually read the licence to know what your obligations are. :-) @Derek: Only in the way that `'42'` is a number...which it's not. Just because a string happens to contain digits only does not make it a number. This isn't PHP. :-P @Derek: Yeah, but once you convert it back into a number, you run into the same inaccuracy issues again. :-P JS doesn't have decimal floating point or rational numbers. You can downvote me all you like; it just proves you have no sense of humour. :-P @Alok: Yes, very good point. +1 @Joonas: Item 40 of Effective Java, 2nd ed describes the rationale for this. I'll paste in the relevant section in case you don't have the book. Problem: `isatty` will return false for pipes, which is what the OP wants to do. Or use `Arrays.toString`. Sort-of through HotSpot, though mostly through the `JVM_*` interface (what _is_ that interface called?), which provides a fairly nice abstraction layer for the VM itself. I especially enjoy the fact that the bytecode verifier is implemented using _only_ JNI and the `JVM_*` interface, without touching any HotSpot internals. :-) For types unknown, `Object.clone` is protected. You can only access that method via reflection (and only if the target type defines a public override, of course). @asveikau: No, no clobbering because of the constraints. Also, no volatile needed, as the compiler's ordering will guarantee the right results. You can do conditional in C code, if you can ensure no branching. (My portable version does that.) @gnibbler: You can, but why would you? The C version generates code (under gcc) that's even better than the assembly version I wrote. It's not _always_ the case, you're right: pre-1.2 JDK versions used green threads, IIRC. But, mainstream JVMs all use native threads these days, and it's not useful to talk about green-thread implementations, in my opinion. Yes, but there's a reference to `foo` _before_ the body of the constructor. +1 As a bonus: no contention! :-D Good answer, but no upvote because of PHP recommendation. :-P There is nothing special about `try` blocks. Stack objects allocated in _any_ block (whether `try` or not) is subject to unwinding when the block exits. @Nikolai: +1 Yes, I presume that's _exactly_ what the OP is referring to. @Will: You didn't hear this from me, but if you bind to port 0, chances are excellent that it will be treated as an unbound port. (But if you can just make your code not bind at all, then even better.) @Will: I wrote a sample test program showing that binding with port 0 works (comment out the binding lines, and see how the same thing happens): http://codepad.org/AtjvJaFb @Dolph: "Doctor, it hurts when I touch here!" "Well, don't touch it then!" +1 for answering why `URL` functions the way it does, though I still think using `URL` is wrong, even if its design was well-intentioned for its time. Can you show some real stack traces? @shinjuo: That constructs a vector, `args`, initialising it with all the command-line arguments in one shot. (I'm sorry, I didn't know how to read your comment very well.) @shinjuo: Yep, exactly. Though, don't forget, if you want to exclude `argv[0]`, you must arrange to do this yourself. @shinjuo: For example, you could do: `vector args(argv + 1, argv + argc)`, although, if `argc == 0` (possible under Linux, and maybe other OSs too), then you invoke undefined behaviour. @shinjuo: The code you posted does exclude `argv[0]`, which normally holds the program name. On Windows, `argc` will never be 0, so don't worry about it: `argv + 1, argv + argc` will work well enough. Re your update question about not compiling, add `#include ` to your `application.h`. @just somebody: Congrats! Very nice (but hacky, but so is my solution :-P) approach to use debug messages. :-P @Paul: It's not because of the "wrong" shell being executed. It's because `popen` isn't the right tool for doing anything interactive, such as an interactive shell. @Software Monkey: I agree too, even though I wrote the accepted answer. :-P @Samuel: Why should it be community wiki? It's a perfectly legitimate point-scoring question. @AnonJr: The way I read the question, it does have a real answer, and the OP is seeking it. It's not "what is your favourite criterion for bringing a product out of beta?", but rather, "what is the definitive criterion for bringing a product out of beta?". Two obvious places to fix. :-) You need to call one of the \*UTF\* functions to convert from bytes to jstring. Also, the function signature should be using `Ljava/lang/String;`, not `java.lang.String`. Can you show an actual stack trace of which method is causing this high usage? @Amir: +1, funny. :-P Almost right: when doing `-exec ... +`, the `{}` must immediately precede the `+`. You can use the `;` form though: `-exec mv {} bar/ ';'`. @Jefromi: +1 for your insight, although a small nit: `stat` is usually a system call, not a library function. :-P @Martin: Thanks, I learnt something new! Will update my answer accordingly. @Brooks: Thanks! Very nice clarification. Except, DNS lookups are network latency-bound, not CPU-bound. As the question says, `_test` isn't being initialised at all. :-P In C++, the null pointer is either called 0 or `nullptr` (the latter only in C++0x). It's not called `null`. Surely, you meant to say `our %vers` instead of `my %vers`. :-P @caf: These days, yes (because of different `struct stat` layouts between kernel versions, and the need to keep user code binary-compatible). Originally, no, it was a straight system call. Nonetheless, good call. +1 @GMan: +1 Nice call, though, the Dinkumware page calls them keywords, so, I suppose they didn't care too much about the distinction. +1 Factory methods are definitely a good solution to working around many of the inflexibilities of constructors. @Tom (I'd say @tackline but that wouldn't highlight your name): Yes, how could I forget those. Adding them now. :-) @David: The original answer said `null` (in `` blocks), implying that you have `null` literally in program text. That was what I was correcting. The answer's author amended the `null` to become `NULL`, which of course is fine (I just didn't bother to comment further on it). @pixelbeat: Thanks! I was trying to model my answer after what the OP wanted (with `%s` and all), but obviously in this case, your solution is even better. @pinkynobrain: The problem with the quick check is that it shrinks the key space a lot: you have a quick way to find out all the passphrases for which the quick check succeeds. Therefore, you have much fewer keys to brute force the AES with. @David: Personally, I detest the use of `NULL` (partly because, as a macro, it's "second-class" compared to 0 or `nullptr`), so I didn't mention it in my list of choices in the initial comment (and why I didn't comment further on it when the answer was changed to use it). @Alok: I just made the links clickable (which the OP couldn't do since he only had 1 rep), so hopefully that makes your life easier. Maybe it's a homegrown `setproctitle`! :-P @Dean: You are correct (that I didn't say why it was preferred): I was going for a "Fastest Gun in the West" answer, but indeed, the added performance is why it's preferred. @Adam: And not all the `at`s either, just the hotspots. :-P +1 for code example (I was about to post one, but won't now :-P), but a small nit: `AF_INET` should be used for the address family (i.e., in the `sin_family` field). Personally I use `AF_INET` in the `socket` call too---the Open Group Base Specification doesn't actually have any `PF_*` constants---but I can see more of a case for "lenience" for `socket` and other non-address usages. @arav: It will get garbage collected eventually (probably soon, but no guarantees of promptness), but, that won't happen straight away at function exit. The try/finally approach allows the closing of the file to happen exactly when you expect it to happen ("deterministic disposal"). @arav: As to whether it's an issue if you don't close it explicitly, if you call that function too many times before the garbage collector can finalize your readers, then you will run out of available file descriptors, and no further opens will succeed (until some existing file descriptors get closed). On a related note, I sometimes really wish Java has `using` (a la C#). It allows deterministic disposal with much less code clutter, and encourages The Right Thing. What Neil said, but also, it'd be worth seeing how/if the code is thread-safe. @martin: I guess the C frontend chose not to "strip out" the empty loop body, unlike the C++ frontend. :-) Also, try compiling with different optimisation flags (e.g., `-O1`, `-O2`). You'll see dramatically different results. @Neil: Thanks for the link; I've changed my link (originally a GotW one) to use it. :-) You can join a thread, but that will block until that thread's finished.The other option, if you can make your code use the Executor framework, is to make your other Runnables tasks instead. Then, you override the `FutureTask` class's `done` method (via a subclass you write) to signal the completion of your task. @Aaron: Normally I'd have posted that as an answer, but I didn't want to spend the time (as I'm working :-P) looking up links for Executor, FutureTask, etc., which is how I'd normally write my answer. So, I thought I'd fire a quick hint for others to pick up and run with. :-) (Please feel free to flesh out my comment into a real answer. I won't mind.) @recipriversexclusion: I think people don't look kindly to "attention-grabbing" done for its own sake. See comment attached to http://meta.stackexchange.com/questions/26305/why-dont-stack-overflow-users-still-know-how-to-close-questions-appropriately/27313#27313 for example. Your post should stand on its own merit, not because you picked a catchy-but-irrelevant title, or put on a fake bounty (in joshhunt's case), or the like. @Tom: Huge bummer. :-( Well, we tried. :-) If you have to disable the back button, you're doing it wrong. Well-written Ajax toolkits are designed to handle the back button correctly (so that they will call your application's callbacks---with the same effect as clicking your navigational links). @Michael: Yep, and still with the basic message of "don't"---as it should be. :-) @OP: See http://www.useit.com/alertbox/990530.html, item 1. @tony: You can throw an `AtomicReference` at it and make it thread-safe. :-P (Or, if it's absolutely imperative that the class not be constructed more than once, then synchronise the `getInstance` method.) @Software Monkey: What makes a singleton "not an enum"? Where do you draw the line? An enum of 1 value (or even an enum of no values, which is legal BTW) is as good as any other enum, just like a tuple/sequence/list/vector of 1 or 0 values is as good as any other. It's too bad that you can't easily get a file descriptor from an `fstream`. You can easily enough check for an empty file using `fstat`, on Unix. :-P @Mike: The JIT compiler does. The source-to-bytecode compiler doesn't, but that's because it's not the place of the bytecode to be optimised, since it has to go through the JIT anyway. It's certainly possible for the JIT compiler to treat certain types, especially ones in `java.lang`, as magical. I'd be surprised if it didn't. @Matthew: Impedance mismatch alert---you and I are thinking of the JIT compiler, whereas I think Frank is only thinking of javac. The JIT compiler is where the heavyweight optimisations occur. Flow analysis at the JIT compiler end would easily tell you that the `Double` objects aren't escaping anywhere, so only their contained values are being used. I dare say that the function above should be easy to optimise in the fashion sought by the OP. @Thilo: Using `final` for local variables has no effect on the bytecode. Certainly, the constancy or not of a variable is for the JIT compiler to determine. @Chris Dennett: Yes and no. Making local variables `final` is mostly an aid to the programmer, to discourage (disallow) them from reassigning a variable (which does help the compiler). But if you actually assign to each local variable once only as a habit, then the presence or absence of `final` doesn't change the bytecode output at all. (The story is different with fields. I do have a policy of making as many fields `final` as possible.) Very seldom do you need to enter the bytes manually: often, like you say, the `u8` is used. So, high bytes just get treated as negative numbers in that case. @Roger: That's fine, but (on exception safety) compilers are not required to implement RVO, in which case, the `return copy` would cause the copy constructor to be called (again). (P.S. Throwing dtors are Very Bad News (tm), because if it happens during stack unwinding, `std::terminate` gets invoked, or something to that effect. So one can/should safely assume that this shouldn't happen.) @avakar: I'm not sure why the roundtripping is important in this case (unless I misread your comment). The way I understand the task is this: you need a way to convert a bunch of `char` into a bunch of `char16_t` or `char32_t`. You could easily widen a `char` during this conversion. @avakar: Normally, you read in byte data from a file or a network. Those will usually be stored as `char` already, in whatever signedness is native to the system. So in a signed case (in the OP's example), 0xC3, 0xA9 is read in as -0x3D, -0x57 (on two's complement systems). That's fine: the conversion functions can still meaningfully promote that into an int, and process them into actual code points that way. Instead of debug.log, try: `MAILTO=your@email.addy` (inside the crontab), then running `/bin/bash -x /home/username/twittercron` as the cron command. That will email the full trace at the end. If your servers aren't gonna authenticate with each other, why even bother with encryption? Either it's a truthworthy local network (in which case encryption is unnecessary), or it's not trustworthy (in which case authentication is necessary to prevent MitM attacks). But, you also want the keys to be weak, so the map entries will drop off when the collection object gets collected. My vote is for Google Collections' weak-keyed concurrent map. @Sinan: Can't believe you turned it into a code golf. :-P What you're seeing is the HTTP response header. Normally, web browsers never display this to the end-user. If it happens randomly, it's possible that the web server is re-echoing the HTTP response header in the response body. This, too, should normally never happen. @The Machine Charmer: +1, funny. I don't think the OP meant shorter in a code-golfing fashion, but, nice. :-) @dkrueger: 0x0C only works for 32-bit pointers. Granted, this is likely to be the case for ARM, but still, highly unportable. :-P @maligree: Casting is one of the fundamental operations in C, definitely not a "finer point". :-P (This isn't so much a poke at you, as the fact that C seems to require lots of casting to get Real Work done. :-P) @Mark, @Matthieu: I've added a C++ version just for your entertainment. :-) @Matthieu: I don't know how to use a constant and still avoid external linkage (which would make it unusable in a header file). @maligree: It can write too (returns a non-const reference). So you could say `uart0ctl() = 42` if you want. The key ingredient is the `&` in `unsigned volatile&`. :-) Is your program the web service wanting to get rid of the expiry for clients, or is it the web service client wanting to disregard the expiry from the server? Just don't follow his code examples of using pixel measurements for font sizes. Use points instead. :-P @matt: No, they're seconds from 1/1/1970. You should add a stacktrace of the `StackOverflowError`, to make it easy to see which line failed. +1 Yes, you do have to make a trampoline, but they're so gnarly (if you want to avoid globals, and all that)! :-( If the API were designed correctly in the first place.... +1 Oh, win! So, the API isn't as broken as I thought. @bobobobo: See Denis's answer. I think the API already supports this (obviously he's researched FMOD more than I have :-P). I'll keep my answer up as a cautionary tale for other API designers, but, at least you do have a solution. "Doctor, it hurts when I rub here!" "Well, stop doing it, then!" :-P Seriously, if a function has a return type, don't just `return;`, but return a value of the required type. @maligree: In so many ways, C++ is so very different from C.... :-P (BTW, this is why other commenters got on your case about referring to "C/C++"; C and C++ are such different languages that you should refer to them separately.) @fortran: The prevailing `signum` answer takes care of that too. @TheMachineCharmer: IIRC LAME doesn't do decoding (also, your answer doesn't answer the OP's question :-P). Indeed, I prefer smallest and fastest...gun in the west. :-P (I just realised that I hadn't responded to your comment for over a year, so I had to say something cheeky. :-P) Yes, I was going to write an entry that uses daemontools too. I'll write my own post, because I'm hoping to be much more comprehensive with my answer, and hope to get the bounty that way. We'll see. :-) How my answer nails the spec: 1. You have to set up services, so as long as you don't set up duplicates (and as long as your service does not background itself), no duplicates will occur. 2. `supervise`, the supervisor, takes care of restarting any service that exits. It waits one second between restars; if that's not enough time for you, put in a sleep at the top of the service run script. 2a. `supervise` is itself backed by `svscan`, so if a supervisor dies, it will be restarted. 2b. `svscan` is backed by `init`, which will auto-restart `svscan` as necessary. 2c. If your `init` dies for any reason, you're screwed anyway. :-P To answer other questions about housekeeping, the daemontools system doesn't use PID files, since they can get stale. Instead, all process information is kept by the supervisor backing a given service. The supervisor maintains a bunch of files (and FIFOs) in the service directory that tools like `svstat` and `svc` can work with. I don't like the `killproc` in the stopping part: if you had a process that, say, ran `java`, the `killproc` will cause all other Java processes to be killed too. Java strings are immutable, so each `+=` actually creates a new string by copying the entire contents of the previous one. (I presume your "huge memory fragmentation issues" is an oblique reference to this.) Or you can use `Arrays.fill(chars, 'a')`. :-) To me, a basic calculator doesn't need to be MVC, nor does it need to use the visitor pattern. Those were "features" I put in to make the entry more "enterprisey". :-) @Ricket: No it's not! It's still the standard way to interrupt a thread, because it works on a cooperative basis. Read Java Concurrency in Practice for more details. No, bad idea. Java has a built-in mechanism for signalling whether a thread should stop (interruption); don't subvert it. @pajton: The interrupted flag _is_ such a flag, except that it's also honoured by the JDK libraries (such as `Thread.sleep` or `Object.wait`), whereas a hand-rolled flag won't be observed by any of the standard libraries. @Jamie: No way Jose. This is a legitimate "standard" question. @pajton: If you are using built-in JDK mechanisms, such as `Thread.sleep`, or `Object.wait`, those functions can't see your user-defined flag (and therefore will keep waiting). If the interrupted flag is set, they will throw an `InterruptedException` straight away. @OP: Re your edit: You have to reassert the interrupted status (see my post) in the `catch` block (for your `Timer.sleep`). @Roman: `InterruptedException` is thrown if the interrupted flag is set at the time `Thread.sleep` is called, or if the thread is interrupted sometime during the sleep. If you're not calling one of the "waiting" functions, no `InterruptedException` is thrown, so you must check it yourself. @Roman: When an `InterruptedException` is thrown, the interrupted flag is cleared. So, you must set it again if you have later code that checks it. That's what the `Thread.currentThread().interrupt()` does. @Roman: If your thread does not sleep or wait in any way, then you must check the interrupted flag yourself. I've added some notes to my post to explain how that works. @Roman: Close enough. :-) In the Java world, there is a way to do amortised-constant time lookups, and still preserve insertion order, using a `LinkedHashMap` (space-time tradeoff). I wonder how easy that'd be to implement in C++. @Firat: I have a "better" way, which is to call the `valueOf` method of the boxed type, but that's really just calling a factory method and is functionally no different from using `NewObject`. :-P I think the OP is trying to implement an interface that requires the boxed object on return; short of changing the interface, you have no way to directly return the primitive. @Firat: No, there's `Integer.valueOf(int)`, `Double.valueOf(double)`, etc.; in fact, that's what gets used in auto-boxing. (Try it and see!) -1 No, both of those are immaterial considerations. (Normally I don't downvote posts, but ones that suggest that formatting changes will make any difference demonstrate a deep misunderstanding of the language.) But but but...aren't you the golfing wizard from anarchy golf? You should know Ruby like the back of your hand! :-D (That was a comment on the wishy-washiness of your statement about what `class_eval`'s behaviour is. If your intent wasn't to sound uncertain, I take my comment back.) @Firat: Please do, but chances are, they're pretty similar (unless you're boxing small integers: values between -128 and 127 do not construct new instances, when you're using `Integer.valueOf(int)`). @Adrian: Sometimes, yes. (`class Foo` is different from `classFoo`.) Other times, such as here, no. Knowing when it makes a difference is a sign of a competent programmer. +1 for excellent link. :-) @Adeel: I could probably improve it even more (discussions of when to use which, Google Collections, etc.), if I weren't trying for Fastest Gun in the West. :-P No, you won't be allowed to cast `objects` to `Integer[]`, because it's really of type `String[]`; you'll get `ClassCastException` at that point. @osgx: In GNU programs, the convention is to call that (`malloc` successfully or die) function `xmalloc`. @OP: I've updated my post to describe a couple of cases where it can be sensible to check for out-of-memory issues. @elduff: It's one thing to say formatting is good for readability. It's another to say it changes language semantics. (In a language like Python, formatting does indeed change semantics, but we're talking about Java here.) Being a good programmer means you're able to tell which is which. @Adrian: Depends on how you define "deep misunderstanding". To me, if one doesn't understand how code is tokenised in a given language (i.e., in Java, `String[]args` is tokenised the same as `String [ ] args`), that says something about how much they understand the language. @invariant: Yes, I missed reading that in the question. +1 @Cocorico: Some would say that using modulo for truncating the value of a random number is non-uniform, because it favours lower numbers. (Example: suppose the range of random numbers is 0..9, and you're trimming the value to 0..2. If you used `% 3`, then there is a bigger probability of getting 0 (40%) than 1 or 2 (30% each).) @Cocorico: Now, `arc4random` has a much bigger range than 0..9, so, the effects of this should be minimal. But just be mindful of it. :-) I actually refrained from mentioning Fisher-Yates in my answer for a good reason: I wanted to encourage readers to use the shuffle function that their platform provides, rather than implementing shuffling by hand. Pretty much all standard in-place array shuffling implementations (e.g., `std::random_shuffle` in C++, `Collections.shuffle` in Java, etc.) all use Fisher-Yates. No, `get()` is a really simple function that gets inlined by any halfway-decent JIT compiler, and doesn't perform differently to using an array directly. If the JIT is halfway decent (something I take for granted when I code in Java), it'd already have done this optimisation for you. Still, good to mention. :-) +1 Totally agree with testing any performance factors empirically. :-) I don't think that the profiler considered `get` the bottleneck per se, just that most of the runtime went there because it gets called so many times. Death by a thousand cuts and all that. :-) I like your edit. Too bad I can't upvote you twice. :-P Stack Overflow does not have a conflict-detection mechanism like Wikipedia has. If you're both editing at the same time, the more-recent edit will trump, and discard everything in the earlier edit. @Carl: Probably, but doesn't change the O(n²)-ness of the algorithm. :-( tl;dr (Sorry, had to say it. :-P) Copying to a naked array is a complete waste of time. Don't do it unless profiling suggests you'll get any speed improvements from it. Here's my simple benchmark to substantiate my statement: http://codepad.org/LZUfDcTL You could just say `else`, since the condition in the `else if` is guaranteed to be true. But otherwise, you got it all right, despite apparently not knowing Java. :-) Maybe the OP translated it from Scheme! (Unlikely, but had to say it anyway. :-P) Not very mysterious. Eclipse uses its own compiler, not `javac`. (I've updated my answer with more details. :-P) I apologise, you're right about the `StringBuilder` dominating the access time (especially because I mistakenly used `append(byte)` instead of `append(char)`, which caused reallocations to occur to the `StringBuilder` in question. Changing the code to use `append(char)` changed the profile a bit: `List` and `Integer[]` took about the same amount of time, but `int[]` was significantly faster. (This could indeed be one argument for arrays: you can have arrays of primitives, but you can't have lists of primitives.) Anyway, looking at your code now. :-) Wow. I totally take back my comment about `get()` being fast. (I both ran your program as well as modified mine to use `get()` in place of the iterator.) I inspected the source code to the `ArrayList` class, looking at both the iterator and the `get()` implementation, and am still scratching my head as to why there's such a huge difference in performance. Wow. You win. +1 I eat my words about `get()` being as fast as array access (which is different from saying that lists are slower than arrays: they're not, just that `get()` is slow for some reason; iterator access is fast). To add another chapter to this story, spong posted a very convincing benchmark that shows that `ArrayList.get` is actually slower than direct array access (but, somehow, using `ArrayList` iterator is just as fast as direct array access). So, I retract my comments on this matter. :-/ @Jörg: +1 for edit (I wish SO provides the ability to upvote edits; oh well). That indeed is the more common use of `class << self`, to create class/module methods. I will probably expand on that use of `class << self`, as that is a much more idiomatic use. What if `generateX` had side-effects? /me runs the program with a few copies of `%n` in the format string...mmmm.... :-P The fact that this question needs asking at all shows a weakness in the Windows command shell. In the Unix shell, you can send argument strings that contain newline characters. @PoweRoy: An untrusted format string can be used to corrupt memory in arbitrary ways. For example, with the `%n` format I mentioned, it writes out the number of currently-written characters into the address pointed to by the next argument. Since the attacker controls the whole format string (in this case), they also have control of what value gets written. Embed a few more `%n` and you get even more scribbling. @Marc-Andre: Wow, that was a very recent decision (capitulation? he seemed very reluctant throughout the thread) on Matz's part. Still, good that there is agreement on what to call it going forward. I almost upvoted your answer (it's very similar to mine), but I don't like this "division by 1024^$pow" business. You should just do 1024^fraction($pow) and be done. :-) If you used `$bytes /= (1 << (10 * $pow))` or the like, I could like it better. :-P Do you mean something akin to GCC's `noreturn` attribute? Yes, that'd be useful (for both C# and Java), IMHO. @Kobi: Eh, points are just points; it's not the end of the world. If this thread generates useful discussion, that matters more (IMO). YMMV. :-P The trouble that I think Jon is pointing to, is that unlike C or C++ (where if you change the header file after compiling a source file, all bets are off, so programmers learnt not to do that), compiled code units in .NET are not subject to the same rigour: if `Assert.Fail` is `noreturn` by virtue of, say, calling another a function that's `noreturn`, and you later recompile that function to no longer be `noreturn`, the system has a harder time of verifying that `Assert.Fail`'s `noreturn`-ness still holds (short of recompilation). @andras: Any function can throw an exception. What would the control flow be? :-P +1 for mention of Pecs. :-) Which platform are you using? On non-Windows platforms, `wchar_t` definitely is not synonymous to `unsigned short`. Not that this has any bearing to the problem you're facing, of course. :-P @KnockKnockWhosThere: Read http://www.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02 for more info. :-) @Jefromi: I think they're referring to `basename`. +1 for defensively copying `Date`, as well as explaining why it's stupid to even have to in the first place. :-) You should state what you are expecting to happen, what is actually happening, and how the latter differs from the former. I dare say that members of SO, other than Jon Skeet perhaps, do not have ESP. @Joshua: In the bottom of your C++ code, you're just calling `PL_toplevel`, so I presume that displaying the Prolog prompt is exactly what should happen. @Thomas: Are you being snarky to a poster who has 3x your rep? Seriously?! :-P Bow to your elders already! :-P +1 This is clearly the "right" way to do it. The other way is (while intuitive) just hacky. :-P @rlbond: I think const reference should work too...see the OP's comment about how it sometimes works and sometimes not. That's what led me to believe some other code `#define`'d a new value of `INCORRECT_FRAME` later. Pointers (and especially `char*`) are not class types, and cannot be derived from. :-) Definitely not programming related---voted to move to superuser.com. :-) +1 I agree with using a factory method to create new instances. It's a bit like `clone`, only that it returns a blank instead of a copy. Unfortunately, because `Object.clone` is protected, the only way you can do that with objects of unknown type is to invoke `clone` by reflection. :-P And if you're gonna use reflection, you may as well reflect on the factory method, or even the constructor. :-P In Scheme, `fold` is provided with SRFI 1 (http://srfi.schemers.org/srfi-1/srfi-1.html). If you're using PLT, say `(require srfi/1)`. If using Guile, say `(use-modules (srfi srfi-1))`. For other implementations, read their respective manual. :-) Here's a spoiler: http://inferretuation.blogspot.com/2008/05/lists-and-lists-tail-recursive-fun.html If this is for homework, you may not want to read it until you've submitted your own answer! But a program can! Any program that can execute the equivalent of `kill -KILL -1` can cause all your instances to die simultaneously. Fail, your answer can be tail-call optimised. :-P (Compiler turns that effectively into `goto _main`, where `_main` is the global symbol corresponding to your main function.) @Callum: Unlike your answer (which I now did look at), mine actually prints the numbers (even if the program runs endlessly). :-P I'll update the post to say what the script does. @Søren: +1 Very good point. I'll try to think of another example where a 64-bit `size_t` comes in, then update my post. Any suggestions you have are welcome. :-) What language is that? GolfScript? :-) inb4: This looks remarkably like (something that can be refactored into) the visitor pattern. :-D Updated my version to actually add some error checking, because getting segfaults on an empty stack really bugged me. :-) It's also home of the unofficial SO channel, #stackoverflow. :-D Although your answer is still longer than the winning answer :-), it's still a pretty neat approach, so +1 to you! +1 Also, obligatory link: http://en.wikipedia.org/wiki/Argument-dependent_lookup If people _really_ want to extract your program resources, there is nothing you can do to stop them. A good interactive debugger (think IDA Pro) is pretty much all you need. What Amber said, plus hyphenated names. :-) (Say I, who has such a name. :-P) Actually, Chinese pinyin can contain apostrophes, to disambiguate between, say, Xi'an (two words) versus Xian (one word). If you want to enforce, say, ASCII only, you can use the `[:ascii:]` character class. @ohho: Spaces are ASCII too. If you want to enforce 2 or 3 words, then maybe something like `[^[:^ascii:]\s]+(\s+[^[:^ascii:]\s]+){1,2}` should work. (Not tested.) You cannot have `-` as part of an environment variable name. `"" + 123` becomes `"123"` because you're specifying a constant. Now try `"" + Math.random()` versus `String.valueOf(Math.random())`. @corgrath: Don't mind Philip, I think he meant primitive types, not POD types per se (which is a C++ concept). In C++, POD means "plain old data", which means (very roughly) that objects of such types have value semantics. (The real definition of POD type is rather more stringent than that.) @corgrath: Only if `x` is `static final`. @Bozho: `Object.clone()` performs shallow clone, but any class that implements `Cloneable` should override that method to perform a deep clone. @corgrath: For non-statics or non-finals, the constant optimisation described in this answer will not apply. "Static/final" can be misleading. A field must be _both_ static and final to be considered a constant, and only for primitives and strings. (Local variables are never considered constant.) Not so simple. See stacker's answer. If instead of 123 you have a non-constant value, then you'd be correct. This is not strictly correct from a code generation point of view, so I will refrain from upvoting. It actually (for Java 6u20, which I tested with) expands to: `new StringBuilder().append("").append(yourObject).toString()`, assuming that `yourObject` is not constant. +1 Also, re arbitrary number of parameters of a single type---is that any different from Java 5 varargs, and in other words, how interesting is it compared to the latter? :-) IIRC, `bind` doesn't actually return a `function`, but something convertible to one. Try using `auto` instead. No, not quite what I had in mind, but I've come to realise what I had in mind won't work as there is no convenience `make_unique_ptr` function. :-P But I hope this works (I don't have a C++0x system to test with): `std::unique_ptr` +1 Wow, you're totally right. I'm actually embarrassed I didn't think of that while writing the above comments. @DeadMG: Java's handling of varargs isn't so different from how Go (thanks Jonathan!), Python, Ruby, Scheme, etc. handle it. So while it's not like how it's done in C, that's no disadvantage. @R..: What?! In a two's complement system, signedness doesn't affect modulos by powers of 2 (it's just an AND on the bottom bits), and doesn't affect divisions by powers of 2 as long as your processor architecture has an arithmetic right-shift operation (`SAR` in x86, versus `SHR` which is for unsigned shifts). @DeadMG: If you want to call it syntactic sugar for arrays, you're welcome to, but understand that the varargs mechanism for Go, Python, Ruby, Scheme, and probably other languages are _all_ handled in the same way, and is in no way unique to Java. Except, perhaps, that the packing of "rest" arguments into an array/list is done by the runtime for the other languages, whereas in Java it's transformed at the caller level. Maybe that was your point? \*shrug\* Oh, fail. :-( Hmm. @Roger: Yes, the compiler must accommodate negative values, and it's extra cycles (so unsigned is still more ideal), but on x86 (which I tested with), gcc still doesn't generate a `DIV` instruction. It does the equivalent of: `num < 0 ? ((num + 7) & 7) - 7 : num & 7` (but without any branching, multiplication, or division whatsoever). So, it's not "extremely slow" by any means. @Willi: If I could assign them to you, I would, because I've already hit my rep cap for the day, so I'm getting absolutely no rep for this answer. :-P @Colin: Welcome to Java! If you want straightforward, code in Ruby or Scheme. :-P @Colin: Totally agree, and in fact, my answer doesn't use any Guava classes at all, just what comes with the Java Concurrency Framework. :-P @santiago: If you really want to watch Guava shine, try the `Multimap` and `Multiset`, and the soft/weak keys/values with `MapMaker`. :-) (There are of course many other features, too many for me to cover.) @DeadMG: Okay, fair enough. Right, but this (the original post, since fixed :-P) doesn't address the "why", only the "what". See the Boost.Function FAQ for the "why". If it's only two integers, why are you not using `std::pair` as your key? Protip: Never use text directly as encryption/decryption keys. That reduces the search space drastically (also, reusing the same symmetric key makes it easier to recover). Instead, use PBKDF2 or the like to convert it into much more suitable key material. Bonus points, use a real key management protocol like what OpenPGP has; that way you ensure that no two messages use the same session key, you can revoke public keys at will, etc. Nice, you beat me to it. :-P +1 @Sheldon: Of course. You want to be able to use all the juicy jQuery goodness, don't you? :-) @skaffman: Eh? I don't see how your answer relates to whether xjc chooses `JAXBElement` over `Foo`. Why even reference `stdin` at all? Why not just use `int fd = 0`, or perhaps `int fd = STDIN_FILENO`? @skaffman: Okay, fair call. @Oren: It's pretty obvious what the OP wants to do---make it so that if, say, the angle is 45 degrees (e.g., `targetSpeed.x - speed.x == targetSpeed.y - speed.y`), then the increment is still `speedStep`, not `sqrt(2) * speedStep`. @DrDipshit: Indeed, I fixed my answer to do just that. :-) http://www.fogcreek.com/FogBugz/blog/category/Wasabi.aspx :-P Given that SQLite has no database server, wouldn't a Type 4 JDBC driver mean that you'd have to port 100% of SQLite to Java? @sbi: The code snippet is for Java (as any seasoned Java programmer can tell you), however, yes, you rightly point out that the OP could have stated this more directly. @Klaim: Why would it depend on the compiler? The `global_initializer` instance has to be created, unconditionally. Yes, `${a%.txt}` will do that (or `${a%.*}` to remove any suffix). That's _way_ too painful for the task at hand. :-) @David: My solution doesn't cause a bunch of errors. :-P @GMan: Boost has `prior` and `next` functions for doing just that (it takes the iterator by value, thus making a copy as you suggested). See http://www.boost.org/libs/utility/utility.htm for details. @xor: If you have two pointers, and change one of them, the other stays the same. Understand, though, that we're talking about changing the pointer, not the pointer's referent. @naikus: +1 Indeed, inner classes require outer instances, and thus are non-static _by definition_. (In other words, inner classes are a subset of nested classes, namely those that are non-static.) +1 for not confusing inner classes with nested classes. Huge peeve of mine. :-) @emory: That's right. Yay for an answer using arrays! +1 Well, it's wrong in that its processing then depends on `$IFS`, which is, like you say, possibly insecure. @dehmann: Nah, it's a British-vs-American English difference. In British English, "orientated" is more common than "oriented"; in American English, it's the other way around. @Alexander: Yay for boycotting American spelling! (I'm a New Zealander, and though we can have our trans-Tasman rivalries, I'm sure we can work together at least in this instance. :-P) @Michael: Your uni was obviously brainwashed by American spellers. I bet they never used "spelt" or "learnt" either. :-P Re "scoping rules can be a bit much", I've found that a good mental model to use is to macro-expand the `let` into the respective `lambda` (and `let*` into a sequence of `let`s/`lambda`s). Of course, this won't help beginners much; oh well. In some architectures, that is certainly possible. Yagni. Seriously. Who cares about filenames that contain spaces or non-numeric characters if that's not in the scope of the question? If the OP wanted to write a general-use script, he would have said so in the question, and the answers would have accommodated accordingly. ...most base 10 fractions, that is. For example, 0.1 has no exact binary floating-point representation. So, `1.0 / 10 * 10` may not be the same as 1.0. This will only work if the directory handle is for the current directory. `unsigned short var[]` is not an integer value. It's an array of `short`s. :-P The use of `[.]` is very curious---why do you prefer that to `\.`? @Quartz: Some people do it as a micro-optimisation because they think the compiler can't handle `/2` properly. I, of course, disagree. Read the question: it does say `int`. :-P @AndreyT: Added a comment addressing your concern. :-) If `a` or `b` is floating-point, then `>>` doesn't work and the program won't compile anyway. So, we'll safely assume they're both integral. Okay, you win. +1 Agree, though, my answer was trying to address the intent of the code, rather than what it actually does. @KeithS: Right, and that's what AndreyT's point is: it's implementation-defined. On x86, there are two instructions, `SHR` and `SAR`. `SHR` does what you say: shifts in 0. `SAR` shifts in the top bit. So, since compilers are free to choose which instruction to use, you can get varied results. While you're fixing your code, consider using `static_cast(*this)` instead of C-style `(float) *this`. +1 You beat me to my answer. (The other posters should delete theirs like I did mine. Late answers usually get no upvotes.) As does Guile. :-P Agree that it's a much more superior solution. +1. I wrote a direct answer to the OP's question too, as well a fully-spelt-out version of your approach. I hope you won't mind. :-) @COMer: It always uses register 1 (`cx`/`ecx`/`rcx`). In your case, since you're using the 32-bit instruction, it will use the 32-bit version of that register, thus, `ecx`. @PhiS: I added something, though I don't know if it's comprehensive enough. :-P @David: Please read ybungalobill's comment fully---it _can_ be conforming if it doesn't invoke UB. For example: placement `delete` doesn't do anything with its argument (at all), so, it doesn't need to check for null either. @David: So, with custom `new` operators, you can (and should) define corresponding custom `delete` operators, so that if the construction of the object fails, the allocated memory can be deallocated. Placement `delete` corresponds to placement `new` (which, of course, also does nothing except return the given pointer). @David: Right, I wasn't suggesting to make a placement `delete` yourself, but using it as a counterexample for the "must check null or is non-conformant" statement. At the maintainer's request (I verified this answer with him on IRC), I've filed a bug for the documentation: https://bugs.freedesktop.org/show_bug.cgi?id=30510 @jim: Do you mean `Collections.singletonMap`? Yes, that works, but it's immutable. :-) @Ibrahim: In this case, it's superfluous---the behaviour is exactly the same if you took the `super()` out. Normally I'd just lop it off if it's optional, like it is here. You need to put the 20081010 _before_ the 20091109. Like Eli said, using a name-based dispatch mechanism is totally fugly and broken. Scheme isn't PHP. Just don't go there. :-P This clearly explains why C++ is more superior to Java. :-P @Justin: I think Bert's point is that your score is awfully low (given you've been on the site for two years now) for someone who's as competitive as you say you are. :-P (Mine is nothing grand either, but then again I'm not very active on this site any more.) Sure, I understand that the OP doesn't care to insert, so a `lower_bound`-based solution is overkill. I kind of just mentioned my answer "for completeness"; like I said, yours is perfectly adequate. :-) @Matthew: Thanks! Fixed up the answer with something a little more general (albeit insecure if the directory is writable by malicious parties). @Jonathan: I've revised my solution with your suggestion, as well using `set -C` to mitigate symlink attacks or anything. It can fail if the filename is already taken, but at least people can't trick you into clobbering files you don't intend to. ;-) Works for me...can you paste the error _verbatim_? Valgrind, of course. :-P @I. J. Kennedy: Only the `ds` can be overridden. The `es` is fixed. In general, any instruction that uses `ds` by default can be overridden with a segment prefix; any instruction that uses `es` (e.g., `stosb` and the like) is fixed and cannot be overridden. Oh hey. Just a heads-up, your avatar is identical to Mike Stone's. I actually asked him about it, and he said to me that he actually made the avatar himself, by stepping frame-by-frame through the particular episode and actually manually editing out the background. I don't think he appreciated people ripping his avatar, either. :-( Cool, thanks! Yeah, things do bounce around the Internet for sure, so, these things happen. \*nods\* But yes, it's a small world, right? ;-) @elektronikLexikon: I can't (because I think it's straightforward enough to do by yourself), but start by playing with (and reading about) `Class.getResourceAsStream`, making sure you understand how that function locates resources. Put the font file in the correct place (usually in the same location as your `.class` files), then play with it till it works. Once it works, passing it to `Font.createFont` is easy. Surely, making your function take `Key` should work? (Correspondingly, your `parent` field must also be of that type.) `results=$(find ...); num_entries=$(echo "$results" | wc -l)` @livibetter: That's not what the OP was asking. :-) Don't forget the quotes: `for j in "${abc[@]}"`. As Matteo alluded to, ATL is not included with the Express edition. I vastly prefer to use the hash and/or array forms where possible, and only use the string form when I must write straight SQL. That way nobody is tempted to refactor it into a form that is open to SQL injection in case they want to delete a parameterised type. No, don't specify the `:conditions` key! The `delete_all` method just takes conditions, not a general `find` spec. @Parixit: Correct. Well, in both two's complement and ones' complement, the top bit specifies signedness. Take away the top bit, and you'll notice that there are 7 bits available for positive values, and 7 bits available for negative values. @Channel72: "even though `b` and `c` are different variables with different locations in memory"---that's actually a major assumption, one that often doesn't apply. If `b` and `c` are local variables, chances are good they're both actually backed by registers, rather than a memory location. In that case, the memory location is simply a temporary holding place that's set up purely to accommodate your `m` constraint---in which case, `b` and `c` could very well use the same temporary location. Now, if `b` and `c` were actually both really backed by memory locations, then you'd be right in that normally they shouldn't overlap at all. And, if one is backed by memory and the other is backed by register...then either of those scenarios is possible. @steven_desu: Code design is seldom about counting assembly instructions. The `dirty()` approach is actually cleaner from a once-and-only-once point of view, and is preferable to the other approach. Also, modern Java runtimes have method inlining, so, runtime-wise, it makes no difference. possible duplicate of [Why is there a delete\[\] in C++?](http://stackoverflow.com/questions/3694333/why-is-there-a-delete-in-c) @Kizaru: I know you can't _use_ it for your project. But you should _learn_ with it first. Use nasm as your assembler, initially. Then, once you get the hang of x86 assembly programming, _then_ use AT&T syntax. Have your project be able to output to both formats, initially targeting nasm, if you want. @Kizaru: Okay. Other suggestions for you, then: 1. Look at the `libm` source code; much of it is written in x86 assembly, and yes, in AT&T syntax. (On GNU/Linux, this comes as part of `glibc`.) 2. Compile some floating-point code in GCC, and look at its assembly output. Re edit: So, follow the suggestion to read `libm`, and read the Intel manuals. I'm sorry, you have no alternative. There are _no_ decent AT&T-syntax-based resources, because _nobody_ serious about x86 assembly programming uses it. Okay, so I was a little too harsh about saying that nobody serious uses AT&T syntax. Anyway, if you Google for "devpro-libm", you can download the `libm` code used in OpenSolaris. This may be a more lightweight download than `glibc`. Then, look in the `usr/src/libm/src/i386/common` directory---it's a goldmine of hardcore floating-point assembly, all written in AT&T syntax. +1 Wow, that's a pretty comprehensive guide, at least at a brief glance (I know x86 FP, so didn't feel the need to read through it in detail ;-)). Yep, hopefully between that and the `libm` code, you'll be all sorted. The latter is actually very well-commented, it's not just a big bunch of magic spells. :-P Very unusual, right, not very usual? ;-) @Mike: Well, I'd presume for non-strict (lazy) languages, or ones which support generators, you can just write the function for generating the whole (infinite) sequence. For strict-only languages, print out elements until interrupted by the user, or something like that. @Ben: The pipe can be closed via some other means than the process's death, and so isn't quite as reliable. But if you don't control the parent process, that may be the only option you have. (daemontools has a `fghack` program that works on that premise.) +1 for using read-write locks. People are _way_ too happy with `kill -9`. Any guide that suggests using `kill -9` as a first resort (or anything other than a last resort) should be shot on the spot (an eye for an eye, much? ;-))---the author of such a post is demonstrably clueless and not worth your attention.  (Hint: `kill` (synonymous with `kill -TERM`) is _very_ different from `kill -9`/`kill -KILL`, in that the former gives the program a chance to shut down normally, whereas the latter is an abrupt program termination.) @BeachRunnerJoe: I'm ranting against clueless post authors, not you. :-) As I mentioned in my second comment, `kill` (without the `-9`) will do well enough. @BeachRunnerJoe: It's okay, but it's a hot spot of mine. I'm the kind of programmer whose philosophy is that "just works ain't good enough if it ain't otherwise good". I'm OCD like that. :-P Like I said, I wasn't criticising you at all; heck, you couldn't have known any better, given the voluminous amounts of misinformation on the intarwebz. ;-) Function calls themselves don't correlate directly with performance problems, in dynamic languages; function bodies could be inlined in, for example. Nice change. :-) Too bad I can't upvote you twice! So, you need to write two functions: in the test cases, I've named them `str2num` and `num2str`. The first one converts the given string to a number, using the given base. The second one converts the given number to its string representation in the given base. To get you started, you have to know to distinguish strings (the bits enclosed in quotes, in my test cases) and numeric values (the numbers not enclosed in quotes). Your `str2num` and `num2str` functions have to convert one form to the other. In Python, you can use `str('1234')` and `str(1234)` (for example) to tell you which is which. Surely, for a homework problem, you aren't allowed to use shortcuts like `int()`? ;-) Yes, if the aim of the course is learning the language. But if the aim is actually to understand the operation of base conversion, with the language as purely a vehicle for practising that understanding, then the course requirements will reflect that. `assert` is pseudocode here. It just means, "this expression needs to be true". In other words, `str2num('1234', 16)` needs to have the same value as `0x1234`. As for the calculations themselves, that's something you have to figure out for yourself---this is homework after all. Your answer is good, and I'm upvoting it. However, I discourage the `insert(0, digit)` approach unless you're dealing with a linked list---with an array (which Python uses, IIRC), each `insert(0, digit)` is an O(n) operation. (The `reverse`-at-the-end approach is the best one, of course.) @Just a Student: `int()` is built-in to Python, no modules needed. No, `p = w` is fine; you just need to adjust for it a different way. It needs a `% 6` somewhere to make the numbers wrap back to 1. 360? You heathen. Should be `2 * math.pi`! :-P @S.Lott, @Joey: Okay, you both win. :-) (What, so you're into boat-programming?! :-O) From what I've read, COW is faster in single-threaded scenarios, where there's no real locking contention, etc. This certainly corresponds with the OP's timing harness---I see no threads being mentioned in the question. Well, you can always use quasiquotation: `\`(,param a "First")` @melee: Don't write in QP by hand (i.e., your template should use `=`, not `=3D`). :-) If your email software needs to use QP, it'll convert automatically. ...one branch is a performance overhead?! Did your profiler say this? I used to know a Cameron Skinner who used to go to University of Auckland, and had some involvement with the Tramping Club crowd. Are you the same Cameron Skinner? Curious. :-) This is Java, not C#. You don't get niceties like `IoC.Resolve()`; at the very best, you can use `IoC.resolve(Game.class)`. :-) (Java has erasure-based generics: the type parameters will not be available at runtime.) @Guillaume: Indeed, it's best not to be too gung-ho about using singletons, though there's a time and place for them (function objects without state being my current favourite example). Knowing when your situation is such a case or not is the million-dollar question. +1 Dependency injection is a good idea, though you should call it that, not just DI. The OP is still a student, and many students have probably not heard of things like dependency injection and inversion of control. :-P I agree that IoC/DI is a good way for this instance (my post about singletons notwithstanding...some would see it as the devil's advocate option), though, I actually liked Landei's answer better, because it touches on current technology in this area (Google Guice). +1 for the very useful link. Well, C may not have exceptions but C has `setjmp` and `longjmp`. Yep, you heard it here first. :-P (P.S. Any changes to your local variables might get undone, beware.) @Steve: Thanks, I aim to please! :-P +1 @Falmarri: In Python, you can't; in other languages, you very well can. I was addressing the distinction between 0.0 and -0.0 in a general floating-point processing sense. @DMan: "Almost" all languages? You surely jest. Try the following expressions in JavaScript and Ruby: `1/0.0`, `1/-0.0`. @DMan: The point of my post is this: support for infinity is built in to most floating-point processors. Disallowing division by zero doesn't come "for free", but must be designed into the language. So, for better or worse, many languages just don't bother. Also, thank goodness, C# and Python are not "almost all languages", nor even close to it. @dan04: Point. (+1) I'll revert my post, then, and let the infinities stand on their own infinite feet. ;-) @Jim: It's HTML in UTF-16LE encoding. (Read every second character.) Re your edit: Python generally does not have autovivification (unlike Perl). Therefore, you can't specify a non-existent key/index and have the slot spring into existence. With dicts, you can have a limited form of autovification by using `defaultdict`; by using `self.details = defaultdict(list)`, you can have a dict that automatically puts in empty lists on accessing a nonexistent key. But you cannot do the same for nonexistent indices for your lists. @pras: Your browser doesn't like the byte-order mark (BOM)? Try using `UTF-16` instead of `UTF-16LE`. Though, your browser violates RFC 2781, which says that the BOM is supposed to be accepted (but optional) if `UTF-16LE` is used. Using `new Integer(0)` is very wasteful of the heap. Consider using 0 and letting the autoboxing work, or if you detest autoboxing, use `Integer.valueOf(0)`. Yes, but so? It gets inlined by the JIT compiler into the cached 0 value every time. Nope, it does `Integer.valueOf(0)` (which uses cached boxed values for numbers between -128 and 127). Both you and the previous poster should be doing some profiling, of course. :-) Visitor pattern! :-O (Well, something related to it, at least.) Probably, the easiest way to do it is to use XSLT (write a stylesheet that copies the allowable elements and attributes), but that only works if your document is XHTML (unless XSLT has an HTML mode---I can't remember if there's one). @Mark: Actually, if I read the question correctly, the OP could get it to compile successfully using `Outer.Inner` in javac. And that's the best you can do, in this instance. Should `Outer.Inner` ever be allowed? That's the part I'm not sure about. In what way does your Java program use the current directory? You can't even do `chdir` in Java, so, the idea is that your program should be cwd-agnostic. @user243655: The `operator<` function I pasted above has to be a free function (outside of the class's definition). Also, `operator<` has to return a `bool` specifying whether the left-hand side is less than the right-hand side. In the second case, so that we don't have N^2 calls to `containsKey` (which would effectively make your function O(N^2)), I'd rather just compute the key-set difference for each map in question. The function is still O(N^2) (since the differencing is O(N) and it's executed N times), but, the constant factor is likely to be lower. @user243655: Because you need to qualify both `lhs` and `rhs` as `const`. Try this: `bool operator<(A const& rhs) const {...}`. (Notice the `const` in two places.) @Let_Me_Be: Deallocating an invalid pointer is well-defined?! :-O @Stephane: It's `std::tr1::shared_ptr`, not `std::shared_ptr`. Scheme's `<` function _already_ takes any number of arguments, including 0. Why would you need a custom `<` function? The problem with using `list?` is twofold: 1. It has to traverse the whole list to determine if it's a proper list, every time (whereas `pair?` does not need to traverse), and 2. Do you want to strip out improper lists too? They are not atoms. I think something like `(or (pair? foo) (null? foo))` is more reasonable. @Joe Blow: The OP asked for the "best" random number generation system ordinarily available, so, I was answering to that. Also, `arc4random` is awesome: it uses kernel-collected entropy and all that good stuff. What you have seems fine. Any decent implementation would support 64-bit files (larger than 2GB, I mean), and thus 64-bit totals too. @Thilo: Indeed, a listener list is the usual use case for `CopyOnWriteArrayList`. @Joe Blow: Actually, `arc4random` is crypto-grade randomness. It's equivalent to reading from `/dev/arandom`. So you could use it for crypto-grade stuff, if you handle the randomness correctly (and don't unwittingly skew the results by not doing the check I mentioned). @William: Funny. :-) Actually, I've done reverse engineering for many years; this is pretty much like RE, only easier because I'm not dealing directly with object code. :-P @codaddict: Semantically, it's no different: `n` monotonically increases, and stops after 120, hence, will never overflow back to 0. i.e., `n += 7` is never going to be false, for the purposes of this code. +1 Don't forget the nasal demons! :-P Curious: was your approach inspired by [Cheney on the MTA](http://home.pipeline.com/~hbaker1/CheneyMTA.html), or did you come up with it some other way? +1 for the "based on this switch statement, you could remove it completely and get the same results". Smart arse! @Steven: Actually, that wasn't what my post was about. :-) Rather, instead of returning your `Thunk` object zillions of times, just make `Thunk` a throwable type (preferably a `RuntimeException` or `Error` so you don't have to declare it), catch it at the top-level, then make your `catch StackOverflowError` block throw an instance of `Thunk` rather than return it. Why would session cookies be kept anywhere other than the browser's main memory? It's supposed to not stick around after you quit the browser. @Martin: In MSVC, that is called "whole-program optimization". You didn't hear this from me, but I've (in a previous job) actually done stuff like `GetProcAddress` the mangled names of `extern "C++"` functions. :-) (And if it's good enough for `GetProcAddress`, I'm almost certain it's good enough for `dlsym`. :-P) @user553514: Are you using the same namespace for each header file, or a different one? My intention is that you would use a different namespace for each different library's header files. @Steven: Oh wow, impressive. Good work! +1 +1 for getting the part of the code that's wrong. However, the code's design is wrong too (see my post), and after fixing _that_, there is no manual comparisons of names any more, so this problem doesn't crop up. @Brian: +1 Yes, you're right, `TreeSet` is good too, though by using a map keyed by the name you can just use natural ordering and not have to write a custom comparator. (`HashSet` is fine in the general case, but here the OP wants the items sorted by name.) @Sam: That is an implementation detail, which is not required by Scheme per se. An implementation is free to use IEEE754 floating point datatypes to represent exact numbers (which have to be upgraded to other datatypes, like rationals, if further results don't fit, of course), or to use rationals to represent inexact, if it wishes. +1 for _forgot_. :-) (The rest of the answer is good too, but, I liked that bit especially.) Try Googling "lisp fasl" and "fasl lisp"; you'll find some interesting entries. :-) As far as I know, each Lisp implementation that supports FASL has its own FASL format (or at least, FASL files generated between different implementations don't interoperate), so if you're writing your own compiler, you probably have to pick one format to target. Do you have some code? It's hard to think about a problem without having some code to look at. @Bozho: It's too bad the question isn't more explicit in what the OP wants. :-( Both your answer and mine are correct, depending on how the question is interpreted. @templatetypedef: My pleasure. :-) BTW, if you're applying to Google, you're expected to know that this method is basically a variant of Fisher-Yates shuffle. Except that instead of leaving the shuffled values in the array, you're extracting them all out. :-P `strtoul` is even better, because who uses negative modes, seriously? :-P Also, report errors with `errno` included, such as by using `perror` or `strerror` (or `%m` in the format string, if using GNU libc). +1 The range 0--255 applies if `CHAR_BIT` is 8; but, no matter what `CHAR_BIT`'s value is, -1 is never a valid value. Mark Byers's answer is correct. For this to work, you must always store the output of `getchar` or the like as `int`, not `char`; `(int) -1` is not a valid character, but `(char) -1` is. @Chris Lutz: Right; I was thinking of the case where `CHAR_BIT` is 16 or 32, not 7 or anything like that. :-) Not only that, but `scanf` is notoriously hard to use correctly (given sufficiently malformed input, `i` would fail to get initialised, in this case), and also I think the OP wants different behaviour depending on whether the `0x` or `0` prefix is present or not. Indeed, `eax` is probably the most frequently clobbered register. @Samuh: It raises the bar a little, but in the end, a skilled reverse engineer can still get at your program. Just keep that in mind. There isn't a way, to my knowledge, of enumerating all the currently-loaded classes using reflection. @Voulnet: It's uncommon in the Unix world to use wide characters (most programs use UTF-8 instead), so it's a non-issue for the most part. `std::string` has an interface for dealing with C interfaces: `str.c_str()` will return a `char const*` that you can pass to C APIs. Well, here's a [Socratic question](http://en.wikipedia.org/wiki/Socratic_questioning) for you: Why do you think the non-`local` version is "probably faster"? I'll post a real answer to this question after hearing your thoughts. :-) @Charlie: That error message is a dead ringer for Racket (or PLT Scheme, if the OP is using an older pre-Racket version). @stacker: Thanks for the +1! We actually use jhat a lot at work, and I actually get to work on improving it on work time: https://github.com/on-site/fasthat (I haven't implemented anything exciting yet, but I have a roadmap for features that our team would really like to start using.) @Amber: I +1'd your comment because you touched on MD5's speed being an antifeature for password hashing---however, SHA-1 is still the wrong approach. (No general-purpose hash is good for use for password hashing.) To use something that's _really_ slow, Blowfish (or Eksblowfish, as used by BCrypt) is much closer to home. @Col. Shrapnel: I'd like to think that requiring strong passwords is always a requirement. @Col. Shrapnel: I think people do routinely crack passwords that are hashed with one-shot MD5, but I'm not "in the (password cracking) trade", so I wouldn't know. Anyway, my point is that BCrypt will raise the password cracking bar by _several orders of magnitude_, and that alone makes it worth doing as a matter of routine. @Col. Shrapnel: For example, if doing a trial using one-shot MD5 takes 0.1 ms, and using an appropriately-slow BCrypt takes 100 ms, then trying 1 million passwords takes 100 seconds (about 1.5 minutes) and 100,000 seconds (over a day) respectively. I don't think any standard guarantees that comparing two instances of unspecific values with `eq?` will return a true value. So, such an approach is not going to be portable. +1 for the right idea, though using `Formatter`/`String.format` doesn't take away the ability to have localised messages either. Or the other way around, `(list->vector (map list->vector rows))`, would be much more consistent. :-) Consistent in that you're using `list->vector` in both places, not `list->vector` plus `vector-map`. :-) It's a very minor thing, but just the kind of thing I'd notice. +1 Fair enough. :-) So, if you liked James's answer, why didn't you upvote it? ;-) @Bill: The language itself, no. But when you're writing your own implementation, you can do anything you want! @Dartoxian: In that case, my `enum` solution is just what the doctor ordered. :-) `enum`s are perfect for representing states in a state machine, for example. @Dartoxian: Right, but does it need to grow at runtime, or are you allowed to recompile? If the latter, this is still suitable. @Bill: OMG, I misread your question, sorry! I thought you were writing an interpreter _for_ Scheme, not _in_ Scheme. Hmm, yes, that might cramp your space a little. Hopefully you can use (or switch to) a Scheme implementation that does do substring sharing. @Russell: Indeed, yes, use buffered streams for both places. (Not that I needed to say this, because two others already did, but just to bring some closure to your question. :-)) P.S. Consider wrapping the input streams in `BufferedInputStream` too, again both for compression and decompression. You've answered your own question, then. In Scheme, you use `#f` and `#t` rather than `nil` and `t`, but you have the right idea. +1 +1 Nice answer. The maximum width is at least easy to compute (at least if all the numbers are positive). For example, `(1+ (apply #'max (mapcar #'(lambda (x) (floor (log x 10))) '(1 10 100 1000 200000))))`. All JSP pages have the `page` object available. In that case, you might think about registering an account on SO...sounds like you'll be asking many more questions on his behalf. :-P What are you trying to achieve? What you're describing just seems to be a completely wrong kind of thing to want to do. @user469652: How would you decide which dictionary should hold which keys? Just for the record: you _can_ put a `default` section at the top, in the middle, or anywhere else within the `switch`; it doesn't have to be at the bottom. @Judah: I rolled back your change (yes, a year after the fact), because you cannot have objects of type `List`. You can have objects of types descending from `List`, like `ArrayList` and `LinkedList`. (It's important to use `List` instead of `ArrayList` when passing them around, but it doesn't change the fact that you cannot say `new List()`.) What operating system are you talking about? (Please mention it appropriately in the tags.) @Cristian: Hahahaha. For reference: http://www.gnu.org/software/guile/ @Judah: Okay, fair point. I'm a Java developer, so I answered for Java, not .NET. In Java, `List` is an interface, so you cannot have instances of it. @JamesM: Moderators have more capabilities than 10k users. @JamesM: It's not possible to nominate other users. You are only able to nominate for yourself. @JamesM: You can _only_ nominate yourself, and only if you have 3000 rep or above. The voting will come later. @John: Only the top 30 nominees by rep will get through to the Primary. The 30th nominee, at the mo, has 9164 rep. @Jeff: I owe you a serious answer to that question, so, here it is. Bill and Ben Party didn't seriously expect to get into parliament, so from that point of view they weren't as serious as the major parties. _However_, they had a very useful purpose: they allowed people dissatisfied with the major parties to go and vote anyway. And in the 2008 elections, they actually got more votes than almost all of the "serious" minor parties. [cont] [cont] In my _personal_ opinion, some of the candidates here are top notch, and a "joke" candidate is unlikely to get far, given only two open positions. From that point of view, if you find that this is reducing the chances for a top-notch candidate, then by all means, I'll withdraw my nomination. However, because I do see the worth of a "vote of no confidence" candidate in general, perhaps this is worth accommodating somehow. [cont] [cont] In the extraordinary event that I do get in (and I'd seriously give this a fair go, which is what I believe your question is asking), I will indeed do my best to implement the policies outlined in my statement. However, in my honest opinion, if the general SO user base does vote that way, you already have bigger problems. :-) @Rook: I may not stand for evil, but it'll be interesting to see how evil stacks up against Trojan unicorns in this election. :-) @Nick: As I mentioned in the comments in the blog thread, perhaps the criterion for appearing in the Primary should be to have 10k rep, rather than be the top 30 by rep. (This won't exclude anybody already on the roster.) This would be a way to allow everybody (with sufficient rep) a fair chance, without having to guilt-trip the dissenters off the system. It would be one thing if such candidates were of absolutely no value, but I don't believe that to be the case. @Nick: In other words, I'm trying to advocate a change in the system. If, in the end, the system of picking the top X users by rep isn't going to change, and no additional slots open up for "non-serious" candidates, then yes, I will indeed withdraw (or turn this into a more-serious nomination). +1 for spelling it as "fulfil" rather than "fulfill". :-D (Now change "behavior" to "behaviour", "aggrandizing" to "aggrandising", etc., and you'll be all good. :-P) @Kragen: If I get elected, I will indeed accept the position. @Nick: I will actually amend my position to something more germane to SO. It will be no less controversial (I sincerely hope), but at least nobody can question the "seriousness" of my position. @casperOne: Pot calling kettle black? Joan was talking about your post. :-) (And yes, shame on me for not noticing sooner!) @Dave: Will is complimenting your name for sounding like a porn star. (Just say "Dave DeLong" out loud. Or maybe "Dave the Long", if "de" and "the" don't sound similar in your accent.) @bzlm: Comments are shown in order if you expand them all. :-) I like my long rambly comments, thanks very much! @Dave: Given the (currently) 17 upvotes on the comment, I guess not, though to my understanding Will meant it as a compliment, not a crude joke. :-) @Paul: It's social rigging, can't you see? And you can't rig socially without engaging the users, and what better way than this? :-P @Tim: Sadly, none of that may matter very much, because you're not too far from the (still-rising) low-water mark. :-( @Tim: The current low water mark is 11.5k rep. If more people apply, you may be bumped off soon, and whether you have Generalist badge will no longer have any relevance. :-( @Tim: That's the spirit! +1 +1 for disagreeing with Jeff+Team, for Generalist badge (look, Adam!, and so relieved for you too :-P), and for low userid. :-P @Tim: Thanks! I look forward to voting for you too. @nvm: Yes, a bit shorter, but no longer conformant to the "only `cons`, `car`, and `cdr`" requirement. :-P @Yasir: Thank you! I appreciate your support, and it's good to see a Scheme person. :-) @borku: You can use `'()` in place of `(list)`. They are identical. @Otaku: I agree re "not a meta diva": https://twitter.com/cky944/status/29549656941797376 :-) -1 for "proper macro system" troll. Unhygienic macros are highly problematic, and even more so for Scheme because Scheme is a Lisp-1 without symbol packages, unlike Common Lisp. What are you trying to do? There is probably a better way to go about it. I rejected the edit to add the [homework] tag, because I believe we're not doing meta tags any more. `map` by itself won't do it, but `map` paired with `filter` will. You should paste your linker errors here too. Verbatim. Very few correspondents have the time to try to replicate your setup, but good error messages will help clue readers in to what's going on. -1 NaN will never compare equal to NaN (or any other number). Undid the downvote because you fixed your answer, but still no cookie for you. :-D @TheBigO: Actually, I _did_ undo the downvote. (But I did not upvote you. Two users originally downvoted you; I retracted one of them.) OTOH, I just noticed that someone decided to serial-downvote my posts. If that's you, be aware that this can cause all your votes to be cancelled: http://blog.stackoverflow.com/2008/12/vote-fraud-and-you/ @TheBigO: I'm glad that got cleared up! :-) Also, I believe you on the serial-downvoting thing. In any case, I couldn't care less, because I have way more rep than people can make a dent on before the system catches them. :-) (On the other hand, there was recently a rep recalc performed on my account (apparently triggered by the serial-downvoting), which docked me ~500 points. Ouch!) Congrats on breaking 2k with this answer! :-D @Rogerio: Using the reflection API to access private stuff requires a `SecurityManager` check. Obviously, if you have no security manager installed, all bets are off anyway. @Nicolas_75: `(denominator (/ 1.0 3.0))` does not have to return 3.0. And on most implementations, it in fact doesn't. (The result I get on my computer, on Racket 5.0.2, is 18014398509481984.0. If that doesn't make sense to you, see my post.) I believe the OP has required the use of a context-free grammar, which PEGs don't appear to fall into. Still, maybe there's a chance that the OP will find PEGs acceptable. -1 Appending a list is an O(n) operation each time, which makes your whole function O(n²). That's what you get when you're working with linked lists. Actually, `reverse` is O(n), just like your function is. Both approaches are okay. Only if you use a very narrow definition of "traverse". Since your function isn't tail-recursive, consing up from your call stack could be seen as the second traversal. @glowcoder: Not true. _Prepending_ to a linked list is O(1). _Appending_ to a linked list is O(n) on the list being appended. (Remember, Scheme lists are singly-linked lists, not doubly-linked.) (Even if you're using a destructive `append!`, you still have to find the end node to `set-cdr!` with, which is O(n). A non-destructive `append` would require every cons cell of the list to be copied.) You might want to write some code to explain your approach, then, as what I'm reading is that you're calling `append` on each iteration. (You can `cons` on each iteration---that's O(1)---but that's not called appending.) (Look, if you change append to cons in your post, I'll undo my downvote. :-)) Actually, you get an upvote for saying that you can treat everything as a list. Because Scheme code actually _is_ a bunch of lists! @Tim: The proper term for a list that lacks a `'()` end is an _improper list_. A _degenerate_ improper list is one that ceases to even look like a list, not even an improper one. +1 I like your answer, because even though it doesn't answer the OP's question, it's a much better thing to want to do than what the OP wants to do with eval. :-P Your method is more robust, but mine is a compile-time constant. ;-) So, pros and cons of each, I guess. :-) Do you have an example of such an expression (that you want to `eval`)? Perhaps then it'd be easier to see how to construct it with quasiquotes. @Yasir: From a "reasoning about Scheme" point of view, I consider recursion and tail recursion to be very distinct concepts. In Scheme, tail recursion is the sole vehicle for implementing iteration, and so the two concepts are often seen as equivalent. This probably works for a small subset of Scheme's functionality. I can't imagine this working for, say, Scheme macros or continuations. ;-) ...or like [Guava](http://code.google.com/p/guava-libraries/) is to Java. :-D @Ben: What's `convert`? I don't believe it's in the code you posted. :-( @Krtek: I think the OP meant DSL, not DNS. ;-) @Macke: No, it's not more suitable as a comment. It's an answer, albeit a facetious one. I don't think it's necessary to relegate all "funnies" to comments, or CW, or what have you. @Ben: The whole paper itself is an April Fool's joke. :-D @Ben: Oh dear!! @unixman83: The OP's account has been nuked long ago (see how his name is greyed out). It's not possible for any answer to this question to be accepted. :-( @Jason: The latter. (Sorry, I wasn't alerted to your response, probably because it didn't start with "@Chris"; I only knew about it because this thread was mentioned in chat lately.) I've fixed the formatting, but not any of the things that are really bogus, of course. :-) Re your edit: I highly recommend [Paredit](http://mumble.net/~campbell/emacs/paredit.html) for doing any sort of Lisp and Scheme coding. It ensures that brackets are always balanced at all times, among many other useful features. BTW, your `return data` is on the wrong indentation level. @David: The OP already posted the error message, as a comment in the code. @delnan: It's actually pretty obvious if you notice that `data` is a string (as that's the intent of the C code). @Endophage: That post actually won't help in this instance. The OP is not doing "logical xor". @jtahlborn: It's indeed a "should" thing, in that others who call your `clone` will be expecting the behaviour as described. Of course, there are exceptions, such as for generic containers (@jt's answer). But in general, that's the expectation. @Schemer: You mean you want to do something like this? http://www.scheme.com/tspl3/syntax.html#./syntax:s39 (see the `letrec` definition in the example). But, that uses `syntax-case`, not `match-rewriter`. @TurtleToes: Yes, using [Jasmin](http://jasmin.sourceforge.net/). No, `"I am a string"` is _not_ `new String("I am a string")`; if it were so, you'd get infinitely recursive calls to the `String` constructor! @Aaron: I believe you mean BCEL; but that's old-school. The modern way to create bytecode on the fly is by using [ASM](http://asm.ow2.org/). @templatetypedef: Actually, it's a significant detail. I sometimes write code that exploits that property: e.g., if I know I'm comparing two variables that I know are string literals or otherwise interned, I use identity comparison. @TurtleToes: The JVM doesn't support memory curtaining, if that's what you mean. :-P That last paragraph really rubs "us" the wrong way. "We" just wanted to let you know that. And if you don't understand why, then please leave "us" alone. @Mark: I'm just lampooning you for your use of the royal plural. :-P @bguiz: One example is where we (at work) had to intern all the setting names (because otherwise, it made our heap usage explode for no good reason). Once that decision was made, all the setting names could be compared using identity comparison. (The interning and comparison are well hidden behind private methods, so that calling code doesn't have to concern itself with such implementation details.) Using `wait` and `notify` is _totally_ the wrong way to go about parking a thread for use in executing multiple tasks. The right way, BTW, is to use an executor (such as `ThreadPoolExecutor`) to do the thread parking for you. Curious: what are you trying to do? I suspect that using a scheduled executor (`ScheduledExecutorService`) is closest to what you want to achieve, but please feel free to fill me in. @TurtleToes: I wrote a comment explaining why your answer was terrible (but I wasn't the one who downvoted you; maybe they'll show themself, or not). Well, you should explain to the OP why the `apply` is necessary (he's already worked out that it's necessary: see `largest`). I think you meant "first-class", not "first-rate". :-) @compiler: Pretty much, yes. R5RS and R6RS are worlds apart, and it's probably worth treating them as totally separate languages. In many cases, the "see the output immediately" is a red herring, since `cout` is tied to `cin`, meaning that if you read input from `cin`, `cout` will be flushed first. But if you want to display a progress bar or something without reading from `cin`, then sure, flushing is useful. Which platform are you using? Unlike Python (which abstracts these operations for you in a semi-portable way), in C, each operating system does it differently. Bummer, I don't know Windows well enough to help you there. But I posted a Unix answer, anyway. :-P But make sure to nuke the memory area before unreferencing it! (Thus, never store passwords in `String` objects, but use `char[]` instead.) You have to register a _protocol handler_ for your custom protocol. For example, see: http://msdn.microsoft.com/en-us/library/aa767914.aspx @Colin: `let*` guarantees left-to-right binding of the given variables. Just for future reference. :-) possible duplicate of [Cartesian product in Scheme](http://stackoverflow.com/questions/2485226/cartesian-product-in-scheme) BTW, the inner lists aren't quoted. You should expect to get `'((1 1) (1 2) (2 1) (2 2) (3 1) (3 2))`. @Tim: It's an internal implementation class, either with Dinkumware or MSVC's derivation thereof. @Tim: Totally agree. I don't see anything in my version of bash (4.1.5) about being able to do regex substitutions using the `${foo/bar/baz}` syntax. Do you have any references for why you think you should be able to do that? If you're going to reach for sed, this is simpler: `s/[oa]/X&/g` Disagree about "write the result in a form in which it actually evaluates correctly". I believe that since results are always data, never "code to be evaluated", answers should be written in "data mode" form, not "code mode" form. i.e., the result should be `(2 16 64)`, not `'(2 16 64)`. Yes, it means you can't just enter the data directly into the REPL without quoting first, but _learning the distinction between code and data mode_ is a crucial part of learning Scheme. IMHO. String and number literals look identical in code mode and data mode (though of course, in code mode, you're allowed to quote them too). So, there is no problem with writing them out as is. Really, what I'm trying to say is, I like to represent data in the form that `write` uses, so that `read` gets the correct result. Try these for size: `(call-with-input-string "(2 16 64)" read)` and `(call-with-input-string "'(2 16 64)" read)`. Only the first one yields the correct result. @prgrammer: It's not enough to do it in the `else`; you must also do it for the operands of the `+`, `-`, `*`, `/`, though that approach gets ugly. You will want to recurse into each sub-branch, but refactor do it cleanly. I would love to try porting Chibi Scheme to the NDK, but it's a matter of Copious Free Time. ;-) @Larry: Only if it has real macros, continuations, first-class functions (not the kind of neutered lambdas Python provides), proper tail calls, etc. ;-) That requires root access, which I'm not sure the OP has. ;-) There is no mechanism for sshd to give you a "warning message" (or any message) during the authentication stage. So it just rejects you. @user247679: Lists in Scheme are composed of zero or more conses (pairs). For example, `(list 1)` is the same as `(cons 1 '())` (list composed of one pair), and `(list 1 2 3)` is the same as `(cons 1 (cons 2 (cons 3 '())))` (list composed of three pairs). In Scheme, you can test for pairs using `pair?`. @Eli: "Cheap" isn't referring to performance in this context, but that I've taken the cheater's way out of the problem. :-) @Eli: I responded on IRC. (Figured that it's the most straightforward way to get everyone on the same page.) :-) @Mark: 100% agree. That's good news. :-) Three things: 1. You can use `zero?` to check whether something is zero. 2. Please format your code in Scheme style, not C style. ;-) (More specifically, don't have dangling brackets.) 3. You can use `(else (count (cdr lst)))`, without adding 0. :-) Can you paste in the entire code (not just snippets), as well as the whole error message (verbatim, please)? Okay, but what if `Automobile` is a subclass of `BaseGame` for some weird reason? ;-) Or, maybe `Automobile` has its own `loadModel` method that calls `base.loadModel(...)`? :-P (Pretty much why I requested the whole code files, not just snippets.) @Nicholas_75: No, the macro is expanded at the point of the `lambda`. :-) If you're matching brackets in your head, you're doing it wrong! :-) Most experienced Schemers like to use something like [Paredit](http://mumble.net/~campbell/emacs/paredit.html) to handle the brackets for them. (In Paredit, brackets are _never_ mismatched---the program handles ensuring that all open brackets are matched with a closing one.) Oops, you need to check whether `(cdr lst)` is null, before you use `(cadr lst)`. :-) Scheme has no `for` loop by default. But SRFI 1 provides `fold`, which is the standard way to iteratively compress a list to a single value. (There's also `map`, which is the standard way to process each element in a list, returning the results in a new list.) @Chan: `(require srfi/1)` should do the trick. @Chan: If you're following @John's suggestion to use `foldl` and `foldr` (which are the Racket names for `fold` and `fold-right` respectively), note that my solution uses `foldl` (since that's iterative). `foldr` is recursive, but allows you to remove the call to `reverse`. @John: Iteration-vs-recursion is orthogonal to functional-vs-imperative. I often code functionally, but still prefer iteration (tail recursion) to straight-up recursion, when it suits the problem at hand. :-) @Chan: Functional programming has a steep learning curve, but once you learn it, you'll never look back. Good luck! :-D @Chan: I updated my answer with something much simpler, if you're willing to stick with Racket. (Yes, it's a `fold`-based solution! :-O) @Chan: I've added a definition of `remove`. I can't avoid using it without making the function suck, so that's the next best thing. -1 My eyes! The goggles do nothing! What are you trying to do? That doesn't look like any code a sane Schemer would, or should, want to write. Right, and that's why I just posted you a `fold`-based answer. Once you get the hang of `fold`, `map`, etc., you won't want to use imperative-style loops again. :-) (I just retracted my downvote, BTW. Thanks for explaining your task.) @Chan: Hahaha. Do your best to study how my function works, by reading up on how `foldr` works. It will enlighten you! :-) @Chan: It is exactly like `std::accumulate`. :-) One day, you'll get used to looking at the brackets (or rather, _not_ looking at them). :-) @Chan: (Also, `map` is like `std::transform`, and `cons` is like `std::make_pair`, while we're on comparisons with C++.) Well, you can use a decimal floating point library. I believe that MPFR, for example, provides a decimal floating point type. (Floating point types are binary by default, if it's not specified as decimal.) Otherwise, you might have to convert your program to C# instead (which does provide a `decimal` type). Even if the machine has Trusted Computing facilities like memory curtaining, etc.? ;-) (Oh wait. No JVM implementation I know of employs any TC features.) 9.7 adds useful features like associative arrays (which are probably implemented as trees, since keys are always kept in ascending order), boolean variables (but you still can't have boolean columns, unlike PostgreSQL), compiled (non-inline) functions, etc. I find 9.7's PL usable enough. 9.5 and below are lacking in at least the aspects I just described. (In DB2, inline PL code is much more restricted than compiled PL code in terms of the functionality it can access. Before 9.7, it used to be that functions can only be inline, not compiled, and you had to use procedures to use the extra functionality provided in compiled mode.) Overall, I think if you use 9.7 or later, you'll find PL easy enough to use. I haven't written a lot of PL in my career, but, I base the above comments on my experiences writing an in-database implementation of Jaro-Winkler, which wasn't too hard to implement in 9.7 but would have been nearly impossible to do in 9.5. What is the use case for inheriting from `MulticastDelegate`? I can't imagine one. @glowcoder: Consider studying the [grammar](http://java.sun.com/docs/books/jls/third_edition/html/syntax.html) specified in the Java Language Specification, in particular the definition of `Expression3`. Although many C++ implementations do use IEEE 754, they're not actually required to. :-) @Phob: Yeah, 20k lines is seriously more over-the-top than I thought ever possible. ;-) @Wyzard: That reminds me of why I don't use C++ any more: lack of sane multiple-value handling. ;-) (Just kidding, but seriously, Lisp and Scheme handle multiple-values much better than most other languages.) @Phob: I encourage you to click on the tick mark next to this answer, just below the up/down vote buttons. :-) @Chan: Congrats! I hope you enjoy your `fold`ing adventures. :-) Not to troll too much, but you know that Java has [built-in bindings to zlib](http://java.sun.com/javase/6/docs/api/java/util/zip/package-summary.html), right? ;-) @Andrew: You can use `cond`. :-) Sometimes, knowing the right package name makes all the difference, especially for a new user. "A suitable Java package" may be above the OP's knowledge level. ørn: Yeah, totally agree. :-( Normally, in later versions of Ubuntu, you use the "Software Centre", but I've never used it (because I'm a command-line geek) and therefore can't give detailed directions for it. If you want faster lookup (at a cost of greater memory usage), and your list doesn't have duplicate elements (from the point of view of `equals` and `hashCode`), you can use `LinkedHashSet`. Java doesn't have pointers, but you can pass in an array and an index together, and clear out that slot in the array. Well, on x86, what's accessible is 2**32 bytes, not bits or words. Other architectures might vary. I've added an answer that talks about how the OP would write binary data directly to `cout`, if that is his wish. That would complement your suggestions rather nicely. :-) +1 for the interface approach. The `return 0` versions are wrong, BTW. In C++, `virtual ... = 0` translates to `abstract ...` in Java. @Yanick: I'll add some ...s to cover that missing one. ;-) `delete s` is wrong. It should be `delete[] s`. @Andrew: You can, as of C++0x. In C++03 and earlier, there is no specific guarantee that `std::string` has to be contiguous (though in practice they have to be, anyway). I think you meant, "arg 0 is the program name". Nothing, I think. I believe there is a serial downvoter in this thread, who's been downvoting many of the answers here (including mine and tommieb's). The attack of the nasal demons! What I want to know is, what is the `let*` doing there, when the `layer` variable it binds is not being used at all. +1 for mentioning that equal temperament isn't the "only" system out there. @J_Y_C: Are you referring to the wolf interval? That seems to affect meantone temperament, not the 12-tone equal temperament. Indeed, I have to ask the same question. So, as far as I understand (and I'm no music theory expert), meantone temperament sounds great for some keys, and terrible for others (due to the wolf interval). Equal temperament sounds slightly terrible for all keys, but eliminates the wolf interval. Do you have another instance of `getAdmitCodeStatus` that would be in violation of that rule? For example, is there a base class that implements that method with a non-empty body? tl;dr (i.e., I only read the title ;-)). But, `pipe` returns an array of two, and you may be able to use the same mechanism for your case. No, I mean [the `pipe` system call](http://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html). And, looking at that now, it does use the approach you suggest (except it returns an `int` so errors can be signalled). @Josh: Make the user specify a length, and verify that the whole region is owned by that process. @Josh: `execve` doesn't fork, just for the record. ;-) Firesheep is for OS X and Windows only. :-) -1 You'd think that C++ people already know what generics are, surely? C++ templates are much beefier than Java generics. @Kazoom: Those classes are called "generic" classes. Read the link given by MeBigFatGuy in the question's comments. @jonsca: Or see [this answer](http://stackoverflow.com/questions/746604/bind-pointer-to-member-operators-in-c/746653#746653) for slightly more readable example. (Disclaimer: I wrote that post.) Prefer to use `Collections.addAll(foo, bar)` as opposed to `foo.addAll(Arrays.asList(bar))`. The documentation for the former claims to be faster. @user328560: Simple! Just take out the star in the `v_map` typedef. ;-) (That's the "store the `multimap` directly" approach as mentioned in my answer. As a bonus, it also makes your code about a fifth of its original size.) If you're using Guava, I'd much rather use `ImmutableSet.of(-5, -3, -1, 0, 3, 6)` instead. Immutability FTW. :-) @Thilo: That is true, re the need for more context. Okay. How about: `ImmutableSet.copyOf(values)`. Still a set, still immutable. :-) Yes. It's called [ACE](http://www.cse.wustl.edu/~schmidt/ACE.html). ;-) @Ashwin: My original suggestion was facetious. (ACE is commonly considered to be a C++ kitchen sink.) But yes, ACE actually does have the containers you seek, so, I might write up a real answer. :-P Still not sure if it's too heavyweight for you, though. +1 Graphs for the win. :-) (Shamefully, I flunked a Google on-site interview because I didn't brush up on graphs.) @Paul: And that bickering (between the R5RS and R6RS camps) has been happening for like 5 years now. It's nothing new. :-) Right, but can you see in the OP's code why the order matters at all? I can't. -1 What part of "please do not just give me the answer" do you not understand? -1 What part of "please do not just give me the answer" do you not understand? Fine, I've pulled my downvote. Possible duplicate of [Java equivalent to #region in c#](http://stackoverflow.com/questions/2344524/java-equivalent-to-region-in-c). @Soner: No need to be a perfectionist. :-) I think anything over 50% (or even 40%) is good enough. By contrast, Java requires its `main` method to be public. It's invoked by the launcher using reflection, so in theory, it's possible to invoke a non-public `main` too, but the launcher actually checks for the public flag and enforces it. (Also by contrast, Java doesn't have `entrypoint`. The method has to be named `main`, has to be static and public, has to return `void` (not `int`), and has to take a single argument of type `String[]`.) @Aurojit: I think Giacomo is just saying that this solution is good for both large and small collections. There _is_ a decent reason to hash a password many (>1000) times, which is called "[stretching](http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html)": it makes each password cracking attempt take longer. However, the proper defence against that these days is to use scrypt (see my answer). @Ninjiangstar: If you're using MD5 to hash your passwords, you're doing it wrong. :-) Just to be sure we're on the same page, rainbow tables are not the weakest link in the chain. You need to use an algorithm that takes a long time to try each password, to deter automated password crackers. @Ninjiangstar: 10 years ago, if you hashed your password >1000 times, it might have worked. These days, you need to do better. Use [scrypt](http://www.tarsnap.com/scrypt.html), and don't try to roll your own solution. +1 I originally wanted to talk about MV in my answer too, but given the OP's level, I figured it'd be too much to explain how to correctly use MV. :-P @GregS: bcrypt works too, especially if `crypt` compatibility on OpenBSD is required, but scrypt is better, because it not only parameterises the work complexity (as bcrypt does), but also the memory usage required (which ups the cost of massively parallel hardware crackers). @Jens: Since you like to be pedantic, 1. `xargs -0` wasn't portable for a very long time, and 2. Chas's, not Chas' (people's names are never considered plural). Putting options after positional arguments is a GNU extension. Some would say that `grep -r` is a GNU extension too, but, still, I usually make a habit of putting all options before positional arguments. @Jan: Yep, true. I'll add your answer too. :-) @DocWiki: I've edited my answer to use `$''`, but in a different way from how you were using it. What error messages are you getting? Verbatim, please. That sounds very, very O(n²). There are amortised O(n) ways to solve the OP's problem. The function is supposed to work like `(map (apply compose fun-list) lst)`. +1 Good catch on the `(null? lst)` vs `(null? fun-list)` thing! Re your edit: Don't use strings in `case` match clauses. I know some/many Scheme implementations that output "no" in both cases. Only symbols, numbers, characters, booleans, and the empty list (`()`) can be reliably written in a `case`'s matches. See http://stackoverflow.com/questions/5768696/case-statement-not-assigning-value/5768775#5768775 for more details. To add to @Billy's point, there's a swapping trick you can use to shrink the storage: `vector(vec.begin(), vec.end()).swap(vec)`. @icCube: The client doesn't talk to the app server directly---all the client's interactions are mediated by the web server. So it's just up to the web server to request compression, and for the app server to support it. @Space_C0wb0y: Orly? I never saw header files called `` and `` in C. ;-) No, reopening the file for every write is still a bad idea, even if you open it in append mode. (Also, it's not portable. Windows has no append mode, for example---it's simulated using at-end mode.) @Michael: Just updated with explanation---historically primitive types never had methods or fields (this ain't Ruby ;-)). Adding that for primitive types would be too magical for people who think of primitives as "non-objects". Autoboxing etc. are indeed syntactic sugar, and I'm not saying that Java avoids all instances of it, just that it has a policy of avoiding it except in cases where not having it would impact a lot of programmers in a bad way. As far as I understand, Java 5 introduced autoboxing/autounboxing because its newly-introduced generics supported boxed types only---and were the autoboxing/unboxing to be absent, generics' non-support for primitive types would have been much more painfully felt. For example, suppose you had `List nums`. Without autounboxing, you could not use this: `for (int num : nums)`. Since you can't have `List`, you would be forced to write `for (Integer num : nums)` if there were no autounboxing. The OP wants to _enable_ Nagle's algorithm, not disable it. :-) Right, and the OP wants to join all the data into a single packet. @Pepijn: Nope; what I was saying was that without autoboxing and autounboxing, generics in Java would be somewhat less usable. I wrote that to explain to @Michael that, while Java's language designers are resistant to syntactic sugar, they will still support it when it has great value. Can I get you to try something? If you have Microsoft Office installed, try sending DDE commands to, say, Word or Excel, and see if that works. I'm trying to find out whether it's DDE that has trouble with non-ASCII characters, or just Acrobat. To make the point even clearer, you can rename `pStack` to `this` (since the latter isn't a reserved word in C). @Ryan: That is not true; all the other reflection-based invocation methods throw a checked exception called `InvocationTargetException` that wraps any throwable thrown by the invoked method. `Class.newInstance` won't do that---it will throw the checked exception directly. The downside is that javac won't let you try to catch those exceptions either, because `Class.newInstance` isn't declared to throw them. @forsvarir: For the general principle of how to go about this, a C# solution is as good as any other. However, I think my solution is probably more compact than any of the ones in that thread. :-) The problem is that just because the URL can be UTF-8, the question really has _nothing_ to do with UTF-8. I've edited the question suitably. -1 Each call to `ArrayList.contains` is O(n). This is a terrible way to create a unique list. `LinkedHashSet` is better for that. @TLP: +1 Good point. Will fix! Micro-optimisation = fail. Most times, never ever think about micro-optimisation unless profiling proves it's needed. @Konrad: Agree about the things that are "always" true, like the `++x` vs `x++`, and using `const` variables whenever feasible (e.g., some COW implementations of strings copy the string when calling `operator[]` on a non-const string, rather than returning a proxy object). But those are not the cases that newbies usually obsess about (and sometimes I wish they did a little more). :-) @Roy: If I understand you correctly---write the object to a `DataOutputStream` that's backed by a `ByteArrayOutputStream`, take the resulting byte array (from the `ByteArrayOutputStream`) and create a `ByteArrayInputStream`, then deserialise that using `DataInputStream`. @Roy: Without using third-party libraries like [Guava](http://code.google.com/p/guava-libraries/) or [Commons IO](http://commons.apache.org/io/), that's pretty much as far as you'll get. +1 This man speaks the truth. Also, for more lulz: `(require srfi/26) (define apply-strategy (cut  ))` The JDK has built-in support for SOCKS proxies. So, really, it's not hard to make any open-source IRC library use it. :-) @whaley: Yes. Usually, what needs saving is externally-visible state anyway, so this shouldn't be a problem. (It's also no different from the constraints on your XML/JSON/YAML solution. :-P) Technically, you should treat an offline machine as though it has no network card anyway. How do you deal with that latter case? @compile-fan: Try this: `int main() {exit(0); printf("Peek-a-boo!\n");}`. "Peek-a-boo!" is not printed. @compile-fan: Because `exit` is specified to deliver its argument to the parent process. Really, the C library initialisation code really just invokes your `main` this way: `exit(main(argc, argv, envp))`, so whether your `main` returns or not doesn't affect whether `exit` gets called. So, you tagged your question with [sortedset], which sounds like you already know about `SortedSet`. In fact, `TreeSet` or the like would be the correct way to implement what you want to do. Your answer is technically correct (and what I thought about writing at first), but the OP asked for a `QFile`-based solution. Thankfully, there is one. Possible duplicate of [Convert HTML back to Markdown for editing in wmd](http://stackoverflow.com/questions/235224/convert-html-back-to-markdown-for-editing-in-wmd). +1 for all this talk about smack downs. :-) For comparison, here's my Scheme version of Cartesian product: http://stackoverflow.com/questions/5546552/scheme-recursive-function-to-compute-all-possible-combinations-of-some-lists/5546880#5546880 @developer: Often times, you don't need to know the "real" type of an object---any functionality specific to its type is implemented in a virtual function, so you only need to call that. However, if for some reason you need to get a pointer to the derived type, `dynamic_cast` is the way to do it. Can you post the entire data on a pastebin site? @ryanc: +1 Agree on both counts. I felt the need to correct the formatting on the spot, but I left the `isin?` in place. Also, instead of nested `if`s, use `cond` instead: it's much tidier. ICC, of course. What do you mean by "decimals" in this context? Decimal point? Integers never have them (a number with a decimal point is parsed as a floating-point number). +1 for hardcoreness. @sean: Nice to know. Though, that's not very portable, especially given that the OP hasn't specified using MSVC. @Dani: It refers to the number of leading 1s. The OP is basically asked to validate the well-formedness of a UTF-8 string. @Ted: It doesn't? It seems to work well enough for me (I updated my answer to use `'\u00ff'`). Of course, it won't do what you expect from `\u0100` onwards, but that's outside the scope of this exercise. @Dani: What? (You should read up on how [UTF-8](http://en.wikipedia.org/wiki/UTF-8) works, then you will understand the question better.) @Op De Cirkel: In the OP's question, the string being validated contain octets only (value < 256). The OP wanted a way to represent these octets in Java as `byte`s given that he has `char`s (all with value < 256) on hand. In this circumstance, the truncation involved in casting to `byte` is appropriate. @Ted: Obviously 0xff is not a legal byte to have in UTF-8. All the bytes in UTF-8 (_not_ the code points they otherwise reconstitute to) are < 256. @Ted: I've updated my post. My example (using U+20AC) would have been to use `(byte) '\u00e2', (byte) '\u0082', (byte) '\u00ac'` (i.e., UTF-8 representation _as_ character literals); obviously, that's much more verbose than the version I actually posted, so I chose not to use that. +1 for stylish answer. :-) @Mehrdad: Oh, you mean dynamic symbols from a stripped executable? I'm not entirely sure. In Java, threads are split into two types: normal (non-daemon) and daemon threads, with non-daemon being default. A Java process does not exit until all non-daemon threads have terminated, so what the OP observed is very likely _not_ to be "undefined behaviour". @Kaj: That's not strictly true; the `JTable`-taking constructor (which is private) is simply a utility constructor used by the public constructor. A few possibilities? Let's see...female, male, intersex, unknown, and other (and whatever other options I forgot)? :-) And then there's this: http://www.sarahmei.com/blog/2010/11/26/disalienation/ :-) @Peter: I agree, Ruby is a zillion times better: `males = users.select {|user| user.sex == 'Male'}` +1 for being...8 seconds faster than me? :-) +1 for "unwilling to pore over your code". :-D @Paŭlo: +1 Thanks for the correction! Much appreciated. @Computist: I don't know how to help you with that question. You should ask a new question! Other people may be able to help better. @kaiseroskilo: The second argument takes an "end pointer", which (if one is given) is set to the end of the number parsing. That way, you can do error checking: if the end is at the null-terminator, the whole string is a valid number. By passing null (written as 0 in my code here), that's saying that I don't care about the end pointer, because I have blind faith that `gmp_snprintf` will always give valid output. ;-) Even shorter: `Class.new.included_modules`. :-) @Marc-André: Thanks! Corrected. -1 "Does not work" is a not valid question. At a minimum, specify (verbatim) what error messages come up. @Rnet: `\s` (which has to be written as `\\s` in a Java string literal) matches one whitespace character. `*` matches zero or more of the "thing" before it. So, `\s*` means zero or more whitespace characters. You can figure out the rest. ;-) @Joe: `Content-Length` represents the length of the entire content. If that's the same length as the first chunk, then that means there's only one chunk. @RanRag: 0 if the ID doesn't exist; 1 or more if it does (1 if the ID column is unique). There is no waste of CPU time. Simple accessors are inlined into the calling code by the JIT compiler. C++'s std::string doesn't "cache" the length. The stored length _is_ the final authority on the string's length. @Vit: Please read [inline expansion](http://en.wikipedia.org/wiki/Inline_expansion). This happen at the JIT compilation level, so don't worry too hard just because you don't see any inlining inside your `.class` files. "coppuprtion"? Did the nasal demons affect your writing too? ;-) Which JSON library are you using? @Jan: Question: does `freopen` alter the buffering mode? If so, the "default on `stdout`" won't matter much. Does the `Plain` class have some POD member variables that aren't being initialised? @Denis: You can't just specify the directories. You need to specify the files to force-add. e.g., `git add -f root/uploads/*`. Maybe because your `msgBroker` is null? @R..: Agree. My response was my little contribution to Fastest Gun in the West, as usual. When I saw paxdiablo's improvements, I figured I may as well give up. ;-) Try changing the `(SELECT SYSDATETIMEOFFSET())` to just `SYSDATETIMEOFFSET()`. It probably won't directly solve your problem, but it will make your code nicer to read. @a1ex07: I've completely rewritten the query now, so that there's not even a `CASE`. :-) @meagar: Instead of `\;`, use `+`. This runs `git add` far fewer times. (`;` => once per file; `+` => once per as-many-files-as-will-fit-in-the-command-line.) Oh wow, fail. I didn't realise that this question is a [common-lisp] question, not a [scheme] one. I'll keep it up to illustrate the principle, anyway. To me, parallel and Erlang go together like bread and butter. Jus' sayin'. :-) @Jimm: C does not guarantee any order of evaluation. It's usually not left-to-right. Modifying a variable more than once in the same statement is undefined behaviour. @Jimm: It's still undefined behaviour, as buffer overflow still happened (it _will_ write a null terminator; it just will do so _outside_ your buffer's bounds). You're in this case lucky that the buffer overflow didn't kill your program sooner. +1 for being faster than me. ;-) But yes, I believe Boost.Random will give portable results across different platforms. People still use Managed C++? I thought most projects would have switched to C++/CLI already. :-O Sadly, yours will blow up if you have files and/or directories with newlines in their names. Unusual, I know, but a fully-robust solution should handle those. Other than that, not a bad solution. What kind of combining are you needing to do? If you're just, say, merge-sorting a bunch of sorted files, you won't need to read the whole files into memory, but can just process them line-by-line. Scheme doesn't have `dotimes` (which, IIRC, is a Common Lisp thing). Probably because yours is one of the first answers. Usually, I play by "fastest gun in the west" rules, which means that if you're not the first poster (or your post isn't within a minute or two of the first poster), usually it doesn't count. (Unless it's a really innovative answer, of course.) @FrankH: Plus, even if using `find -exec`, always favour `+` over `;` in cases where you can (and this is one such case). +1 for detailed answer. :-) I think requiring locking for signalling is to ensure memory consistency, since locking a mutex involves a memory barrier. Without it, other threads may not be able to observe the change. (Though, I guess it's possible to have the memory barrier _at_ signalling. But, it's probably simpler to require a lock.) @ninjalj: Ah, very good. Thanks! :-) BTW, note that incrementing by 0.1 each time could introduce floating-point errors (since 0.1 is not representable as an exact number in binary floating-point). Consider representing the number as an integer, e.g., 958 and 959 in your example, then dividing by 10 upon display. Guile versions before 2.0 had `procedure-source`. Since Guile 2.0, however, I've never managed to get `procedure-source` to work any more. But yeah, it's very implementation-specific, and most implementations don't provide any such thing. @Klaim: Thanks, I've added your suggestion of `boost::scoped_ptr`. :-) @Kerrek: It works, but isn't the best style. I'll update my post. Thanks! That depends on what you're trying to do. If you want to tell if your object is of a certain type, then @miku's link is good. If you want to get the type name of an arbitrary object, there's `typeid` (include `` first). You need to show some code that demonstrates what you're talking about. @Ozair: It's almost certain to be C++ (which is why I retagged the question). I'm also almost certain that the problem the OP faces is simpler than the scenarios you listed. :-) If all code follows the recommended Java naming conventions, then this never arises: package names are always fully lower-case, and class names always start with an uppercase letter. If your code doesn't follow that convention, well, what you see in the language specification is what you get. Right, and that's why my comment is a comment, not an answer. ;-) The server response should include, in the `Content-Type` header field, a subfield called `charset`. That contains values such as UTF-8, UTF-16, etc. @jleedev: If you read beyond the literal meaning of the OP's words, I think they actually mean the content retrieved by the URL, not the URL itself. :-) I refer you to [JSDoc](http://code.google.com/p/jsdoc-toolkit/). :-) Yipes! What a query! Consider doing this query: `WHERE day_id BETWEEN ? AND ? AND month_id = ? AND year_id = ?`. +1 You could also do a `remove`-and-`put` in a loop, looping through a _copy_ of the original keys so you avoid a `ConcurrentModificationException`. @tekknolagi: `(define (square x) (* x x))` is syntactic sugar for `(define square (lambda (x) (* x x)))`. It's pretty obvious here that `var` is `square` and `exp` is `(lambda (x) (* x x))`. @tekknolagi: `lambda` creates a _function object_. In Scheme (just like in Python, JavaScript, etc.), functions are first-class: you can pass them around like other objects. Additionally (unlike other objects), you can call them. @tekknolagi: It simply creates a Python lambda object that holds a reference to the expression given. When the Python lambda object is called (in the line `return proc(*exps)`), that stored expression is then passed into a recursive call to `eval`. @tekknolagi: It's a naming convention for an _unused variable_. i.e., it's just a placeholder for holding stuff that is simply thrown away. @tekknolagi: The arguments passed to the Python lambda, of course. (Read up on how to use variable-arity functions in Python.) @Emil: Some people use `_` as a prefix for member variables (fields). I detest that sort of naming convention, but I guess @Bside's professor thinks otherwise. The question is tagged as ksh, you know that right? ;-) @sehe: I invoke GIGO. You should be able to cast to `JSONArray`. However, make sure you're casting to (and/or importing) the correct `JSONArray`. The version in the simple library versus the non-simple one is totally different. Now try `import org.json.simple.JSONArray;` and see what breaks. :-) +1 for actually reading the question (unlike my answer, sigh). Possible duplicate of [Code Golf: Lasers](http://stackoverflow.com/questions/1480023/code-golf-lasers). Or not. This question should be migrated to [Puzzles & Code Golf](http://codegolf.stackexchange.com/) anyway. @Alan: Indeed. All I did was load up the regex using `Pattern.compile` (in JRuby, so I can use single-quoted strings and thus not get stung on the single backslashes), and keep fixing the pattern until the `compile` call returns successfully. :-) I'm pretty sure that if your game is rendered using hardware acceleration, that means there is nothing "software-side" for you to take a screen shot of. @Billy: Hitting the PrtSc key on the keyboard causes the whole display's image to be copied to the clipboard, in Windows. @agent-j: Decent virtualisation systems that do passthrough to hardware is still going to give you a black box when you do a screen shot from the host. :-) Not all "boolean expressions"; you can use `&` and `|` with booleans, and they are not short-circuiting. Technically, that number isn't 2.36, it's 2.359999999999999875655021241982467472553253173828125. Truth. @ratty: You want to round down? Then use minitech's approach: `printf("%.2f", floor(2.3678 * 100) / 100)`. Right. My point is that the OP's question cannot be answered with floating-point numbers. You can't catch `SIGKILL`. Your program will always be forcibly terminated no matter what. Hahaha. Your solution and mine do different things: yours look for spaces (use `isspace`, not manual checks for `' '` and `'\t'`), whereas mine squeezes all clusters of the same character into a single instance. :-) @LCYSoft: You can get a function pointer for a static function. @Adam: I wanted to upvote your answer, but it uses C-style casts, which have got to die. Your answer is otherwise correct. I wanted to upvote this answer, but it uses C-style casts, which must be terminated with extreme prejudice. This answer is otherwise correct. @Martin: +1 That is true. I thought about fixing it, but then it seems your answer already took care of that. :-) @Serge: Thanks, I updated my post to reflect official support. Re "more native back-ends are available": on KDE, Qt _is_ "more native" than GTK+ (or to put it differently, unless you have a GTK+ engine that emulates the look of your current KDE look and feel, your GTK+ apps will look fugly). I'd _love_ to have an officially-supported Qt build to use. You have to use reflection. There are plenty of questions on this site about reflection; use the search box at the top right. :-) @cody: Ideally, you _would_ use a different map for each object type, if those types are not related at all. But assuming you just want to stash them as `Object`s in the map, you should cast the object to the right type first. e.g., `if (thing instanceof Worker) { return ((Worker) thing).getCoord(); }` You can use the helpers defined in `ActionView::Helpers`. Does that help? ;-) @Abhisek: I don't know anything about Windows XP. On Linux, you can add IP aliases for all the addresses you want to use. @luvieere: Then just use `SomeClass` in your source code. The type parameter is ever only useful at compile-time, and since you don't have that info at compile-time, `?` is the way to express that. @luvieere: In Java, at runtime `SomeClass` is the same type as `SomeClass`: both are of type `SomeClass`. That is why the kinds of things you can do with type parameters in Java is very restricted compared to what you can do in, say, C#. (Java == erasure generics, i.e., type parameters lost at runtime. C# == reified generics, i.e., type parameters preserved at runtime.) @luvieere: In other words, `SomeClass` is _not_ "radically different" from `SomeClass`. Is the reason you can't use the standard library because this is for homework? @luvieere: It doesn't make a difference. Trust me. :-) For example, if you're dealing with a `List`, its `get()` method returns a `String`; a `List`'s `get()` method returns an `Object`, which you have to cast to `String` yourself. In both cases, the generated bytecode would be identical. @luvieere: In other words, if you use `SomeClass`, the most you have to do is throw in a few extra casts. It won't change the behaviour of the code any. @duedl0r: I did say "cleanly". ;-) @luvieere: You'll need to pastebin some _real_ code that demonstrates what you're trying to do. I'll then pastebin back some real code that actually does it (if it's actually achievable). @Spike: Indeed, I updated my answer to demonstrate that. (I had planned to put that in at the outset anyway, but since I wanted to get first post in---"Fastest Gun in the West"---I usually post something basic, then expand it within the 5-minute grace period.) @Joel: Parameterised statements forever! @Steph: In that case, put `@author unascribed` first, then add your own `@author` tag. "Unascribed" is the standard name used when the authorship is unknown. (Many classes in the JDK, dating back to the 1.0 or earlier days, have `@author unascribed`. Just for fun, Google for "author unascribed". :-)) @Daniel: `@author` tags are good for determining whom to blame if there are "questions" about the code. ;-) @pst: (Re edit.) When authorship is unknown, the standard placeholder name is "unascribed". See http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html for more details. @Robert: +1 for FGITW. :-) (No upvotes for all the SCITE answers. ;-)) @trutheality: http://meta.stackexchange.com/questions/18014/what-is-fgitw-and-scite-on-mso What do you mean by "masking"? @user800799: No. Just reuse it straight away. The real problem is that you're 100% misusing the wait/notify mechanism. I'm writing a real post about it right now, but I just wanted to put that out there. You can't cast between a function pointer and a PMF. Just no. @Gearoid: At least make your `testMethod` static. Then at least you're not casting between a function pointer and a PMF. @Gearoid: I've posted an answer that allows you to do that. When you create the thread, use the instance of `Test` as your context object. @Mohit: A string doesn't need to be interned to be printed! It just needs to be interned if you want to compare using `==`. Otherwise, there is no difference whether you intern a string or not. @Justin: I agree; I upvoted adymitruk's answer too. :-) @minitech: Actually, it still is true: 16.9 is actually 16.89999999999999857891452847979962825775146484375 when using doubles. @minitech: .NET doesn't "fix" anything. However, I'll grant that most floating-point _display_ functions will display 16.9 because it rounds to, say, 6 decimal places, not 15. That doesn't negate my point that you _cannot_ represent 16.9 exactly using only a double. HMAC is still too fast for password hashing. Please read the article linked to in my post, as to why you need a few thousand iterations. The point is to make the password _slow_ to crack, by making each password trial take a long time (e.g., a quarter of a second each). People legitimately logging on the site won't "feel" a quarter of a second; but people cracking passwords _will_ feel those quarter seconds, painfully, as they're trying to attempt a billion passwords. @Stuck: For Java, I use Damien Miller's implementation, [jBCrypt](http://www.mindrot.org/projects/jBCrypt/). Damien is the maintainer of portable OpenSSH and I trust his security knowledge. Not sure about Objective-C. @minitech: What Rune FS is talking about is that the .NET framework code displays a rounded value, but (some) debuggers show the real value. Sure, the number _displays_ as 16.9 when you round it (even to 15 sig figs), however, the number is not really exactly 16.9; it's just a close approximation. It doesn't seem to be a scoping problem, but rather some problem with the JIT. The problem can be summarised as: it happens only when `reverse` is used, and only if the useless `cond` is taken out. That sounds like some kind of overly-aggressive optimisation had been going on. That it works for `float` and not for `double` is purely a fluke. You'll see different results for other numbers. You should display your code with a format string if you at all can; then make the format string round properly (e.g., `%.1f`). +1 Thanks---I stand corrected re the JIT (obviously, I know nothing about Racket internals). @Trejkaz: It's very hard to not inject _any_ JS, but here's an example of adding an `exit` function that involves _very_ minimal use of `eval`: http://codepad.org/IDOR4jxY @Space_C0wb0y: It probably is a show-me-teh-codez question. :-) @Steve: +1 That is true, and relevant if there are non-unique elements. @Gunner: See Steve's comment. I'll amend my post to make that clarification. @Dustin: Good question. I was thinking of [`ConcurrentHashMultiset`](https://guava-libraries.googlecode.com/svn/tags/release09/javadoc/com/google/common/collect/ConcurrentHashMultiset.html) (the Java equivalent of `ConcurrentBag`) when I was writing my answer, which _does_ have a `remove` method. I have no idea what the .NET `ConcurrentBag` class is good for, then. :-P The ordering of the stored elements is none of the client's business. So from an API point of view, "unordered" always refers to the order of enumeration (from the `GetEnumerator` method). What feature of `cron` do you need that Task Scheduler doesn't provide? You need _way_ more info for anybody to know how to diagnose that! You can, but it's not as type-safe as doing the covariant overrides. i.e., the covariant overrides guarantee that `ColorBinaryTree.parent()` always returns `ColorBinaryTree`, never just a plain `BinaryTree`. The cast as you had it in your edit is just fine---it's just an implementation detail and doesn't burden the caller with having to figure out if the cast is safe. @new_perl: It's not a function. You would have to grab an `xattr` Perl module from CPAN. Sadly, that module does not appear to exist. @wzb5210: Just make `revFeaturePoints` a field. Re edit: That's not O(1) picking (`collection.toArray()` is always at least O(n)), and also it doesn't remove the picked value from the container. @Vlad: How would you RAII using placement new? Yes, it totally barks up the wrong tree. The problem isn't to do with using a double, but just the way it's formatted "by default". (I was the downvoter, for the record.) Plus, you should be shot for using `new BigDecimal(1)` when `BigDecimal.ONE` is a much better choice. :-) I've retracted my downvote, because you've provided a suitable use case for BigDecimal, namely when you overflow what a double allows. Granted, different from the OP's question, but still of value. You're not supposed to be allowed to `git stash pop` without committing first. What did you do to achieve that? From what I've read, doing much of anything inside a signal handler beyond setting a flag or the like is dangerous. Why would you try to scrape Google anyway, instead of using their API? (Hint: Google search results work just fine without JS. At least if you're using a text-based web browser.) Please pastebin your entire build log, verbatim, and post a link here. @Xeo: Not quite: `std::vector`'s data is stored in separately-allocated memory. `std::array`'s data is not. (Where's the -1 button for comments when you need it?) @Nemo: I agree. I have a feeling the error is elsewhere. Try using `#:socket 'guess` and see what you get. If the error is still there, your problem is not with the `#:socket` value. You would need to post more code. Then, the error isn't in what you've pasted so far. Please include the rest of your code. @Mikhail: Yes, because you're returning `this` in that case, and not a local variable that's going out of scope. I do not recommend doing the `i <= sqrt(num)` test every iteration. Instead, store `sqrt(num)` in a variable of type `int` (or `long`, or another integral type), and compare against that in each iteration. +1 for talking about interning; I am currently writing some slides and one of the topics I talk about is how immutable objects with equal value can be coalesced and/or interned. :-D @Brooks: You should ask a new question on the site for that. However, here's a one-line answer: `code.matches("\\d+")`. @Hunter: No, `static` means it does not belong with any specific instance. :-) @Neal: The OP is asking about JS code that's being run from Java, using JSR-223. Sometimes this kind of context matters, hence why the OP mentioned it. @kamal: Make sure: 1. `export` first. 2. Run NetBeans from that _same_ shell. (i.e., type `netbeans` directly into that same shell, don't launch it from an icon or something.) Except, there is no way to get at the actual exception object. :-( By definition, inner classes are non-static nested classes. Static nested classes are called just that. :-) @Michael: Fancy! +1 @Dogmatixed: Well, if one day you decide you can't deal with that, `CopyOnWriteArraySet` is perfect for this sort of thing. @charley: `vector` is not a good idea; you will leak `Player` objects. Instead, it should be `vector` or (if `Player` objects are not readily copied) `vector >`. @Brendan: You can use auto (stack) objects instead of allocated (heap) objects, but that's not suitable for every circumstance, for example, if you need objects that outlive the current scope. @Holland: You don't need to use C++ to develop games or OSs. More and more of that is done using managed languages now, and that's the way it should be (in my opinion). If you want to learn C++ for the sake of learning unmanaged programming, then please, of course do it. :-) @Brendan: You know how in Java, you have to use `finally` a lot if you want to close resources in a robust fashion? In C++, you have to use RAII to achieve the same, and smart pointers is one of the simplest applications of RAII. :-) Are you trying to dodge the JDK installation requirement? I don't actually think (technically, if not legally, speaking) it's very proper to deliver tools.jar standalone. You should aim for a better solution, up to and including just requiring the JDK to be installed. Or, you could do it the Eclipse way: Eclipse comes with its own Java compiler (called ecj), and so it can be used with just the JRE. @charley: You can wrap everything in a data type, but (to me at least) it gets too tedious after a while. I like things to be automatically done for me, and that's why I'm a big fan of smart pointers. :-) @Brendan: Actually, RAII is _the_ motivating factor for creating smart pointers in the first place. It allows your program to be exception-safe. (Please, for your sanity, do not get me started on Google and Mozilla's policy of banning exceptions. :-P) @Brendan: "Just do a `delete`": how do you propose to do that in an exception-safe fashion? @Kevin: Yeah, the square brackets are for something else entirely. (e.g., `[a-e]` matches any single character between `a` and `e`). @Laurynas: 1. `asm goto` cannot have any output constraints (current limitation that may be removed in later gcc versions); since I don't "care" about the current value of the lock (we're not trying to do recursive locking ;-)), that was acceptable. 2. Because the examples for `asm goto` don't have it either (and yes, it does conditional jumps too), so I presume that `asm goto` assumes a clobbered flags by default. @bestsss: Yes, you're totally right. I forgot about the reordering (and I should not have forgotten). I'll revert my answer back to the first revision. ;-) @bestsss: It's not just your opinion, it's a fact. :-) Seriously, not having the `volatile` was very sloppy. :-( @charley: Sure, agree with centralising rules to the type, etc. However, if you don't use smart pointers, then you have lots of boilerplate for dealing with when pointers get deleted, etc. That's still more tedium than I want to deal with. Plus, the rules for smart pointers are (to a point) fairly straightforward and I wouldn't consider them "sprinkling". I suggest you do some timing tests comparing `QueryPerformanceCounter` with other "less high-resolution timing methods", and see what differences you observe. :-) @Bo: Start a timer (of any type). Query one timer type a million times. Stop your timer. Repeat with other timer types. @Behrooz: If you need to handle C10k or something like that, threads may not be the best way to do it. Instead, you can use something like asynchronous I/O (which will debut with Java 7's NIO.2 library). I have one question: what _are_ you trying to do, in the big picture? Maybe that will help with finding a good answer. To be more specific with @Tomalak's point, please post your error message, **verbatim**. Few people have the time to try to cut and paste the code and compile it (especially when it's not guaranteed to reproduce your issue), whereas looking at an exact error message is often enough to tell what's going on. As a side comment, I think keeping a separate `type` field is doing it wrong. `boost::variant` has that sort of bookkeeping already. @MByD: Ugh. No. Just no. Threads are not a substitute for non-blocking I/O. -1 SCITE. Not because your answer is wrong (it's not), but because it provides less information than my answer and it's posted 3 minutes late. @Paul: [This article](http://www.ibm.com/developerworks/java/library/j-javaio/) explains it better than I can. :-D @Pierre: Just added a usage example. Basically, if you take a class name (`String` in this case) and add `.class` after it, you have a type key (class object) for that class. `String.class` has type `Class`. @paulsm4: Now now, I'm not claiming you stole my answer or anything. I don't give a toss about that. I'm just saying that in the old-timers' honour code, if you post a late answer that isn't substantially better than earlier answers, the Right Thing to do is delete your answer. (The principle being that all else being equal, the earlier answers should win out.) Certainly, I've deleted many of my answers for that reason alone, and [I'm not the only one doing it](http://meta.stackexchange.com/questions/9731/fastest-gun-in-the-west-problem/9745#9745). @paulsm4: (As an aside, users with 10k rep can see deleted posts, and once you get there, you'll notice just how many deleted duplicate answers there often are.) I'm mentioning this to you as an insight into how the culture on SO works. +1 for actually answering the question. +1 for actually answering the question. @Peter: Associativity is still about which way the syntax binds---it doesn't determine execution order (see Steve Jessop's point). @Peter: SO has almost 500k users. By the pigeonhole principle, at least 98% of users must be illiterate. ;-) -1 No. Singleton classes in Ruby have nothing to do with the singleton pattern. @Vladimir: Thanks, it took me two tries to get it right, but I'm glad to have an answer I'm happy with. :-) @loosecannon: Actually, I dislike (incorrect) speculative answers, and feel they have no place in an "experts' Q&A site", so I will downvote them when I see them. @Ivan: It's a sarcastic comment about the fact that there's only a finite number of literate people (notionally set at 10,000 in my comment, or 2% of 500,000); that leaves 98% illiterate, the quota having long been used up. @caf: Sort of but not quite, unless you're trying to say that the larger the population, the nearer the proportion of literate people approaches zero. :-) @caf: (BTW, are you caf on #stackoverflow? If so, small world. :-P) Consider using non-blocking I/O (start with `Socket.getChannel()` and go from there). You can't accept TCP connections with pipes! @Soren: Expressions _in general_ have no set order of evaluation. _However_, `&&` and `||` set a sequence point between the left- and right-hand sides, so that the left-hand side of `&&` and `||` are executed before the right-hand side (if at all). No other operator, other than `,`, works that way. That's _way_ too roundabout when you can use straight JavaBeans introspection. Plus, how will it deal with JSON-incompatible objects? The solutions from highlycaffeinated and me will deal with that just fine. +1 I think between your solution and mine, the OP should have it sussed out. (Yours deals with fields only; mine deals with getter methods only. :-P) @Amir: Introspection uses reflection to do its work, but works at a higher level than reflection. Reflection finds Java-level fields and methods; introspection finds JavaBeans-level properties and events. @caf: +1 Yes, you're right. I don't have the MSVC sources in front of me at the moment, but there is _no_ reason why `snprintf` would need to do any allocations, ever. Everything that needs to be done can happen using only stack-based memory. The rule of three says that you also have to implement the assignment operator, in addition to the copy constructor. Granted, the copy constructor alone will solve the OP's immediate problem, but it's all about thinking about the longer term. ;-) @Jarrod: Chances are 99% that it's for batch files, hence I just edited the question tags accordingly. +1 Not a bad answer, though in the case of the inverted map I'd rather just use Guava's `SortedSetMultimap` instead. (I'll post an entry expressing the idea in a minute.) +1, funny. :-)) @chinchu: `HashMap` does not have any iteration ordering guarantees. If you want one, you have two choices: `TreeMap` (natural or comparator-based order) and `LinkedHashMap` (insertion order). @chinchu: 1. Don't use `Vector`! If you must, use `ArrayList` instead. 2. I'd still, in most (>95%) cases, prefer to use `TreeMap` instead of `HashMap` if sorted keys are desirable. Actually, since the libc `free` can be called on null with impunity (the Single Unix Specification says, "If `ptr` is a null pointer, no action shall occur."), your `my_free` should also be designed that way, for minimal surprise. Ugh, gross. Include files (and SSI) are so 20th century. Master pages (and Rails layouts) are a much better idea. I think a lot of people come from Ruby and similar backgrounds and expect to be able to use name-based dispatch (e.g., Ruby's `Kernel#send` method). In Scheme, there is no direct mechanism for name-based dispatch, and people need to design programs with that in mind, e.g., building a hash table with the name-to-function associations. The problem with that is that 0 is a valid running time value, and should not be treated the same as disqualified. (The more general variant of the problem is a case where `disqualified` cannot map onto _any_ valid number value (including infinity), and must be treated specially. That's what my answer addresses.) @Jeffrey: Red herring. Modern JVMs have function inlining and using getters is not slower if all they do is just returning the value of a field. @the Tin Man: This isn't Java, the function name should be `disqualified?`, not `is_disqualified?`. :-) @the Tin Man: I don't think ActiveRecord has a precedent for using `is_` in front of boolean getters, either. You need to show us more code than that. Where is `mThread` set, and to what value? Where else is it used? +1 You win 3.1415926535 intarwebs. @Michael: You should, like, totally forget my answer and just go with Peter's. :-P It has more or less a similar idea to my answer, only 10x simpler. Actually, the condition is the _second_ clause, not the third. So it's actually `for (init; test; update)`. @ysth: In that case, the OP's problem is that he's not using `s///`, and thus the string isn't modified. :-) @ysth: I have a feeling that the OP had the argument in the form of `s/foo/bar/` and was expecting the `=~ $regex` to "expand" to `=~ s/foo/bar/`. +1 You are correct, there is no way to get at the "real address" of any object in Java, and for good reason---the GC can move objects (for example, between young and old generations, if using a generational collector), and thus there is no way to get such a thing in JRuby either. Also, like you said, what's the point? The address is ephemeral at best, especially in implementations that use a moving GC. You don't need to explicitly mention that you added an annotation; annotations that have the `@Documented` annotation are automatically added to the documentation. @Zaid: Try using it with a sparse array, and see if the keys that come back are also sparse. (I don't have a 5.12 to test with.) @Zaid: Example: `my @a; $a[4] = $a[42] = 42; print keys @a;` Does that print 4 and 42, or 0, 1, 2, 3, ..., 42? @Graham: Did you type in the `.*` before the `time`? Did you type in the `-n`? Both are vital. (Also put in a `.*` after the `ms` if there is expected to be any output after that.) @jrhorn424: Yes, and it must be the first parameter. (And if you _don't_ want to use an instance of the class---if it's a static method---then, in order to avoid having to specify the (unused) `self` parameter, you must decorate that method with the [`@staticmethod`](http://docs.python.org/library/functions.html#staticmethod) decorator.) 1. You should cut and paste your real code. Your constructors have syntax errors. 2. `operator=` is not a copy constructor, it's an assignment operator. And you are correct, your code never uses it. It uses copy construction, but you haven't defined a copy constructor. Well, use a _real_ JVM that lets you cluster around several machines! ;-P @Rachel: Correct, it _shouldn't_ accept a `PersonCommand` instead of `BaseCommand`. (See my answer for more details. :-)) Using iterators as map keys is a terrible idea (because any iterators that subsequently get invalidated could cause undefined behaviour). Don't do it. :-( @James: True, but if items get removed off the set, the iterators corresponding to those items would be. :-) I almost upvoted your answer, but I believe in using the default delimiter (`/`) unless there is very good reason not to (e.g., the pattern or replacement contains such a character). Moreover, since `#` is the comment character, I would object to its use even more than using, say, `:` or `,`. @Peter: I think if you're going to get a 72GB machine, that's awfully close to the 68.4GB instances, and you will probably find EC2 more cost-effective unless you're doing your testing 24/7 over an extended period of time. :-) Let's step you through a simpler example of how argument substitution works. :-) Say you have a function, `(define ** (lambda (x y) (exp (* (log x) y))))`. If you then call `(** 42 24)`, then that calls the lambda with `x = 42` and `y = 24`. Since `**` is the same as the lambda, the equivalent expression is `((lambda (x y) (exp (* (log x) y))) 42 24)`. Hopefully that makes some sense. :-) Now to directly answer your question of how we get `newlat2 = '(bar)` and `seen2 = '()`, it's simply calling that lambda with those given arguments. Consider the expression `((lambda (newlat2 seen2) ...) '(bar) '())`. If we gave that lambda a name, say `inner`, then that expression simply becomes `(inner '(bar) '())`. It's easy to see, then, why inside the lambda, `newlat2` and `seen2` would have the values listed. I'd love to see whether the "no-`BigInteger`" version is faster than both versions, too. :-) (If I find some time today, I'll do some testing and post my results.) +1 Very nice (re divide-by-10). That's probably the most straightforward way to do it. You have no idea just how many Enlightened badges I got that way. :-P Do you have some example inputs, as well as expected outputs? It's hard to see what you're trying to do in precise terms. @Denoteone: No. You URL-encode stuff when you have a bunch of user-entered strings that you don't want any special interpretation for. For example, if a user-entered string could contain `&` and you're not filtering for that, then URL-encoding that string would allow the `&` to be sent correctly, rather than starting the next parameter. So, if you're talking about "breaking apart the URL", that sounds very different from the usual use case for URL-encoding. So what are you trying to do? @Sam: Sure, but `URLEncoder` is the name used in the JDK. There is no chance they will rename it, due to compatibility requirements. In my experience, Erlang is really, really well-suited to distributed message passing. I don't know any of the protocols you've mentioned, but I do think Erlang is good to try for these purposes. @Thomas: Only because the formatting is crap. I'm going to fix it right now. (No matter what language you code in, if someone uses non-standard formatting, it will cause headaches for everyone else who reads it.) @Ross: Nice, I see your suggested edit. Standard indentation in Lisp and Scheme code is two spaces, BTW. (All the other places where I had more than two spaces are, of course, for alignment purposes.) @angelofdeath: If I were your exam marker, I'd dock all your points for poor formatting, notwithstanding whether the code works or not. :-P @Henning: http://mumble.net/~campbell/scheme/style.txt @Henning: Actually, when it comes to Riastradh and Scheme style, it _is_ as close to standard as you're going to get. In the Scheme world, Riastradh is not just "somebody". @angelofdeath: Actually, Henning has helped you as much as he (or anybody else) can help you at the moment. You actually have to understand recursion in order to solve this. @Kublai: Probably more because `System.out.println` is synchronized. +1 for example command. (I'll leave my post up in case some users prefer the prose version.) @Rocket: It's a hypothetical function, possibly (hopefully) provided by the unit testing library the OP uses. It would throw an exception if the value is not in the given range. You need to write `"\\*"` because of string escaping in Java. Also, consider `String.split(Pattern.quote("*"))`. Most of the time (in the enums we work with at work) there simply aren't enough enum constants for the map approach to be worth it, but I agree that there's a time and place for the map approach. :-) @Alexandre: Not to "troll", but, R6RS and simplicity go together like water and oil. Any implementation that tries to do both will have to compromise, to some degree, on either/both. The question, then, is how much compromise you are willing to accept in each criterion. +1 for mentioning Larceny, BTW. I don't believe `setAccessible` was _ever_ designed for any kind of fine-grained use. It's used to "break the firewall" for debugging purposes---from a code style perspective, it certainly shouldn't be used in normal code. And if `this` is not a `Child`, then you get UB. :-D @Oli: Exactly. So this approach doubly won't work. (I updated my answer to describe how you can do it with `dynamic_cast`, albeit very grossly.) @Oli: So have hundreds of `else if` branches. I did say yucky. :-) @john: I agree, I'd like to think the "hundreds of `else if` branches" approach serves more as a counterexample than anything one would actually do. @unexplored: Yes, you need to list all the child classes one by one. If you use the virtual function approach, have `DoSomething` call a pure virtual function. Then any child class that doesn't implement said function won't compile and/or link properly. :-) The OP was trying to avoid modifying the children classes, since there are over 200 of them. But it seems the OP doesn't have a choice any more. :-( Oh, I 100% agree (see my comment to @john about the `else if` branches being more of a counterexample). The OP agrees too. You need to paste some actual code that demonstrates this. (In relation to your first question, ideally the destructor is also virtual in the base class.) If you want any kind of non-blocking or timeout I/O, you should use the NIO (`java.nio`) classes, not stuff in `java.io`. What do you expect to happen? What do you see instead? @ArniBoy: I almost just wanted to answer with "Because C++ is not Ruby", but perhaps you mightn't get that reference. :-) @Praetorian: That's precisely the kind of thing Ruby permits (by design), via monkey-patching. :-) C++, again by design, does not have monkey-patching. :-P @Kerrek: Unlikely, since the `stringstream` is being used for, essentially, a `lexical_cast`. +1 for beating me to it. :-) You shouldn't create any Swing objects outside the EDT, so your question is based on an invalid premise. ;-) I hear that Google App Engine is going to use a new billing scheme that doesn't bill purely for raw CPU time, but the amount of time your app is kept active, since it continues to occupy memory, etc. So, your approach would lose under the new system. See http://googleappengine.blogspot.com/2011/05/year-ahead-for-google-app-engine.html for more details. Thanks! Fixed. :-) @spacemanaki: Does rlwrap support vi editing mode? That's one thing I <3 about readline (and libedit). Even reflection can't get at the type parameter; like you say, it's erased already! Re edit: that's to get at the type of a _parameter_, not of the passed-in object. Alas, the type parameters of actual live objects are actually erased. In your `result.setMap(map)`, does it do a deep copy of the `map`? If not, then there's your problem right there. In other words, what Chad said (+1). Mine is certainly golfier. ;-) Really though, both are just as good (though I beat BoltClock by one second, hahaha). ;-) I'm glad to be of help. I vastly prefer the name "eigenclass" also, but I've been overruled: see http://stackoverflow.com/questions/2505067/class-self-idiom-in-ruby/2505077#2505077 and its attached comments. :-) Wow. Okay, let's see.... :-) Okay, I added a binary digit edition. Enjoy! (Not tested yet.) Does this have any practical use? `nth` is O(n) on the number given, so, once you get above 10 or so, it gets really expensive to call. You need to paste in much more code than you have; what's `wptr`, for example? To the downvoter: There's no need to downvote this question...the OP was just a little frustrated, and in this instance, I can actually understand. The documentation was written with a seasoned Perl programmer in mind, so it's rather daunting if you're not such. @Igor: +1 Neat idea, though I think perlreftut might be a better idea. I think perlref will go over the poor OP's head. :-( @Appy: In C++, no return from `main` is necessary; if your code falls off the bottom, the compiler effectively inserts `return 0;` automatically. But it must still have a return type of `int`. @Appy: C++ introduced the concept of const and const-correctness; prior to C++, the concept of const didn't exist. Strictly speaking, for const-correct code, you should never be able to assign a string literal to `char*`. However, because a lot of people migrate code from C to C++, some concessions had to be made to allow the migration to be smoother. This is one such concession. @Eli: I've been guilty of reaching for `map` instead of `for-each`, because of code golfing contests I've entered (where small size is the only thing to optimise for, not speed or memory usage). I do have to remember to stop using golfing techniques when writing real code though. ;-) For the record, for anyone who asks why `for-each` is better than `map` in this context: 1. `for-each` processes the list items left-to-right; `map` makes no such guarantees. 2. `for-each` doesn't build a result list (which in this case is just thrown away anyway). 3. In R6RS onwards, "unspecified value" can be zero or more values, not a single value, so `map` could fail when used with functions that return "unspecified value" (such as `display`). That only works if your list consists only of numbers. :-) @JasonFruit: In standard Scheme, `equal?` is not variadic the way `=` is. :-) (I tested with Racket, for example: "equal?: expects 2 arguments, given 3: 1 2 3") You're going to have to use folding, sorry. :-P @testSubject528491: If your singleton has to extend a real class (as opposed to implementing an interface), your design is broken. (And yes, I consider the design of `Reader`, `Writer`, `InputStream`, `OutputStream`, etc. broken. They should all have been interfaces.) @Backo: Correct. Build your hash (with both present and blank values), then run that `delete_if` line to nuke off the blank ones. @Backo: Updated post accordingly. @Howdy_McGee: Other languages, you mean like Python or Ruby or Java? :-P (IOW, what In silico said. :-P) In this context, Daniel's answer is correct. However, in general, `IllegalArgumentException` is the appropriate exception to use, when it doesn't involve numerical ranges. (I still maintain Daniel's answer is correct, except that we use the Java class `IndexOutOfBoundsException` instead of the .NET `ArgumentOutOfRangeException`. Details schmetails!) +1 Yes, in this particular usage, I can understand creating your own value-added subclass (of `IllegalArgumentException`, not `Exception`---I absolutely detest inappropriate use of checked exceptions). +1 100% agree with all of this. Therefore (to avoid whitespace problems), use `for f in src/*`, and `rm "dst/${f#src/}"`. @freezdom: `mlist?` simply tells you if all the contained conses are mutable. Since an empty list has no conses, that statement ("are all conses mutable") is true, in terms of there being no conses that are immutable. @freezdom: Absent using `set!`, or a box, or something like it, there are no workarounds. An empty list is always immutable, no exceptions. @freezdom: Actually, in Common Lisp, the empty list is named `nil`. In Scheme, though, it's just called `()` which can look deceptively like non-empty lists. (You only have 5 minutes to edit a comment.) @Brian: No, the annotation processor code could just contain a `while (true);` inside it. In addition, all existing iterators are invalidated. :-) @wallyk: It's small for a float, yes. For a double, you'd expect one [ulp](http://en.wikipedia.org/wiki/Unit_in_the_last_place) to be much smaller than that, of course. @liv2hak: Yep, exactly. @Rainer: Thanks! Updated. (I'm actually a Schemer, so I'm sometimes unaware of the "better way" to do things in CL. Though, in Scheme I'd use `reduce` too (it takes different arguments from the CL version though), so.) +1 Very nice with the "bottom-up" approach explanation. I wrote a similar type of answer, albeit less eloquently ;-), and for Scheme, quite recently: http://stackoverflow.com/questions/7313563/flatten-a-list-using-only-the-forms-in-the-little-schemer/7324493#7324493 And yes, the conclusion is that `reduce` (or `fold` in Scheme) is a very important operation. :-D You need to `loadLibrary` the native library containing the `Java_ogs_test_ogskcg_ogstranspose` function before that will work. Did the `loadLibrary` fail for some reason? Make sure your log statement is _inside_ the `if`, so that you know it's actually tried to load the library. :-) (Google App Engine was cost-free at the time of this post's writing. Google has since revised the pricing structure and it's no longer so cost-free.) Normally, `set!` in Scheme doesn't support places. But with SRFI 17 loaded (if your implementation supports it---Guile does), you can use `(set! (list-ref lst 3) 100)` if you want. EDIT: Oops, that doesn't work in Guile, but `(set! (caddr lst) 100)` does. @Andrew: Really? If you redirected stdin, `/dev/stdin` will get at the redirected file. I thought `CONIN$` is supposed to get at the terminal, regardless of any redirections. No, as far as I know there is no annotation for that. In any case, for what you want to do, substitution groups seemed to be a red herring (I think I misread your question initially). What's the use case for that? That sounds like a very bizarre thing to want to do. +1 Fancy, I've never tried to play around with the JAXB annotations; usually I just tweak the XSD file and let xjc do the rest. :-P @K-ballo: It's probably an in-house class. @Ita: Is your LUSOutputJNI static initialiser throwing an exception? You should print the exception raised. Is this a homework question, by the way? Alas, you may have to reimplement `ScheduledThreadPoolExecutor` yourself, as I do not see a way for you to customise your work queue, nor a way to replace it once the executor is created. :-( @MGZero: Because chances are, if you need to do something special in the constructor, that means there are special resources being used that have to be disposed of correctly. @Amir: This answer is too "enterprisey" to be able to submit as a homework entry. ;-) @Amir: No, it won't. Java will auto-seed your RNG as necessary. :-P But if the OP didn't have JavaMail installed, then where would the `javax.mail.NoSuchProviderException` come from? What makes you think you can't? Do you have some example code that demonstrates? All classes extend `Object` (at some point), which is non-generic. If you're really going to use locking, just use `Collections.synchronizedList`. @Peter: Of course. My point was to get as close to `ImmutableList` as possible; `CopyOnWriteArrayList` was basically just one step away from that. :-D The title of the post is one I wrote, based on what I understood of the question. The OP's title was "ServerSocket vs Socket Java", which doesn't ask anything in particular. :-P What's so hard about showing the _real_ arguments to `start-process`, instead of `foobar` and `some-args` and `"the" "other" "arg"`? The most obvious way to avoid a `finally` is, of course, to call `System.exit`. :-P @Eric: "Won't" is a strong word. There are some of us here who do still prefer Scheme to any other language, because it's just that awesome. :-) `System.exit` is friendlier to the CPU! :-O But yes, okay, clearly this is a subjective criterion. Also, I didn't know you to be a code golfer. ;-) @MikeJerome: Correct, if you're passing in one list. In general, your function takes as many arguments as lists you're passing in. @Jonathan: Also particularly helpful is that dates are unlikely to contain quoted commas. In the general case, using the `Text::CSV` module or the like is necessary, or at least very helpful. @cjd143SD: Everything up to the _first_ comma. (Without the `?`, it would be everything up to the _last_ comma.) Indeed, as with most things in programming, there's no one-size-fits-all solution. :-D And on ELF systems, such string literals are usually in the `.rodata` (read-only data) section. Why Java? The technology for capturing network things is more likely to be available from C, not Java. +1 GUIDs/UUIDs are teh awesome. @Scorpion: The OP is basically trying to parse C++ and Java source files. Facebook isn't going to let you do that, because that's tantamount to encouraging users to spam. I remember that American Express had a Wish-a-Day thingy for holiday season last year, which initially had a feature to give you points if you did a wall post promoting the promotion. They had to pull that a couple of days in (so that you could get the points whether you did the wall post or not). The anchors are really not necessary in this case. :-) Heck, if you take out the anchors, you can even remove the `\s*` from the front. @David: Indeed, that's how things like `vector().swap(vec)` works for shrinking a vector's allocation (and the seemingly-similar `vec.swap(vector())` will not compile). (BTW, I am sorry for not clarifying this in my answer. I would have cleared it up, but like I mentioned, your answer is in any case better, so I don't need to keep mine around.) @mange: You should fix the issue pointed out by David. I will undo my downvote. Is this a one-off event? Some other process might have changed your system time. Of note is that `tempdata` is `0xffffffff` in the stack trace. That is very...unusual, at least for the code pasted above. That is a highly unusual error message. Do you have some example code that triggers this? @Dani: True in general, but IIRC, in MSVC, that's indeed the standard function to call to spawn a thread. Well, if your function normally returns lists of a bunch of items, and you're returning an empty bunch of items, then an empty list is appropriate. What "trivial case" are you talking about? Scheme doesn't really have a concept of "null" (in the way that Java and similar languages have), so if your program relies on such a concept, then you should rethink your design. @cHao: Actually, I wasn't actually kvetching at your edit, but the one two revisions before. Feel free to do the non-code version if you really, really object. I do want to keep the backticks for `_beginthreadex` and `threadFunc` in the prose paragraphs, though. @John: Of course `null?` tests for the empty list, so it that sense it's null, but (if I understand correctly) it's not intended for use in the same way null is used in Java, as a "this has no value" marker (and like you say, it's its own distinct type, and cannot be lumped in with other types like you can with Java). That's what I meant when I added the "in a way that Java and similar languages have" comment. @cHao: In that case, your edit is all good. :-) +1 for also bringing up the boolean getter naming convention. ;-) (Actually I upvoted you even sooner than that, but that happens to be a peeve of mine, so it's nice when others reinforce that. :-)) +1 for not overengineering your solution. I was originally planning to write a solution that micro-optimised a couple of things, but your answer is very concise, and obviously plenty fast enough. Yay for simplicity! @pst: String interning works across all classes. @rationalSpring: Matt's point was that interning should be the _main_ point of the message, not an afterthought. @paxdiablo: If you deal exclusively with string literals, it's okay to use `==`. But having to document that is generally such a pain that it's easier to just use `equals()` across the board. @vivek_jonam: Java strings are immutable. You can rebind `s3` to a new string, of course, but that will not affect the string `s1` is bound to. @pst: Each `.class` file has its own string constant pool (so you will see duplication if you look at the same string literal across two `.class` files), however, on class load, everything in the string constant pool is interned, so equivalent strings will refer to the same string object. @HemalPandya: No, not a duplicate. That question refers to whether to use `equals`; this question asks when `==` will actually work reliably. That refers to the signals to be blocked _during_ the call to `sigchld_handler`, which like you said, is empty. Interesting, Common Lisp has `vector-push-extend` which does the auto-growing part. In Scheme, vectors are one-dimensional arrays, and they are fixed-sized; you get to do the growing yourself! @AAB: So change all references to `A` in your code into references to `$class`. e.g., `printf("$class's constructor")`, and `$self->{NAME} = $class`, if you want. Run that command before you type `ant`. I am assuming that you're running `ant` from the command line. If you're running ant from an IDE, your IDE should provide you a way to pass Java options. +1 for explaining the other possibilities. For completeness, you can also specify the name of a base class (to use a non-default base class constructor), or (in C++11) the name of the current class (to use constructor delegation). There's nothing at all that says that `wstring` has to be UTF-16 (on Unix, for example, `wchar_t` is typically 32 bits). So it stands to reason that the book doesn't address UTF-16 specifically. Plus, because of astral characters, you will need to specifically deal with surrogate pairs in UTF-16, and ensure that they convert properly to 4-byte UTF-8 sequences (and vice versa). @noloader: `libiconv`'s functionality is built into GNU libc. So all Linux systems should already have it. @raphnguyen: Done. Note my first point; you swapped the meaning of `dl` and `dh`. @raphnguyen: Um. 0x is a prefix (used in C code, and anything derived from C, such as C++, Java, JS, etc.) for denoting a hexadecimal number. There is no such thing as 1x. :-) You can do type checking if you want (but if all you do with a failed check is to throw, then that's pointless, since the reflection mechanism will throw for you). No casting will be appropriate. @raphnguyen: I wrote my post based on your original statement that `dx` is 0x0680. But you later said that `dh` is 0x80 and `dl` is 0x06. These are conflicting statements. If the latter is true, then `dx` is 0x8006. You should decide whether `dx` is 0x0680 or 0x8006; those are very different numbers. :-) @raphnguyen: I'm glad that made sense to you in the end. :-) Always glad to help. Look at the header file: the `extern "C"` stuff is already there. But if you used `int value[10] = {};`, then they would be zero-initialised. @CharlesBailey: +1 Wow, good call. I see that `{}` is a gcc extension (and when compiling with `-pedantic`, you get a "warning: ISO C forbids empty initializer braces" message). (It's too late for me to edit my comment now, alas.) No, `std::map::swap` really does just swap the pointers, and not do a copy. (But if you used `std::swap`, then that _will_ do a copy.) @CharlesBailey: Well, once again, you're right. Hat tip, etc. :-) @Foo Bah: I rolled your edit back, because the point is that it's an expression that contains 0, 1, i, e, and π. If you rewrite that as `exp`, then it loses its "poetry". @FooBah: Not true. Mathematicians (especially ones trained in the intricacies of floating point) do _not_ agree that `exp(pi * i) + 1 = 0`. It's only the pure mathematical form that's accepted as true. The question is an exploration of how "leaky" that is in floating-point terms. @FooBah: Because you're justifying using `exp` by its floating-point basis, which brings the `exp` form into the domain of floating-point. Obviously, in floating-point terms, `exp(pi * i) + 1 != 0`. Thus your change to use `exp`, going by your logic of changing to `exp` in the first place, would falsify the first sentence of the post. @KirkWoll: +1 I couldn't agree more. :'( `ldexp` is for floating point numbers, not ints! @SevaAlekseyev: I dare say you need to come up with more insightful interview questions. ;-) Yes, because having really, really deep recursion is an antipattern. :-P @mikera: Surely, though, if you're going to use prototype-based OOP, you'd do better to use a language that's built that way? Rhino is an excellent JavaScript runtime for the JVM, for example. To me, prototype-based OOP goes against the grain of Java. +1 Agree, though behind the scenes it pretty much does what the OP's approach does, albeit without copying. I like exceptions much, much, much more than error codes. Why? Because error codes are too easy to ignore. Exceptions **cannot** be ignored. Sure, you can do a catch-all block that does nothing, which effectively ignores the exception, but any statements that follow the failed statement (up to the end of the `try` block) will _not_ execute. This isn't the case with an ignored error code. The reason is pretty obvious if you trace through the program with pen and paper. I suggest you do that, and update the question with your findings. Hints: 1. Think about how lists are formed, under the covers. 2. `(+ 1 (getlongest (cdr ls)))` does not do what you expect, given the way that `getlongest` is defined. How does "homework" imply "not suppposed to use higher-order functions"? I'd like to think a _good_ course on FP would want to encourage as much HOF as possible. Also, you can simplify the `apply` invocation thusly: `(apply max (length x) (map get-longest x))`. I find that the extra `cons` makes the code harder to read. In that case, use mquander's answer as a starting point. :-) If you like, trace through their version and see how it differs from yours; though, mquander's answer already explains in detail where the difference is. Actually, I'd say the other way around, since numbers are formatted as big-endian: `randomNumber1 * 100 + randomNumber2 * 10 + randomNumber3`. @NullUserExceptionఠ_ఠ: It doesn't matter from a practical point of view, but it does make the result display the same as `"" + randomNumber1 + randomNumber2 + randomNumber3` (as opposed to `"" + randomNumber3 + randomNumber2 + randomNumber1`), which may help the OP understand this approach better. @BrokenGlass: In PHP, if `$test = 'foo'`, then `${$test}` accesses `$foo`. +1 for "beats the purpose of using exceptions in the first place". Totally agree. @KevinBourrillion: Thanks for confirming the rationale "from the horse's mouth". :-) I'll go and mark the post as accepted. In fact, `let*` is usually implemented as a macro that expands to nested `let`s. While my answer is correct, unfortunately, yours isn't. :-( The list returned from `Arrays.asList` is of type `java.util.Arrays$ArrayList`, and unlike `java.util.ArrayList`, is not resizeable (an `UnsupportedOperationException` is thrown if you try). So the returned list is _always_ backed by the given array. The "implicit" `this` should be listed before the other parameters. This will make the `bind` call make more sense. @jamesio: I agree. Write those functions yourself. :-) (This question is too homework-like for most SO users to want to write you a straight-up code solution; such answers tend to get downvoted through the floor.) @jamesio: Hint: both `map` (which is a Scheme built-in, BTW) and `iota` are **really** easy to write. But you should write them yourself; discovering how to do it is a very enlightening learning experience. @jamesio: 1. Do you know how to use `cons`? If you use `cons`, you will very quickly spot a bug in your default branch. 2. You should remove the second branch of the `cond`. Let the `(= start stop)` case fall through to the default, and let the first case trigger upon the next iteration. Glad to hear you got it working. You should still remove the `(= start stop)` line; it makes your function ~5 times uglier than it needs to be. (If this were homework, and I were the marker, I would dock you points off for having that line, because it demonstrates that you Don't Get Recursion™.) Indeed, if your hash table gets resized, the order changes completely. :-) @Ravi: That wasn't what I meant by resizing the hash table. Try inserting enough items to go above your hashmap's load factor and see what happens. The first sentence is a red herring. The `Multiset` _interface_ specifies a `count` method (which is the correct one to use). No need to use `HashMultiset.count` specifically. jhat/fasthat is designed to load a heap dump file standalone, without consulting any other dependent files, like jar files. I was rather hoping that the version information could be part of the actual heap, rather than be metadata. Yes, but that is brittle, because in general you can rename jar files, or repackage them (a la `jruby-complete-*.jar`, which is an amalgamation of a whole pile of jar files). Sure. But that doesn't change the fact that you should still just use the `Multiset` interface, rather than `HashMultiset` explicitly. (i.e., `Multiset multiset = HashMultiset.create();`, not `HashMultiset multiset = HashMultiset.create();`.) You would still operate in terms of the `Multiset` interface; only the factory method needs to care that it's a `HashMultiset` behind the scenes. Obviously, if the Java package is renamed, then all bets are off. That's not what I'm talking about re `jruby-complete-*.jar` and the like. I'm still expecting the class in question to be named `com.google.common.collect.CustomConcurrentHashMap`. I just don't expect the jar file it's in to be named `guava-r09.jar`; it could be part of `jruby-complete-1.7.0.jar` for all I know. Re "information ... which wasn't designed to be there", both the JDK and JRuby have version information stored in static fields in a class (`sun.misc.Version` and `org.jruby.runtime.Constants`, respectively). It's really not that hard; I don't mind if the location changes between versions, as long as for any given version, that information can be extracted 100% reliably. let us [continue this discussion in chat](http://chat.stackoverflow.com/rooms/4103/discussion-between-chris-jester-young-and-peter-lawrey) It works for me. Of course, I've edited the post a few times in between.... (Standard FGitW technique, y'know? ;-)) Parameterise your class on that type: e.g., `public class MyClass & XYZ>`. Then just use `private Class myVar;`. @ChrisLutz: Thank you, I've incorporated the "not evaluated" into my answer. Sure, use `Character.isHighSurrogate()`. (There's also `Character.isLowSurrogate()` for the second half of the surrogate pair.) @webhound: That does compare two instances of `E`. Notice it says `class GreaterQuery>` (which means `E` must be comparable), not `class GreaterQuery implements Comparable` (which means `GreaterQuery` itself is comparable). @webhound: If `Comparable` isn't guaranteed, then the comparator must be specified. How else are the comparison rules going to be specified? :-) @bandito's answer answers that adequately. My answer was purely relating to the code style. :-) +1 for ER implementation (which MIT Scheme supports). :-) @Bogatyr: Wait till you get to continuations. ;-) (Seriously, though, Scheme is a pretty big language, conceptually, notwithstanding that the R5RS spec fits within "50 pages".) +1 Indeed, there's a similar story between `append` and `concatenate`. I accepted your answer because it's closest to the spirit of the question, though I also accept Peter Lawrey's point that version testing may be barking up the wrong tree. The "canonical" formula for a greyscale value (see [Poynton's Color FAQ](http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC11)) is 0.299R + 0.587G + 0.114B. If each of your channels is a vector, then getting a vector of the greyscale values is trivial. Not according to the CLHS, where `cond` is listed as a macro, and `if` is listed as a special operator. This is in line with Scheme also, where `cond` is a macro atop `if`. Your `llambda` is almost identical to [SRFI 31](http://srfi.schemers.org/srfi-31/srfi-31.html)'s `rec`, and the latter is the usual name for the construct. :-) @Matthias: Indeed, "can" and "should" are totally different, especially in this context. ;-) I was addressing why providing a `self` by default is a terrible idea, in general. Don't know about books, but Racket has an excellent guide for macros: http://docs.racket-lang.org/guide/macros.html +1 for Dybvig's article. I've actually read it a while ago and it helped me understand `syntax-case` macros a lot, especially how things like `with-syntax` worked. Ugh, manual argument unpacking. :-( Thankfully, Racket implements SRFI-89-style optional arguments (as demonstrated in my post), and this question is tagged as Racket-specific. :-D Except, `append` + `list` is an antipattern in Scheme programming (`cons` + `reverse` is much more orthodox, though in this example no `reverse` is necessary). So, I wouldn't consider it a suitable "introduction to Scheme" example. :-( `sudo visudo`. Edit to your heart's content. Yes, you should add it there. @Xavier: You can use Boost.Variant, if it's just one of two types. This will give you much more type safety. However, there's no real way to get around using Boost. That's a feature, not a bug. What in particular do you have no idea about? Or, perhaps, what do you have an idea how to do? Surely, you must know _something_, or else you have much bigger problems. Use `for-each`, not `map`, when you are not using the return value. As a bonus, you can do away with the `void`. P.S. You should use `for-each` instead of `map` when the return value from the function is not used. +1 Very nice writeup! Do you have an XSD (XML Schema) file for your XML file? If so, use JAXB to process the XSD file into a bunch of bean classes. I agree with the OP, the stack trace tells everything necessary in this case. Wait, it seems from the stack trace that your layout is much more complicated than you're explaining here. It appears to me that your widgets are at least 25 levels deep! What happens if you just do `java -cp ojdbc6.jar -jar ETS.jar`? I don't understand your question, sorry. What do you want this tool to do? @John: That just goes to show, mailing lists need a rep system too. :-P Methinks you meant JavaScript, not Java. :-) @BrendanMcK: Indeed, I 100% agree with your points, and I would not, in general, think of instantiating COM objects via any means other than `CoCreateInstance` or the like. My post was written to directly address the OP's question, which is how to use low-level means to access a COM DLL, such as if dealing with a DLL that isn't registered (and doesn't self-register). @BrendanMcK: Good point. I've added such a disclaimer, along with some explanations of what the recommended functions actually do (minus the thread model checking stuff). Standard Scheme does not have `first` and `rest`; it uses `car` and `cdr`. Some implementations, like Racket, do have `first` and `rest`, so for avoiding confusion, it's still good to avoid reusing those names. But it's not correct to say that they're "predefined procedures in Scheme". @CláudioRibeiro: You should use `let`, not `setf`, if `jogada` is intended to be a local variable. @James: [spp](http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/tip/make/tools/src/build/tools/spp/Spp.java), of course! ;-) Not as shown above, but if you change the field later on, any other threads may not see the new value. (Changes in one thread are not guaranteed to be visible to other threads unless there's a _happens-before_ event that happens in between the change and the retrieval. `volatile` is one way to provide this.) Yes, but, IIRC, even without the `final`, that guarantee still holds. (Tom Hawtin will probably correct me.) So really, what you wanted to do is check if two _sets_ are equal. Those sets happen to be represented with a list, but essentially you are trying to do a set comparison. That may give you a hint as to what to search for. Flattening `(a . a)` into `(a a)` just seems wrong, since that really introduces an extra level, not decrease it. Right. Start Googling for "Scheme set comparison" or "Scheme set equality" something like it. :-) Okay, re `incf`. Then you have to use `progn` there too. (If you want to use more than one expression in `if`, you have to use `progn`.) I haven't read your second explanation yet, I'll get back to it. :-) @David: smitec has already written more in his answer than is generally appropriate for a homework question. Please try to extrapolate from his very comprehensive answer, and work out an acceptable solution from that. :-) OMG! Counters! It's like everybody's favourite dog-and-pony show of closures-for-state. :-) (Including mine. I'm going to nuke my dupe answer now.) @newacct: That's precisely John's point: those cases are _not_ tail calls. If you use a loop-only paradigm, you'd have to track the return context. And if you use a recursion-only paradigm, you'd always eat up call frames even in tail calls. By having what Scheme has---tail calls where possible, recursive calls otherwise, you get the best of both worlds. Even a queue (with a header cons cell that points to the head and tail) will do. But both approaches lose a key advantage of Lisp lists, as explained in my answer. @user102008: Correct. John's point is that in Scheme, you don't have to separate out those two cases with different-looking code for each: Scheme will do it for you, depending on whether the call is in tail position or not. And visually, both kinds of code will look exactly the same. Consistency for the win. @Debbie: Then simply replace the `(add3 points)` with `(set! points (add3 points))`. .NET's `Dictionary` is implemented using a hash table. Thus, it would probably be more useful to touch on the difference between an alist and a hash table. IMHO. @PeteHerbertPenito: You can use nano with visudo. Simply add the line `Defaults editor=/usr/bin/nano` or the like to your sudoers. Then, in future, always use `visudo`! It does syntax checking for you. No, Scheme does not mandate TCO. It does mandate proper tail calls (PTC), i.e., unbounded tail calls cannot consume unbounded memory. TCO is one way to implement PTC, but there are other approaches, such as "Cheney on the MTA". @leppie: You mean tail calls in general are not required to be proper? :-O @leppie: Well, in that case, you're not dealing with unbounded tail calls anyway, so that satisfies the Scheme requirement. :-) @JohnClements: Inconceivable! :-P So maybe I'm mistaken, but I always thought of TCO as translating tail calls to a jump, whereas other PTC approaches include using the heap for call frames and letting dead ones get collected. @KerrekSB: It actually is an answer: the bottom two functions listed on that page will do exactly as required. If you think it's better to write that into the answer, that can be done, but is less ideal, because I want to encourage the OP to do some reading of their own. @Alex: Sorry, your answer is not suitable for the question, which asks for a GMP-based solution. (Why? Because GMP is much more memory-efficient than your solution.) A decimal-expansion-based solution is okay if you are in a programming contest where you can't use external libraries. Otherwise, it's a really suboptimal approach. @Alex: More specifically, in a decimal-expansion solution, you are using a whole char to store 3.322 bits of data. That means you have a 58.5% wastage in space. +1 Wow, that is quite some answer. Very detailed. :-) @Alex: Yes. That is called BCD (binary-coded decimal), which is from the era of EBCDIC and the like. It's evil. :-P (I meant that in a tongue-pokey way, BTW...sort of.) It's not as wasteful ("only" 17% wastage), but, well, you know my opinion on BCD, so. `s/change_result/change-result/g`. In Lisp style, identifiers use hyphens to separate words, not underscores. Reference: http://mumble.net/~campbell/scheme/style.txt "Symbolic names are written with English words separated by hyphens.Scheme and Common Lisp both fold the case of names in programs;consequently, camel case is frowned upon, and not merely because it isugly. Underscores are unacceptable separators except for names thatwere derived directly from a foreign language without translation." I would upvote this 10 times if I could. :-D In CL and Scheme (up to R5RS), identifiers are treated case-insensitively, so `car` is treated the same as `Car` or `CAR`. That is what case-folding refers to. `(. args)` is not valid Scheme read syntax. However, Guile seems to extended its reader to read it as `args`. It's definitely not portable and, like you say, best avoided. This uses a feature called _variable-length arrays_, which debuted in C99. @Pacerier: The local _variables_ are all on the stack, correct. However, if the variables are of reference type, the objects they point to are all allocated on the heap (except cases where escape analysis optimisation kicks in). (NB: In Java, arrays are of a reference type, even arrays of primitives.) @DannyKK: Thanks! Fixed. @Pacerier: The variable itself? No (stacks are thread-local). The objects pointed to by reference variables? Yes. @Pacerier: A non-thread-local stack doesn't make any sense: two threads would then scribble on each other's call frames! "What is your _opinion_?" is a dangerous sentence to have in your question. As you know, there is no place for opinions on Stack Overflow, only facts. Seeking opinions will only get your question closed. Already, it has 4 close votes; one further close vote will cause your question to be closed. To save the question, I'll completely rewrite the question. I hope it's okay with you. +1 Great answer! (Thanks for your vote of confidence. :-)) @Stas: There you go, straight from the horse's mouth. \[[status-bydesign](http://meta.stackexchange.com/questions/tagged/status-bydesign)] :-P The OP asked for a macro; if it just a function that takes an S-expression and returns it, that still requires an eval to run. :-) @RacketNoob Yes, it does work, if you update the macro (make sure it's the version with the `datum->syntax`), and remember to write in the `biteme` (my bad for forgetting the latter). :-) Alas, CL macros are very different from Scheme macros! @RacketNoob Do not forget to write the `biteme`. (See the edited last example.) Yes, that is a reasonable expectation, but see the OP's comments on my post. @RacketNoob dyoo is referring to the infix syntax as a dubious purpose to be overriding `#%app` for, however, I do believe that doing that for this macro is even more dubious. Likewise, it was good macro-writing practice for me, so yay for us both (even if the OP doesn't like any of it). :-D @RacketNoob Picky, picky. @Edwin: "Brackets" is correct to people outside the US: http://www.catb.org/~esr/jargon/html/C/Commonwealth-Hackish.html. I make a point to prefer "brackets" to "parens", precisely because I'm proud to be a New Zealander (and, more specifically, not American). @dyoo: Wow, I'm impressed. +1 Like you say, not really something to use in production code, but still, that's of quite some hack value. :-) I would +1 this many times if I were able to. Very nice! @RacketNoob Most of the Racket devs recommend How to Design Programs. It's not a Racket manual, and it probably doesn't cover `#%top`, but it's still a useful book to read. @Bill: Related (but not duplicate): http://stackoverflow.com/q/7936024/13, which explains why `labels` or `letrec` or Y combinator or the like is required. (Disclosure: I wrote the accepted answer.) That is because there is no regex-based solution that works in the general case. It is the same reason that you [cannot parse XML with regex](http://stackoverflow.com/a/1732454/13) (again, in the general case). Just as a hunch, do any of these work? 1. `say.apply(args)` 2. `say(*args)` Huge bummer. The star notation is what's used in Python and Ruby, so it was worth a try. Oh well. If you are using Racket's R5RS mode, you will instead need to use `(#%require srfi/13)`. Define it yourself! `(define mcadr (compose mcar mcdr))` @chustar In that case, you'd be better off using `syntax-case`'s guards. Lemme post an example. @Eli: I agree. I just wanted to match your code (which I know works, because your posts are always high-quality :-)), so I don't have to bother testing mine. But I'll edit the code now. @chustar: Most of that info is from Eli. Thanks to him, indeed. :-D You might like Eli Barzilay's very accessible explanation of the various sorts of continuations: http://tmp.barzilay.org/cont.txt What are you trying to achieve? What output were you expecting from your sample? Seasoned Schemers/Lispers would use `let*` instead of nested `let`s. (`let*` is a macro that just expands to nested `let`s.) @trinithis: In general, because methods can be called via superclasses, which have the wider return type. In that case, when doing virtual method lookup, the method that is looked up is the one with the same method signature; the method with the covariant return type will not be found. I presume this behaviour (of not finding the covariant override) is for compatibility reasons. If Java had covariant returns since the beginning (so that virtual method lookup considers covariant return types), I'm sure that the synthetic method would not be necessary. After doing all that, another fun thing to try is to `map` the numbers into a list of closures, then `fold` or `reduce` with `compose` to build the desired function in "one" step. :-) Indeed, the two approaches are interesting to compare. In fact, `compose` itself can be implemented using both approaches, too. Here's my "compiler"-like approach to implementing `compose`: http://refactormycode.com/codes/836 If your command string is trusted (i.e., you don't have to worry about attackers, etc.), just use `execl("/bin/sh", "/bin/sh", "-c", cmd, static_cast(0))`. If it's not trusted, then yes, use `wordexp` to expand. @jcubic That's a little harsh. My opinions on square brackets notwithstanding, it's part of R6RS and has been with a number of major implementations (like Chez and Racket) for a long time. You can't say they aren't real Scheme implementations. I prefer to use `(eval (call-with-input-string "(+ 1 2)" read))`. Why? 1. String port is automatically closed before the `eval` (unlike the `open-input-string` solution; okay, so for string ports, it probably doesn't matter too much (unless you're using Guile ;-)), but still); 2. It doesn't use fluids/parameters (unlike the `with-input-from-string` solution). @RossLarson: I think the `begin` is part of the R7RS `define-library` form, and specifies the contents of the library. This would be a _great_ time to edit your question to include words and tags like schelog and simple-types. We aren't mind-readers here! @rubik: Thanks for the heads-up, this is now fixed. So, Python joins languages like JS where you have to explicitly say return. (I think it's stupid; I prefer languages like Ruby, Perl, and Scheme where the last value is implicitly returned, but that's my functional programmer self speaking there.) Even this isn't quite right. @RajeshBhat: Also, I've just updated my answer with the explanation of why your unhygienic macro isn't working. :-) But I still encourage you to use the hygienic version, of course. ;-) That does indeed work, though a `do` loop usually macro-expands to a named-`let`-based loop anyway, and many Schemers tell me that named `let` loops are much more idiomatic than `do` loops, which are more...CL-style. ;-) @DrewSears I don't think you "have" to; you could just use the `Status` header field just like in CGI. But it must be said that for PHP programmers unfamiliar with CGI, the "HTTP/1.1" syntax is easier to read, because, well, it mimics an HTTP response. @Claudiu That may be, but it's still longer than both the RePeNt and GolfScript solutions, so by the rules of golf, you should pick one of those (depending on whether you view RePeNt as a valid language) as the winning solution. (Aren't you also a member of Code Golf SE? You should know this drill by now. :-P) Seasoned Lisp programmers would find rainbow parens to be a huge nuisance (since [parens are supposed to be "invisible"](http://mumble.net/~campbell/scheme/style.txt) (see the Parenthetical Philosophy section)), so from that point of view, the lack of rainbow parens is probably not as much of a surprise as you might think. You can't execute Scheme code with a Common Lisp implementation. Here, it seems you're trying to run it on SBCL. I'm not quite sure how `values` implies that the continuation has arbitrary arity. You're not allowed to return a different number of values from what the continuation supports. :-) Thus, `(+ (values 1 2 3) 42)` is not valid: in this context (assuming `values` as defined in R5RS), the continuation so created has arity 1, nothing else. Of course. So my question is, why doesn't the continuation have the arity of the consumer? :-) `(procedure-arity list)` is `(arity-at-least 0)`. So in this case, it's entirely appropriate for `(call-with-values (lambda () (call/cc values)) list)` to have arity `(arity-at-least 0)` too. So, that's a straw man argument. :-) No? Then why is it that when you run `export` (without any arguments), it prints out the current exports using `declare -x`? Wait, are you saying that there are times where the continuation's arity is _unknown_ at the point of its capture? Maybe I'm not thinking hard enough about this. Great answer! As mentioned in my answer, under R5RS, even the `define` version of the OP's code is incorrect, not just the `letrec` version. Which version of the JDK do you have installed? In none of the trees I've looked at is there a `src/share/native/sun/awt/font` directory, nor a `truetype.c` with a `glyph != NULL` assertion in/near line 2133. If it's a really old version, consider upgrading to the latest; the issue may already have been resolved there. Nice! Now I must read up the HyperSpec and see how it all ties together, especially for `identical-tail-head`. The OP specifically asked if there were an alternative to this approach. Also, why use nested `if`s when you can use `cond`? \*boggles\* Yay hygiene! Definitely the answer I prefer. That is implementation-dependent, BTW. Some implementations implement `#e0.2` as the read-time equivalent of `(inexact->exact 0.2)`. What you're perhaps meaning to propose is to ban flonums outright, and exclusively use decimal floating-point numbers. That'd work but be much slower since no common processor natively supports them, so it all has to be implemented in software. I updated the formatting more to make it even clearer. @TomAnderson: Excellent, thanks for the clarification! I'll edit the post accordingly. You can use [JNA](https://github.com/twall/jna/) to easily pass structures around. JNA allows you to write your binding completely in Java code. :-) I would call it just-in-time (JIT) compilation. A number of Scheme implementations use it, such as Racket and Larceny. @clankill3r Do you have some example code? You should never need to convert to `ArrayList`. 48 sounds a little too magical. What if they're not on an ASCII-based system? Better to use `(char->integer #\0)`. Even that assumes all the digits are represented contiguously, though. You can use `eval`, I suppose. But I would consider the `delay` or even plain `lambda` to be more preferable. Most implementations I know of _do_ reuse literal datums. They are allowed to, because it's invalid to modify literals; that's "nasal demon territory". @MarcP. Wrong. It's not a bug. You're not allowed to mutate literals. ([R5RS](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-6.html#%_sec_3.4), [R6RS](http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-8.html#node_sec_5.10)) R6RS does say that implementations "should" (not "must") signal an exception in that case, and perhaps more implementations "should", but in such a scenario, any kind of behaviour in appropriate, and you should have no expectations of anything in specific. @MarcP. The difference you see in Guile 2.0 is that Guile ([from 2.0.2 onwards](http://git.savannah.gnu.org/gitweb/?p=guile.git;a=blob;f=NEWS;h=64d374d9dc8aee45113dc25f517dce5335ff3beb;hb=1321a36ed61deb9431b41768dc92cb7230c9afa1#l565)) has an optimisation called constant folding, so the same list constant `'(x)` can be folded into the same object. So, if you **erroneously** modify one, this will be observable in other places that use the same object. But this behaviour is allowed. @leppie It's certainly better (from R6RS's point of view) to diagnose mutations of constants, but it's certainly not required, and IronScheme is not non-compliant for failing to diagnose it. @user1508893 That looks awfully complicated. Why not just `(bitwise-and n 1)`? @harold A number is even iff the LSB is **set**? Seriously? Okay, for negative numbers under a ones'-complement system, sure. But otherwise, no. (Seriously, though, even a corrected version of that assertion, that a number is odd iff the LSB is set, only holds for a two's-complement system, or for positive numbers.) The dynamic approach was indeed what I had in mind when I asked the question, but perhaps it's not viable. I should try creating a proof-of-concept to see if this would even work. Meanwhile, have a big green tick. I mean, you've waited 2 months for it. :-) Surely, you'd build the Java files the same way any Android developer would, using the Android SDK. @Ryan You know how Python is indentation-sensitive, and Ruby is whitespace-sensitive? Lisp and Scheme are parentheses-sensitive. I've never thought of it this way, but now I see that you can define `not` simply as `(cut eq? #f )`. The idea of boolean comparison, in general, is so offensive to me that the whole idea has been fnorded out of my head. :-) Your "simpler" version is wrong, sorry. `(<= a b c)` means `(and (<= a b) (<= b c))`, not `(and (<= a b) (<= a c))`. Sorry, I misread your question. I see, you're trying to zip the two lists. That's easy (with [SRFI 1](http://srfi.schemers.org/srfi-1/srfi-1.html)). I'll update my post soon. What you're describing is zipping, not shuffling. Shuffling is non-deterministic (based on the output of a random function). Zipping is always deterministic. My post is updated now. You should try out the code and see if it does what you expect. :-) Then just use `\[.*?\]` in your regex expression, I guess. Sorry, I'm not an expert in Jenkins. @wrygiel That is not true. For MD5, compression is always done in 64-byte blocks (no matter what the size of your "big chunks" are), and, if you haven't yet filled up a block, no processing happens until the block is filled up. (When you finalise the hash, the last block is padded up to a full block, as part of final processing.) For more background, read [Merkle-Damgard construction](http://en.wikipedia.org/wiki/Merkle-Damgard_construction) (which MD5, SHA-1, and SHA-2 are all based on). @wrygiel That's why it pays to do your own research when following an idea "found on the Internet". ;-) In so saying, that last comment was easy for me to write, because I actually implemented MD5 from scratch a few years ago (to practise my Scheme programming skills), so I know its workings very well. @RainerJoswig The presence of the phrase "bad syntax" in the error message is pretty much a dead giveaway of Scheme being in use. :-) Nice, I like that `listp` in CL in O(1), since dotted and circular lists are considered lists too. In the Scheme world, `list?` only returns true for proper lists, so (other than implementations with immutable conses, like Racket), `list?` is O(n), which means that usually I'm hesitant to suggest the use of `list?` for general use. For golfing, sure, but how else is `foldr` different to `fold-right` (notwithstanding having to import `srfi/1`)? @EliBarzilay There, that (edit) addresses your second point. ;-) @mjafari: It's not my fault if they have arbitrary requirements like that. :-P I understand that some people (such as people who write such restrictions into their tools) think non-bottom `default` clauses are bad style, but I disagree and I would not hesitate to use it if it makes the code clearer. Spoiler: http://stackoverflow.com/a/7324493/13. (If this is for homework, please don't read that thread until you've tried solving it first!) If you want to do most anything useful with Racket, you can't use the R5RS language. Please choose a different language, such as Racket (choose "Use the language declared in the source", then put `#lang racket` at the top of your file), if you can. Here, I've updated my answer to accommodate that. :-P `next` is not a function. It's a variable defined inside the `let`. Now, think about what it should logically do. (I've changed the brackets to be square, more in line with Racket's style. Hopefully this should make things even more obvious.) Yes, `next` is indeed `(unzip (cdr l))`. Now, you should think about how you would assemble the new result given the old result. Try this: think about what the result is, for an empty input. Then, for a single-element input. Then for 2 elements. And so on. You'll quickly get an idea for what you need to do at each step. The `(cons (car l) ???)` part is correct. The `(cdr l)` part is not. Can you figure out why not? (Also, hint: at least one subexpression will involve the `next` variable. Otherwise, there's no point for me to define it in the first place.) Congrats! If you want to compare your answer to mine, look at this: https://gist.github.com/871a0abf0aa6a020f52b You can't. The static type of local variables is not retained in the bytecode, nor at runtime. (If it's a field, you can use reflection on the field's containing class to get the field's type.) That is indeed very similar in style. Instead of counting, you are trying to see if the current value is what you're looking for, `or` the left branch `contains` that value, `or` if the right branch `contains` that value. Makes sense? :-) Perhaps not, but note that you're passing `a` unchanged between each run of `append-to-end` in your solution. In such a case, I'd say that using a closure is indeed cleaner. Like @enobayram said, don't use `sscanf`. Use the iostreams approach mentioned in my answer. It's much better for your sanity. But if you really, really insist on using `sscanf`, you need to say `&rPoint.x`, and `&rPoint.y` (and ditto with `&pPoint.x` and `&pPoint.y`). No modern JVM does interpretation any more. Dynamic (JIT) compilation is the norm and should be assumed to be the case. (You can specify JVM flags to force interpretation, to track down whether there's JIT-related bugs. But, no normal deployment should ever use such flags.) @nneonneo Actually, I consider the JVM runtime's JIT to be the only "real" compiler there is. `javac` does not optimise the bytecode that is emitted, and for good reason: such optimisations are best left for the JIT compiler. @nneonneo In theory, perhaps. But in practice, any practical JVM implementation will JIT, because otherwise the execution will be horribly inefficient. @nneonneo In that article, it explains that the bytecode actually undergoes binary translation to native ARM instructions. So, yes, that is a form of JIT, albeit a somewhat more lightweight version compared to what you get with HotSpot's `-server` mode. @JonSkeet I didn't say that javac isn't a compiler. I'm saying that it's not appropriate to discount HotSpot's JIT as a compiler, since it's got much more complicated compilation machinery compared to javac. @JonSkeet That was indeed badly-worded on my part. I had issue with nneonneo's assertion that "the JVM compiles nothing (unless you count JIT)", which I felt diminished the JIT compiler's (much more intense than javac) compilation, so my response was basically saying, hey, if you want to say which one is the "realer compiler", well.... @JonSkeet Yes, that's a better way of looking at it, I agree. Then you can say, for the ".java-to-.class phase", javac is the compiler in use, but for the ".class execution phase", then the JIT compiler kicks in, etc. And then there are other phases, like microcode, etc. @MarkoTopolnik Thank you---between you and Jon Skeet, I am having to learn to be more nuanced in what I say. Actually, yes, I think in particular HotSpot's `-client` mode does interpretation even more frequently than `-server` mode, so of course your point holds. My main point was that, if you don't specify `-Xint`, there's (usually---as you've pointed out, not "always") much more going on under the covers that just interpretation, so I was responding to that. I would edit my earlier comment, but SO doesn't permit that. :-) @MarkoTopolnik Well, JIT compilation is not ahead-of-time, either. I don't actually know the specifics of the instruction-to-microcode translation, but I understood that it has a lot of smarts behind it. My choice of terminology here, of course, is that compilation == smart and interpretation == dumb. And not everyone is going to think of those terms quite that way. :-) @MarkoTopolnik Fair enough (and of course, at the instruction level, there's no concept of methods). To my very limited understanding (since I currently know next to nothing below the instruction level), with the instruction cache, the possibility of "[referring] only to [the compiled microcode], skipping the actual machine instructions" is, in theory, there, even if current processors don't actually do it. But like I said, I don't know what actually happens in reality, so I'm happy to accept what you've said. @MarkoTopolnik Yes, JIT/dynamic compilation does indeed blur the line between (static, ahead-of-time) compilation and interpretation. It's a particular shade of grey, and I wonder if there are other shades of grey. :-) Yes, it's a debate I've often had myself. For code snippets on SO, I tend to like the non-closure form, since it has fewer lines of code. But for my own code, I tend to like the closure form, since the inner function is shorter. Personally I prefer quasiquotes for this: `\`(the answer is ,n)`. @ConnorWoods Let me write a solution myself, then I can redact bits of it and get back to you with a skeletal solution to play with. :-) Okay, have updated the post with much more details about how you would go about solving the problem. @millimoose Indeed, this is why deques are (in general) better than linked lists for use as queues or the like. @millimoose Nope, see [`ArrayDeque`](http://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html) for a description of one. Also, it says: "This class is likely to be faster than `Stack` when used as a stack, and faster than `LinkedList` when used as a queue." The OP [doesn't have enough rep](http://stackoverflow.com/privileges/vote-up) to upvote your post! They can, of course, accept an answer, and should, assuming they are satisfied with it. I think you got the left and right mixed up. Implementing reverse using `foldl` is trivial, but with `foldr`, it's not. I can't believe that I misspelt sleight-of-hand in my earlier comment. Oh, if only old comments were editable. ;-) @Pavel By default, a native method `methodName` in class `fully.qualified.ClassName` is searched under the C name `Java_fully_qualified_ClassName_methodName` (which your C-side code must export). You can call `JNIEnv`'s `RegisterNatives` method to override this linkage. In other words, if you don't use `RegisterNatives` first, "all that java gobblygook" [sic] is required. If you haven't called `RegisterNatives`, and the exported names aren't available, then you will get a runtime error when you try to call the method. `Object.registerNatives` is an internal method of OpenJDK's implementation of `java.lang.Object`, called from its class initialiser, and its sole purpose is to register the native methods that pertain to `java.lang.Object` only. If you are writing your own native library, it's up to you to register your library's native methods yourself (should you wish to). Which language are you using in Racket? `take` is defined if you're using the standard Racket language (`#lang racket`). In that case, just define `take` yourself. `(take lst n)` simply returns a new list with the first `n` elements of `lst`. In that case, you probably want to use the standard Racket language, rather than Pretty Big. The latter is pretty outdated (or so Eli Barzilay tells me). Interesting question (especially if you only want to traverse the list only once). What should happen if the list has an even number of elements? What should happen if the list is empty? You're doing the same course as Nathalie D, aren't you? :-P Same non-standard `show` function, same usage message, etc. In my honest opinion, the best way to check parameter types is via Racket's [contracts](http://docs.racket-lang.org/guide/contracts.html). I don't know contracts very well, so I can't help with that. And I definitely can't help with the `show` thing your course uses, since that's not even standard Scheme. Very nice, I forgot that `format` already does the implicit string port thing. Your code is still tail-recursive. ;-) You could make it non-tail-recursive by swapping the two branches of the `or`: this turns it into a right-fold instead of the left-fold it currently is. @ÓscarLópez You're absolutely right, it's totally redundant, now that I think about it. Once the third case matches, then by definition, the first case will match the next time through the loop. Can you also show some sample input for `break-sign`? I do not know what that function is trying to do. +1 I like your answer, but I feel the need to point out that, though supported by a number of Scheme implementations, that syntax isn't standard Scheme, so it may or may not work for the OP. Even easier: instead of `(list (car lis))`, just use `lis` directly. It is, at that point, a singleton list already. Right, that appears to be the case based on my understanding of your code. Can you paste the contents of your script into the question? What version of Guile are you using? If it's 1.x, you will need to use `(use-modules (ice-9 optargs))` at the top of your program. (Guile 2.x already has `define*` built-in.) You do use that syntax to specify _one or more_ arguments to the constructor. But when using _zero_ arguments, you must not use the parentheses. Many of C++'s syntax issues came from the fact that it needed to maintain backward compatibility with C. In this specific instance, C already used the syntax `int f();` to declare a function named `f` returning `int`. So C++ couldn't reuse that syntax for something else. I would say that a fold _from_ the right/left is more accurate. If you picture a piece of paper that you're folding, a right-fold folds from right to left, and left-fold folds from left to right. It's SRFI 89 syntax, so it's "standardised" to a point. @berry120 Congrats on your 56 upvotes on a more recent question. ;-) Did you hit their request quota/limits? I don't know the first thing about the Foursquare API but if things worked for you previously and then suddenly ceased to, that would be the first thing I'd check. Which C++ compiler and standard library are you using? This makes a huge difference. Next question. What type is backing your queue? The gcc stdlib's `std::queue::empty` and `std::queue::size` simply delegate to the equivalent functions in the underlying container. Yes, it's all about programmer performance, and the less they have to type, the faster they code. ;-) Did you reference the required assembly (`PresentationCore`) in your project? @JamesKanze I totally agree, of course. I just wanted to write a cheeky answer. :-) Okay, so the underlying type is `std::deque` then. You should check out how `std::deque::empty` is implemented in gcc's stdlib. It actually simply compares `begin()` to `end()`, and doesn't actually look at the size. Here's a hint: lists have structural induction. That means that you don't need to address the 6th, 8th, 10th, etc. directly. They can all be seen the same way as the 2nd. Ah, the left-fold solution. I was wondering whether someone would post that. I felt that a right-fold solution was more "structurally inductive" so I chose that approach. :-) @jcayzac No, because variadic macros is a gcc extension, and the main reason for macroing out `__attribute__` is if you're not using gcc, since that, too, is a gcc extension. Also, literals are supposed to be immutable, so calling `rplaca` on it is fishy. (Just to add to your list.) @jcayzac Before C99, back when `__attribute__` was first invented, guess which C compilers had to be supported. @Rörd I added a `mapcan`-based solution. You're right, in this case all lists are either freshly-allocated or nil. Well of course the foreign keys are individually unique (since they're supposed to be primary keys in their respective tables), but a uniqueness constraint across the two columns means that you don't have duplicate rows in your join table. Fine, I've edited my post to say that a primary key across the joined columns is standard practice. @jcayzac C99 is 13 years old, but C++11 is not. ;-) Many header files are written for C++ compatibility too, and there are still many, many programs that are written for C++98. So I'd still say that the use of the present tense remains justified, for a great number of programs still in maintenance. So, in `flatten1`, `cdr` goes before `car` for the reason I described: the accumulator list is built from right to left. In `flatten2`, the order doesn't matter, but Racket always uses left-to-right order when evaluating expressions, so that's why you see `car` before `cdr` here. In all Scheme systems, lists are always built from right to left, but the order of evaluation for subexpressions is unspecified (meaning that different implementations are allowed to use whatever order pleases them). The Racket developers made a conscious decision to always use left-to-right evaluation; other Scheme implementations may exhibit a different (and not necessarily deterministic) order. @AngshumanAgarwal Fair enough re C# always using `callvirt`. Regardless, my description of `call` and `callvirt` are (to my understanding) still correct, and my comment about how JVM bytecode works still holds---Java code that uses, say, `super.foobar()` would indeed still use `invokespecial` (and not `invokevirtual`). @Wes Or `foldl`. :-) @simmone [Eli Barzilay](http://stackoverflow.com/users/128595/eli-barzilay) is a core Racket developer. You're welcome to ask any Racket question on Stack Overflow, and if nobody else can answer it, I'm pretty sure Eli can. :-) (In fact, he wrote an answer to your question; it just happened to be almost identical to mine.) Sounds like Datomic will fit your bill very well. It has a caching model very similar to what you describe, and it has a query system based on datalog. I upvoted your answer, because it seems closest in spirit to mine, and because I dislike the other answers. @ÓscarLópez In standard Scheme, internal definitions can only appear at the _start_ of a procedure (and not just "not at the end"). Special exception: for Scheme implementations (like Guile) that use docstrings, the docstring appears before internal definitions. Your answer has the same idea as mine, but mine is faster. :-D Though, +1 for the reminder of `#:when` (I wrote a very similar thing to yours to validate my solution, but I used a manual `if`). R7RS directly supports that syntax. For R5RS, SRFI 38 has a specialised reader that can read that syntax. A number of Scheme implementations support it out of the box. Please Google for "sed". All the top hits will tell you everything necessary. @jlordo Updated my answer to address that case. You are close. If you based your approach on `cons` instead of `append`, your solution would be pretty idiomatic, at least out of the set of solutions that don't use higher-order functions. (See my post for a higher-order-function-based solution.) Yeah, in general, `eval` is to be avoided. There are very few legitimate uses of `eval` (a REPL is one of them), so any time you start to want to reach for `eval`, think harder. ;-) It'd still be nice to have printf-style format strings so you can just say `(sprintf "%032b" 42)`, since that is a lot more concise. ;-) DSLs for the win; this is why we use regular expressions, for example. @WarwickMasson While that is true, MIT Scheme's built-in streams work on a totally different model from SRFI 41's streams. There are legitimate reasons to want to prefer SRFI 41 streams. (Disclosure: I ported SRFI 41 streams to Guile, despite the existence of a built-in streams library in Guile.) (Interestingly, from the feedback I received for my Guile port of SRFI 41, the single improvement that people are most happy with is that I changed `stream->list` from right-fold to left-fold, so people don't get a stack overflow when they're converting long streams.) @sepp2k If by "standard" you include "final" SRFIs (and I do), [SRFI 27](http://srfi.schemers.org/srfi-27/srfi-27.html) specifies an interface for getting random numbers. If you use `read`, the only way to get `#\newline` is if you actually enter `#\newline` literally in the input. :-) But if you use `read-char`, it will work as you expect---but, you should use `peek-char`, so that if it's not newline, you can read the next expression without eating the first char! Also, don't use `eq?` for character comparisons: use `eqv?`. Thus, all in all: `(eqv? (peek-char) #\newline)`. Or, if you double enough times, it could take longer than the age of the universe. :-) I second @PaulVargas's comment. Please just use OpenCSV and be done, and not manually parse CSV with regexes. @ReutSharabani The usual way for dealing with "not only quoted expressions" is to use `quasiquote`. Then, things are quoted by default, but you can break out of the quoting using `unquote` and `unquote-splicing`. Much tidier than the double-quoting thing you've got. `(lambda () (b))` contains a free reference to `b`, which is the previous lambda. So the latter cannot be collected as long as this new lambda holds a reference to it. It so is valid (try `1 ? 2 ? 3 : 4 : 5`), but the `return`s in the subexpressions look suspect (try `1 ? 2 ? 3 : return 4 : return 5`). @WillNess It also doesn't return the item being matched, only true or false. But it serves the OP's purpose well enough. @WillNess Also (while you're here), the default avatar generation system isn't Gravatar's fault; SO chose to use identicons for default avatars. If you need to blame something, blame the identicon algorithm. Each closure has bindings for _new_ identifiers only. Free variables do not get new bindings. In Lisp programming, you should not access lists via indexing (`nth`), but should instead use `car` and `cdr`. This is because Lisp uses linked lists, so list indexing is O(n). Also `append` is also O(n), and should not be used in a loop if it can be helped at all. See my solution; it uses neither of those. There are very few tail calls even in my Scheme solution (just the one to `outer`), so it's not really a "cute Scheme loop thing" that I was going for in my solution. :-) But I do like Rainer's explicit loop approach a lot. @leppie Not strictly the same if you want to use `set-car!` or `set-cdr!`. :-P Sure, an in-order traversal can be implemented using this strategy. I updated the post with a Scheme example. Then, you'd use an accumulator, the same way you'd write any kind of folding collection function (e.g., if you're implementing `map` using a left fold). I'll update my answer with an example. Totally, right? That's why I said I liked the `SimpleDateFormat` approach better. :-) @lindelof It's just in case they add [`FileNotFound`](http://thedailywtf.com/Articles/What_Is_Truth_0x3f_.aspx) to the front of that enum. ;-) [R5RS, section 6.3.6](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.6): "Like list constants, vector constants must be quoted" (in particular, there are implementations like Chicken that will actually treat unquoted vector literals as an error). @newacct `do` does not use `goto`. It macro-expands to a tail recursion on a named `let`. Speaking of which, here, tail-recurse on this: http://instagram.com/p/NObwZSkEAk/ ;-) @WillNess Technically you _could_ implement `do` as built-in syntax rather than as a macro, but I can't imagine any implementation wanting to do that, since: 1. named `let` is strictly more general than `do` (all instances of `do` can be rewritten as named `let`, but not vice versa), and 2. `do` is very little-used. So thus, in practice, you really do need proper tail recursion to loop, unless you want to abuse `call/cc` for that purpose. My pleasure. I'm not related at all: I just downloaded Ypsilon after I saw this question and decided to dig around. However, two things helped: 1. I am a committer for Guile (another Scheme implementation) so I do know how Scheme implementations work in general, and 2. I have professional experience in C++, and consider C++ one of my primary languages. What kind of "significant visual artifacts"? If it's a chequered background, it's because you didn't set a background colour and some programs will display chequers to signify a transparent background. SRFI 1 also has `concatenate`, which is arguably _the_ solution to this problem. @ÓscarLópez In Guile, `concatenate` is a builtin. ;-) But yeah, the best approach depends on which implementation you use. In fact, in Racket, `concatenate` is actually aliased to `append*`. I always use `GroupLayout`, no exceptions. It makes much prettier GUIs than any other layout manager can achieve. :-) @NikO'Lai I do have a modified version of `srfi/61` that does work, but I'm reluctant to suggest people modify their Racket installation. This is actually not an easy problem to solve: right now, `srfi/61` only works with old-style programs, but with my change, it only works with new-style programs. I wish I know of a solution that will work with both old-style and new-style programs. @NikO'Lai My pleasure! In general (and in other Scheme implementations), the SRFI 61 `cond` is really the way to go, and I hope there will be a satisfactory solution for Racket soon, so you can take advantage of it. :-) @NikO'Lai My fix has now been [officially accepted](https://github.com/plt/racket/commit/9e93ee268269a7f289dd2a936670842e07db5237), so you should be able to use that and win. :-) @NikO'Lai If you can edit files in your Racket installation, just replace your `collects/srfi/61/cond.rkt` with [this](https://raw.github.com/plt/racket/master/collects/srfi/61/cond.rkt). You may have to remove the corresponding precompiled files (`cond_rkt.dep` and `cond_rkt.zo`) in `collects/srfi/61/compiled` too. @NikO'Lai Another alternative is to install a [nightly build](http://pre.racket-lang.org/installers/), but that updates _everything else_ too, and it may be less stable than a release. @AlexandreJasmin There, finally done. ;-) I think, as a homework question, the prohibition on using `list-ref` isn't so much for efficiency as to demonstrate understanding of the tortoise-and-hare algorithm. :-) @Bill Okay, I've adapted my answer based on the only `MultivaluedMap` I know about, which is [this one](http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/MultivaluedMap.html). `lambda` creates a function, but `lambda` itself is not a function. :-) But yes, it maps to the `function (x) ...` concept directly. @GoZoner Yes, but it does so using a much more "object-oriented" approach: sequence types simply implement a sequence interface. Doing this kind of branching inside your `member?` function isn't very OO at all. :-) The ramification of OO vs non-OO is that if you need to add a new sequence type, it's _much_ easier to do under the OO approach. @theyshookhands The "all abstracted out" is exactly what object-oriented programming is all about, and it enables you to add new sequence types without having to change all the places that use sequences. :-) @Javran Did you run the `(define-syntax define-syntax-rule ...)` thing I pasted? You need to do that first. @Javran In some Scheme implementations, like Racket and Guile, it's already defined. In MIT Scheme, I guess that's not the case. :-) Anyway, glad that helped. :-) Since your parentheses are in the wrong place, your function will always return 0, no matter what. Re your most recent edit, titled "use my style for code": please don't use that "style". Use round brackets everywhere: http://mumble.net/~campbell/scheme/style.txt. Some people like to use square brackets for variable bindings, and it's well-established enough in some circles that it's okay, but making up your own bracketing scheme ensures that nobody else can read your code. @Alexey: You can design an evaluator to treat an improper expression as an implicit `apply`, but there are still cases where `apply` is required. For example, what if you wanted to do `(apply + (map square nums))`? You can't write that as `(+ . (map square nums))`, since the reader will read that as `(+ map square nums)`. @Alexey: As for your other question, `(a . (1 2))` is read in as `(a 1 2)` and the two forms cannot be distinguished in any way. The reason I say what I said is that experienced Lisp and Scheme programmers have learnt to "not see" the round brackets: i.e., they are effectively invisible. They're there for ease of machine parsing, not for human reading. When you introduce other bracket types into the mix, they're not so easy to ignore, because Lisp/Scheme programmers haven't been trained to ignore those. Seasoned Lisp/Scheme programmers use editors, like paredit, that handles brackets for them, so that they **never count brackets manually**. This is important. (And one day I want to write a userscript for Stack Overflow so I can get paredit functionality on the site, so I don't have to cut and paste from a real editor.) Not quite; yours involves returning a reference to a member. That is arguably safe in many cases (unless the containing object gets destroyed sooner than the reference is kept around), but this question is more general. :-) Clojure doesn't read separately from evaluate? :-O Try doing a clean build, and see if you run into the same error. This error is happening because it's receiving values that are of type `Integer` rather than `Double`. R6RS does not have `make-promise`, and R7RS `make-promise` does not do what you think it does (it corresponds to SRFI 45's `eager`). R6RS doesn't seem to have promises in its core library, and R7RS's promises are created using `delay`, `delay-force` (`lazy`), and `make-promise` (`eager`). @sdasdadas Okay, lemme fix that. @sdasdadas Okay, I've fixed it the best I know how. I'm not a Clojurian (I'm a Schemer), so people who do live and breathe Clojure should suggest further improvements. :-) I like it! Though I would rename the variables a bit, like using `tortoise` and `hare` instead of `last` and `fast`. @OldPro I still prefer the name eigenclass, as (I believe) Matz also does. But, can't please everyone, I guess. Okay, that's easy. You know how you handled the case where you're matching the element you're replacing, right? Your answer should be of the form `(cons  (replace (cdr lst) from to))`. The answer for the sublist case is similar, just with a different expression for ``. (Hint: What if the inner list were a flat list? What would you use for ``? Would it still work if it were not actually flat?) I +1'd your post because it's correct, but one minor nit-pick: it's named `let`, not `named let`. (Look at the R5RS document, for example, and you'll see it's typeset the same way.) You're the first non-Racket-dev I know who uses `curry`, congrats. :-) (I usually tend to use `cut` for similar situations, where true currying isn't required, because you can insert arguments in the middle, like [this](http://git.savannah.gnu.org/cgit/guile.git/commit/?h=stable-2.0&id=b6e374e535597448cb09588300d76b5d270d5d3a).) `write` is pretty similar, though, in that it outputs a `read`able version if possible. +1 for the right approach, but I'm going to edit your answer to add `` to indicate something to fill in. The comments on their own (without the placeholders) were really confusing. (I actually implemented the complete solution myself, of course.) I also updated my answer with an example, that doesn't invoke undefined behaviour. :-) Yes, but I encourage you to actually try it out. :-) Actually, I think `.ss` was a more common extension back in the PLT Scheme days. Searching on `docs.racket-lang.org`, it seems `define-datatype` is part of both the `lang/htdp-advanced` and `eopl` modules. The OP should mention which book they're using. Re update 2: Sure, you can do this two ways: 1. `(list (cons word 0))`. 2. `\`((,word . 0))`. I'm not sure what you're trying to do, do you have some example code? @Maxwell That specific case can be handled with Guile's `local-eval`, but that's not anything that Racket supports. So I'll look at the OP's updated question and see if there's a different way to go about it. @KPatnode For your specific use case, I think you're going to have to use macros (and not `eval`). Certainly, Racket's built-in classes stuff is all done using macros. Just use `cdr` instead of `cadr`. Not true. I just tested your function in Racket, with the incorrect parenthesis placement, and the results are exactly as I mentioned. As demonstrated here: http://i.stack.imgur.com/dahh0.png Implementing [cdb](http://cr.yp.to/cdb/cdb.txt) in Scheme? Nice. (Those constants, 5381 and 33, look a little too familiar. ;-)) @SamSelikoff Correct, but it actually has a server-side Markdown implementation to create the HTML with. It does not accept client-generated HTML willy-nilly. (Oh wait, I already said all this in my comments from 4.5 years ago. ;-)) Racket doesn't have `first-frame`, `make-frame`, `frame-variables`, and `frame-values`. Where do these procedures come from? Two words: recursive descent. `case` in Scheme is analogous to `switch` in C-style languages. @Steve Thanks for explaining. It sounds like the OP edited the post after you started making your edits. Stack Overflow coalesces all edits within a 5-minute window, so further edits that the OP made within that window won't show up in the edit history. It's a roundabout way to do recursion without using letrec. Indeed, the extra gcdnew argument is what enables it. Can you describe your exercise in more detail? In standard Scheme, that's the _only_ way to get a symbol's length. You may be using a special Scheme system that lets you do it a different way. I disagree. I do think that `(exit)` is perfectly reasonable here. It causes the `call/cc` to return with 0 values. Since its result is discarded, this is okay. Remember that the OP is doing imperative-style programming, so everything that's done is about the side effects, not return values. For what you want to do, you will probably need to use a macro. But, as others have mentioned, why do you want to do this? @kapitanluffy [Because the standard says so.](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html) It specifies what `=` does, but `==` is not mentioned at all and is thus invalid. Maybe not shorter code, but certainly it's easy to find faster code, since your `equal?` does a recursive comparison. You can replace `(replace-first)` with `replace-first` globally, and your code should still work. :-D Oh, right, I did forget to test a second time. Oops, sorry. :-( Possible duplicate of [Flatten a list using only the forms in "The Little Schemer"](http://stackoverflow.com/questions/7313563/flatten-a-list-using-only-the-forms-in-the-little-schemer) and [Racket/Scheme Flatten Explanations](http://stackoverflow.com/questions/13547965/racket-scheme-flatten-explanations). (Both of those posts feature quality implementations of `flatten` that do not use `append`. Disclosure: I wrote one of those implementations.) `flet` makes the bindings visible inside the body only. `labels` makes the bindings visible inside the binding definitions as well. `int.class` is compiled as `Integer.TYPE` at the bytecode level (why they don't simply use a primitive class constant pool entry is beyond me, but it's what it is), and this applies to all the other primitive types also (including `void`: `void.class` is compiled as `Void.TYPE`). So they really are equivalent. @lightlike Yes---that's basically what Rainer's answer is---but like Rainer said, your macro argument must be a number literal, and not some expression like `n` or `(+ 3 4)` (which the macro will see as a symbol and a list, respectively; remember macros are expanded at compile-time and expressions are evaluated at run-time). `atom2` is actually a _symbol_, so of course it's not a list. Remember your list is quoted, so it can't possibly be evaluated as a variable reference or anything. @ÓscarLópez `null` symbol? This isn't Common Lisp. :-) (In Scheme, an empty-list object is not a symbol. In CL, the `nil` symbol is used _as_ the representation of an empty list.) @WilliamMcCarty Yes, `'((atom1) . '(atom2 atom3 atom4))` is the same as `'((atom1) quote (atom2 atom3 atom4))` and is a proper list. But I think you actually meant `'((atom1) . (atom2 atom3 atom4))`, which is also a proper list (`'((atom1) atom2 atom3 atom4)`). What do you mean by "how the lambda is processed" or "inner function"? That's an invalid expression, since the lambda expects two arguments and you're passing only one. You could, however, use `((lambda (ff x) (ff x x x)) + 2)`, which would be the same as calling `(+ 2 2 2)`. In this instance, `ff` is `+` and `x` is 2. And `+` happens to be a function which can take any number of arguments, and in particular, it can take 3 arguments. @JanWrobel As I mentioned in my answer, your interface should be to return the new value, which may be the same list or not, depending on whether you were able to modify it in-place. Callers should use the return value, regardless, reassigning back to their variable if necessary. I edited your post to use `defun` and not `define`, which is from Scheme. I don't expect that you're talking about Scheme, since Scheme doesn't have `nil`, it doesn't allow you to pass in an empty list to `car` and `cdr`, and the use of direct list mutation is much more frowned-upon in the Scheme community. @JanWrobel Lists are an illusion. The real data is in the conses and the `nil`. Conses are mutable. `nil` is not. That's all. I don't think people really try to pass Ruby off as a Lisp. Really?! Also, funny stab at Scheme in the last paragraph. ;-) Racket conses are immutable by default. So a non-mutating version is probably going to be a better fit. @RyanCulpepper Jinx! @ThomasBartscher Thanks! It's now implemented. (Actually I looked at Rainer's answer and it seems `pop` does the same thing as what I'm after. That's what happens when a Schemer tries to write CL. ;-)) ...and Óscar López's answer demonstrates the first approach. :-) +1 Very nice. :-) Notes for non-Racket implementations: `split-at` is part of [SRFI 1](http://srfi.schemers.org/srfi-1/srfi-1.html), and `let-values` is part of [SRFI 11](http://srfi.schemers.org/srfi-11/srfi-11.html). If your implementation doesn't have SRFI 11, you can also easily convert to use `receive` from [SRFI 8](http://srfi.schemers.org/srfi-8/srfi-8.html), or alternatively you can use `call-with-values` directly, though the latter is uglier. :-) BTW, I think `(/ (length lst) 2)` returns a non-integral number for an odd-lengthed list, which `split-at` might not like. `(quotient (length lst) 2)` may work better. So I wondered, what exactly are you trying to convey when you say your question is university level (since you also annotated your last question the same way)? That it's really simple? That you're trying to cheat your assignment? Or something else? I'm really curious. @Peter You "can" (use selection for each position, for example) but it will be really slow! In Scheme, it's always `()`, not `nil`. @FrankEpps In Scheme, `()` is not self-evaluating, so you must quote it first. `(list)` is less optimal than `'()`. Why? Because `'()` is a read-time literal, whereas `(list)` has to be evaluated first. @PeterPenzov Well, I posted a separate post about the approach I just described, but trust me, it's inferior to the sort-first approach. @David Of course, but this also illustrates that you'd be far better off using `String.format` directly in your code (use `%s` as your placeholders rather than `?`). :-) ...I think you mean to join your parenthesised expressions with OR, not AND. As your query is currently written, that condition will never match. @David Sure thing. (The `replace` was simply to replace your `?` with `%s`; general usage would not require using `replace`.) You've still missed my point, which is: `a = 1 AND a = 2 AND a = 3` is guaranteed to be false; `a` cannot be 1, 2, and 3 at the same time. If you want to see if `a` is 1, 2, or 3, you could say `a = 1 OR a = 2 OR a = 3`, or `a IN (1, 2, 3)` or (for contiguous numbers) `a BETWEEN 1 AND 3`. @Wayne: Please feel free to write your own answer about the `English` synonyms, and perhaps link to it from a comment. :-) @WayneConrad Really, more because I dislike `English` than anything else. Part of my dislike is because: 1. it's only in `stdlib` and not in `core`, and seldom mentioned or used, and 2. `English`'s side effects in Perl (it reifies `$\``, `$&`, and `&'`, [with performance implications](http://perldoc.perl.org/English.html#PERFORMANCE)) has completely turned me off of it. (Granted, Ruby is not Perl, but old habits die hard.) Be aware that in R6RS, procedure comparisons do not have a guaranteed specific result. In particular, the result of `(let ((p (lambda (x) x))) (eqv? p p))` and `(let ((p (lambda (x) x))) (eq? p p))` are unspecified (but must still be boolean). It is for that reason that [my answer to a recent post](http://stackoverflow.com/a/16973455/13) uses a flag, `left?` in my case, to specify the toggle value. (But, unintuitively given the above, `(eq? car car)` is specified to return true. Go figure. Maybe your solution may work after all.) The 9th R7RS draft resolves this confusion: `(eq? car car)` is also unspecified. (But this whole "procedures are not necessarily `eq?` to themselves" thing is highly controversial, and [it will be revoked in the 10th draft](http://trac.sacrideo.us/wg/wiki/NinthDraftEditorialCorrections).) I see. It may be clearer to simply state that you're working on an assignment, and that the concepts you've been taught so far are: _list concepts here_. Different courses teach different concepts at different paces, so it's better to be explicit about what you're able to use. On the JVM level, inner class constructors are just constructors that additionally take a reference to the outer class. So the mental model is not surprising to me, at least. Granted, I'm not particularly trying to defend its use in a constructor reference expression, just trying to understand the rationale for its removal. Re green-field languages and breaking changes, this is why C# has reified generics and Java does not. ;-) @duffymo Easy, dude. She has already got a bunch of accepted questions, so clearly she knows the drill. She might not have 6-figure rep like you, but that doesn't mean you have to condescend her as if she's a noob. @duffymo Your attitude is toxic. It's not a matter of "getting out more" and/or "too thin-skinned"; if someone in my team has that attitude, I'd get rid of them very quickly (no matter how skilled of a programmer they otherwise are). There's no need, and no place, for insults and condescension among professionals (and professional programmers in particular). There's no need for macros for that; you can write a pure function implementation of `make-map-fun`, without changing the interface at all (`(define (make-map-fun . funcs) (lambda (args) (map (lambda (func) (apply func args)) funcs)))`). And thus, the usual advice of "only use a macro if necessary", etc. :-) +1 Good catch! I've edited my answer appropriately. @Tom Agree with using `Object#methods` (as noted in my answer), but I always pair that with `sort`; for me, seeing things in order always help me find stuff more easily. @Juhana That only applies if your browser has a search bar. Otherwise you have to clear out the current address (or open a new tab), type in `http://www.google.com/`, wait for that to load, click on the search box, _then_ type in your query. Phew! :-P Yes, you edited your answer after I posted mine, but my point is still valid. ;-) Java 6 compatibility is overrated, since it's end-of-lifed. ;-) (Now, if you're coding for Android, that's a different story.) @BrianRoach I realise that (at work, we're only just now completing our switch to Java 7). But I take the same stance as Guava, which is "we are not going to support people using 1.5 or lower". ;-) (Okay, Guava actually does have a special 1.5-compatible branch. But it's still a second-class citizen. :-P) @BenjaminGruenbaum Agree re enum being better for this, of course. You should mention the `SortedMap` and `NavigableMap` interfaces, which _do_ specify an ordering. @BrianHannay Remember that if `a` and `b` are both the target word, the result _must_ be 0. Ewwww. `eval`, really?! Seriously, though, passing in function name symbols rather than function objects is just really broken. Chop off the `SEQUENCE: ` first, before doing the splitting: `str.replaceFirst("SEQUENCE: ", "").split("\u2192+")` Of course not. VisualVM uses the same code base as NetBeans. :-) Here's a "dialect" of Lisp where `if` is not a special form: http://www.thimbleby.net/misc/ (Hint: MISC uses lazy evaluation.) ;-) If you use SRFI 1, the lists don't need to be of the same length either: the mapping stops when the shortest list stops. You realise that `nth-element` is a built-in function called `list-ref`, right? @someguy Just subtract 1 from all your arguments to `list-ref`. :-) @farey Most Scheme implementations provide an `error` function for that. @farey That's easy. See my updated answer soon. :-) @user2261693 The compiler will always convert your expression to a boolean value first, before storing in memory. If you really want to store something else in that byte, you could do `reinterpret_cast(a) = 3`, but be aware that that's undefined behaviour and compilers can optimise it into something you weren't expecting. Floor, not ceiling. :-) But you could just use `quotient`. `(car (l))` and `(cdr (l))` (when `l` is a list) are wrong. They should be `(car l)` and `(cdr l)`, instead. Sure, it takes the same arguments as `fold`. In fact, it's a left fold, except that sublists are traversed also. If you haven't used `fold` before, the first argument (`visitor`) is a procedure that takes two arguments, let's call them `elem` and `last-value`. For each element in your given list, your procedure is called once, with `elem` bound to that element, and `last-value` bound to the value returned by the previous call to your procedure (or `initial` if this is the first call). `x` is the list you're traversing. Good, it sounds like you have your half of the solution implemented. You just need a way to wire it up to my `recursive-fold` and you're in to win! Ah, so you haven't learnt about `fold` yet, or else its benefits would have been immediately obvious to you. (It's one of the most powerful operations in functional programming, and it's well worth your while to learn.) That's unfortunate, because I've been meaning to write an article on `fold` for a long time. In fact, here's a preamble that's supposed to lead up to my `fold` article: http://dyscour.se/post/10113691502/5-ways-to-flatten-part-1 It's my life mission to eradicate all `append`-based flatten implementations. Sorry yours has been targeted, too. More explanation: http://stackoverflow.com/a/13548087/13 @RAJ Once upon a time, in a previous release of Debian (and probably Ubuntu), `aptitude` was vastly more capable than, and preferred over, `apt-get`. Times have changed, though, and `apt-get` is indeed more favoured these days, which is why I approve of the edit on my post. @RenniePet http://meta.stackexchange.com/questions/18014/what-is-fgitw-and-scite-on-mso @Kaz I'm a Schemer, so clearly can't speak for CL (the question is tagged for both, so I figured either one would do). The question is, does `eql` compare strings correctly? Certainly, in Scheme, `eqv?` will not compare strings the way people tend to expect. Hence the recommendation to use symbols (as opposed to strings) as alist keys is still generally correct. @Kaz Right, so `eql` is analogous to `eqv?` in Scheme. In fact, there's an `assv` procedure in Scheme, useful for alists keyed by numbers or characters. (`assoc` in Scheme uses `equal?` by default, which is too heavyweight for most alists.) @ymfoi `let` is a macro too. An expression like `(let ((foo 42) (bar 10)) (+ foo bar))` expands to `((lambda (foo bar) (+ foo bar)) 42 10)`. @ymfoi Ideally, you want as few builtins as possible, while still maintaining reasonable performance. Since `let` is easily defined as a `lambda` construction-and-call, it seems counterproductive to make it a special case, unless your lambdas are heavyweight, in which case you have bigger problems. @jozefg I'm not sure how a builtin `let` allows any greater amount of typechecking than is already enabled by its expanded form. @jozefg First hit when searching for "let generalization": [Let Should Not Be Generalised](http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/let-gen.pdf), coauthored by Simon Peyton Jones. ;-) No, SRFIs are Scheme-only. I'll see if I can cook up a CL version. Okay, I added a CL version. But since I'm not seasoned in CL, it may not be the best solution there is.... @sds That's fine, your version seems plenty good, so I edited my post to instead be a CL port of the Scheme version (which is, in my view, the optimal way to implement it in Scheme). Oh, and my revised answer prompted me to try to implement `multiple-value-call` in Scheme, and here's my implementation: http://codereview.stackexchange.com/questions/29385/multiple-value-call-in-scheme (though, for my current answer, `call-with-values` is perfectly adequate, of course). @felix021 Yes, that's true, in the sense that fewer conses have to be created and discarded. I'll incorporate your suggestion. Thanks! Actually, in Racket, even a `begin` wouldn't be sufficient to cause the infinite loop. It _is_ possible to have the PNG data within the HTML (by using a `data:` URI), but I do agree it's not recommended for newcomers. But it does provider inline images, literally. :-) @BertieWheen `A f() {B b; return b;}` always returns an object of type `A` because of slicing. But if you had something like `A* f() {return new B;}`, then the returned pointer would indeed reference an object of type `B`. @DieterLücking It's not a no-no if the return type is `unique_ptr` ;-), but in any case, I was simply trying to talk about how the main way to avoid slicing is to return by pointer/reference (and I didn't want to create a dangling reference). @BertieWheen Return a `unique_ptr` or a `shared_ptr`, depending on what ownership model you need. @user2671945 And sometimes, an exception is exactly what you need. :-) @AmirNoori But you have to square root that, and `sqrt` isn't available. :-P `begin` is a "pure functional code smell", in that it's seldom used outside of side-effecting contexts, but by itself it's not inherently side-effecting. @HotLicks That doesn't address why it generates `Derived.someMethod` a priori. You also need to add `-L/usr/local/lib -liconv` in the linking command. :-) @HotLicks That is what my answer says, in concrete terms. `float func_cos(float rad) {return func_sin(rad + 1.5707963267948966);}` @RobertoMilani No, when you do `b[0] = D(6)`, the assignment only copies the `B` portion of your `D` object (as if by calling `B::operator=(B const&)` with your `D` object as an argument), due to slicing. That _is_ well-defined, _if_ `b` is actually an array of `B` and not an array of `D`. Are you using a different language from `racket`? If so, all bets are off. Or, to put it more kindly, please switch to the `racket` language in order to have a much nicer programming experience. Under what circumstances might you be dealing with an improper list? Variadic argument lists are always proper. Also, you should describe what your function should do, with sample inputs and outputs. `send` is a macro, and you cannot `apply` it directly. That's why I used `send/apply` in my answer. Also, Racket has `take` out of the box, you should not redefine it. @LucasJones DMCA, while US-specific, is a specific implementation of the [WIPO Copyright Treaty](http://en.wikipedia.org/wiki/WIPO_Copyright_Treaty), which is implemented in EU as the [Copyright Directive](http://en.wikipedia.org/wiki/Copyright_Directive). That means, just between the US and EU, DRM is already legally watertight (IANAL). Distributors can then simply refuse to distribute their content anywhere outside those places. This is similar to the regional restrictions that all music subscription services use. @JamesDuval To a seasoned Schemer, a named `let` is much more readable than a `letrec`. A named `let` works almost like an unnamed `let`, except that it creates a label you can use to jump back (or, if you want, recurse) to the start of the `let`. An explicit `letrec` is best reserved for situations that a named `let` can't handle, such as mutually-recursive functions. To be honest, even in Lisp, `eval` is _not_ the correct way to delay the evaluation of an expression. Generally, you wrap the expression in a `lambda` and call it later on. Scheme also offers `delay`/`force`, which provides memoisation of the `lambda`'s result. +1 As I mentioned to the OP, even in Lisp, `eval` is the wrong answer to most questions, including delayed evaluation. (EDIT: You just made an edit to say the same thing. :-D) I +1'd your answer because I like the detailed approach you took, but I'm not sure if you answered the OP's question, which is how to deal with the fact that both `car` and `cdr` are potentially mutated when calling `nreverse`. I agree, _if_ the list you're passing in has no aliases. Otherwise, you run into all sorts of trouble. Scheme, in particular, has lots of list procedures that return shared-tail results, which are a form of aliasing. For example, the result of `append` and `append!` (`nconc`) shares tail with the last list given, so calling `reverse!` (`nreverse`) on that could be problematic (if the list with the tail-sharing is being used elsewhere). Right, in fact I nuked my last comment because I reread CLHS and it was too late to edit the comment. :-) (For the record for others reading this, the remainder of the comment read: True, the actual side effects may indeed be different from what's expected (in Scheme, in particular, implementations are allowed to implement reverse! as reverse, especially for implementations like Racket where conses are immutable; so using the return value is a must).) @JamesDuval Your comments prompted me to write a blog post about named `let`; hope you enjoy! http://dyscour.se/post/58639636506/named-let @Giorgio Well, that's part of what's meant by "not in a complete shape". ;-) Yes, `add` with no index will always add to the end of the list. A "static inner class" is properly termed a _nested class_. Properly speaking, an _inner class_ is non-static, by definition. @EdwinDalorzo What heap pollution? Casts to a generic type is equivalent to casts to the raw type, which in the OP's case is `Object` (unless they implement my suggestion of using `DatabaseAccess`, in which case `T`'s raw type is `Student`). Can you make `Student` and `Food` implement the same interface, with all the methods you need to use? Then just use that interface in `T`'s bound. @EdwinDalorzo Of course it'd fail, but not at the point in the code that you'd expect. @EdwinDalorzo I think you and I mean completely different things by "heap pollution". I think you're talking about the ability to put non-`T` objects into a `List`. When I say "heap pollution", I mean that objects are unnecessarily created. @EdwinDalorzo Point taken. To make it global for all users, add that line to `/etc/profile` instead. @BoBTFish Actually, if you're using precompiled headers, using one giant omnibus include file allows the same pch to used again and again, resulting in faster compilation. @Chris It may be "nicer" but `&` is definitely the wrong operator for the OP, where they need to turn a bit _on_. Note that the author of the org.json library is a JavaScript programmer, not a Java programmer, and this fact is demonstrated throughout the code. For serious JSON processing, consider using Google's Gson library. As of Java 6, lock biasing means that acquiring an uncontended lock is fast anyway. @Dr.Dredel As harold already mentioned, `>>>` is indeed the correct operator for your case. :-D Cool. This is much more efficient and your comment about "not particularly efficient" no longer applies. :-) @Jeremy Don't use a `TreeMap`. Just use `Arrays.sort`. Please paste the whole stack trace, along with what the line numbers correspond to. No, you have to run `ldconfig` after editing `/etc/ld.so.conf` or one of the files in `/etc/ld.so.conf.d`. After that, assuming you don't change those files, you don't usually need to rerun `ldconfig`. Actually, the rule is, the `-jar` option must come last. Everything that follows that are arguments to be passed to the Java program, not options for the JVM. Um, when you use `system("cls")`, that _is_ running a shell. So, just use `system("clear")`. (I was rather hoping I didn't have to spell it out quite so explicitly :-() @JoshM Running `string += ...` in a loop will result in O(n²) performance, as a new string has to be built for each iteration, copying the (increasingly longer) string each time. `StringBuilder` does not build the new string until you call `toString` on it. No, `clear` does not work in Windows. Is your `$string` variable set to a defined value? Also, aside from @IgorTandetnik's excellent point, are there other threads that are changing `observers_` while this loop is happening? Or other crazy concurrency bugs (e.g., insufficient synchronisation)? Okay, do you have a stack trace for that exception? Well, that's easy, then. Add `/usr/local/myprog/lib` to a new file in `/etc/ld.so.conf.d` (maybe `myprog.conf`, if your program is really called `myprog`), then run `ldconfig`, then try again. Also, double-check that your `/etc/ld.so.conf` includes this line: `include /etc/ld.so.conf.d/*.conf`. Without that, nothing in `/etc/ld.so.conf.d` would get loaded. Where's your breakpoint set at? At the connection handler? Remember that HTTPS connections use the `CONNECT` method so you have to watch for that (and not for `GET`, `POST`, etc.). I think you're listening for the wrong event. Read this: http://nodejs.org/api/http.html#http_event_connect I didn't either, seeing as I've never used node.js before, but I cloned the node.js source and started digging. :-D The reason is that if you use ordinals, then when you extend the enum, you can only add values at the end, never in the middle or elsewhere, or else you break everything that depended on the ordinal. This was a hard-learned experience at work, where for a while we stored ordinals in database tables, etc. This made the code much, much less flexible than it should have been. We have now committed not to use ordinals for new code. @MarioRossi You bet. Ordinals were widely used at the time I started at the company, and I had to go around to explain to a number of people why that was a terrible idea. Not only does it prohibit adding values anywhere except at the end, but when you have multiple branches that you have to merge (that add new values to the same enum), at least one of them is guaranteed to break the "add at the end" rule. `ConcurrentHashMap` is nonblocking. However, if your threads all updated the same key on the map, you will encounter contention. @SaadShakil Whether the runnables run concurrently depends on how your executor is set up (for example, `Executors.newSingleThreadExecutor` will run tasks serially), but in general, assuming you're not using an exotic executor, your tasks should run concurrently. @SaadShakil Can you show me your code for the `run` method (and maybe the `call` method for the callable, since you mentioned it)? I can probably quickly spot if there's anything that'd block you. JavaBeans properties usually use [Introspection](http://docs.oracle.com/javase/7/docs/api/java/beans/Introspector.html), but yes, that does use reflection behind the scenes. @FabienTheSolution In general, I'd agree with you, but notice the `LEN(region) > 5` condition afterwards? That'd filter out the case you mentioned. Correction: the Firebase Java client library uses [Jackson 1.x](http://jackson.codehaus.org/) behind the scenes, and Jackson has [its own introspector](http://jackson.codehaus.org/1.9.9/javadoc/org/codehaus/jackson/map/introspect/package-summary.html), distinct from the JavaBeans one. Really, at that point, you may as well just use `LEN(region) > 5` and rely on the fact that when `region` is null, `LEN(region)` is also null and `NULL > 5` is false. (I do agree with your point in general.) By the way, busy-waiting is really gross, especially for minutes at a time. (Your CPU usage will sit at 100%, and your computer will get really hot for long periods of time.) Prefer to sleep that time off instead. @JonSkeet This kind of confusion is a large part of why I yearn for `const` in Java, not to mention that it would obviate the need for Guava's `Immutable*` classes. :-D They are similar, but not similar enough. For example, consider this: `List>` is not compatible with `List>`, but it is compatible with `List>`. When you have a `List>`, the element type of the outer list must be _exactly_ `List`, nothing else. @Pawel Sure, I've edited the post to put a good example of why. Ooh, you're a fellow Kiwi! Are you related to Brenda Wallace (br3nda/shiny)? @Pawel Right, so it means you could set `bar` to an instance of `Map>`, `Map>`, `Map>`, etc., since `List`, `List`, and `ArrayList` are all assignable to (but not the same as) `List`. Because these are all possibilities, and those types are _not_ compatible with each other, that effectively means that you cannot put any value into that map (except null). @Pawel There's an acronym we use, called PECS ([producer `extends`, consumer `super`](http://stackoverflow.com/a/2723538/13)), that helps you remember when to use `? extends Foo` and when to use `? super Foo`. Basically, if you want to _read_ `Foo` values, use `? extends Foo` (covariant). If you want to _write_ `Foo` values, use `? super Foo` (contravariant). And if you want to both read and write, then you have to use `Foo` (invariant). @billz Just those 3. My system started out with [Squeeze](http://www.debian.org/releases/squeeze/), but was recently upgraded to [Wheezy](http://www.debian.org/releases/wheezy/). I guess the upgrade retained the older versions. Hmm, [this person](http://stackoverflow.com/q/10308167/13) successfully used `std::mutex` on gcc 4.7 on their Mac. Try that. :-D Obviously, that's not the same as `flet`, which binds the given identifiers in the function namespace. :-( @Gerardo You should read the [OWASP Top 10](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project). They're not the only things you have to defend against, but they're very common mistakes and very commonly exploited. @EvgheniCrujcov TCP is a little too low-level for what the OP's doing. I do agree that validation is very important and that everything that could be validated, should be. @TechGeeky Easy. With your approach, you had to write your own loop to sleep and resubmit. With a `ScheduledExecutorService`, you simply `scheduleAtFixedRate` (or `scheduleWithFixedDelay`), and everything is automatically taken care of. +1 because I agree with your answer, but as the OP said in the question comments, you might want to write them an example just so they don't shoot themself in the foot. :-) I'm not sure I understood your question. Do you just want to print the line to the screen, or do you want to return a string? If the latter, as my answer mentioned, just create a `StringBuilder` and `append` each line you read from the page. Nah, that'd include the newlines too. The OP wants to remove the newlines. @NikolaNovak In that case, why not hold the `A` by value, rather than by reference? Of course, but you should state that in your answer. :-) @NikolaNovak Yeah, that's probably a more sensible approach. @Iowa15 Your lecture notes are wrong. `private` top-level classes make no sense; they would effectively be inaccessible to everyone. @PatriciaShanahan That's what I thought, until I saw "Choose at least one answer". Then I realised that the question was poorly-written. :-) No, `*` means zero or more. `+` means one or more. @WillBaker Here, I added some sample code to demonstrate my idea.... @HirenPatel Why on earth would you use a `ByteArrayOutputStream` when a `StringBuilder` works just fine? See my edited answer. Not strictly correct. 1. The bytecode for a 100% pure Java program is indeed platform-independent. The _underlying Java platform classes_ that such programs invoke are, of course, not. 2. Most of the time, the JVM will also JIT compile, not just interpret. (You can enable pure-interpretation mode, but it'll be slow!) @StormeHawke It's called the "enum singleton pattern", and is described in Item 3 of [Effective Java 2nd ed](http://www.informit.com/store/effective-java-9780321356680). That book is well worth reading, and I think every Java programmer should read it. :-D Thanks! Had a brainfart. :-) I almost upvoted your answer, but I'm of the "use `instanceof` for `equals`" school. XPath does not support regular expressions. I'm not sure that what you're trying to do is possible. I see. I have an answer, then. A quick Google turned this up: http://stackoverflow.com/q/13511527/13. It sounds like your XML has some namespaces that has to be added to the namespace manager. Dude, you're only 13 minutes late. :-D Oh dear, that's because .NET doesn't actually support XPath 2.0 out of the box: http://stackoverflow.com/q/6447476/13 (see the top answer for a workaround). .NET is the name of the platform that C# programs run on. :-D I guess they were trying to tell how "never" you've done C#. :-P That is probably _way_ above the OP's level, given the question the OP's asked. You have to coerce your string to an integer by using `.to_i`, first. On systems with a huge filesystem cache, this may be a nonissue. :-) That page already explains how to do it. `sudo update-alternatives --config g++` But but but...branching is so slow! >_< @Balaram26 In that case (where you want early termination), in your worker threads, don't forget to frequently check `Thread.interrupted()` and exit the loop when it returns true. Seems fine. Do you have an `index.shtml` file in that directory? If so, you might want to nuke it.... (And if there's no such file, maybe your web server is (mis)configured to do server-side includes handling for `.html` files.) In C, `volatile` does not mean what you think it means. In particular, it's not the same as an atomic variable, or anything that does memory synchronisation. @user1068636 Use `-lClient`, not `-lClient.a`, to load `libClient.a`. @Raj Don't forget `containsAll` and `toString` from `AbstractCollection` (and `LinkedList` doesn't implement `removeAll` or `retainAll` either). Sure, I'd say that `Collections.singletonList` returns an implementation that defers most everything to `AbstractList`. I'm not sure what you're wanting to do now. Are you trying to count how many times the words appear in standard input? @Alex There are 3 distinct function objects, right. The _body_ (code) of those function objects are the same, but with `msg` bound to a different object each time. As others have mentioned, these are closures (I guess you could think of closures of "dynamic functions" if it helps you understand them, initially). @roliu I agree, though in two's-complement systems, usually overflows and underflows don't hurt, even though technically it's considered undefined behaviour. Suppose you can do that. How will you deal with aliasing? e.g., if `obj1` and `obj2` both point to common objects in the graph, it'd be misleading to count those twice. @delnan Jinx! (re graph) @Aleks-DanielJakimenko That's good. You still need to quote your regexps. Maybe I'll just edit your post for you. @Stephen See my comment to roliu (in the post below). @Will In Haskell, that's easy to implement due to pervasive lazy evaluation. In Scheme, it's a little trickier. :-) @user2480503 `defmac` is not a standard Scheme macro, so I had to hunt around for it. The version I found was [here](http://tmp.barzilay.org/defmac.ss), and I've reformulated the macro to use that version. @user2480503 I've found a different version, which is probably the version you're using: http://users.dcc.uchile.cl/~etanter/defmac.rkt @SotiriosDelimanolis It's nothing to ruin until it hits 31337. ;-) (Say I, who is way past that. :-P) @StephenCanon I 100% agree. My comment was facetious, though I suppose not everyone will successfully read that. (Serious comment: I don't usually let microoptimisations decide how I write code, unless profiling indicates a need to.) @PaulTomblin Maybe they've been "disregard this, I **** ****"'d. :-P Fair enough, I'll edit my answer to clarify this. @user2623967 The question is, is the OP doing something wrong or otherwise misunderstanding correct C++ behaviour, or did they really hit a bug in VS2008. Please edit your question to include the current C code you're working with. I may be able to convert that to JNA for you. So basically, what you want is a persistent queue? @MarcGlisse Thanks for the heads-up! I'll fix this later tonight. @user2245634 `awaitTermination` doesn't actually shut down your executor first. So unless another thread shuts down the executor, `awaitTermination` will just sit there until the timeout runs out. Obviously, in your example, you were waiting only 1 nanosecond before timing out, which was why you didn't observe the "very long time". @MarcGlisse To be fair, I'm not a gmp expert, I was simply trying to do a straightforward translation of the linked C++ code to C. @user2245634 Correct, any incomplete tasks will be cancelled (their threads will be sent interrupts). If your tasks don't check for interrupts, however, then of course cancellation won't work. @user2245634 Your task finished before it was interrupted. Try doing something like: `while (!Thread.interrupted()) {System.out.println("loop"); Thread.sleep(1000);}`. You will see results. @MarcGlisse I've reimplemented these functions using `mpz_export` and `mpz_import`, as you've mentioned. (I've even tested them this time!) Note: `mpz2ull` will smash your stack if the number is too big to fit. This is a feature (albeit one with undefined behaviour, in order to keep the code simple), not a bug. ;-) @user2245634 What bowmore said. (Just said that to highlight your name, so you get notified.) @IchabodClay Thanks, edited my answer. :-) @PP. `exist` presumably does a `stat` and returns true if `stat` returned a successful code, and false otherwise. @PP. Yes, indeed, although of course it's susceptible to race conditions (and absolutely not recommended for use with `/tmp` for that reason). Yes, though you'd have to convert the `char[]` to a `Character[]` first, since `Arrays.sort(char[])` does not have a version that uses a `Comparator` (since `Comparator` cannot work with primitive types). +1 for using a collation-based approach; it's been a long time since I've seen any use of a collator. Also, I must be missing something; I don't see anything in your answer (except the last sentence) that might hint at your being Canadian, unless "pretty powerful, eh" is supposed to be a Canadian idiom or something. :-P (I'm a New Zealander, by the way.) Ctrl-C sends `SIGINT`. I would expect `SIGTERM` to be handled differently to `SIGINT`. Just use `==` instead of `!` accompanied by `^`. @user814064 Right, I'll add that to the answer. You need to install the `openssl-devel` package. Although the ordering is for the keys, most of these maps actually store key/value entries (`Map.Entry`). Thus, values will most usually also appear in the same order as their associated keys. @VeronicaCornejo Lol. I'm sure Kiwis and Brits end sentences with "eh" pretty frequently too, so it wouldn't be unusual for me to hear, eh? :-P In particular, you can always use `map.values().toArray(new Party[0])` to dump into an array, and you can use `new ArrayList(map.values())` to dump into a list. Of all the 5 or 6 answer so far, I like your one the best. It has O(1) lookup and still maintains insertion order. By the way, `sudo cd ...` is a nonsensical command. `cd` is a shell builtin, and the current directory only affects the shell in which it's run. You cannot elevate the privileges of your _current_ shell; Unix doesn't work that way. Yes, but of course the _value_ of `SUDO_ASKPASS` should be the program that prompts for the password, and not literally `SUDO_ASKPASS`. @PogoStick29 Yes, you can use `true` or `false`, which are commands that do nothing other than return 0 or 1, respectively. @Aleks-DanielJakimenko `gksudo` uses `sudo -S` behind the scenes, and if you're going to do that, there are easier ways to achieve the same thing in Swing. :-D @PogoStick29 Actually, since you're already writing a Swing program, I figured you'd write your `askpass` program in Swing, also. @KerrekSB True, but I think in gcc, you can use `asm volatile` to keep the assembly from getting relocated. Also, why are you using inline assembly when you could just use `syscall(SYS_read, STDIN_FILENO, str, 16)`? It seems like a much easier way to test out syscalls.... Where do `Api::GetOpenWindows` and `Api::GetEditWindow` come from? That's not an API I recognise. Okay, you need to paste in the definitions of those function too, then. `sed` uses Basic RE, so `+` is not a special character. Also, since you're not doing minimal matching, there's a chance that you're replacing too much, such as if there are further slashes later on in the same line. Not working? Let me know what's wrong, it may be an easy fix. @PaulNikonowicz `-E` is not a [standard option](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html) for `sed`, and even for [GNU `sed`](http://www.gnu.org/software/sed/manual/html_node/Invoking-sed.html), the most common `sed` implementation on GNU/Linux systems, the option for using Extended RE is `-r`, not `-E`. You can use more than one search by using the `|` regex operator, for example, `perl match7th.pl '11A|D7A'` (don't forget the quotes or else your shell will misinterpret the `|`). You can then pipe to `xargs mv -t /new_folder/25.5E` to do the move. All together: `find . -name '*.png' | perl match7th.pl '11A|D7A' | xargs mv -t /new_folder/25.5E` By the way, relating to your other post, where I mentioned that `sed` uses basic regular expressions (BRE) (but could switch to extended regular expressions (ERE) using the `-r` option), in Perl, it uses an even more enhanced regular expression system. So you could convert your other `sed` script to use Perl instead and get awesome regexes, if you wanted to. Yes, use `'^11A|^D7A'`. As for running inline, in theory you could, but it would make your main script ugly. "Missing file operand" means no files matched, so there's nothing to move. Actually, people usually _do_ assume that GUIDs never collide. @Andy Use a regular expression. e.g., match against `Windows (?:XP|Vista|7|8)`. @Andy On my system, the `os.name` property says `Windows 8`. Don't include `./xmpp` in your compilation classpath. I think you haven't read the OP's question fully. What the OP wants to do is make those static versions available virtually to the base class, while still having the static versions available statically so that outside code can use it without creating an object instance. @Alex Fair enough, that is a huge bonus C++ has. :-D That is a fair point, and a good use case for your solution (+1). It does, in Scheme, where macros don't just work on symbols, but on identifiers that are tagged with lexical information. (Yay hygienic macros!) Unless there's a specific example where you think my example doesn't address adequately. @SaltyEgg I've added a Scheme implementation of `quasiquote`, anyway, for your reference (even though I don't know CL enough to write a CL version thereof). @EvilClosetMonkey Thanks for the correction. I'll nuke my comment. @PaulTomblin True, but I think `,` has lower precedence than `=`. I would rather Java supported `const` methods instead, which would go a long way towards solving this nonsense, but it's too late for that. :-) @SaltyEgg The inability to use `(foo l)` in your example has to do with the way macros work, not to do with the way `unquote` works. If we leave out discussions of macros, how would `unquote` work in your desired scenario? Rereading your question, I get the impression that what you want isn't `unquote` per se (which is already provided, as I mentioned in my answer), but a kind of [`local-eval`](http://www.gnu.org/software/guile/manual/html_node/Local-Evaluation.html) that works the same way as JavaScript's `eval` (wherein lexical variables are available). You see, the kind of `unquote` you wanted would effectively amount to a `local-eval`, which is much more complicated to implement than the simple `quote` or `quasiquote` system, and is thus unsuitable to be a primitive. @BlackBox s/format/extension/. The _format_ of the file doesn't really change. Are you allowed to implement this using a different technique? For me, the first one that comes to mind is a state machine. @Oleksiy You can only use `delete` for objects allocated using `new`. I've provided an example where the memory underlying an object was allocated using `malloc` instead. +1 TIL that you can placement-`new` (and manually destruct) `union` members, at least in C++11. I seem to recall that this (and generally using non-POD types in `union`s) is UB in C++03.... Ah, thanks for the correction. @computer No, `delete` does not ([necessarily](http://stackoverflow.com/a/240308/13)) use `free`, just like `new` doesn't (necessarily) use `malloc`. The C++ system has its own allocator that the default `new` and `delete` use. In any case, this is all beside the point, since my example is supposed to be generalisable to the case where C clients are specifying custom allocators (that use a `malloc`/`free` interface). @computer You cannot use `delete` on objects whose memory was allocated using `malloc`. That is because `malloc` may be using a different area of memory from what `new` uses. `new` is [allowed, but not required](http://stackoverflow.com/a/240308/13), to use `malloc` behind the scenes. @computer Yes, that's the reason. Placement `new` doesn't allocate anything. It just allows you to specify a pointer to construct an object at, which must already point to valid memory. I think you misread the OP's question. The OP _wants_ the compiler error to occur, even when assigning the array element. What you want is `yield`. Unfortunately, Java doesn't have `yield`. You'll have to switch to C# for that. :-P You'll have to paste in the code that uses `CompareStudentNames`, so we can see how your `Student` objects are created and filled in. I'm sure there is, but it'll be ugly. :-( `yield` is a very clean and easy-to-read feature. I really do wish Java had `yield`. See also: http://stackoverflow.com/q/1980953/13 `hlt` does not reboot. That's not what it's for. It pauses the processor until an interrupt arrives, and since you've disabled interrupts.... @JanDvorak Presumably because it's how the emulator is implemented. I think if you do this on a real CPU, it should not busy-loop; I know that (some versions of) Linux use `hlt` to idle the processor. @JanDvorak No, I didn't vote to close the question. @MotiejusJakštys Okay, I've posted an answer that summarises this thread. :-) s/compliment/complement/g. Java uses two's-complement by definition, but C++ implementations are not required to use two's-complement. If it used ones'-complement, the above would not apply. @dharam In two's-complement arithmetic, you negate a number by taking its ones' complement and adding 1. It so happens that the `Integer.MIN_VALUE` and `Integer.MAX_VALUE` are complements of one another, in a two's-complement system. @DaoWen I meant that `Integer.MIN_VALUE` and `Integer.MAX_VALUE` are _ones'_-complements of each other. `Runnable`s are not allowed to throw `InterruptedException`. You actually have to catch those exceptions and interrupt the current thread when that happens. Re your last comment: R5RS has `letrec` semantics for internal definitions, and R6RS and R7RS have `letrec*` semantics. This is why you see a different behaviour depending on whether you're using `#lang r5rs`. @WorBlux Well, yes, that's a fair point. :-P (I've edited my answer to incorporate a simpler form of your suggested solution.) 1. `bigNum` is a `long` but `factor` is an `int`, which means your algorithm stops working way sooner than it should. 2. I always cringe when I see `+=` being applied to a `String`, especially in a loop, since it's a Schlemiel the Painter problem, and consider `StringBuilder` a much better fit for that (since it also implements `CharSequence` and thus has a `charAt` method also). That won't help the OP, since what do you do with the `StringBuilder` after you're done? Remember you're not allowed to use `parseInt`, etc. @Sallyerik That is because your `` and `` are being printed from the wrong place. Try placing those _outside_ of the inner loop. @Sallyerik Yay! I'm glad to hear it works. If you can, please click the green tick on my answer...I've already hit my rep cap, so the only way I can get any rep is by getting accepted answers. :-) `LinkedHashSet` is usually a better choice if you want fast (constant-time) lookups but with predictable iteration order. Only use `ArrayList` if you're trying to save space, and can tolerate slow (linear-time) lookups. Remember that streams memoise all the elements that are materialised, so that each element is generated at most once. This is why if you materialised the whole stream, such as by calling `stream-length`, all the elements would be memoised and they would not be collected until the stream nodes holding them are also collected. The nice thing about x86 is that you can have it both ways: you can use `setXX` instructions to store single-bit results into a register or memory location. :-) But things do go into the flags first. @DCoder It's nearest upward. @ZanLynx I'm not certain that rounding up to 16 will actually make any difference for fragmentation, since even the control structure for many memory allocators would take about that much space. :-P Also, quality allocators will ensure good alignment, without you having to manually do so. @EricDong You've found one error, not the only error. You still need to reformulate your `swap!` to use `unsafe-bytes-set!`; your use of boxes is still incorrect (and turns the `swap!` call into an effective no-op). Make no mistake: all your `S[x] = y;` statements _must_ eventually turn into `unsafe-bytes-set!` calls. Using boxes won't get around that requirement. Sort-of duplicate of [(Scheme) Recursive function to compute all possible combinations of some lists?](http://stackoverflow.com/questions/5546552/scheme-recursive-function-to-compute-all-possible-combinations-of-some-lists). Granted that's a Scheme question and not CL, but it's not hard to adapt. @Rörd Indeed, that's exactly what I searched for when trying to find a (sort-of) duplicate: I first search for `[common-lisp] cartesian` (which found nothing), then `[lisp] cartesian`, and so on. Problem is, technically even _that_'s not exactly 33.3, which is not representable in any binary floating-point system. @hexafraction (Misread your comment, sorry.) Yes, you can create a rational type, and it'd indeed work. In fact, some programming languages have built-in rationals. <3 @ÓscarLópez If it's any consolation at all, I've had to become _very_ familiar with SRFI 41 since I [ported it to Guile](http://git.savannah.gnu.org/cgit/guile.git/log/module/srfi/srfi-41.scm) (with much thanks to [Mark H Weaver](http://stackoverflow.com/users/2007219/mark-h-weaver) for his outstanding review comments, which helped fine-tune the library into the form you see today). Look at Óscar López's answer; he explains each step very, very well. There are two problems with the `let` approach you have: 1. it's not exception-safe, so if an exception got thrown from your wrapped function, the counter wouldn't be decremented. 2. it doesn't handle multiple values. `void` is a single value and you can reference its value just fine, but if a function returned zero (or two or more) values, your code wouldn't handle that correctly. I'm suggesting even further, that if the memory-mapped file is laid out exactly the same as an array of the structures in memory, _all_ elements of the array can be copied with a single `memcpy`. That's where it's even faster than "simple assignment". Isn't the `syntax->datum` covering a little too much? Surely you want it to only cover `hello`, while keeping `define`, `print`, and `newline` hygienic. Much better. But please fix your indentation. :-D Sounds like your `current-time` has a granularity of 10 microseconds. You might want to measure a bigger batch of work, e.g., 1000 iterations, then divide the resulting time by 1000. You don't need a `cond`, `if`, or any arguments, indeed. What do you understand of the code you've got? Before anybody here can help you, you have to be able to show what you do, and don't, already understand. Here's a motivating question: how do you roll a _single_ die? If you can do this reliably, just repeat the process twice more and add up the results. @user2785589 Of course! One of those `` will indeed have `random` in it. It's up to you to figure out where. @user2785589 Have you tried it? Does it give you the same result every time? Can't be very random now, can it? ;-) Yeah, just add a `#!/bin/bash` line at the top. Did you write `<(` with _no spaces_ between the `<` and `(`? Anyway, I updated my answer to help you even further. No. Let's try a different exercise. Write a `one-die` function that rolls one die and returns the result. That is, the result should be a random number between 1 and 6. Test it and make sure it works. Then paste me the code. Did you save that script under the name `summarise_accounts.sh`? You have to use whatever name you saved the script as. Re your edit that all lines end in a space, just edit the `s/\n/|/g` to `s/ \n/|/g` (i.e., add a space before the `\n`). That should be all the change that's necessary. "Unnecessary" seems to imply "optional". That is not the case. In Scheme, any extra brackets (beyond what the syntax requires) will make the code wrong. Brackets either must be there, or must not be there; there is no middle ground. ;-) Fair enough, I'll soften my wording a bit. I still think it's overkill when `datum->syntax` will do, but your answer is good (+1). @stchang That is actually a very good point, and I'll remember that next time before I start telling people "no, you can't break hygiene in `syntax-rules`". :-P Are you trying to send structured data, rather than just a bunch of bytes? If so, you should consider using something like [protocol buffers](https://developers.google.com/protocol-buffers/). That _is_ structured data. In particular, if you want to send strings or integers and you expect the other side to know that it's a string or integer, there has to be some way to encode the type of the data inside the byte stream. That's what protocol buffers will do for you. Even with hex, you're not really supposed to be sending structured data. I mean, with strings, do you have an encoding scheme to say how long the string is? If you're prepending a byte counter as one byte, what happens if your string is longer than 255 bytes? etc. Even if you're the other side, having to design a custom protocol for every message seems to be painful. It's easier to just use a system for structured messages and be done with it. Sure, each frame is 16 bytes, but in theory, by joining the frames up, you can have data as big as you like. Unless you're really trying to fit each message within one frame. In which case, good luck; 16 bytes really doesn't fit a lot. You can also use a subshell: `(unset FOO; some command)`. But anyway, I consider empty environment variables to be different from absent environment variables, so I wouldn't use the `FOO= some command` approach. Re your last example: assuming a block is the 16-byte unit you referred to, are you really going to use a whole block for sending just an int?! @glennjackman No, what JB is saying is that running `FOO=bar` by itself does not set an environment variable, unless `FOO` is exported. @EliBarzilay I'm in the process of reading [Keeping it Clean with Syntax Parameters](http://www.barzilay.org/misc/stxparam.pdf), and reading through that, I can see how the non-parameterised approach can lead you down a giant rabbit hole. Thanks for the pointer! +1 Clearly, if `destructuring-bind` were sufficient for your needs, you wouldn't need to have a `destructuring-setq`. :-P Anyway, if you _really_ wanted to, you could implement `destructuring-setq` using `destructuring-bind` using this approach: 1. `gensym` a bunch of symbols, one for each symbol in your destructuring lambda list. 2. Set up a `destructuring-bind` with those gensyms. 3. Set up a `setq` in the `destructuring-bind` body which does the real setting. @KrzysztofKozmic If you use an LGPL library in a proprietary product, you do have to ensure that end users are allowed to modify the LGPL portions. In practice, this usually means you have to dynamically-link the library. Are you using Chicken with the [allegro egg](http://wiki.call-cc.org/eggref/4/allegro/) by any chance? It's hard to try to reproduce anything without knowing what Scheme implementation and libraries you're working with. I 100% agree with @LouisWasserman and withhold my upvote in solidarity. :-D @akim Yep. Go lambdas! +1 for the shout-out. ;-D `(define null 'null)` is not a good assumption. The OP clearly intends `'(())` to be `equal?` to `(cons null null)`. @DanielV Only in some implementations. It's not defined in the Scheme standards. Since I've nuked my answer (since it is probably more like Scheme and less like CL; Schemers generally can't get their heads around funcalling symbols, for example), you may want to modify your answer to address the most idiomatic way to write what the OP is intending. :-) @jaymmer Yes, the `#include` has to be done using `bind*`, as you can see from all the examples. What that does is cause the `#include` (and also the function declarations, if you're using `bind*` for those) to be emitted into the generated C file. If your function declarations matched what's in the header file _exactly_, then using `bind*` for them is harmless. Otherwise, your compiler might baulk.... You can use `csc -t` to generate the C files without compiling them. Then you can compare what effect using `bind*` has compared to `bind`. `unquote` doesn't work the way you think it does, in any implementation, ever. Also, I don't understand what you mean by "`(set! t x)` will not work". In particular, [`unquote` is not `eval`](http://stackoverflow.com/q/18515295/13), and you shouldn't use `eval` for this, either. Remember that Haskell has lazy evaluation. This applies whether or not the expression is "constant". @Backo They are necessary. The conditional operator binds more loosely than `==`. My hint is that you should use `map`, not necessarily `local`. @JoshuaTaylor Indeed, and my answer is basically just a simplified form of Óscar's answer, so I'm perplexed about why somebody felt compelled to downvote my answer. :-( @LuiggiMendoza This is the subject of massive debate, but the idea is that we want SO to be the destination when people do a net search, and so it's actually reasonable for people to ask a question on SO even if it's easy to find elsewhere. By all means, if this already duplicates an existing question on SO, then do flag it as a dupe. @meagar Yep, and if you take the limit as an option, defaulting to 200, it would immediately solve the OP's problem. @SotiriosDelimanolis You can implement a comparator using a (C++-style) predicate, where it's assumed that the predicate returns true iff `a < b`. e.g., `return less.apply(a, b) ? -1 : less.apply(b, a) ? 1 : 0;` @SotiriosDelimanolis Rethinking on this, obviously you can't use `Predicate` directly because it's unary, but assuming there's a binary version, it's always assumed to return whether `a` is less than `b`. You simply swap the arguments to test the other direction. At least, that's how it's idiomatically done in C++. Why use `eval` at all? Just use `(call-with-input-string "((a b))" read)`. s/unnecessary/incorrect/ In compiled bytecode, `this` is the first parameter of a method call (much like Python's `self`), so it really does have a location. In fact, it works very much like a final parameter. @IlyaBursov `.*?` is to be preferred over `[^']*` (yes, it's `*` not `+`, since it can be zero-length). No, the OP just had a confusion about the invocation syntax, which is `(xtoy (1+ x))` and not `x2y(1+ x)`. I see this confusion extraordinarily frequently in the questions I see here on SO. Ah, right. Point taken. @TedHopp You're not going to find a collection where overall iteration is ordered by values but still allow lookup by key. If the latter can be done away with, then just swap the key and value. @TedHopp Edited the post to be clearer about the limitations of my approach. Try changing the `k = 6` to `k <= 6`. Also, your `for` syntax is wrong, it should be `for (j = 0; j < 3; j++)`, i.e., `for` outside the parens. Plus, instead of having the `newj`, you can just have `j` iterate from 1 to 3 if that's what you want: `for (int j = 1; j <= 3; j++)`. Oops, you need to put the function as the first argument of the `map` invocations. Huh, for whatever reason, the OP's account is no longer existent. I guess they won't be able to accept your answer. Personally, I think it's broken to rely on top-level expressions being printed. (Sure, it's understandable if you're in a REPL, but this isn't a REPL, and also, I don't think R6RS modules support being used like a REPL.) Are you sure you can't just `display` them directly? "You keep using that word. I do not think it means what you think it means." Anyway, [this is what compersion means](http://en.wikipedia.org/wiki/Compersion), and it has nothing to do with compression. Possible duplicate of [Get the middle elements from List in scheme](http://stackoverflow.com/questions/13306626/get-the-middle-elements-from-list-in-scheme). No, there's an approach that does not use `length`. :-) See the dupe link I posted, it contains an answer I wrote for a similar question. I'd upvote this 100 times if I could. :-) Because it's an awesome, elegant solution. Especially the destructuring one. Unfortunately, destructuring isn't that commonly used in the Scheme world (it's used in the `match` macro, but that's about it), so it's not the first solution I reach for, much of the time, and I need to learn to use it more frequently. Basically the same as [my answer](http://stackoverflow.com/a/13308315/13), except that I took care to return a list even in the single median case, so that there's no information lossage if the elements are themselves lists (and also allows me to return an empty list when given an empty list, rather than throwing an error). :-) No, just use `lsusb` to find out what the vendor/product ID for your phone is (you may need to enable `adb` for your phone first, if it's the type that uses a different product ID for `adb`), then add the appropriate entry to your `udev` rules (see my example). Good. Then make sure you're in the `plugdev` group (you may need to relogin if you weren't in that group at the start of your login session), and then run `sudo service udev reload`, and you should be good to go. You may also need to unplug your phone and plug it back in. Since when does one "need" `defmacro` in Scheme? `syntax-case` is strictly more powerful than `defmacro`. I've never looked at the Chrome extension, so I don't know if it needs it. I just use command-line `adb`, myself. Why on earth would a standard prelude provide unhygienic macro support? That seems to go against what Scheme is about. @SK-logic Perhaps, but in the Scheme world, we use `syntax-case` (or perhaps explicit renaming) for macros with controlled unhygiene, not `defmacro`, which is uncontrolled unhygiene. I frequently use `syntax-case`, but I would absolutely 100% avoid `defmacro`. @user448810 As I just said to SK-logic, `syntax-case` is sometimes useful. `define-macro` is only good for compatibility with CL-style macros. But it's seriously deprecated for new Scheme code. @SK-logic Given that you can implement `defmacro` using `syntax-case`, clearly it's powerful enough to break hygiene wherever you want to. I am saying that you do _not_ need 100% uncontrolled unhygiene in order to have metaprogramming. In Guile, some of us are [in the process](http://git.savannah.gnu.org/cgit/guile.git/log/?h=cky-hygienic-macros) of converting legacy `define-macro` macros to `syntax-rules` and `syntax-case`, and yes, it's absolutely great. For example, hygienic macros could call package-private (unexported) functions the simple, obvious way---which would have been much more burdensome to do in a `defmacro`-style macro. Oh, and by the way, I took on board your advice to use syntax parameters: http://git.savannah.gnu.org/cgit/guile.git/commit/?h=cky-hygienic-macros&id=98a1e95e9997b8a9b38693bd772fb0e20e88a935 By the way, this whole `defmacro` purge started when ijp made the observation that [hygienic macros and `defmacro`s don't mix](http://lists.gnu.org/archive/html/guile-devel/2013-09/msg00015.html), and stis was like, [what, we still have `defmacro`s in Guile?!](http://lists.gnu.org/archive/html/guile-devel/2013-09/msg00026.html) Granted, we started "N years" later than Racket, but I'm glad it's actually being done now. What's so hard about exiting your browser normally, that you have to force it to exit? Yep. So it only compares true if they are the same object. @depsypher However, remember that the result of `Arrays.asList` still cannot be resized. The only thing you can do (in this instance) that `Collections.singletonList` can't is using `list.set(0, ...)`. Also, APIs are cleaner when returning immutable lists. Callers really should clone the list when they want to modify it; shallow list copies are not expensive. ...and one of the other other answers also has this, but also uses `cadr` like your solution did, rather than the synonym `second`, but your post seemed to have overlooked that, even though it was the fastest gun in the west and was the accepted answer. ;-) @Keith Thank goodness! (I'll keep the other comment for reference, but thanks for the correction.) You're doing this "just for fun", right? Because [SRFI 26](http://srfi.schemers.org/srfi-26/srfi-26.html) already has a `cut` macro that does what you need: `(define apply-to-four (cut map  '(1 2 3 4)))` So read that page. It describes everything you need to know to implement it. :-) The reference implementation is also worth checking out. Writing to a fixed temp file is very unsafe, as it opens up avenues for a [symlink attack](http://en.wikipedia.org/wiki/Symlink_race). To be safe, you'd have to use `mkstemp`, which is not "pure Scheme". Perhaps, but it's still a poor solution, akin to telling someone to use `gets` (in C) to read in a string from stdin. Well, let's do one better: R7RS has recently been ratified, and it has `open-input-string` built in. ;-) @JoshuaTaylor If Barmar's answer worked for you, do consider upvoting it (since currently I'm the only upvoter). ;-) Uh, what are you trying to do? I smell an XY problem here. @JoshuaTaylor Technically true, but in Scheme, actually mutating stuff isn't recommended anyway, so it's about as good as it gets. I could add a mutating version, though. @JoshuaTaylor Here, I added a mutating version. @JoshuaTaylor In the Scheme world, update doesn't necessarily imply mutation, unless the word "in-place" is also used. @user2789945 To add to c45207's comment, to make it even more infix-like, you can look at it as the equivalent of `lambda rhs: area > rhs.area()` (Python syntax). (And yes, I did intend `rhs` to mean right-hand side.) Why are you doing this using regular files instead of using a real fifo? Since you have only one reader process, a fifo does sound like the ideal solution. Remember, it's easy to make named fifos using `mkfifo`. You can use `tee` to send the fifo's output into a file. Then your main application would still be reading from and writing to a pipe, not a regular file. @JohnFriedrich There are sorting algorithms that are faster than O(n²), so no need to be extremely disappointed. (The fastest ones have O(n log n) worst-case time; I believe it's impossible to go any faster.) @WillNess Nice! Thanks for the heads-up. :-) @user782220 If a `let` body has multiple expressions, each one will be executed in sequence; it doesn't care about whether it hits an atom or not. The magic is that `(lm (car l) out)` could potentially call `out` (via `(out (car l))`), which is a continuation. That's what makes it "break out" and not continue on with `(lm (cdr l) out)`. @user2869231 Okay, the code will be slightly longer, but here's a version that basically reimplements `map` for you. @Sage The OP knows about `Deque`, but I was more reinforcing that `Stack` is a really ancient class and it probably won't receive any further love from the Java maintainers. Like `Vector` and `Hashtable`, it's sorted of discouraged to use (even if not officially `@Deprecated`). @lnwvr The ability to iterate over a `Stack` is an accident (of the fact that it subclasses `Vector`---it actually violates [Liskov Substitution Principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle)), and not a part of its design. If you really want to exploit this accident to the max, you can just use `listIterator(stack.size())` and use `hasPrevious()` and `previous()` on the returned `ListIterator`. But again, none of that is part of `Stack`'s design. Why do you expect the answer to be `["123456","89"]`? You've only added the string to the array once, so the array will only contain one string. Also, the array holds the string by reference, not by value, so when you did `string.clear`, it would also affect the string in the array. I would return `(values)` if given an empty list. Yes, this will be the same as `(values nil nil)` for your case with the `multiple-value-setq`, but there are other situations where that distinction would be useful, which I'll demonstrate with an upcoming (Scheme) solution I'm posting soon. I love fold, but I really wished it would handle multiple values, so that I could rewrite [a min-max function](http://stackoverflow.com/a/19993142/13) using fold. (No, not particularly liking the idea of packing the min and max into a cons, as you'll soon see when you look at the code.) @JoshuaTaylor Racket doesn't have that limitation, so there you can use `apply` with reckless abandon. :-) Uh, what?! The question gives you all the information you need. Your code simply needs to check whether the tree is empty, in which case return 0. (That's the base case.) Otherwise, get the height of the left subtree and right subtree, see which one is greater, and add 1 to that, and return that. (That's the recursive case.) +1 Nice, a skeletal code form of what I said in words in the comment. ;-) String literals are always interned in Java. So you will find, in your example, that `a == b`. But your example is wrong, because `x` and `y` both point to the same string literal, and string literals are always interned in Java. If you changed your example to use `new String("hello")` for at least one of those variables, then your assertion of `x != y` would indeed be true. @maaartinus Ew. I would never make an `equals` method that only compared the `id` if there are other mutable fields, because those are part of the object's observable state. @Harish Interning can be useful if the universe of possible values is bounded and there are potentially many duplicates. In that case, interning is justifiable for the memory savings. It's usually not really about the runtime savings, and like all the other comments say, you have to be judicious about which classes to intern. For example, you shouldn't intern `Integer` generally (though for small values, like between -128 and 127, those _are_ interned if you use the `Integer.valueOf()` factory method; but that's another instance of "bounded universe"). @maaartinus It depends on whether you consider your type to be a "value type" or "reference type". I feel that data access objects are value types. In the way we architect our code, we use an `Integer` for the map keys, not the data access objects themselves. We have a separate cache (with soft-referenced values, usually) for looking up those objects, if they are expensive to refetch. @asandroq What?! DaoWen's answer with quasiquoting actually applies to all Scheme implementations. It doesn't require `eval`ling through lexical variables; those actually get interpolated by the quasiquote. Your concept of using the `id` only while keeping everything else mutable reminds me of the use of stateful enum values. Personally I prefer to keep enum values stateless, especially if calling code uses the enum values directly. In limited special cases, such as if I'm implementing an enum-based singleton, stateful is okay; the enum is just an implementation detail. It's all about reducing surprises for users of your code. [By default](http://docs.racket-lang.org/reference/printing.html), DrRacket displays results as an `eval`able datum, so for `(cons 'quote '(a))`, it'd print that as `''a`. The actual datum is still `'a`, but by printing it as `''a`, you can copy that into the REPL and get the result you expect. That is not true. When I tested with `plt-r5rs`, it printed out as `(quote a)`. And with DrRacket in `#lang r5rs` mode, it printed out `(mcons 'quote (mcons 'a ()))`. That is not guaranteed; in fact, the documentation explicitly says that values may be negative. Again, you cannot make any expectations on its value. Since `(stream->list (stream-take n x))` is a common use-case, there's a short-hand for that: `(stream->list n x)`. You forgot to use `back_inserter`. Also, see my answer. :-P @ZacHowland Indeed, and the way to do so (in terms of avoiding reallocation, rather than avoiding `back_inserter`) is to use `vector::reserve`. :-P (I have a strong distaste for default-constructing objects and then assigning them later on, far rather preferring to construct the correct value in the first place, so yes, I kicked back your edit.) @ZacHowland True, there's a time and a place where this extra update/check of the size has a higher cost than the extra initialisation and assignment. Let me update my answer with a few more nuances. It sounds, from the question update, that all the OP needs is a cartesian product. @svk Your intuition turned out to be right, it seems, based on the OP's update. Your Racket implementation of `cartesian-product` is _way_ too complicated. My version is thus: `(define (cartesian-product lst1 lst2) (for*/list ((x lst1) (y lst2)) (list x y)))` Fair enough, then. :-) Yay for completeness (+1). My answer extends that by explaining the circumstances under which you should prefer each approach. In particular for generic functions where the target type is not default-constructible and/or assignable, this approach would be infeasible. Also re the custom iterator approach, unless it models a random access iterator (in particular, `distance` should run in constant time), the performance is unlikely to be better than the `back_inserter` approach. With the exception of returning `()` instead of `#f` when the searched item is not found, this function is identical to the standard `member` function. In other words, you can define this function thus: `(define (y s lis) (or (member s lis) '()))` ;-) Gah, it's probably called `stosl` in AT&T syntax. (I'm 10x more familiar with Intel syntax since that's what I grew up with.) To explain the distinction, a 32-bit quantity is also known as a dword or long. Intel syntax prefers to use `d`; AT&T syntax prefers to use `l`. I upvoted your answer because it's correct, but I think the OP is trying to follow the HtDP design recipe. There is a reference solution to this in HtDP, and I glanced at it when looking at the OP's previous question, but yeah, it's not the kind of answer you might expect. @ShayanRC Re your edit, don't take the `stringVector` by value, instead prefer to take it by const reference. Otherwise, all this talk about performance is just wasted. (You do have to return `doubleVector` by value though, so the return type is correct.) You could also just use a macro. That's how `incf`, `pop`, etc. work. Nah, you don't "suck at coding". :-) It's just that vectors are very different from linked lists and the coding techniques for dealing with them are very different. Since vectors are seldom used in Scheme, there aren't many Scheme books and sites that give a decent treatment of vectors; they generally assume that, if you use them at all, you already know how to use them correctly. I saw your comment in your subsequent question, and I get that you felt that I was condescending your coding. My answer was perhaps a little too directly worded, and for that I apologise. Direct feedback is a habit I have from the code reviews I do at work---at work, we have a policy where _every_ code checkin must be peer-reviewed, so everybody in our team has reviewed a lot of code, and over the years, I've developed a certain style for reviews. I'm sorry I treated your question as a code review when, in hindsight, that wasn't what you were seeking. Now, it's my turn to make a confession. 1. My Scheme level is nowhere near the likes of Eli Barzilay, and I defer to him for the really hard stuff. :-) 2. I've been playing with Scheme since 2002, so I've had a lot of practice at this. I have every confidence that, in 11 years' time, you'll probably be way more experienced than me. @Menschenkindlein Of course, the same caveats apply as when deciding whether to use `list`/`cons` or literals. Since I'm a Schemer, my habit is to return immutable data by default, and only enabling mutability on a case-by-case basis. Certainly I do not mutate objects returned by other functions unless it's expressly documented as being a fresh instance or otherwise okay to mutate. @Karthick Correct, the question title is an [XY problem](http://meta.stackexchange.com/q/66377/13), so I solved the _real_ problem with my answer. @user2968401 People who can answer Scheme questions competently tend to love Scheme, so saying that you hate Scheme is unlikely to endear you to them. I know for a fact that when I avoid answering questions where the OP says they hate Scheme. @bigyanshr Sounds like your tests need a wider threshold. In particular, you want any values within, say, 0.00005 to be accepted. @JoshuaTaylor All the sample code from On Lisp are listed here: http://ep.yimg.com/ty/cdn/paulgraham/onlisp.lisp @JoshuaTaylor It also doesn't presume that the function returns mutable lists, unlike `mapcan`. @user1461328 Well, yes, we were just discussing about how it differs from `mapcan` (which uses `nconc` instead of `append`). The main difference is that `append` copies the incoming lists, and `nconc` mutates the incoming lists. The latter is more performant but can only be used if the lists are linear-update; the former is usable everywhere. @GoZoner :-D I especially recommend typing classes for Dvorak, but I'm biased. (I've used Dvorak for 10 years, and enjoy my leisurely 120 wpm typing speed.) @WillNess TBH I chose to close the other one not because this one has an answer, but because this one has a cooler-looking postid. ;-) @WillNess Would it be more readable as post_id? ;-) 20506666 is the postid for this question. @WillNess Alas, that ship has already sailed. Quoting from R7RS, section 4.2.8: A quasiquote expression may return either newly allocated, mutable objects or literal structure for any structure that is constructed at run time during the evaluation of the expression. **Portions that do not need to be rebuilt are always literal.** [emphasis mine, continues] @WillNess [continued] Thus, `(let ((a 3)) \`((1 2) ,a ,4 ,'five 6))` may be treated as equivalent to either of the following expressions: `\`((1 2) 3 4 five 6)` `(let ((a 3)) (cons '(1 2) (cons a (cons 4 (cons 'five '(6))))))` However, it is not equivalent to this expression: `(let ((a 3)) (list (list 1 2) a 4 'five 6))` @WillNess To summarise the quoted section above, the behaviour you mentioned for CL is a _required_ behaviour in R7RS (i.e., not at the discretion of implementers). This should not be surprising, since Scheme is generally even more mutation-avoidant than CL is. @WillNess It's not as simple as that; even the "list ends with some var" case is allowed to be treated as literal, as described in the `\`((1 2) 3 4 five 6)` example, though that is implementation-specific. So to be safe, you need to always use `list-copy` (or something similar, such as a deep-copying version) if you plan to mutate the data. BTW, in Racket (`#lang racket`), conses are immutable (and `set-car!` and `set-cdr!` are not provided); it provides a new type, mcons, that people can use if they really need a mutable cons. But I very seldom see mconses being used. In Scheme, with [SRFI 26](http://srfi.schemers.org/srfi-26/srfi-26.html), you can write the lambda as `(cut mod  3)`. Someone should write an equivalent macro in CL. ;-) Yep, that was the original implementation I wrote (since it's more straightforward than the version I eventually posted, and was thus what intuitively came to mind), but I didn't like the order of the resulting elements. (I know, since when are sets about ordering, right?) Still, have a +1. :-) BTW, your `color` function should call `(random x)` only once and store its value (using a `let` or an internal `define`), and not call `(random x)` multiple times. Thus: `(define (color) (let ((value (random 500))) (cond ((< value 100) 'blue) ((< value 200) 'purple) ((< value 300) 'yellow) ((< value 400) 'red) (else 'green))))` You need more examples of what you want to do, in terms of before and after. Right now your question is just vague. I've been tempted for years to amend @AdamRosenfield's edit to say "amortised" instead of "amortized", but I can't bring myself to make such a small edit with no other changes, especially since said edit is 5 years old. Still, I should at least state so for the record. BTW, `-lpthread` is not portable, and in particular, older versions of BSD used `libc_r`, not `libpthread`. Thus, `-pthread` is more portable and recommended. Possible duplicate of [Why (apply and '(1 2 3)) doesn't work while (and 1 2 3) works in R5RS?](http://stackoverflow.com/questions/17232240/why-apply-and-1-2-3-doesnt-work-while-and-1-2-3-works-in-r5rs). @boxed Yes, but deques are not built in to Clojure, whereas lists and vectors are. @JohnClements ...no love for the alist solution? It's just as O(n) as the `cond`/`case` solution, doesn't confuse the symbol-to-procedure translation, and (in my opinion) more succinct. ;-) In many Scheme implementations, the "undefined" value is a void value, and is a (usually singleton) object distinct from other objects. It's not "nothing returned", it's just a value that the REPL is programmed not to display. Try `(define foo (list (if #f #f)))` and play around with `foo`, `(car foo)`, etc. @ricardo I've updated the post to answer your question, but yes, it basically does what you described. The assoc functions returns the association itself (e.g., `\`(+ ,+)` in the first code snippet, `(cons '+ +)` in the second), so we use `cadr` or `cdr` respectively (in combination with `cond`'s special `=>` syntax) to extract just the procedure value. (Note: `(cadr \`(+ ,+))` = `(cdr (cons '+ +))` = `+`.) Using `eval` for this is way over the top and not recommended. In Racket, you can use `andmap` to do this: `(andmap values '(a b c))` => `c`. (In Racket, you can also use `identity` instead of `values`.) The use of `eval` to run programmatically-generated code in this way is not a good idea, sorry. The standard way to dynamically generate code (at compile time) is to use a macro, and writing a macro is definitely to be preferred to using `eval` where it's feasible. The fundamental difference is that `loop` in my version is not a macro. Oops, I was looking at your last example, not the first one. The fundamental difference with your first example is that I'm not passing the expressions into the recursive calls. `eval` is way too frequently misused, and can be a security concern if you don't quote everything correctly. It is also too heavyweight for what you're doing here. To me, the main use of `eval` is to run user-supplied code (with all the security implications attendant to running user-supplied code), such as in a REPL. @JohnClements Thanks for introducing the term "insider-Scheme"; I've [put it to good use](http://meta.codegolf.stackexchange.com/a/747/3). :-D But yeah, I don't really know a nice way to use `assoc` and the like without using `cond`'s `=>`. It's either that or I'd have to throw in a `let` plus `and`. Yes, atoms (other than the empty list) are indeed a base case for improper lists. You can create circular lists using either [SRFI 1](http://srfi.schemers.org/srfi-1/srfi-1.html)'s `circular-list` function, or [SRFI 38](http://srfi.schemers.org/srfi-38/srfi-38.html)'s `read-with-shared-structure`. Almost! In the green box, you should say "dotted pair whose cdr is a proper list". @T.J.Crowder Yep, incorporated your comment into my answer. Cheers! Right, adding elements (or methods) to an enum does not require recompilation of calling code. This allows forward compatibility, so that you could slot in a newer version of a library you're using and have it Just Work. I think the OP's question isn't about macro vs procedure, but macro vs builtin. `import` declarations can be translated into an equivalent `load` in an implementation-specific way. Also you can just `load` a file that contains the user-entered REPL expressions. Personally I'd just try to `eval` the `import` declaration directly, but as you said, that's not totally portable, and quite possibly, nothing is. I guess REPLs are generally implementation-specific for a reason. (Disclosure: [I do not believe Scheme portability is realistic.](http://stackoverflow.com/a/11066232/13)) @Frank Nice, thanks for that info. Do you want me to fold that into my answer? @LightnessRacesinOrbit I edited my answer to explain why, but it's because they are not being printed at all. The passing of `a.rez` and `b.rez` is pushing two words to the stack each. @LightnessRacesinOrbit I don't _know_, but the output supports my anecdotal hypothesis. @kungi "The faster you go, the bigger the mess." http://www.youtube.com/watch?v=uV5o_-UADiY (That's one of the less graphic ones; go and search YouTube for more. New Zealand is really into the graphic ads to discourage drivers from speeding.) This is a fine example of return value optimisation (RVO) at work. :-) http://stackoverflow.com/q/12953127/13 `com-invoke` works on `IDispatch` objects, so the particular method you're calling matters (like, I actually need to see its actual IDL definition). Is the ProgID _really_ `dcomobj.1`? If so, is this a custom COM object you wrote yourself, or is it easily obtainable? Do you have some sample inputs and sample expected outputs? @MichaelFox Alas, a rewrite may be inevitable. I'll see if I can rewrite what you've posted into `syntax-case`. @ryrd How were you trying to call `string->syntax-name`? As I mentioned in my answer, it _only_ works when using string literals, e.g., `(string->syntax-name "foo")`. You _cannot_ use `(let ((foo "bar")) (string->syntax-name foo))`; I have a syntax guard in place to block that, and the error message suggests to me that you were indeed attempting such a thing and my guard caught it. And if the DSL is S-expression based, you can just use `read` (along with, if warranted, macro-expansion). ;-) @ryrd What _are_ you trying to do at a high level, anyway? Poor-man's `eval`? I keep getting the feeling that we're dealing with an [XY problem](http://meta.stackexchange.com/q/66377/13) here. @ryrd Sorry, that's not "high level". High-level is basically explaining _why_ you're trying to do what you're doing. Like, are you _really_ trying to access top-level variables by name, or is it okay to use a hash table to hold a list of user-defined variables? If the latter is okay, there is a portable Scheme solution to your problem (and GoZoner's answer is a variant of that, except he/she is using [alists](http://www.gnu.org/software/guile/manual/html_node/Association-Lists.html) instead of hash tables). Um, most decent compilers will already perform such optimisations for you automatically. I wouldn't try to hand-optimise them unless it's a non-obvious strength-reduction optimisation. Certainly, the examples you gave are trivial for a compiler to optimise. @uselpa Use `modulo` and `length`. :-) My solution approach is actually shorter, clearer to read, and doesn't have the same computational pitfalls. Still, I avoided posting an actual code solution because I wanted the OP to actually _think_ about the solution rather than just cutting-and-pasting, but I may have to reconsider, in the name of making my answer more likely to be accepted. I would also consider my solution truer to functional programming: it's built from very small, composeable, general-purpose functions. `take`, `drop`, and `append` are standard functions in any functional programming toolkit (as are `map` and `fold`, though those are not used in this problem). I would far prefer to use these components than writing a manual loop. Again, not trying to be offensive, just giving my view on code quality. (At work, we have mandatory code reviews, so I have done a lot of them, and have a certain review style I'm accustomed to. I'm sorry you find my style offensive.) Scheme doesn't have overloading of the sort you're thinking of, but it does have optional parameters, and it does have `case-lambda` (though not sure if you can use that for structs). Did you run `sudo locale-gen en_IN` first? I tried it and it worked for me. @OliCharlesworth Thanks! I wasn't aware that there was a "typo" close reason. I have put in my close vote. It means that that function can be called via a `const` reference. In specific, it makes `this` a const pointer within the context of that function. `Data&` => non-const reference. `const Data&` => const reference. What kind of variables? Shell? Perl? Ruby? Java? PHP? Yes, technically this works, but it's probably easier and more readable to rely on `IFS` tokenisation, as used in all the other answers. :-) (And if the delimiter isn't a space, it's easy enough to adjust `IFS` accordingly.) It's not so ugly if you're using `local` (supported by bash and dash) to set it, within a function. @user877329 The declaration lives inside ``, which only your OS provider can change. Certainly you cannot expect user code to be able to override its contents. A usual `sudoers` line looks like this: `user = (ALL : ALL) ALL`. This means that the given user can run any command, as any user or any group. The final `ALL` there (outside of parentheses) is the command list. You need to replace that with the list of commands you will allow the user to run. Choose the commands carefully, for even simple commands like `less` will permit shellouts. @wonce The OP wants to require the root password for the root shell, so that he can let users run selected things as root but not get a root shell. As mentioned in my answer, achieving this is quite tricky because many commands allow shellouts. What commands do you want them to be able to run? Be specific. "All" commands? Try this: `sudo less /etc/passwd` (or another file; the specifics don't matter). Then press `!`, then enter. Instant root shell. That is what a shellout is. Many commands that users can run provide such capabilities. Or, how about... `sudo sh`? `sudo bash`? `su` is not your only problem. @Barmar I actually detest `sudo su`, I prefer to use `sudo -i` or `sudo -s` as appropriate. :-) @user3259496 Right, in vanilla Unix (without using capabilities or such like), you either trust someone to do a small set of tasks (in which case, it's best to write scripts to perform those tasks, and put _only_ those scripts in the command whitelist), or else you trust them with the world. Those are really your only options. @Barmar There's really no easy way to win, short of whitelisting (and even that is tricky). Many years ago, before I realised the wisdom of this, I tried writing a logging shell that only allowed a whitelist of commands (but still allowed `cd` and redirections to work), and to this day I still have no idea if my whitelist is tight enough to avoid shellouts. I have come to learn, at the end of the day, "it's trust or bust". There is "a" solution, but it's totally overkill. You use `ptrace` to monitor for all `execve` system calls and log them. But your logs will be flooded with useless crap when you run shell scripts.... Here's another overkill solution. Set up LXC containers or something similar, one for each user. They can have root there to their heart's content. These containers talk to the main system via Unix-domain sockets (or even TCP/IP sockets, but that's even more overkill). Log everything coming through these sockets. You have to write a daemon to listen on that socket and process/log requests. @user3259496 Has it occurred to you that a satisfactory answer to your question is impossible, due to the design inherent in both Unix and `sudo`? The best answer I have for you is, if you can't trust your users, then do _not_ allow them to run anything untrusted. And the list of untrusted programs is very, very long.... @user3259496 Then don't give sudo access to the other users. Simple. Or else, figure out what commands are safe for them to run, and allow them _only_ those commands. @user3259496 It's on hold pending migration to Super User. Well, assuming the Super User mods want it migrated there. Also, Stack Exchange is not for opinions. Certainly what I stated is not opinions per se. They are actual observations based on my understanding of Unix's security model. And I don't think you're likely to find someone who has a different but still correct view of Unix security. @mbratch Isn't a macro seriously overkill? I was just thinking of something like `(setf (symbol-function '%) #'rem)` (there may be a better way to write the same thing; I'm a Schemer, not a CLer). Symbols can contain _any_ sequence of characters that would be valid in a string, and you can intern any string into a symbol by using `string->symbol`. However, the symbols you can write as bare tokens, without using pipe or backslash escaping, is a rather smaller subset. I'll add a Guile 1.8-compatible version, though, the Guile team no longer supports 1.x versions, in case you didn't already know. :-) Well, it also guarantees that if two threads both call `append` (or other synchronised `StringBuffer` methods) on the same instance, there will be a happens-before relationship. :-) @assylias With different classloaders, you're then talking about different classes (from the view of the JVM), so, it is still singleton---for a given class. @John Or rather, its ones' complement. @Lefteris No, the comparison against 0 is to see if the item is an exact match for a value in your `ArrayList` (as opposed to between two values). @Lefteris It will be non-negative for an exact match, and negative otherwise (such as when between two values). Then, you go up to the previous level, where I said _The word "D" isn't empty, so we will join "D" with the reverse of ""_, which as we've established, is "". Thus, the result of the previous level is "D" joined with "", which is "D". @bassim Updated answer, thanks! Or just use `call` instead of `apply`. In Unix, many utilities assume that text files end with a newline. If the last line doesn't end with one, it's considered an incomplete line. In your case, since you're using a colon as your line separator, your input needs to end with a colon. No, it's not negative infinity. It's an "indefinite" value, which is a special type of NaN (whereas an infinity is not a NaN). Read the article. I'd almost upvote you, but your indentation for the `if` is off. Standard indentation is to align the "then" and "else" at the same indentation as the test. I tend to use [Riastradh's Lisp Style Rules](http://mumble.net/~campbell/scheme/style.txt), though it's not CL-specific. But even the [first Google hit](http://dept-info.labri.u-bordeaux.fr/~idurand/enseignement/PFS/Common/Strandh-Tutorial/indentation.html) for "common lisp indentation" agrees with this. @Henrik Óscar's answer is right, of course, but you can (and should) do away with the `if` altogether, and just return `(and (proc item1) (proc item2))` directly. @jozefg Pretty much, assuming that that's the only place the continuation is used. R6RS internal definitions, like R7RS ones, use `letrec*`, not `letrec`. @espertus Because the Scheme language defined two different meanings to `define`, one for top-level bindings and one for, essentially, syntactic sugar for `letrec*`. That's Scheme for you. :-) That Java code is using encryption in a really gross way. :-( Usually, you don't ever want to pad with zeroes (like that code is doing) because you won't know the size of the original data (before padding). The standard way to pad is to use PKCS #5 padding. If you can arrange for the Java code to use that, your C# code will have a much easier time interoperating with that. @ChristopherJohnson I added a comment about calling `swEncrypt.Write((byte) 0)` a bunch of times. Hopefully you can work it out from there. :-) Based on your previous questions and this one, I feel that you're really struggling with an [XY problem](http://meta.stackexchange.com/q/66377/13). It's best if you can talk about what your desired end result is, rather than trying to muddle through the steps that you "think" you should be taking but are instead just a big distraction. That is, what is your overall project about, and what aspects of that project will your new proposed reader solve? (And don't say "so I can parse i+j+k"; that's not (or rather, had better not be) what your whole project is about!) You may like to read this article: [On adding quaternions to Scheme](http://www.ccs.neu.edu/home/dorai/squat/squat.html). (Granted, that's just the top hit when I searched for "scheme quaternion"; you may find joy with other hits too.) @ChristopherJohnson Try this: `for (int i = plainText.length % 16; i > 0 && i < 16; ++i) { swEncrypt.Write((byte) 0); }` (and take out the `if (plainText.Length < 16)` check, of course). @ChristopherJohnson Yes, it seems they're using ECB (ugh). ECB doesn't use an IV, so don't set one. (Clearly, whoever wrote the Java code doesn't know anything about how to write secure crypto code. See [my post](http://programmers.stackexchange.com/a/51528/5167) on the topic of "hand-written" crypto code.) I agree that the dialect in use is irrelevant for your specific question (except that Scheme macros are different, heh), but, fewer people object to CL code being tagged as "Lisp" than Clojure (or Scheme or Arc), just judging by the number of Clojure/Scheme posts on SO where the OP tagged with [tag:lisp] only to have it be untagged by (mainly) CL posters. This is why I converted your code to CL rather than, say, Scheme (which is my primary language, and at which I'm much more adept than CL). In any case, Common Lisp, Scheme, Clojure, and Arc are vastly different from each other (in the same way that C++, Perl, Java, JS, and PHP are vastly different, despite those languages having a C-style syntax (`for (...; ...; ...)`, curly-braces for blocks, etc.)), and it's probably best to label your code's language correctly. In particular, I would generally avoid labelling Scheme, Clojure, or Arc code as "Lisp". @CodeMaverick A fold starts out with an initial value (`'()` in this case), then updates that value with the given function (`cons` in this case) for each item in the list (from left-to-right in the case of a left fold). Since `cons` builds lists right-to-left, and since the input elements come from the incoming list left-to-right (due to the left fold), the resulting list is a reverse of the original. Similarly, you can copy a list by using a right-fold instead, which gets input elements from right-to-left. A better name for `reverse-helper` is [`append-reverse`](http://srfi.schemers.org/srfi-1/srfi-1.html#append-reverse), since that's what that function is called in SRFI 1, and it looks less like an artificial helper and more like a real function. :-) Show me your current code. I see. I just Googled and saw that elisp doesn't have `return-from`, so I edited my answer appropriately. No. `intermediate` has no parens around it. Also you need to hoist the whole `tailfact` expression within the `if` expression. What are you wanting to search for the  for, and why would you use a regex for that? Sounds like an XY problem. Step 0: if the element is the end of list, the length is 0. You're too late to the party. ;-) Please paste the code you used to try this allocation. Does your filesystem have ACL enabled? If so, you can add an ACL entry to explicitly grant access to your web server process user. @BryanChen I think the OP assumes that _all_ the `TreeNode`s will be needed until the program's exit (think short-lived program that just processes one XML document and quits), and whether there is harm in that case in just exiting the program without releasing the nodes. @user3352668 In that case, deleting those objects is optional. @BryanChen I agree it's "bad style", but sometimes, it is actually faster to let your OS deallocate everything en masse than to deallocate them one by one. Just try exiting Firefox after opening 350 tabs, vs simply killing the process. (Hint: one approach may cause lots of swapped-out pages to be paged back in, not very usefully.) :-) @user3352668 Obviously, my answer assumes we're running something very short-lived, and you don't have any "trash" objects during your run. If you do have trash objects, or if it's long-lived, then Paul McKenzie's answer applies. So in general, do free everything, but there are limited circumstances where freeing stuff is optional. @BryanChen Actually, I do have virtual appliances that I do "shut down" that way. Especially if the next thing I do is restore from snapshot. @BoristheSpider Yep, indeed. (And in fact even the cast will cause a compiler warning.) @BoristheSpider I've implemented your suggestions, thanks! Notice that your code doesn't implement the first two `cond` clauses (the base cases) correctly. Fix those first, then continue with the last clause. s/symbol/identifier/g Please see: [the syntax of definitions](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8.html#%_sec_5.2) and [what a variable is](http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-6.html#%_sec_3.1). The external form for an identifier is indeed a symbol, but in the actual code, an identifier and a symbol are very different things. In the same way, the external form for the expression `(+ 3 4)` is a list, but when running the code, obviously it doesn't evaluate to a list. As mentioned in my comment to keltar, please don't confuse symbol with identifier. `define` expects an identifier, not a symbol. For example, you cannot do `(define (string->symbol "foo") 'bar)`, or even `(define 'foo 'bar)` for that matter. To further reinforce my point that `define` wants an identifier and not a symbol, this is invalid: `(define (string->symbol "foo") 'bar)`. Heck, even `(define 'foo 'bar)` is invalid. @GoZoner See section 5.3 (page 25) in R7RS. It still uses ``. (I do agree that it actually does boil down to an ``, and section 7.1.6 (page 64) says the same thing.) +1 for saying that Intel syntax is "more readable". :-D In the second example, try `string const& test = string[0];` instead, and see if that still works. If so, the problem is (probably) with the type inferred for `strings[0]` in the first example. If it stops working, the problem is with finding a `back` method for `const` strings (which is odd, since [`back` has a `const` overload](http://en.cppreference.com/w/cpp/string/basic_string/back)). @Fabien The intent was to present a real use case for `cut`, which involved linking to real code that used it. It wasn't to provide documentation for people who didn't already know what `cut` was. A `letrec*` is not the same as a nested `letrec`. You can refer to later variables in a `letrec*` during the definition of an earlier variable (in the same `letrec*` expression), they just won't be bound at the time (whereas with `letrec`, they won't be bound at all until all the binding values have been evaluated). You can formulate the mutually-recursive `odd?` and `even?` functions using `letrec*`, but you can't do it using nested `letrec`s. @d11wtq How would your `let` allow the 10 to happen while still allowing recursive expressions to be defined in the same way? Remember that the outer `x` and inner `x` are different variables and point to different locations. @d11wtq I've added some tests that demonstrate the differences between the `let` types. You should decide which variant your `let` abides by. (Note: `#` means inner, but value not yet bound.) Notice also, that in all cases, "before" and "during x" have the same results and "between" and "during y" have the same results, but "after" and "body" have the same results only for `let*` and `letrec*`. Also, consider using the `multimap` gem. Then (assuming you use a `Multimap` instance for `@agencyList`) you'd use `@agencyList[domain] = match` to add an entry, in all cases. @d11wtq Okay, in that case, how would you implement `outer`? It sounds like its implementation would be gnarly. @d11wtq So effectively, it can only be implemented as a builtin special form (and not as a macro, for example). Deus ex machina and all that. :-) I agree with Óscar and John Clements about the XY problem. Why are you attempting to "evaluate list of commands, and handle undefined literals using [your] own procedure"? There is a very high probability that there is a better way to solve that problem (the answer to the why). Strings are part of the read syntax. Therefore, you can extend the reader (either by using a read macro, or a completely new reader) that will read raw strings, using whatever syntax you like. Your version is extremely inefficient. Cons-based lists are meant to be built right-to-left, using `cons` (which is an O(1) operation). Trying to build it left-to-right using `append` (which is O(n) for each call) is the wrong way to go. There are two ways to do this: you can use a left-fold and then reverse the result, which is what Sylwester's solution is. Or you can use a right-fold, which is what my solution is. Most CS courses try to teach students recursive algorithm using right-folding techniques, which is why my solution preferred that. I, too, used to prefer left-folding for everything, but I have come to learn that right-folding is right (har har) for some situations, such as if you have to reverse the result of the left-fold. Yes, tail recursion has advantages _if are no other costs_. In your case, `append` adds a huge cost that negates any advantage tail recursion might bring. Even the `reverse` in Sylwester's solution adds a cost, but it's a one-time cost, and nowhere as bad as calling `append` in a loop. Because hygiene. (I'll write a longer answer later, if someone doesn't beat me to it.) No, my solution is the `partition` directly, without the `let-values` or transformation to list. ;-) Besides, if you want to transform to list, it's probably more efficient to use `call-with-values` directly: `(call-with-values (lambda () (partition even? lst)) list)` @AsumuTakikawa Wow. That's head-explodey in the way that trying to read psyntax's implementation is. :-D @Metaxal If you used `plus` and `times`, it would totally negate the question. The OP seems to be wondering why the inner `+` didn't apply to the definition of the inner `*`. Olin Shivers argues, in SRFI 1's commentary, that using a heap-based "stack" in the name of making an algorithm tail-recursive isn't usually worth it. Read http://srfi.schemers.org/srfi-1/srfi-1-reference.scm, "A note on recursion and iteration/reversal". Excerpt: The natural and efficient way to code these algorithms is recursively. This trades off intermediate temporary list structure for intermediate temporary stack structure. In a stack-based system, this improves cache locality and lightens the load on the GC system. Don't stand on your head to iterate! Recurse, where natural. Well, you _would_ know your code better than I would. :-) (For my version, it really is as simple as swapping the `#f` with `#t`.) @Will See SRFI 31. P.S. All of those operators work with one argument too, and `+` and `*` also work with zero arguments. So the length check you have in your code may be overly restrictive. @Sylwester I suspect the OP had a case of the XY problem. It happens frustratingly often. Now could also be the ideal time to explain to the OP why `cond` is so much better than nested `if`s. :-P I am itching so much to change that into a `fold`, you have no idea. `(fold (lambda (e1 e2 r) (+ (square (- e1 e2)) r)) v1 v2)` or something similar (not tested). ;-) But I understand you were trying to preserve the OP's code as much as possible.... @lurker That's what I said in the bottom paragraph. :-) @lurker It's in the comment to Jerry Coffin's answer. :-) @user123378 Are you trying to find the _predecessor_ or the _successor_? Your question is about the predecessor. Finding the successor involves a totally different, but much easier, approach. @RobertGrant You need 50 rep to comment. Many new users without 50 rep try to respond using an answer. Personally, I think that the "requires 50 rep to comment" policy needs to be revisited. :-) @user123378 `(define succ (x l) (cadr (member x l)))` @user123378 I hate to say RTFM, but seriously: http://www.lispworks.com/documentation/HyperSpec/Body/f_mem_m.htm :-P @user123378 Sorry, I'm not going to do your homework for you. Professional Lispers use all the tools that their language gives them. You already have a huge leg up with the code I've already posted; make the most of it! I just noticed that your question is about Racket, not Scheme in general. Racket has immutable pairs by default, which means that you _cannot_ update a list in-place. Some Racket languages might let you use `set-car!`, but most won't. @Sylwester It's actually more similar to `mapl`, but returns an unspecified value. You should not have deleted your [original question](http://stackoverflow.com/q/23006630/13), if that were the actual problem you were trying to solve. Because now, you've turned this question into an [XY problem](http://meta.stackexchange.com/q/66377/13). (For non-10k users: the original question was about how to turn a list like `'(123 45 6)` into the number 123456.) Well, let's start with what your _end goal_ is. Is it to get the output of a C program? Or just the contents of a file? Or something else entirely? The _why_ makes a huge difference, and it's important to articulate in in the question. The original function is already currying. I'm not sure what your version is supposed to do differently. @nandom Okay, so it sounds like curiosity is your end goal. That's fine. The reason I ask for this is to prevent an [XY problem](http://meta.stackexchange.com/q/66377/13): if there's an actual problem you're trying to solve, it's best to know ahead of time what that is. :-) But as I said, curiosity is fine too. @user123378 Ewwwww! Do not use a list-reversal approach, that's the worst of all possible solutions. Why don't you implement your own `member` (it is trivial, I promise) and use that? @user123378 Yes, you can implement `member` yourself using only those primitives. It's really that simple. @user123378 I've implemented all the functions (predecessor, successor, and member) in Scheme, for you to learn concepts from, if you want to know how it's done "from first principles". You will have to translate them to Common Lisp to be able to use them in your homework, of course; I won't do that for you. I would actually argue that publicly-inheriting `std::vector` is a violation of the is-a rule (Liskov Substitution Principle), and you're better off using private inheritance. Then you wouldn't even be using a `std::vector*`, you'd be using `MyVector*`, and all your problems go away. You can write an OS in .NET (e.g., [Singularity](http://research.microsoft.com/en-us/projects/singularity/), [Renraku](https://github.com/daeken/RenrakuOS)), so at least some of the concepts should be transferrable to the JVM. It sounds like SISC parsed the number as inexact first, then converted it to exact "after the fact". :-( I think that's buggy behaviour, but technically (if I remember correctly), the standard allows this. Meh. That requires the OP to know how to read `syntax-rules` macros, which is not a skill they'd have if they're just doing 101-level coursework. :-P The error check you have is a _very_ bad idea: it's O(n) for each check, and you call it once every recursion, which means your function has a runtime complexity of O(n²). Remove it, and your answer is okay. Interesting to compare and contrast your approach to mine: you map once with a function that does the repeating, whereas I map multiple times with the original function. :-) Well, if you read the question more literally, the OP wanted to define `func`, and wanted to know if `double` had to be defined within. The answer, of course, is no, as both answers demonstrate. +1 for an actually legit use of `cute`, and for using libraries. :-D (I would +10, but SO doesn't permit that.) Subclass instances contain a whole copy of the superclass instance. So if you can subclass a singleton, that means there would be two instances of the superclass. That, by definition, is not singleton. @juanchopanza I'm assuming the OP wanted to make the subclass a singleton too; then there would be two instances of the superclass. If the subclass isn't singleton, then there could be many instances, instead. :-P @juanchopanza The first instance is of the base class itself (that's what "singleton" means: you instantiate it once, and once only). If you were able to subclass it, the second instance of the base class lives inside the subclass instance. @MadScienceDreams In your example, then, `Ford` is the singleton, not `Car`. If `Car` were singleton, then you cannot have both an instantiation of `Car` and `Ford` and still call `Car` singleton. @MadScienceDreams I think we have different ideas about what a singleton class is. If you make a `Car` a singleton, that means you pre-create the one exclusive instance of `Car`. (This is also what I'm alluding to in my answer to juanchopanza.) @MadScienceDreams How are you going to enforce a singleton policy from `create_car_from_config`? It seems whatever mechanism it uses, can be reused elsewhere to create singleton-violating instances. (Just to be clear: when I say singleton classes, I don't mean classes that your program chooses to instantiate only once, but classes that are technically restricted from having a second instance being created.) Thanks for providing decorators as an inspiration for redefining `define`. With my `define`, you can simply use `(define (@ memoize) (fib n) ...)` and it will be memoised for you. :-D @Poody Your `slambda` macro doesn't correctly handle more than one body form, which is the problem you're running into. @Poody You need to make your macro take multiple arguments for the body. Though, I still believe that `define-macro` is the wrong way to solve this. If you're using Racket, you can just use my answer. If you're using a different implementation, you'd be better off just using [`rec`](http://srfi.schemers.org/srfi-31/srfi-31.html). @Poody Then just use `rec`, and forget about trying to write an anaphoric macro (and forget about my answer). Your brain will thank you for your assistance in stopping its pain. :-) Trust me, `rec` is the standard way to write a self-referencing procedure. @Sylwester I agree with the use of named `let`, because it expands to `rec` anyway. :-) I wrote a blog post about this: http://dyscour.se/post/58639636506/named-let @Poody Further to Sylwester's recommendation for named `let` (which I agree is potentially a good way to solve your problem), here's an example of the correspondence between named `let` and `rec`: http://stackoverflow.com/a/22870415/13 @Poody Try to figure out what your expanded code should look like. When people ask questions about writing macros, I always ask them what their "before and after" is. :-) The general concept in Scheme is that: 1. redefinitions affect your current module only, and are not global (though you can export your redefinitions for other modules to import), and thus 2. there is no need for reserved words, and everything can be redefined. Being able to augment built-in functionality is certainly a nice feature, but not the reason per se for being able to redefine `define`, `if`, etc., but simply a result of nothing being reserved, because nothing needs to be reserved. @Sylwester I don't know about Poody's macro, but my macro does return the outer function. Why? Because the inner one is not bound or returned anywhere, so it's thrown away. Try this (tested on Racket 6.0): `(let ((foo (slambda () (slambda () self) self))) (eq? foo ((((((foo))))))))` @Seeker Do you know Python or Ruby, and their "splatting" operator? (`foo(bar, *baz)`) `apply` is the Scheme version of the same concept. `list-ref` and `list-tail`? Not sure how one might use these to solve this particular problem. I guess I didn't understand what you meant by "compress". :-) What is this, a software implementation of [Bohnanza](http://en.wikipedia.org/wiki/Bohnanza)? :-P Why stop at `fold`? You can use `string-fold` from SRFI 13, and skip the `string->list` steps. ;-) @Sylwester Quick, file a bug report! (Seriously though, I can understand why having more than one string is troublesome, because of the need to also be able to optionally supply start/end parameters. Still, bummer.) @WillNess Thanks for your support! I thought the snippet was pretty self-explanatory, but I'll explain it here. Each queue item is a cons cell, of which the `car` is what to prepend, and the `cdr` is the remaining items to iterate through. (You'll notice that my `(cons (car x) item)` suggests that it's not being prepended, but notice the `reverse` at the end.) I'd suggest factoring out the `(+ (* y 8) x)` into a `board-index` function. Also learn how to use `ArrayList.add()`, and `for` loops. :-) `Math` is _not_ in `java.util`. Also, the use of `ArrayList` is wrong: it should be `List`. Thus: `List nums = new ArrayList();`. Also, it's wrong to manually call `input.close()` like that, since it's not exception-safe. The standard way to do it is to use `try (Scanner input = ...) { ... }`. @manan s/integer/double/ You may have "always" used `ArrayList list = new ArrayList();` but it's still not best practice. Use interface types like `List` when possible. The use of `new ArrayList()` is also correct for Java 7 and means you don't have to duplicate the `Integer`. Also, your `\@$HSPs` is decidedly wrong. Just use `$HSPs`. "Better methods" are bcrypt and scrypt. SHA-512 or SHA-3 are _not_ "better methods" as far as password hashing goes. But anyway, the answer to your question is "yes, of course". Well, that wholly depends on how you define "simple cleartext values", but, if you can enumerate all such values, you can easily build a table of which MD5 values those all correspond to. Crossing the JNI boundary is expensive. You should try to minimise the number of JNI calls, by aggregating the functionality on the Java side, and the functionality on your native-code side, so you don't have to travel back and forth quite so frequently. Write a wrapper facade, on the C++ side, that encapsulates as much of the C++-side operations as possible. You may also need to write a wrapper facade for the Java-side code, too. The general idea is to minimise the number of crossovers to the greatest degree possible. I don't know of any such options (but then, I haven't looked very hard). Technically, that's wrong too, but if your first directory is the current directory, you could get away with it. Yes, that's right. SISC also supports `syntax-case` (and in fact, like pretty much every implementation with `syntax-case`, its `define-macro` is defined using `syntax-case`), so it's far more preferable to formulate procedural macros using `syntax-case`. In fact, pretty much _any_ system is better than `define-macro`. It is more verbose in this case, yes. :-) (There are other cases where `syntax-case` macros are more concise, especially when dealing with complex destructuring.) I did edit your post to use the standard reader abbreviation for `syntax` (for implementations that have `quasisyntax`, `unsyntax`, and `unsyntax-splicing`, such as Racket, there are also similar abbreviations for those). If DNSSEC is being used, then the next step is to use QUANTUMINSERT. :-D If the target server isn't being accessed via TLS, then altering the traffic is easy. If it _is_ using TLS, then unless the program uses certificate pinning, it's easy to use a compromised certificate authority to allow you to spoof the server anyway. ;-) @Denis Yes, really `+@`, which is the unary `+` operator. Try running this: `+nil`. @EdHeal It's C++/CLI, as delnan said (I've edited the post accordingly). @LaszloPapp No, `^` is a C++/CLI managed reference. @LaszloPapp C++/CLI could perhaps be described as "C++ for .NET", but yes, I can understand why it could be seen as a typo if you've never seen C++/CLI before. @user3578572 It's only self-explanatory if you've seen C++/CLI before and the reader knows you're using it. It's not correct C++. @PillPilon What empty lambda? I don't see an empty lambda. Try running `ldd /usr/local/bin/mzscheme`, and see if you have any missing dependencies. @vinit `mzscheme` _is_ a dynamic executable. If it says that message, it probably means your EC2 instance is 32-bit and you're trying to run a 64-bit Racket. Try downloading a 32-bit version and try again. Looks good to me. By the way, numbers are self-evaluating and do not need to be quoted. @Sylwester Each invocation of `lambda` generates a new location tag, rather than, as you say, lexical place in source. :-) This is analogous to each invocation of `list` generating a fresh list. Should be `$JAVA_HOME/jre/lib/security`, not `$JAVA_HOME/lib/security`. Also, the return value isn't used correctly; 0 means equal comparison (assuming `strcmp` instead of `strcpy` of course). @Marek No, it delegates to `Array#all?`. The version on the website still has the extraneous `synchronized`. :-( @user1680222 Yes. Probably even better to use `each_char` instead of `chars` because `all?` is an `Enumerable` method, but, excellent answer! Are you using this just to practise recursion? Because the better (and more standard) way to do what you're doing is simply `(for-each display lst)`. No, if you don't have CI, then it's your job to set one up, if you care about things continuing to work. I'm just saying that beyond GitHub-integrated CIs, GitHub has no specific workflows to test your code for you. If you want to ask contributors to test code first, that's up to you, but it may result in far fewer pull requests arriving your way.... Also, read up on how to generate a [power set](http://en.wikipedia.org/wiki/Power_set). In your case, since your array has 5 elements, you'll be making 32 trials (2**5) to decide whether the sum is 15. (Oh wait, I didn't see the part about selecting exactly 3 of the 5 elements. Oh well, you'll just have to filter down the results some.) `assoc` doesn't raise an error if the key isn't found, it returns `#f`. Also, for `hash-ref`, you can pass in a procedure that is called if the key isn't found; it's just that the default procedure raises an error. `(and pair (cdr pair))`, or else use `(cond ((assoc ...) => cdr) ...)`. :-D Great! Also, since the OP is using `eq?`, you can feasibly use `assq` and `make-hasheq` (assuming Racket's hash interface). And now, I have all the justification to do it! http://meta.stackoverflow.com/q/252503/13 But, why would you implement `string->number` by hand, when it's built-in to Scheme? Of course. In fact I usually use `lst` as the variable name, and I had to fight my motor memory to write `list` here. ;-) @GoZoner For learning, perhaps. But shadowing is often detrimental to code maintainability. The left and right folding thing, for mapping, is a heap-stack tradeoff: for left folds, you're keeping a temporary list to reverse at the end, or you're generating a temporary reversed list to fold over. Olin Shivers, author of SRFI 1, argues that in such cases, preferring the stack (i.e., right fold) is a better tradeoff, because of data locality (stack frames are generally kept together, whereas cons cells can be all over the show) and ease of memory reclamation. You already know all that, of course, but the OP may find that useful. My comment re heap/stack, of course, assumes a traditional calling mechanism; for implementations that use CPS for everything, well, everything's likely going to be heap-based anyway. :-) The product of 1, 2, 3, 6 is not 12, it's 36. @user1915570 Then just use `foldr`. If you insist on using `foldl`, you're going to have to use `reverse`, or else implement `reverse` yourself by hand. Questions like this make me want to make a Lisp implementation where gensyms are UUIDs. ;-) That's fine, but eventually you'll get to a place where you'll want to use the "pro" method, and then you can come back to this answer. :-) There is such a thing as a "normal" dot symbol, and in R7RS, you write it using `|.|`. However, that's completely different from the dot you're talking about here. :-) For the OP's benefit, I mean: `'(a . b)` is a single cons cell, with symbol `a` as its car, and symbol `b` as its cdr. `'(a |.| b)` is a proper list with 3 elements (i.e., 3 cons cells), the symbols `a`, `.`, and `b`. @user3624683 Preprocessor identifiers are ones that are processed by the [C preprocessor](http://en.wikipedia.org/wiki/C_preprocessor) program, usually known as `cpp`; generally, that's anything created using `#define` (or via the `-D` option to your compiler), though there are some builtin preprocessor identifiers like `__cplusplus`. Any identifiers that aren't processed by the preprocessor are, by definition, non-preprocessor identifiers. Most variable and function names are non-preprocessor identifiers. @EngineerDollery What alternative to `StringBuilder` do you suggest? The OP wants to collect all the input up to a given string. @LuiggiMendoza Well, of course I agree with _that_. But you still need to collect the return value via a `StringBuilder`. The SISC implementation does not include the SRFI 45 fix, alas. (I just checked.) There's no reason why SRFI 41 can't be used with SISC to my knowledge, but it's been orphaned since February 2007, before SRFI 41 existed. @Sylwester `sqr`, not `sqrt`. +1 for bringing up the elephant in the room. @ManuHegde Hey, at least it's unlikely that you're a bot, then. Which was what the question was supposed to guard against. ;-) The OP already has an IOStreams stream; presumably they're trying to interoperate with a C API that uses stdio. Suppose we changed your query to say `LEFT JOIN stats ON login.user = stats.user LEFT JOIN poll ON login.user = poll.user LEFT JOIN announce ON login.user = announce.source`. What that means is that your `login` rows will all be there, regardless of whether a corresponding row exists in `stats`, `poll`, or `announce`. Does that sound like what you want to do? @QuentinPradet Obviously, for a fixed string like "FooBar", `-name` or `-path` work just fine. The OP has specified the use of `grep`, presumably because they want to filter the list using regular expressions. The standard way to write a loop is to use a named `let`, just like I did in the second snippet. Also, Google for "named let loop" for more examples. There's a bug in my `sum-of-divisors` that computes the wrong value for 0 and 1. That's been fixed in my updated answer. I also added an `amicable-pairs-between` function, that doesn't use `set!`, but uses a named `let` loop instead. Also, for running a sequence of side-effecting expressions, use `begin`, not `and` (which in your case only happened to work because `display` returns a truthy value). In any case, instead of `(if foo (begin bar baz) #f)` (for cases where you only care about the side effects), it's better to use `(when foo bar baz)`. Thus, use: `(when (and (= i (sum-of-divisors a)) (< i a)) (display i) (display " and ") (display a) (newline))`. I added a recursive version to my answer. Enjoy! Please split this into two separate questions. Otherwise if one person answers your first question and someone else answers the second, whose answer will you accept? +1 for a hardcore answer. :-) Sure, just use `(jsexpr->string x)` for the example above. What kind of data do you want to create JSON of? I want to create a useful example. Okay, here we go, added how to create JSON from a structure type. Enjoy! @AsumuTakikawa Thanks! I don't currently see any examples in the `json` module documentation, where would these go? You realise that `map`, `filter`, and `foldr` does the looping (or recursion) for you behind the scenes, right? That's how you do it without (manual) recursion. Here's a hint on how you might solve this. First, implement [`bagify`](http://stackoverflow.com/a/5741004/13) in some way. Then swap the order of each of the elements (since `bagify` puts the item first and the count second), then sort the elements. @wberry I've decided to find a way to quote that code snippet that's hopefully more "fair use"-compliant. Use [HTML Tidy](http://tidy.sourceforge.net/) to post-process your XML output. The home button is easy. That just launches the launcher, and you can write a custom launcher that pops up the password prompt. ;-) @William Well, no, you want to only `exec` in the child process only. The parent process should `wait`. If you just call `fork` without checking the return value, you'll be `exec`ing from both places. ;-) @user2864740 I would prefer to say pointer, since that's what references in Java are, but that seems to be a four-lettered word in the Java world. ;-) Eh, I'll just nuke my answer. It's clearly already well-answered elsewhere. :-D @Christian Java has a specific meaning for "reference", which is basically a pointer to an object instance. What user2864740 means is that references are themselves rvalues, whereas variables are lvalues that (if of the correct type) can hold rvalue references. In comparison, C++ has real pass-by-reference, and references in C++ are lvalues. @user102008 That would make the diagram so complicated, because symbols and `()` are interned, and instead of all those black boxes in my diagram, I'd have to turn them all into arrows that point to a single `()`. ;-) Conceptually, of course, it's valid for beginners to think of Scheme values that way (though eventually they encounter tricky questions about why `(eq? 1000 1000)` is true but `(eq? 1000000000000 1000000000000)` is false in many implementations ;-)). That creates a new list, it doesn't mutate the existing list. It's probably better that way, but it's still important to be aware of the distinction. ...if you're using awk, surely you should be handling the sorting and uniqing from there too! @JonathonReinhart Thankfully, I find Perl easier to remember than awk (see my answer). Then again, I haven't done any serious coding with awk, so. @hawk That won't get you the occurrence count. @jaypal Yes, I knew about `-n` and `END`, and I almost used that. I should probably put that in my answer. In recent years I've been using Ruby more, where `END` is seldom-used, so I've gotten out of the habit of using it in Perl, also. @jaypal Implemented, thanks! @jaypal Thanks! I did [hit 100k for real today](https://plus.google.com/104178729694994695707/posts/cDbKRT2s89H), so thanks for the congrats. :-D @ÓscarLópez `when` and `unless` are standard as of R6RS and R7RS. @GoloRoden The code won't do the wrong thing if you used `mapcar`, but people who look at your code will scratch their head and wonder why you didn't use `mapc` instead, if the return value is not used. (In Scheme, the situation is a little different: `for-each` (Scheme analogue to `mapc`) calls your function on list elements left-to-right, whereas `map` (Scheme analogue to `mapcar`) does not specify an order (many implementations actually use right-to-left), so you should only use `map` for pure functions.) CLHS `push` reference: http://www.lispworks.com/documentation/HyperSpec/Body/m_push.htm In this specific instance (and _only_ in this specific instance), where you're setting `MAXIMIZED_BOTH`, you can safely clear out the other bits, because the only other bit there is is `ICONIFIED`, and it doesn't make sense to set that alongsite `MAXIMIZED_BOTH`. But, if, say, you're actually trying to set `MAXIMIZED_HORIZ`, and `MAXIMIZED_VERT` is already set, then your approach will inadvertently clear `MAXIMIZED_VERT`, perhaps to the user's surprise. 6 years ago, I wrote a pure-Scheme implementation of MD5. Since SHA256 is also a [Merkle-Damgard hashing function](http://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction) like MD5, much of the same techniques will apply. I don't want to post 6-year-old code, but I can probably write one from scratch relatively quickly. @Vatine I only have SBCL to test, and in SBCL, `(symbol-value (intern "FOO" "KEYWORD"))` already has the correct value. Besides, Alexandria implements it using the same approach also. It appears that your Sublime Text was set up to use Gambit as the implementation. Do you have Gambit installed? If you're using a different Scheme implementation, the command will have to be different. Just use [`tac`](http://www.gnu.org/software/coreutils/manual/html_node/tac-invocation.html). :-) @AldiUnanto Why would you want to do such a thing? You don't ever want to mix the two up. @AldiUnanto Maintainable coding is not [golfing](http://codegolf.stackexchange.com/). :-) You really should not mix the two up if you want your code to stay maintainable. But if you really insist, there are some monkey-patching tricks you can use. You didn't hear this from me. When you have an aspect ratio that sits between two possible desired ratios, and you want to figure out which one is closer, using the log means you can compare against the arithmetic mean of those two log ratios, rather than the geometric mean of the non-log ratios. But really, either way is fine. Yep, that's right. @L33T Read the link. But anyway, a warmup phase means that you throw out the result of the first runs, and only count the times from runs subsequent to that. This is to get caches loaded, etc. @san What does your writer thread do after it's finished writing? Does it just return? If so, that's sufficient. Daemon threads are usually for things that run in a loop and don't exit on their own. @san If it falls off the bottom of the thread function, it returns implicitly. It returns `None` in that case, but it doesn't matter, the return value isn't used. @JoshuaTaylor Exactly. See my implementation of the `Cons` class, which does implement the dotted notation. Sure, `&:to_s` is a shorthand for `{ |x| x.to_s }`, and similarly `&:inspect` is a shorthand for `{ |x| x.inspect }` (see [`Symbol#to_proc`](http://www.ruby-doc.org/core-2.1.2/Symbol.html#method-i-to_proc) for more details). These blocks get invoked by the `yield`s inside the `print` method. The reason I did this was that I wanted to implement both `to_s` and `inspect` without tons of duplicate code. If we passed in `&:to_s`, then `yield(car)` is the same as `car.to_s`, and `yield(cdr)` is the same as `cdr.to_s`. Likewise, if we passed in `&:inspect`, then we get `car.inspect` and `cdr.inspect`. Lisp macros works on S-expressions, which I suppose could look like parse trees to non-Lispers, but still. I mention this distinction because in pretty much any Lisp dialect, the reading phase comes before the compilation phase, and so Lispers see code _as_ data when writing macros. Yay homoiconicity! (You clearly know all of this since [common-lisp] is a top tag for you, but I feel other readers here should understand the difference too.) It's more proper to call it a "dot" rather than a "period". Cons cells are sometimes called "dotted pairs". If it's real code, what are you really trying to do? This looks like an [XY problem](http://meta.stackexchange.com/q/66377/13). I looked at your edit. Your question is still way too abstract. What real problem is your code trying to solve? @dfeuer Not for the purposes of deriving the SHA-2 initialisation values. Most implementations use IEEE-754 doubles, which have only 53 bits of significand, not nearly enough for the 64-bit values used in the constants. I basically convert the doubles to rationals, then use Newton-Raphson to get the extra precision necessary. @JoshuaTaylor That, and `reset-count` was simply an unspecified value (being the return value of `set!`, and thus not resetting the count at all ;-)). (Oh, I noticed your answer covered that. Have a +1.) (Of course, I agree with your comment; I wanted the OP to do a diff between their version and mine and figure out where the differences were.) Also duplicate of http://stackoverflow.com/q/850878/13 Also, as I highlighted in my answer, use `equals()` to compare strings, don't use `==` (unless you are sure that all the strings being compared are interned---which is _not_ the case the vast majority of the time). @BrianGoetz +1 Totally that, and nice to see a comment from the spec lead of JSR 335 himself. :-D On which note, maybe you'd know the answer to [this question](http://stackoverflow.com/q/17203781/13)? :-) Googling for "com import wchar_t" gave me this useful thread: https://groups.google.com/forum/#!topic/microsoft.public.vc.language/wUYXDasgjow @zerkms I personally wouldn't test for `list[i] in hash` (and just insert into hash unconditionally), but, yes, for this small data set, even removing that test, the hash approach is still 75% slower than the indexOf approach. Fair enough. @zerkms Since this thread has gotten so long, I'm going to trim my comments off soon. BTW, I just noticed that you're also a 100k+ Kiwi! (Okay, maybe Kiwi is too strong of a word, reading your CV. But at least you live in New Zealand.) Well met, and I concede your point that there's a time and place to use linear searching. @Ian Of course, for 2000 elements, hashes are better (and the more elements there are, the better hashes will scale). Nobody is disputing that. The discussion that zerkms and I were having was whether the `indexOf` solution is slow for the small array that the OP is working with. Try this: `findCmd=$(eval "$CMD")` @EuroMicelli One other point of difference: null BSTRs are supposed to be treated as empty strings, but if you pass null to the wchar_t* functions, boom. (First-hand experience with MSXML 10 years ago.) @EuroMicelli (I'm not just talking about property names, but also things like setting the value of a text node, or the value of an attribute, where an empty value is semantically valid.) @GregHendershott Yes, but it's a much more restricted form than what pthreads provides, which is what the OP is asking for (whether they really need it, is another story; XY problem and all). @GregHendershott Indeed. Other than shared vectors, though, you generally cannot send mutable objects over. (You can send strings, vectors, and hash tables, but they will be converted to an immutable version at the other end.) This is distinctly different from Java-style memory sharing, which is what Racket doesn't support (for good reasons, in my opinion, since it can be dangerous). I sense an XY problem here. Your bucket can either be a linked list of nodes, in which case an empty bucket is simply denoted by a null link, or else it's an array of nodes, in which case it has length 0. Also, you did not state which programming language you're using. What happens if you have bucket collision? You need for each bucket to be able to hold multiple entries. You need to install the `-devel` package, not just the runtime package. Also see: http://www.bellard.org/pi/ @SotiriosDelimanolis That information is not visible to non-moderators. @SotiriosDelimanolis What the OP means is that they aren't able to post any new questions subsequent to this one, because they've become question-banned. I can believe that. @user3781061 Ouch, I see you have a couple of negatively-scored questions, plus a zero-scored one here, and more importantly, no positively-scored ones. This is indeed bad news for your ability to continue posting on this site. (Note that I can't see any deleted questions you may have, but those will penalise you too. So the picture may be even worse than I can see.) @user3781061 It is very, very important that most of your questions have a positive score, if you want to avoid being question-banned. I've written some about this topic here: https://www.quora.com/How-do-I-avoid-getting-Sorry-we-are-no-longer-accepting-questions-from-this-account-on-StackOverflow/answer/Chris-Jester-Young @quantdev That is certainly a plausible interpretation so I upvoted your answer. Installing vlc will only bring in runtime deps, not build-time deps. Sorry. Consider two random variables, `a` and `b`. The difference between your two scenarios is between: 1. `a * b`, where `a` and `b` are (theoretically) independent (the `random() * random()` case), and 2. `a * b`, where `a = b`, and thus very much _not_ independent (the `pow(random(), 2)` case). The distributions of `a * b` would thus be very different, depending on whether `a` and `b` are independent. If you want something "nicer", you're going to have to provide two versions (named differently; can't be overloads) of your method, one that takes varargs and one that takes the array directly. Yes, that's why I said "named differently". :-D @BigMike Those cases are actually part of the heap, too. :-) I'm sure people want _a_ canonical question, just not _your_ canonical question. :-P (I'm not one of the downvoters.) @DavidWallace The intent of a "canonical" question is to make all the other similar question marked duplicate of the canonical one. Again, though, my comment is, why pick this one over any of the others? @MehmetM.Inanc No, the JVM doesn't only refer to HotSpot. Excessive recursion causes `StackOverflowError`, not `OutOfMemoryError`. @DavidWallace It can, if you make all the other duplicates point to this one. (I am not actually endorsing _this_ question to be a canonical question, just endorsing the canonical question concept.) Because on other platforms, `LONGLONG` is actually defined as `__int64` and `ULONGLONG` is defined as `unsigned __int64`. So source code can just use `LONGLONG` and `ULONGLONG` and get the expected behaviour regardless of the platform in use. As mentioned in my answer, in Java 7+, the OP's comparator is likely to break (it uses timsort rather than mergesort). Java 6 and below is somewhat more tolerant of broken comparators. I know this from first-hand experience when doing our Java 7 migration project; our broken comparators were discovered very quickly when tests started becoming red. :-) Then, like JB Nizet's answer says, it only works by accident. Don't make your program fragile! Write a proper comparator. Your second method broke rule 2. +1 for "absurdity". :-D @Anand Then your code will flunk the interview for violating a basic comparator rule. @Anand For the purposes of determining distinctness, a `TreeMap` will _only_ consider what the comparator returns, and when it returns 0, the elements are considered equivalent. It does not call `equals` on the keys. The best way to edit an S-expression programmatically is to treat it as a data structure (by `read`ing it in), updating it, then writing it back out (using `write`), rather than treating it as a string of text. @Deduplicator As the post says, function pointers are never going to be null. It's probably more readable to use `==` instead of `^ !`. @Deduplicator Oh! I misread your comment. Of course it's always false. Hahaha. @Rapptz Thanks, edited. Note, you can (and should) just use `wrappedObject` instead of `wrappedObject.toString()`. The default `toString` does not use the object's memory address (which is moveable, by the way, and thus inaccessible to Java code); it uses the object's hash code. I totally understand. At my work, we had a case where our third-party library expected a callback in the form of a global variable, which I had to get and set via JNA. I will try to adapt our work code to your case. I may have to do some testing first, so bear with me. @David Please read the question all the way to the bottom. The OP has already said they don't consider the "wrapper callback" approach to be okay. Also, that was also the solution approach for the initial iteration of my answer, and the OP explicitly commented that they wanted something different. @David It doesn't "need" to be done that way, it's just the cleanest way to do it. The type-punning solution I posted is ugly, but it actually works. (I use something similar but even uglier in production code.) @DavidHeffernan At a fundamental level (i.e., if you look beyond JNA), callbacks _are_ pointers. At the JNA level, of course they're not the same, since `Callback` has a `this` pointer and `Pointer` (and more specifically, `Function`) does not. However, with the marshal/unmarshal approach that my post uses, JNA creates a proxy object for the `Callback` that makes it delegate correctly. @DavidHeffernan Demonstration of callback proxy in action: http://i.stack.imgur.com/cVtoT.png @DavidHeffernan (and the OP too): I've put together a fun little program for testing out callbacks, both Java-side ones as well as type-punned C-side ones: https://gist.github.com/cky/7397db4908fa9616539b Sure thing. Like I said, I've had to do something like this for work code, so the whole subject is by no means new to me. And back then, I had to spend a _lot_ of time studying the JNA source to figure out how to get it going in the first place, so I'm only too happy to share the technique with others. :-D No, you can't do it with just one command, at least not with the tunnelling method. JS doesn't do integer division, so you must round the number in some way. @Cerbrus Yes, in Chrome's console, in fact my testing was why my answer was not the first one. :-) Almost good edit. You are still missing the edge case between `<` vs `<=`. @Karl-AndréGagnon Good catch!! Assuming it's intentional, I'll have to edit my post a bit. @Cerbrus There is still a point: I can retract my downvote. :-) Yeah, people are strange that way. :-P @AndrewG Here's the [Wikipedia article](http://en.wikipedia.org/wiki/Asynchronous_I/O) on it. If you'd like me to explain something there, I can try. Why would formatting the PC affect anything? You can always generate a new key and use that to push to GitHub. bcrypt is not an encryption algorithm, it's a one-way password hashing algorithm. If you "encrypt" your data with bcrypt, you will never be able to get the original data back. In any case, tying the data's encryption to the user's password in any way is a bad idea, unless you don't plan to provide any sort of password reset. The kill-with-no-exceptions signal is called `SIGKILL`, not `-9`. This still assumes a synchronous I/O model. As my answer points out, there are ways to download multiple files simultaneously using only a single thread. Test with a case where `c` is the smallest number. @Sylwester The OP talks about using `compose`, so clearly they'd be prepared to define it themself. Spliterator, not SplitIterator. :-) @user432495 There isn't. But your post already talked about defining your own, `(define (compose f g) (lambda (x) (f (g x))))`. \*shrug\* @Rptx It's probably a cut-and-paste of a homework problem. The definitions to `factorial` and `two-to-the` are actually (facetious) answers I wrote for a [previous question](http://stackoverflow.com/q/24618860/13) from the OP. (You need 10k rep to see deleted posts. [Screenshot here.](http://i.stack.imgur.com/qSTGt.png)) @Zeus In this specific case, my question was actually intended to be a "fun" micro-optimisation question (which, these days, would probably be a better fit for [Programming Puzzles & Code Golf](http://codegolf.stackexchange.com/)), but the general premise of "fastest way to calculate pi" seemed to be useful enough to keep this question here. So, at some stage, I will probably reevaluate whether I should just accept the best algorithmic answer (probably nlucaroni's one), without regard to whether it's related to micro-optimisation. @HopelessN00b In the dialect of English I speak, "optimisation" is [spelt](http://en.wiktionary.org/wiki/spelt#Verb) with an "s", not a "z" (which is pronounced as "zed", BTW, not "zee" ;-)). (This is not the first time I've had to revert this sort of edit, too, if you look at the review history.) Object monitors do not allow you to see which thread (if any) owns a lock. `ReentrantLock` does have a `getOwner` method you can call. If you want to tell which threads are blocked, you can run `jstack`. This does not run inside of your Java program, though; it's an external process. @ShashankAgarwal It'd only be 71 if + has higher precendence than -, and/or if + and - are right-associative. Neither of those conditions are true, so you wouldn't get 71. @ShashankAgarwal * and / have higher precedence than + and -, but * and / are same, and + and - are same. Since this is a language-agnostic question, I'll bite: whether it's a common idiom or not depends on language. In C++, using `!=` is a much more common idiom, because C++ uses a concept of iterators, where for many iterator classes, the `<` operator isn't defined. (For such iterators, only `++` is defined, not `+=`, so the "skip too many elements" argument mentioned in the other answers doesn't apply.) @ooga Updated the post with corrected information now. The "use header files" is pretty much the same conclusion as my answer, but unless the OP knows how to avoid using `static` and to make the declaration in the right namespace in the header file, it still won't help them. :-) Also, standard C++ idiom is to catch by reference, not by value. That way you don't get object slicing, potential allocation errors, etc. +1 for catch-by-reference. :-D There's also `update-java-alternatives`, provided by the `java-common` package. But all this assumes the OP is using a Debian-derived distro (such as Ubuntu), which is not stated in the question. Not all computers have a serial number that is accessible via the SMBIOS, especially older ones. `syntax-rules` has been standard since R5RS, and it's expected to stay standardised "forever". I would consider any Scheme that lacks `syntax-rules` support to be broken. In other words, I don't consider `syntax-rules` to "differ by interpreter". If we're talking about Racket, go straight for `define-syntax-rule` in this case. :-) @AndrewCone Can you explain what you're actually trying to do, in real, non-hypothetical, non-redacted terms? Actual code where it is to be used, with actual context. I'm not trolling, I simply believe you have an [XY problem](http://meta.stackexchange.com/q/66377/13). It is the responsibility of answerers to rat out XY problems early, to help find the best solution approach. Why do I believe you have XY problem? Because you started mentioning monkey patching with `class_eval`, when you didn't state this in the original question. This is _relevant_ information (and you are still withholding information on where and how your monkey patching is being used), and it is counterproductive to hide it. @AndrewCone Thanks for the update. I've updated my answer in a way that hopefully matches better what you're trying to do. The precision can be variable, BTW. Try this: `sprintf('%.*f', 5, Math::PI)` @AHmad Do you have an example of what you're talking about? Use `"(\\d+)\\s*\\.\\s*(\\d+)"` as the regular expression. @ben It's a binary predicate, of which `` are two. The intent, BTW, is to pass those directly, not a wrapping function like `my-less`. @DavidUnric It's not unrelated at all. I'm simply answering the actual question the OP has, after the additional information from the OP. Read the last update on the question, re what the OP is actually doing. I'm not averse to restoring the original content below the current content, if that alleviates your "worry". You can manually print out your own XML declaration, then print a newline directly, then the document that's generated with `OMIT_XML_DECLARATION`. :-) As Arup's answer says, you _are_ getting the grouping in pairs already, but `puts` will print the array elements on separate lines. Try `puts a` and see what you get. The Guava Multiset approach is faster (and more semantically descriptive), so prefer that if you can use Guava. (Internally, it uses an internal `Count` class as the map value type, which is like a mutable `Integer`.) Even faster is to use `lower_bound` instead of `find`, then if the result is the same as `end()` or the key is not the same as `i`, then do a hinted insertion. :-) Thus: `auto f(map.find(i)); if (f == map.end() || f->first != i) m.insert(f, std::make_pair(...)); else ...` Of course not. At least, not with a standard JSON serialiser. Thanks! No, I don't intend to post my own answer. :-) @UriAgassi What about the case where you're opening a class's eigenclass in a different file from where the class was defined? (e.g., monkey-patching a built-in class.) You don't get to escape naming the class in that case, so is there a benefit to still using `class Object; class << self` vs `class << Object`? @Nemo OP said that isn't an option: "(Additional note: I was required to keep the constructor within the class body.)" @Alf: Of course I agree the lengths should be checked first, but then in that case, we're not dealing with "C" strings any more. Comparisons should then use `memcmp`. @cookiemonster Indeed, it isn't _always_ the right answer, but it should be the default stance. @LokiKira No, `(cons '() '())` creates a list with one item, an empty list. @LokiKira `(list '() '())` "Strings of the form `:)`, `:-)`, etc." are _emoticons_, not _emoji_. Emoji are special characters in a [specially-designated code point range](http://www.unicode.org/faq/emoji_dingbats.html). JS strings may be UTF-16, but is there anything that says that the _regex engine_ works on that basis, as opposing to matching on actual code points? @KevinL The JVM can JIT-compile the bytecode into native assembly, depending on how frequently the section of code in question is being run. The JITting is more aggressive for `-server` VMs (compared to `-client`). It is much better to use `andmap` or the like instead of an imperative loop. IMHO. This question is about Scheme, not C#. I understand that your answer is language-agnostic but the correct solution approach for Scheme is nothing like the C# snippet you posted. Indeed, even the logic is totally different. C# is not a functional programming language, and the solution approach to this differs when using a functional language. You still have too many parentheses. Remove the extra ones just after the first `#f`. nlucaroni's answer has reached 100 upvotes (congrats), so it's probably a good point to green-tick it. Enjoy! (Though, since it's community wiki and all, it is generating no rep, so not even sure if nlucaroni will even notice this.) Yay for fighting misinformation with data. :-D +1 @odedsh Right, a good choice of encoding is one way to reduce the storage requirement for Arabic text (and pretty much any non-CJK language). @zneak Exactly, which is why for numbers, it really doesn't matter. For user-defined classes in C++, however, it does matter because the compiler has more-limited freedom in what it can optimise away. I've also successfully made Java 8 method references and lambdas usable as callbacks; JNA doesn't currently have direct support for Java 8's new features (especially with regard to extension methods), but with some care/workarounds you can still get things to work. (Same link as before: https://gist.github.com/cky/7397db4908fa9616539b) @EdS. I haven't missed anything: I commented that it should be `char const *`. Prefer to output `"\n"` or `'\n'`, not `std::endl`. See [_The little `endl` that couldn't_](http://www.aristeia.com/Papers/C++ReportColumns/novdec95.pdf) for more information. @JongzPuangput Put `#include ` at the top of your program. Actually, the OP was using `printf`, which never flushes by default. So it's somewhat unlikely for them to have a change of heart here. Also, `operator*` needs to be a _free function_, not a _member function_ like you're defining it. On OS X, the extension used is `.dylib`. @SunnyAgarwal Of course not. Each thread is constructing a _new_ instance of the cache. And there are no static variables or other shared state between those two threads. @SunnyAgarwal Code in the constructor _happens-before_ any code that runs after the constructor exits. So in general, there is no need to ever `synchronize` on `this` inside the constructor, assuming you're not passing `this` off to some other code during the construction. @SunnyAgarwal Yes, that line is okay without having to use a `synchronized` block, because `volatile` fields have _happens-before_ for reads and writes. So a thread may get an _older_ value if the timing is wrong, but never an inconsistent value. Ah, the great normalised vs denormalised debate. Usually, the decision to go denormalised is due to a concern for runtime performance. See: http://en.wikipedia.org/wiki/Denormalization. If speed is no concern for you, using normalised data keeps data in a centralised place, meaning more consistency. Do you have the _whole_ program? No, but try to make a small minimal program that can replicate the same problem you're seeing. See: http://stackoverflow.com/help/mcve The `if` and `end` should be using `<%`, not `<%=`. `class MyClass` also allows you to reopen an existing `MyClass` class, whereas `MyClass = Class.new` will rebind `MyClass` with a new class. You basically have to create an intern pool (basically a hash table), which you'd use for generating all symbols. Your symbol-generation function would take the symbol's name, look it up in the intern pool, and either add it if it doesn't exist, or return the existing instance in the intern pool. In either case, all symbols thus returned will reside in the intern pool. One potential point of trouble is that most C programs don't employ garbage collection, and so your intern pool would only grow, and never shrink. This may or may not be problematic for you. Once you have a suitable hash table implementation, an intern pool is really easy to implement. Here's Guava's implementation of it (in Java): https://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/collect/Interners.java The key can be the string underlying the symbol, or can be the symbol instance itself; up to you. The value is the symbol instance. To answer your second question, the symbol's name is a string, which should be owned by the symbol object and not modifiable by other code. To ensure the symbol's ownership of the string, if you're _adding_ a symbol to the intern pool, you need to clone the underlying string so the caller doesn't have access to the symbol's backing string. The OP's code is inside a `switch`. So you'd need to make a labelled thingy to break out into. Ah, I thought they wanted to break out of the switch itself; perhaps I misread the code. Okay, have an upvote. @MarcoAcierno Yes, markspace knows that. But still, there is no special accessor for getting that thread. Unless what you want to do is iterate through all the threads and look for one named `main`. But any Tom, Dick, and Harry can create a thread named `main`. @MarcoAcierno If the OP wants to go to that kind of trouble, they could just code in a processing loop and task queue. ;-) _Both_ JVM and .NET are multiplatform. That has nothing to do with its runtime performance, at any rate. .NET tends to rely more on ahead-of-time compilation (via `ngen`), whereas JVM tends to rely more on just-in-time compilation, but both can provide near-native speeds. @AdamC. C# is _not_ Windows-specific by any means, and in fact Mono and Xamarin provide .NET for many platforms, including mobile. @user3920489 Change the `,` in the first line to `;` instead, and use `$F[1]` instead of `$F[0]` for accessing the second column. @Rapptz We call it [MCVE](http://stackoverflow.com/help/mcve) these days. :-) @user3161006 Try `vecSWKeys[count].second = "Hello, world!";` and see if your program works. If it does, then the contents of `sVal` is corrupt. If it still crashes your program, then `count` is an invalid index of `vecSWKeys` (i.e., `vecSWKeys` does not have at least `count+1` elements). `Integer::parseInt` is more concise than `str -> Integer.parseInt(str)`, and I would also choose `mapToInt` instead of `map`, since `IntStream` has more capabilities than `Stream`. `k[0]`, not `k.[0]`. Similarly for the other lines. @cyc115 If you're dealing with streams of numbers, also look at `IntStream`, `LongStream`, and `DoubleStream`; they're even more awesome. :-D @sam If it's a "good" question, then there's no reason to remove it! Flag as duplicate, if applicable. To elaborate, `HashSet` overrides `contains()` to do a hash lookup, which is amortised O(1). It does not do the same thing as `ArrayList.contains()`. :-) @sawa The `retry` jumps to the top of the `begin`. Actually, the OP should also use the member initialisation form, e.g., `check(const check& obj) : cstr(new string(*obj.cstr)) {}`. Of course, if they followed your advice and just stored the string by value, then that automatically solve itself. @EdMorton The Perl version uses a hash table, giving amortised-constant-time lookups for each row. From what I understand of the awk solution from John, it uses arrays, so the `$1 in a` check would be linear on the length of the name list---for each row. This would have disastrous performance if the list of names is long and the data has many rows. @EdMorton Ah, that's good to know. Thanks! Well, I'll be happy to remove my answer in that case. @HotLicks The second sentence of my post talks about what loading a class means, which is pretty much most of the cases listed in the JLS. Yes, it's a less formal answer than an actual JLS citation, but I think it's close enough to reality and is more accessible. @HotLicks Fine, I removed all references to "loading" a class. @jpmc26 `/(.*)\s+(\S+)/` is shorthand for `$_ =~ /(.*)\s+(\S+)/`. You can put a different string on the left-hand side of the `=~` operator. @jpmc26 `=~` has very high precedence, so you can even omit the parentheses here. @dfeuer And now, on [Mark Weaver](http://stackoverflow.com/users/2007219/mark-h-weaver)'s suggestion, I don't even use doubles at all, but instead use pure Newton-Raphson. It does make the startup slower, but that's a one-time cost. @user3519914 HotSpot is the implementation of the JVM that comes with OpenJDK and Oracle JDK. Other Java implementations (e.g., IBM, Harmony, etc.) use different JVM implementations. @user3519914 The JVM is defined in the [Java Virtual Machine Specification](http://docs.oracle.com/javase/specs/jvms/se8/html/index.html). Any software which implements what that document says is a compliant JVM implementation. HotSpot is one such implementation. I'd say that anything that can be private should be, so yes. :-) This might help you: http://perl.apache.org/docs/2.0/user/config/config.html Apache is not usually considered "third-party"; it's a major part of the Java ecosystem. Your answer is correct, but given what the OP is trying to do, probably better to use the shorthand, `(define (get-n) (random-integer 10))`. I'm not saying to exclude the longhand version. Indeed, I agree it's important. You need to create a global symbol named `start`, at the top of your code. :-) @Christian You should update your question with more details, in that case; nowhere did you say that a custom DSL was your objective, nor did you have examples of the syntax you had in mind, or even what a statement is. I don't have enough information to evaluate whether using the default reader is even right for your situation at all, even though it seems you're gung-ho about that approach, based on your comment to Greg. Right now your question seems to be an XY problem. Because Perl reads in the whole line with the newline character, and removing that will cause the newline not to be printed. Don't use R5RS mode if you want to be able to use square brackets. Racket's R5RS compatibility mode is quite strict, and square brackets are not valid in R5RS. If you do want to use R5RS mode, then change all the square brackets to round brackets. @WillNess Remember that the car-side "recursion" is tail recursion. It's pretty similar to traditional left-folding algorithms that do recursion only for car and tail-recursion for cdr. In fact, just by swapping `car` and `cdr` in `flat-fold-right`, you have `flat-fold-left`. :-) @rebnoob The problem with using a defmacro-like thing in Scheme is that it's too easy to capture other stuff too. For example, in the specific case of this macro, what if `if` is redefined within your current lexical context? (Common Lisp gets around this by having symbol packages, and ensuring that things in the `COMMON-LISP` package can't be redefined. Scheme doesn't have such a concept.) Having said that, if you want the "simplicity", an alternative is to write an explicit-renaming macro. I'll update my post with such an implementation. @malisper `define-macro` is easy to define on pretty much any Scheme system that provides something more than `syntax-rules`. However, the trouble with `define-macro` is that it does not have any way to constrain the lack of hygiene. Even gensyms can't cope with the fact that all your "free" identifiers (like `if` in the case of the current macro, or just simple stuff like `lambda` or `let`) can be rebound in the current lexical context. @Chris `define-macro` is trivial to define using `syntax-case` (you simply `syntax->datum` the macro body, then `datum->syntax` it back using the current syntax object as the context), so "where available" is redundant. :-) Say goodbye to having sane bindings for all the built-in identifiers your macros use, though! Just use `(cons x y)` instead of `(cons y x)`. Actually, these days, it's `data:application/json,{"location":{"lat":xxx,"lng":yyy},"accuracy":10}` How exactly would you evaluate the last function-call argument as a tail call? Remember that after evaluating it, you still need to pass its value to the function call itself. A good way to think about this is, how would you implement the whole thing in CPS (continuation-passing style)? If and only if you can pass your continuation directly (with no changes) as a function call's continuation, then that is a tail call. Totally understandable. The first version is trivial to inline. The second adds more indirection cost, and mine takes it up another notch. :-) I am actually writing a proof-of-concept macro for such a thing, but without using reflection (since that has a cost, too). Okay, the macro is written now. It's, uh, not the most elegant thing in the world, but hopefully still has less code duplication than the original. ;-) In fact, by the pigeonhole principle, since there are (much) more than 2^32 possible strings, hash codes are guaranteed not to be unique. You can't look at the `PATH` environment variable by running `$PATH`. You need to use `echo $PATH`. I don't know what Chicken offers, but Racket has [place channels](http://docs.racket-lang.org/guide/parallelism.html#%28part._effective-places%29). It's called a "grammar". In particular, there are programs (called "parser generators" or "compiler compilers") that, given a grammar, can create a parser for you. @user124577 Actually, Lisp languages are _not_ huge into reflection at all. Lisp's hallmark is macros, which generate code (usually from some kind of template) rather than pry into existing code. Also, many Lisp (and Scheme) systems compile a lambda expression immediately (usually into an intermediate form rather than straight into object code) and don't retain the original source. For such implementations, you would not be able to recover the original code. You don't even need a hash table. Just add 1 and use `list-ref`. @AndrewMedico Too bad you can't downvote comments, but I disagree. With `let*`, you are allowed to reuse variable names. So I'd use `best` each time. Actually, R5RS's `min` takes one argument at a minimum: http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_idx_276 (note that `...` in Scheme standards means zero-or-more of the previous thing, just like `syntax-rules` macros). Also, `fold` and `reduce` are in [SRFI 1](http://srfi.schemers.org/srfi-1/srfi-1.html), which almost all Scheme implementations provide. @ÓscarLópez Racket (and SRFI 1) provide `split-at`, which return the results of `take` and `drop` as multiple values, but using one iteration only. I'm sure the OP's question can also be implemented using one iteration. Welcome to Stack Overflow! We welcome programming questions, but this is not a homework-answering service. You are expected to understand the specific programming aspects posed by your homework, then ask questions about the programming stuff. Make it useful for other programmers, not just you or people doing your course. See the line after that to see what `cube-mid`'s purpose is. Note how it's being compared with `n`? Of course it did. ;-) I filed that bug report and have tested the fix on my own computer. :-) @onmyway133 Because Ruby's strings are mutable. Interning only applies to immutable values. I saw you briefly in the #racket channel. You should come back in, I'll be sure to say hi. :-) @nnnm Trace through your code and see if there is _any_ situation where you'd return `'day`. What is the content of `words`? R7RS-small provides a larger common core than R7RS? Surely you meant R5RS. :-D +1 for correctly suggesting the use of the literal list. The reason using `'as` doesn't work is that that is read as `(quote as)` (and not as a symbol---remember, `'as` is only a symbol when evaluated, and macros are pre-evaluation), where both `quote` and `as` are pattern variables (matching any datum at all). I would actually prefer to use quasiquotation in this case (`\`(loc ,globals)`). That way, it's instantly obvious what's getting unquoted (rather than "oh, just something I forgot to quote when using `list`"). @uselpa I think the OP is just trying to learn how to write a tail-recursive version of (essentially) `map`. @BBladem83 Can you post the _actual_ code you tried that doesn't work? This problem is really easy. Hint: the second case should read `(make-auction (auction-itemnum anetry) aname bid (auction-status anentry))`, that is to say, `aname` and `bid` must not be surrounded by parentheses. @uselpa True, it's better to be sure we're not dealing with an XY problem. Indeed! I wrote a post about [named `let`](http://dyscour.se/post/58639636506/named-let), too, which explains how they work behind the scenes. @Sarah It would be if `fib-iter` were written a little differently, such as `(if (zero? count) a (fib-iter b (+ a b) (- count 1)))`. But in your case, the roles of `a` and `b` were swapped from their conventional meanings. Re my edits, your code could be even more readable with the use of `cond` instead of nested `if`s, and the use of named `let` instead of the inner definitions. But I've kept my changes exclusively to formatting only. Version 49 class files are generated by Java 5. That means that somewhere in your system, you have a version of Java older than Java 5. Find _that_, and upgrade it. Note, you can have multiple versions of Java installed on the same computer, so just because your default version is Java 6, does not mean that that's the version your Oracle is using. The `$line =~ s/\x02//g` worked for me. Are there more funky characters you didn't account for? @MrJman006 The difference is, Óscar's answer is correct and Jack's answer is more questionable (I will write a comment explaining this in a minute, along with a downvote :-)). I would therefore recommend you accept Óscar's answer instead. Now, here's my objections to this answer: 1. Two instances of `"a"` in the source code are _not_ guaranteed to be coalesced or interned. Implementations are free, but not required, to do so (for example, Guile returns false for `(eq? "a" "a")`). It's not wise to depend on this behaviour. 2. `symbol->string` is not guaranteed to return a fresh string. In fact, the way R5RS and R7RS is worded, if an implementation uses backing strings for symbols, `symbol->string` is certainly allowed to return the same backing string when called with the same symbol. (For implementations that don't use backing strings for symbols, then of course `symbol->string` is more likely to return a fresh string.) 3. `(eq? '(#\a #\b #\c) '(#\a #\b #\c))` is false in many implementations (including Racket). Implementations are allowed, but not required, to coalesce literal data, but in practice, implementations coalesce atomic data only, if at all. Which version of rsync are you using? Those options were added in rsync 3.1.0, and they are described in the [man page](http://rsync.samba.org/ftp/rsync/rsync.html). 1. What OS and distro are you on? 2. What version of Guile are you on? 3. What happens when you try to run a sample program? @TomBarron Thanks! I'll update my post. Well, if your distribution doesn't have 3.1.0 or 3.1.1 packages, you'll have to backport them yourself. See https://wiki.debian.org/BuildingFormalBackports for instructions. I frequently build backport packages myself and I can create one for you, but that might be considered too untrustworthy for you. :-) @JoshuaTaylor (My comment doesn't apply to CL.) In Scheme, it's still better to use `else` instead of using the expression as the test form, because the `else` expression is in tail position, whereas the test form still has to be tested for truthiness. @JoshuaTaylor In Scheme, there's a difference between `#f` (which is the only false value, in Standard terms), and an "unspecified value" (which is what is returned if `cond` "falls off" the last clause, and is usually `(void)` in implementations that provide it). So a test-only last clause can't simply be optimised to be an `else`, in Scheme. (But I can see how you can do that in CL, since `nil` is both a false value and is the result of `cond` if execution falls off). @JoshuaTaylor That clause only applies if the "value of the test" is truthy. Otherwise, it falls through. @JoshuaTaylor Right, I was just trying to explain why (in Scheme) you can't simply optimise a "last" test-only clause to an `else`, and thus why such test-only clauses can't be in tail position. :-) @bames53 I've posted a reopen vote now. You seem to have enough rep too, so do it. :-D @skomi That's true, perhaps it is better to roll types into the discussion. Especially since, there are general unary functions (`T -> U`), predicates (`T -> bool`), and operators (`T -> T`), each of which has a different feel to the other. Lemme amend my post. @skomi Yes, it is (T,U)->R, but, for people who are used to using currying languages (like Haskell), it would indeed be T->U->R. @stakx I primarily use Scheme, which is functional but not currying. So I tend to use non-currying notation. :-) @skomi I think function shape is more abstract, whereas function descriptor has a formal concrete definition (as mentioned in JSR 335). @MadProgrammer Or just use `Collections#max`. O(n) is better than O(n log n), if you ask me. :-D Heheh, "advanced". This kind of stuff makes me yearn for Ruby: `list.max_by(&:area)` (or, for more flexibility, `list.max { |a, b| a.area  b.area }`). BTW, the 475fdaaa in `br.com.helpradar.entity.User@475fdaaa` is _not_ the address. It's the object's identity hash code. Why is this distinction important? Because heap objects in the JVM are frequently moved by the garbage collector, so very few objects retain a constant address. But the identity hash code stays the same for the life of the object. @Krishna My point is that finding the object in a list with the maximum area is a one-liner in Ruby. It is also a one-liner in Java 8 (though not quite as short as the Ruby), but in older Java versions, it's just a PITA. @Krishna It will certainly reduce the programmer's brain load. And programmer performance is generally much more important than code performance. No, don't use `eq?`. Just use the result of `(first lob)` directly. I was rather hoping you'd say Ubuntu or Debian, since I have those on hand. :-P Anyway, where is your `gnome/gobject.go` file? The toplevel directory for that needs to be added to your `GUILE_LOAD_PATH`. Huh, how bizarre. Maybe `make install` didn't install the `.go` files. What about `gobject.scm`? @Edie Don't worry about that. `concat1 + concat2 + concat3 + concat4` is the right way to do it. It gets translated into `StringBuilder` by the Java compiler automatically, and so you don't need to worry about it. @clcto They're only treated as constants if declared as static final fields. Not the case here in the OP's code. Did you run `make install` (as root)? Okay. Does your code work now? By the way, the most uniform way to distribute mines is to put the required number of mines at the front of your grid, then shuffle the whole lot. This is just a special case of a list-flattening function (albeit using a struct instead of conses as input). There are a number of ways to write a flattening function, including http://stackoverflow.com/a/7324493/13 and http://stackoverflow.com/a/13548087/13. @fuiiii Surely, you should be using `draw-x86_64-macosx-2` instead of `draw-i386-macosx-2`, unless you downloaded the 32-bit Racket package instead of the 64-bit one. @user2864740 I disagree. Fastest Gun in the West is a feature, not a bug: http://meta.stackexchange.com/a/9758/13 P.S. To all the closers: Vagrant is a _dev_ tool, it's not a networking/sysadmin tool. Its purpose is to enable devs to set up VM recipes that work identically for all devs in your team. `#lang htdp/isl` ;-) @choloboy `/Applications/Racket v6.1/lib`. @SW_user2953243 It's like a 32-bit version of `memset`, where the thing to set to is a 32-bit quantity (unlike `memset`, where the thing to set is a `char`). `ecx` specifies the number of dwords (and not number of bytes) to set. `(list-ref x 0)` → `(car x)`. Please have some patience. People often take a few hours to respond, especially if the tag isn't [c#] or [java]. ;-) @JasonL No, remember that these iterators are bidirectional. So you simply check the iterator's previous spot, and see if it is suitable (as regards the key ordering) for inserting the entry. If the hint is incorrect, then you fall back to the O(log n) unhinted insertion. @Downvoter My answer is correct, and correctly identifies the cause of the OP's problems, but the OP changed the question with the fixed code (read the above comment, and the question revision history). Just so you know. Are your substitution strings _literally_ `Dog_1` and `Dog_2`, or are they something else that requires shell escaping, etc.? @DBRN Then you will receive an `OutOfMemoryError`, and life will suck for you. But your `HashMap` still won't lose elements. Also, before getting to this point, your GC will be running at 100% continuously trying to free up memory, and your program will be very slow.... An `OutOfMemoryError` will indeed be thrown. In theory, code can catch it, but catching `Error`s of any type is bad practice, so don't do it. @SleeplessAnnoyedNerd: My original post had only the 64-bit library because 1. that's what the OP uses, and 2. I cannot believe anybody still uses the 32-bit version of Racket. Anyway, I've updated the post to accommodate both camps now. @Layla Yes. :-) @ÓscarLópez What the OP seemed to have wanted is something akin to C's unions. I don't know if any Scheme implementation supports unions though; that seems memory-unsafe. Of course, statically-typed languages have concepts like algebraic data types, but again, this doesn't apply to Scheme. Scott Hunter's answer describes what the function does correctly. If you wish to implement it, combine `mapcar` and `nth` (Common Lisp) or `map` and `list-ref` (Scheme) in some appropriate way. @GregHendershott I'd rather use Clojure's `#(cdr (assq 'age %))` syntax! https://gist.github.com/cky/8500450 Totally agree re supplying key accessor function. Heh, I see that that dialogue box isn't actually a real OS-level window. I tried using ⇧⌘4 + space, and it only wanted to select the top-level DrRacket window. It's a bummer, because I hate having to manually crop my screenshots. ;-) (Reminds me of the days of trying to debug Swing programs using Spy++. Swing windows aren't real windows, so it's basically impossible.) If your crawler doesn't respect `robots.txt`, sites can set up honey traps for your crawler (with links that no humans would click, if they were hidden by JavaScript or CSS, for example) that would tip them off that you were running a noncompliant bot. This may potentially lead to legal action. @ThrowawayAccount3Million No, you should _not_ use a `#lang` line unless you use "Determine language from source". Which is why you should always use "Determine language from source". As for the command-line REPL, use `racket -I lazy`. Yes, there are. Any legit search engine's crawlers will respect `robots.txt`, no questions asked. @anonymous Makes sense. In that case, the OP's analysis seems correct. That was pretty much what I intended to say (in my now-deleted answer), but I don't think `loop`'s syntax (in Common Lisp, at least; the OP didn't say what dialect they're using) uses keywords. @Rainer Thanks! Learnt something new today. Still I'd say that seeing them as keywords or alternative package symbols seems unidiomatic. You can also use internal definitions to define your helper function. For beginners, that's what I usually suggest. Of course, like you said, seasoned Schemers prefer named `let` instead. @BasileStarynkevitch Only "most"? @knivil Other than special forms and macros, standard evaluation rules (i.e., eager evaluation) apply. That's why `and` and `or` are macros. I think your code came from either http://wqzhang.wordpress.com/2009/08/12/sicp-exercise-3-65/ or http://lawfulsamurai.blogspot.com/2009/01/sicp-section-35-streams.html. Note that it's important to attribute the source of any code you post. It sounds like you should use `(helper-2 '((2 0) (4 0)))`? I have not tested it, though. You've actually modified the code from what I've got, and it's incorrect. Please cut and paste my code and use it directly. It does, actually, tell you where the error is. It is telling you that `top-left` does not exist. You can search through your code to see where that is being referenced. That would assume that `FootballClub` implements `Comparable`. :-) I like my definition better, since it aligns with the SRFI 1 definition of an improper list, which also counts standalone atoms (which are improper lists of length 0). Uh, I think `(improper-list? 1)` should be true. If you think inductively, it will make sense: an improper list is: 1. an atom that isn't an empty list, or 2. a pair where the cdr points to an improper list. This also makes sense when you think of the lambda syntax for declaring a function that takes 1+ arguments, vs one that takes 0+ arguments. While we're talking about SRFI 1, it provides a `dotted-list?` predicate that seems like exactly what the OP is seeking. P.S. Scheme, not Lisp, and definitely not LISP. Any decent Scheme implementation, including Chicken, has a module system. Chicken's module system is documented here: http://wiki.call-cc.org/man/4/Modules. Instead of loading `complex.scm`, you should make both `complex.scm` and `arithmetic.scm` modules, export everything you want to from `complex`, and import `complex` inside `arithmetic`. You can rename identifiers upon import. @MistyD After you call `f.reset()`, _of course_ `f.use_count()` is 0. It has no reference to anything! But if you call `vec[0].use_count()`, it should have the correct number. Think harder. Hint: each of those `` is a whole expression, not just a single variable. The first one has the shape `( )`, and the second one has the shape `(  ( ))`. And the built-in `max` is pretty easy to implement in terms of SRFI 1's `reduce`: `(define (max . items) (reduce (lambda (a b) (if (> a b) a b)) #f items))` On which note, I think you forgot an `apply` somewhere in your last paragraph.... Correct re the first ``. As for the second one, why would you call `add1` twice? Think about what you're adding 1 to. Hint: Think about what happens in the `else` case, then think about what you're doing differently in the `string=?` case. @FloatingRock Actually, very few mainstream programming languages have rational numbers built-in. Arne is a Schemer, as I am, so these are things we get spoilt on. @Stefan Indeed, though I was hoping that that would be obvious. :-D @DerekAdair I've recently written a post that explains this even further, that you may be interested in. Enjoy! http://stackoverflow.com/a/27030789/13 Are your lists _always_ guaranteed to be in ascending order? If so, there's a faster solution to this (than Óscar's answer, which does not require the lists to be ordered but is slower). @mtyurt That's too bad. You need to be much more specific about what "caused" and "some problems" are. @xEscape Read up about `split-at` (preferred), or `take` and `drop`. @GoodPerson It applies to all platforms. If that were not so, `inetd` and the like would not work. (`inetd` dups your socket into your daemon process's stdin and stdout, and your process can interact directly with stdin and stdout in the normal way, without any awareness that they are sockets. Of course, you can do socket stuff with them too.) An E8-based `call` opcode will only apply to targets with local displacements. Chances are (I don't have MSVC to test with at the moment), then, that your function being called must have local linkage, such as by being declared `static`, at a minimum. What are you trying to do? What does `a == 1` mean, and what does `a == 2` mean? Well, obviously, if you're assigning shared state, then it's not immutable. Programming in an immutable way requires you to not use mutable shared state (so all mutable state must be thread-local). So you'd have to restructure your program with that goal in mind, which brings me to the question, _why_ are you updating that variable? What is its purpose? I would use a `BlockingQueue` that is shared between threads, to be used purely for message-passing. All state changes are done in response to messages from the queue. Instead of having a `cond` in the `else`, just fold those conditions into the outer `cond`. :-) Even though I find the use of `set!` distasteful in general, I don't have a better solution at the moment. Still, it's better not to use `list-ref`. You can do something like `(let ((result (car lst))) (set! lst (cdr lst)) result)` instead. (Common Lisp has a `prog1` macro for that kind of thing in general, though in this specific case, its `pop` macro is even more direct.) Re correct indentation, I notice that Emacs uses "body-indentation" for the else branch of the `if` form, but in the Scheme world it is much more common to indent the else branch flush with the then branch (and Riastradh's style guide supports this). Keen to hear your thoughts on all this. @dyp Agree. What names do you suggest? @MistyD `std::map::value_type`, or in other words, `std::pair`. @dyp How does it look now? @dyp Here you go. :-) @MistyD and now, since I've changed the template to use `M` for the whole map rather than `K` and `V`, the type of the `auto` is now `typename M::value_type`. :-P You should run `/usr/libexec/java_home` to see which `JAVA_HOME` is going to be used by default. @RC. On OS X, it's not `PATH`-dependent at all. `java` is always in `/usr/bin`, and it's a wrapper that uses the same method as `/usr/libexec/java_home` to find the appropriate location. Like Jack said, really it should just be `(map * a b)`. :-D Oops, it's supposed to be a _weighted_ histogram, so a simple `incf` won't do. In particular, in the OP's example, the result should be `(2 1 1 0)` instead of `(1 1 1 0)`. Just to nitpick a little: integer arithmetic is only exact in floating-point up to a point (pun intended). If the number is larger than 0x1p53 (to use Java 7's hexadecimal floating point notation, = 9007199254740992), then the ulp is 2 at that point and so 0x1p53 + 1 is rounded down to 0x1p53 (and 0x1p53 + 3 is rounded up to 0x1p53 + 4, because of round-to-even). :-D But certainly, if your number is smaller than 9 quadrillion, you should be fine. :-P You need to explain what `choose-items` is supposed to do. It doesn't seem to be documented anywhere. Define "best". It's hard to see if your code has a bug in it if there's no definition of what the correct behaviour is. :-) @LePetitPrince Correct, and the function name is insane, but the description at least describes the behaviour you see. @user3457747 You don't have to. You can instead use a `do`/`while` loop as explained in Kassym's answer. Right, in that case, you'd be better off using `do`/`while`, where `guess` won't be made to do "double duty". :-) Well, if you changed to `guessloop`, that means that your actual human guess isn't updating it, right? (Hard to tell without seeing your changed code in front of me.) In that case, the loop condition will always stay true, and so you won't exit the loop. I've also updated the post to suggest an alternative that uses an unconditional loop paired with `break` to exit the loop. You may find that easier to work with. (BTW, were you the one who posted in my Ask Me Anything? If so, I appreciate it. :-)) Are you just doing this for fun? Racket comes with a [much more general comprehensions](http://docs.racket-lang.org/guide/for.html) system, and there's no point for you to try to reimplement it. In particular, see Joshua Taylor's answer: http://stackoverflow.com/a/27257000/13 "Public keys" come in many formats. It could be OpenPGP, or PKCS #1, or anything else that allows you to transport the modulus and exponent. Heck, it could just be a JSON object that has those two values encoded as strings. It all depends on how "those who need it" wants to process them. @tm.sauron You can't lock a field, only the object the field refers to (in that case, only the latter is locked). If you call a static method that is `synchronized`, it locks the class object since static methods do not have a `this` reference. (Non-static `synchronized` methods lock `this`, not the class object, upon invocation.) @colin Rainer's point is that if you want to use a non-accumulative solution, you have to implement `append` and use that, and it's a poor solution because your reverse operation would be O(n²) instead of O(n) (which the `revappend` solution is). @RainerJoswig Re newer list operations, surely you'd be using `endp` instead of `null`? ;-) @RainerJoswig Agree re TCO, and I would have used a `do` or `loop` normally, but those aren't in the list of allowable operations from the OP. :-) @Rainer I don't mean linear-update functions (like `nreverse`), I'm talking about things like `setf` that's used purely for side effects. Whoops, I should have had CLHS in front of me before writing these sorts of comments. :-) Yes, but `revappend` is a standard CL function, so I figured I may as well use it. Which version of Guile are you using? I'll assume 2.0.11 unless you say otherwise. Also, try using an absolute path for your `--with-libunistring-prefix`. That's implementation-dependent. For example, if you implement continuations by using CPS-transformation instead of stack copying, your call stack would actually reside in the heap, and not be subject to the limitations of the CPU stack. Please edit your question to use the _real_ path, since `dir/install/libunistring` is clearly not an absolute path. :-) (In troubleshooting situations, details matter. Don't edit them out.) Does the directory you specify contain an `include` and a `lib` directory? I just tested with `--with-libunistring-prefix=/usr/local/stow/libunistring-0.9.4` and, on my system, `/usr/local/stow/libunistring-0.9.4/include/uniconv.h` exists. Yep, that sounds reasonable. They are not the same continuations (one returns to the outer `call/cc`'s caller, the other returns to the inner `call/cc`'s caller), but their effects are similar enough that you could consider it that way. Predicate, not predecessor. :-) Also, using [Alexandria Morgan's picture](http://instagram.com/p/uyspYSJfcl/) for your avatar is kind of creepy. It's better to use your own picture, or none at all. On Windows, you can always use `start` to open any file using its default file assocation. So instead of `notepad` or `arduino` or what not, replace all of them with `start`. @Tobias Just wanted to acknowledge your comment ("Im using the Logitech G510 :( But I need the quare bracket for my Cond...otherwise its confusing"). Lemme ask on the #racket IRC channel to see if there are any other remedies. For the case of decreasing by 1 each time, your solution is fine. For the OP's other example of decreasing by 0.45 each time (a number that does not exist in binary floating point, only in approximation), the error will accumulate each iteration and after enough iterations, the number will be quite skewed. :-) (This is why I posted the `45 * i / 100.0` solution.) @justmscs Right, 0.45 is actually parsed into the nearest binary floating-point quantity, 0.450000000000000011102230246251565404236316680908203125. So with `0.45 * i`, when `i == 40` (the end of the OP's loop), the skew will be multiplied by 40. With the `45 * i / 100.0` approach, the `45 * i` part is exact, so you will always have the minimum skew each time (which happens in the `/ 100.0` part). @justmscs `System.out.println(new BigDecimal(0.45));` As a bonus, a functionalised version of the code is not only much shorter, but also much easier to translate into Clojure. The reference implementation of `cond` is also in R5RS: http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.3 What kind of error were you expecting? I mean, other than for the missing semicolon in the first line. @user3257891 No, `equals()` takes an `Object` of any type. If it's the wrong type, it just returns false. @MattCoubrough The OP was expecting calling `foo.equals(bar)`, where `foo` is a string array and `bar` is a string, to result in a type mismatch error. In the worst case scenario, delete Android Studio 1.0.0 and install 1.0.1 anew. You'll retain all your program settings. Fields are per-instance (unless we're dealing with static fields, but that's not the case here). So two different instances of an object will have independent values for the same field. @pbabcdefp Do not call `double` and `float` "decimal" types, because they are absolutely not. `decimal` (in C#) or `BigDecimal` (in Java) are decimal types. No, you can't do that. The phone keeps track of which app (`com.android.vending`, etc.) was used to install the app, and reinstalling or updating an app is considered installation too. No, you can't bugger (sodomise) me, but you can bug me, sure. :-) The name check is to find a method named `toRealPath`, in this case. A method reference of `Path::methodThatDoesNotExist` would not be valid, for example. Yes, that is what happens. What I want to know is why people can even pick Pretty Big as a language option. It seems to cause the most amount of trouble, judging by the questions I see on Stack Overflow. More germane to your question, please post a screenshot. @LePetitPrince I think you meant to ask what distro, since the OP already mentioned Linux. @Sylwester Indeed, and because it comes after the 1+ case, it won't even fire at all, ever. As mentioned in the documentation, the encoder does not encode anything to false. This is the downside of a language that doesn't have different representations for null and false! It looks like Node doesn't like being installed in a location with spaces in the name. This isn't particular unusual, since it uses `/usr/local` by default, at least on Unix (including Linux and OSX). Still, bummer. @LePetitPrince `(/ 0 0.0)` _should_ be NaN. But _multiplying_ anything by an exact zero is, mathematically speaking, an exact zero, so Scheme implementations are allowed (but not required) to account for that. @LePetitPrince True, I think I can agree with that, in the sense that NaN means "I don't know what this number is", and that number could potentially be infinity. But certainly, any non-infinite number multiplied by exact 0 is 0. C strings have to be null-terminated. So that line adds the terminator. @NKN Canned comments like yours are best reserved for users with less than 100 rep. Higher-rep users deserve better than cut-and-paste comments. @Michael "Dynamic" might be the wrong word here. The OP can't use OS functions so there's no heap memory or anything. Well, it's unstable, which means it won't be portable between versions. :-( Right, but the required import might change, so your code still won't be stable between versions. ;-) They (the Racket maintainers) could, in theory, but why would they? It's unstable, after all. @soegaard Agree, I think that versioned packages would be more useful (re allowing subject-to-change interfaces). Oh wait, PLaneT had those! (I'm not familiar enough with the new package system had that too, but since it links to GitHub, I'd certainly hope so—wherein each version links to its own git commit.) @JohnClements If that were actually to be the case, then like Jens said, "unstable" seems like a not-very-well-thought-out idea. I mean, real code is really supposed to treat unstable as invisible, surely, and not actually depend on anything in it to, y'know, be stable. :-) ASCII is a strict subset of UTF-8. That is, every valid ASCII octet is encoded in UTF-8 in exactly the same way. So if your code were actually ASCII (and not something funky like Windows-1252), it should be able to be processed as UTF-8 with no changes. @JDM Matt's answer is really good, and you should click on the big green tick below the voting buttons to mark this answer as accepted. 一 is the Chinese character for one. I wonder if, in the OP's locale, that would match `[:digit:]`. @user3787253 Yes. @user3787253 Oh, that's easy. Just click "Download" on the top-right, then use `iconv -fGB18030 -tUTF-8  c.input_0.utf-8.txt`. @AvinashRaj It's articulated in the original question. Basically the OP wants to join up the lines that don't start with the number-space sequence. @gsg Technically `jecxz` is not a `jcc` instruction (it's outside the opcode range of the `jcc` instructions, it doesn't look at flags, and it doesn't have a `setcc` form), but since for some reason it's listed in the `jcc` section of the Intel manual, I'll update my answer to address that. Thanks! @CudelcuMedvidekEmilek Not all tail-recursive/iterative functions need an accumulator. In particular, short-circuiting boolean functions (such as `andmap`/`every?` and `ormap`/`any?`) do not require an accumulator. (Your `unique?` function is easily transformable to use `andmap`.) @benrudgers It _does_ include the last value among the odds. Have you run the code? :-) @RemyLebeau Indeed, I agree with just using `RegGetValue` if the OP could work with that. Surely, these days XPSP3 and/or Vista must be the minimum baseline? :-P @en93 Numbers and pointers are "convertible to boolean" in C and C++, where 0 and nullptr are false, and everything else is true. In this case, the code is the same as `bufferSize != 0 && installLocation[bufferSize - 1] == 0`. But I hate having to write those out "long-hand"; this is C++, not Java. :-P There's also `first`, `second`, `third`, `fourth`, `fifth`, etc. @boxed You cannot implement a deque on top of a vector or `ArrayList` without, effectively, reimplementing `ArrayDeque` yourself. @TobiasHeitkamp In future, instead of using `(* -1 b)`, just use `(- b)`. At the JVM level, the return type is part of the signature, and can be overloaded on. This is crucial to the implementation of bridge methods used for return type covariance in Java 5. However, at the Java _language_ level, the return type is not part of the signature. @Bathsheba Because I don't need the rep. :-P Besides, it's a response to your answer. @Henr.L The only book I can think of that explains this adequately is the _Java Language Specification_. However, it's absolutely not designed to be accessible to Java beginners; it's for people who implement the Java compiler and runtime. I don't have such a list on hand, but I strongly urge you to use a whitelist rather than a blacklist. That is, specify the valid characters, and allow _only_ those through, as opposed to specifying the invalid characters. @user1185790 Indeed. @user1185790 You should use `%s` for strings, not `%d`. @brandonto Excellent! Please note that the right-hand side of the `=>` does not have to be a lambda expression. I've updated my post to highlight why you might want to use a named procedure, to reduce code duplication. There are two places in your function that have `if` in them, as I've identified in my answer. Only if both of those conditions are false, does the `return scope` line get reached. @LuisColorado Yes, you can pass anything you want to `argv[0]` (it can even be null on some operating systems, which would mean that the new process will have `argc == 0`), but by convention, you should pass the program name by default, because that's what the shell does. @Svante Oops. Was too focused on getting the code working and neglected to look at the problem domain. @DomnWerner `(* dec dec dec)` is the same as `dec * dec * dec` in infix. It basically evaluates to the cube of `dec`. @maja What do you mean less? They have 824 and I have 114! ;-) ;-) ;-) You actually should be using a JSON parser for JSON data, not regexes. From R6RS onwards, the correct way to do side-effecting conditionals is to use `when` and `unless`. `if` should strictly only be used for situations where you'd use the conditional operator (`?:`) in C-style languages. `(foldl cons x y)` is the same as `(append-reverse y x)`. The latter, I hope, is more intuitively-named. :-) Be aware that outside of Racket (basically any Scheme implementation where cons cells are mutable), `list?` is O(n). So usually I'm sparing with its use unless I know I'm on Racket. `positive-result`? Are you sure you didn't mean `empty-result` or `null-result` or similar? ;-) Hehehehe, great minds think alike (re your most recent edit, vs my answer). I've added a version that follows the template but doesn't use `set!`. But it's still ugly, because it exploits Scheme's dynamic typing.... ;-) @ÓscarLópez Okay, I've updated the text. ;-) @Tobias I nearly always answer questions in the way a professional Schemer would code it, not in a "homework-approved" way. However, `car` may be spelt `first` in your course. A really easy speedup: replace `(= (length coins) 0)` with `(endp coins)`. The whole list has to be traversed to calculate its length, whereas it's really quick to tell if the list is empty or not. When entering the numbers, did you ever use backspaces? If the failed cases involved backspaces, it could be because the input is being sent to Racket as-is (e.g., "1`^H`2", where `^H` refers to the backspace character). If I find some time, I'll try to make a backport PPA. We'll see. Or even `(apply values (map list '(1 2 3 4)))`. Also, literal data is to be treated as immutable. The effect of mutating literal data is undefined, and often not what you expect. In your case, instead of using `'("log4cplus/socketappender.h" ...)`, just use `(list "log4cplus/socketappender.h" ...)`. @Alexis I 100% agree. See my answer (Boost IO Stream State Saver). :-) You can also use `integer-sqrt/remainder`: `(define (perfect-square n) (define-values (q r) (integer-sqrt/remainder n)) (and (zero? r) q))`. Also, for your `for` version of `sum-of-perfect-roots`, in this case, it's easier to just use `for/sum` instead of `for/fold`. Anyway, my edited comment includes a `integer-sqrt/remainder` version of `perfect-square`. :-D (I try to avoid floating-point if it can be avoided, but that's just me.) Also, you can use `(for*/sum ((n (in-list lst)) (r (in-value (perfect-square n))) #:when r) r)`. `in-value` provides something akin to `let` in comprehensions. :-) There isn't, but I edited the post to add a `properise` procedure, which will turn your improper list into a proper list. You can then call `butlast` on that. I agree, as does the OP. In fact, the OP is trying to figure out why `completion-all-completions` in Emacs (sometimes) returns improper lists.... BTW, using a literal datum, like `'(1 2 3)`, as a non-last argument to `nconc` is not technically okay. Literal datums are supposed to be considered constant. @TimX `'(1 2 3)` is a proper list. However, it's a literal, which means you are not supposed to modify it, and you may encounter undefined behaviour if you attempt to. `(list 1 2 3)` is a fresh list which you can freely modify. @RainerJoswig It's just as undefined as in CL. Try running this function three times: `(defun fun () (nconc '(1 2 3) '(4 5 6)))`. (Okay, maybe don't actually run it, but you can imagine what that does. Same behaviour on Emacs as on SBCL and quite possibly every other CL system.) @TimX Modifying literal data isn't okay in Emacs Lisp either (see the example in my previous comment). I don't know about the CL world, but in the Scheme world, circular lists are considered distinct from improper lists (and distinct from proper lists, of course). @Clément Your version should probably have an `n` prefix since it's destructive on the incoming list (which means you have to use `copy-tree` first if you're dealing with literal data). :-) My version doesn't modify the input list which makes it okay to use with literal data. @Rainer I 100% agree. My point is that what you see in Emacs Lisp is bad enough already that people shouldn't write code that modifies literal data, and is certainly not "OK in emacs lisp" (quoting Tim's comment). I've posted an answer in the module case. But if you're actually writing a standalone program, make sure that the `use-modules` is at the top level, and isn't misspelt (e.g., as `use-module` or the like). The default setting for IDEA 14 is exactly what you see in the "what I would like to see". I think you have some non-standard indentation setting active. :'( I've added a hopefully-simple explanation. Lemme know if there's something else you need explained. :-) Though, in the Racket universe, it's much more common to use `andmap`, since that's provided by the `racket` language without any imports. My use of `let` just defines a local variable that holds the result of the recursion (you don't want to recurse over the same sublist more than once!). The first `if` is there to handle the base case (return `#f`, the false value, if there are no remaining elements), and the second `if` is there to handle a `#f` return from the recursion. Good luck with learning the code! I would not advise using `(cons +inf.0 -inf.0)` as the initial value. If anything, use `#f` (in a similar style to my solution). That's because using `+inf.0` and `-inf.0`, which are inexact numbers, forces the result of calling `min` and `max` to be inexact, also. Technically, your version is iterative too (and so is Alexis's version). ;-) But I'll see what I can cook up. Wow, Vim gifs? Nice. Is there a site for making those? Please edit the question text to include the non-working code. No, you cannot "simply eliminate the internal definition". As mentioned in my answer, the inner procedure is a closure. In fact, even your tail-recursive definition is still a closure, so you still can't hoist it out to a top-level procedure without adding an additional `tree` parameter. Try running it in command-line `racket` instead of DrRacket. The optimisations used for that are more aggressive, IIRC. When I tested that in `racket` 5.3.4 in Debian, I got 2162.788818359375and 1930.303955078125. Good catch re improper list! See Sylwester's answer. It is totally spot on and you should accept it. A better example of "Hello Jim" would be to use `(format #t "Hello ~a~%" (cadr args))`. Also, you can use `(load "myfile.scm")` to evaluate a whole file. You don't have to make the file executable to do that. Hint: `(define (reduct n) (modulo n 9))`. Study any numerology site to learn why. I've elaborated on it some in the last paragraph of my answer. Basically, unless this is for homework and you're required to do it recursively for some reason, my one-liner is a much faster solution. I just added a version that works in plain ISL. :-) Well, then, just hoist `make-pixel` and `make-row` into internal definitions. That's allowed in ISL, right? ;-) Ahh right, you have to use `local` instead. Lol. @AlexisKing Me too, I usually prefer to answer questions with "professional" implementations. @Ryan On Stack Overflow, we do _not_ delete a question when it's solved. We leave it on the site to help others who have the same problem. In fact, if you delete (or deface) too many of your questions, [the site will eventually ban you from posting any new questions](http://meta.stackexchange.com/q/86997/13). Well? Where's the code? Your answer is technically correct (+1) but the OP really wanted to manually implement bubble sort. 1. `,.` is a non-consing version of `,@` (unquote-splicing). It's used for lists that are freshly-created (such as by `mapcar`, in this case) that you know can be modified in-place. If in doubt, just use `,@`, which is always safe. 2. No, you still can't use quoting here, and in particular, you can't actually quote the `triad` or `quad` or the steps lists. @glglgl Right, that works too. I just don't want to see code like `if (this == LEFT)`, that's all. :-) In this case, there is no need to use `cute`, you can just use `cut` (which expands to a simpler lambda expression). `cute` is mainly used when there are expressions in the form that must only be evaluated once, so it generates some `let`s around the `lambda`. So `(cut memq  random-words)` is the same as `(lambda (x) (memq x random-words))`, and `(cute memq  random-words)` is the same as `(let ((g1 memq) (g2 random-words)) (lambda (x) (g1 x g2)))`, where `g1` and `g2` are effectively gensyms. But `random-words` is just a parameter. There's no effort involved in evaluating that. Also, you can merge the two `use-modules` forms into a single one: `(use-modules (srfi srfi-1) (srfi srfi-26))`. Also, your code isn't too long at all (I have seen some horrendous questions with over 100 lines). Thank you for posting code with enough detail for me to work on. :-) Can you show me your current code? I reread this answer. If you are going to cache, cache the values of `isWindows`, `isUnix`, etc. That way you save on the string comparison time also. @djechlin `'(1 2 3 4)` is a datum literal. You can't evaluate expressions in it. e.g., `'((+ 1 2) 3 4)` is a datum literal for the list `((+ 1 2) 3 4)`, not `(3 3 4)`. But, calling reverse on the result _is_ the standard way to implement this. @dzieciou I've finally updated the code to something that works with the latest Guava (18.0 at current time of writing). And this time, it's tested! If `TestB` subclasses `TestA` and the `age` field is protected or public, then you can refer to `age` directly in `TestB`. @soegaard I presume it doesn't really matter as long as they're all `eqv?`-comparable. You'd read in a form (rather than a line) at a time, but the rough idea is correct. I'd make two changes: 1. with SRFI 1, you can use `append-reverse`, which is more direct (it skips either two reverses, or one reverse and one right-fold, depending on how `append` is implemented); 2. I'd use `case` instead of `cond` (and its attendant `eq?` checks). @Zai But that's just an implementation bug, not by design. Maintainable code should not exploit that. Your solution is missing a `cons` somewhere. Anyway, the OP was wondering if there were a built-in way to achieve it, which there isn't. :-( Anything you can cons onto to build a list, by definition, is not a sentinel. Sure, I added an implementation of such. It's quite cryptic though (intentionally; there are less cryptic ways to write the same code), so have fun figuring out how it works! According to http://docs.racket-lang.org/htdp-langs/intermediate.html, `#f` does indeed work. It worked for me when I tested. In any case, you can use anything else instead, such as 0, `empty`, etc. It's just that in Scheme, we conventionally use `#f` for an "invalid" or "unused" value. As for the `compose`, it worked for me when I tested too (both in `#lang htdp/isl` and `#lang htdp/isl+`). But you can replace that with `(compose f (compose second list))`, or, to be less cryptic, `(lambda (_ r) (f r))`. You should search for `#f` in the page I linked you! It's the false value. @Ryan: Please read my second-to-last comment for the lambda version. @soegaard Of course, but its main relevance is as an unused value, since (as you can see in the lambda I posted earlier) it gets plugged in as `_`. "Needle" and "haystack" are names used in search algorithms. "Needle" is the thing to find. "Haystack" is the thing to look in. See http://english.stackexchange.com/q/120218/1825 for more information. As for `pair?` (not `pairs?`), this is called `cons?` in ISL. (`pair?` is the standard Scheme name, though, not `cons?`.) @JoshuaTaylor It could be slower, but it'd still be constant time, albeit with a greater constant factor. @bartektartanus We have moderators who are age 13. Anyway, there are other things to focus on, like the candidate score. :-) @ColeJohnson Close, except that with `stosd`, the individual bytes in the dword can have different contents. @GregHendershott Yes, `call-with-values` is the ultimate plug-in-your-own-continuation system. I've actually used `case-lambda` with `call-with-values` on occasion, though I have not tried using keyword arguments! I think my reason for not trying the latter is that I don't believe `values` supports that: you'd have to directly call the continuation to use keywords. `defun`, `let`, `lambda`, etc. have a section for the code body. I'm voting to close this question as off-topic because Stack Overflow is not Rosetta Code. You could have used internal definitions for `a0` and `b0`, but `let*` is fine too. Also, personally, I prefer to use `integer-sqrt` (or `exact-integer-sqrt` as it's called in R6RS) so that no floating-point numbers are involved. To step back from this discussion a bit, I feel that [Thomas Ptacek's post](http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-secure-password-schemes.html) (in response to a [Jeff Atwood post](http://blog.codinghorror.com/rainbow-hash-cracking/) on a similar topic) explains best why you should not use anything like MD5 for password hashing. Recommended reading. Lemme reformat your code (only the first one; don't have time to reformat your second one) and see if the method is obvious. :-D @JamesPatterson Updated my post to answer your new question. @Pacerier See http://en.wiktionary.org/wiki/boggle and also http://en.wiktionary.org/wiki/mindboggling. @HAruMOmo When someone answers your post, please use the green tick to accept the best answer, rather than deleting the post. 1. You do not use commas for separating arguments to a function call. You use spaces. 2. You are missing either a `twenty` or `fifty` argument. Your function call, thus, should be `(sum 3 1 2 0 0 2)`. My second point has still not been corrected. Your function takes 6 parameters but you only passed 5 arguments. In your specific case, you really should make your function take keyword (named) arguments. Lemme write an answer to demonstrate the concept. Standard Scheme does not have optional parameters. @Predator44 The syntax described in the page you linked to is available only on Racket, as well as Scheme implementations that provide [SRFI 89](http://srfi.schemers.org/srfi-89/srfi-89.html). But it's not part of the Scheme standards. @sjamaan I like your idea, but it doesn't quite pertain to the OP's case where they want to omit arguments in the middle. :-( (Oh, and small world! I always enjoyed reading your IRC messages.) @DanF: `x ** y` is `pow(x, y)`, except in the case of `2 ** n`, where `n` is an integer, you can use a table lookup. The inputs are `x` (a floating-point number, separated into the exponent `n` and mantissa `f`) and `y`. @DanF The punchline is in my answer. Second-to-last sentence. :-) @soegaard Oh, it's okay, it's just that I hand-indented (including the correct semantic meaning of `trace-lambda`), so I prefer to keep that. :-) @Hunter If you are using the container correctly (following all the correct iterator invalidation rules, not having any dangling references, etc.), hinted insertion does not erase or overwrite any entries. Either the hint is correct, in which case the item is added to the right place with O(1) runtime, or the hint is incorrect, in which case it falls back to using unhinted insertion (with O(log n) runtime). @Hunter Can you show me your code? If it's not massive, I can probably review it for you. @xebtl I presume the OP means non-tail-recursive. Right, macro "calls" don't evaluate anything. In fact, suppressing (or otherwise delaying) evaluation is a major point of using macros. @WanderingFool Yes, I'll be happy to elaborate more when I get home. Had errands to run shortly after posting my answer. @chux Even if computer hardware provided efficient decimal floating point, many _programming languages_ are specified to use binary floating-point. So, I don't think the dominance of binary FP is going away any time soon. @WanderingFool I hope my added explanation, using a simplified floating-point format, makes it easier to understand and verify. :-) Please feel free to ask for any further clarification needed. @WanderingFool Also, if (as your question states) you care about precision in the decimal realm, you may prefer to use decimal floating-point if your language supports it. Then you'll have no uncertainty about the precision offered by your numbers. @WanderingFool `**` is exponentiation. I'll clarify more when I'm at a computer. @WanderingFool Okay, updated the post to use superscript for exponentiation now. :-) Anyway, the sign doesn't affect the precision at all: if `s == 0`, the number is positive, and if `s == 1`, the number is negative. That's all. If I understood your use cases correctly, you need to use parameters, which establishes a "scope" for the overridden `x`: so in your first case, you'd establish a parameter that is in scope for your top-level `define-let` invocation, but would be out of scope for your macro-that-calls-`define-let`. Since you're binding data rather than syntax for your `x`, you'd use normal parameters, but Racket also provides syntax parameters for cases that need it. It's technically available in top-level (assuming that's where your syntax parameter is defined), but if you make its default binding call `raise-syntax-error` or the like *during the macro-expansion phase*, it may as well be the same as not existing. I cannot imagine any Scheme implementation where the two forms would be treated differently at all, assuming we are talking about the implementation's default implementation of `define`. Thus, your answer is exactly equivalent to Óscar's answer, so it's not an alternative per se. Here's a showoff answer for you (it macro-expands to exactly the same thing, but looks cooler; requires [SRFI 26](http://srfi.schemers.org/srfi-26/srfi-26.html)): `(define add1 (cut +  1))` :-D @ayshee Óscar is referring to [my answer](http://stackoverflow.com/a/5741004/13), in which I answer that question in multiple ways, depending on your performance and/or portability requirements. Because there are multiple ways to solve it, there's no point repeating the answer in this thread. To add to ALassek's excellent answer, many wireless interfaces do not support promiscuous mode, and therefore cannot support bridged networking either (I'm not implying that you're in this situation, just mentioning it for the record). So yes, NAT is the first port of call in such cases. @natenho `-pthread` does different things on different platforms, but all of them, in some way, enable pthreads to work. So, omitting `-pthread` may cause pthreads not to work (or not work reliably), or it may do nothing for platforms that already has pthreads support enabled out-of-the-box. @ticktock The outer _types_ are the same, but the outer _instances_ (which is what the `getOuterType` returns) are not necessarily the same. That's what the comparison is for. @AntarrByrd In Ruby, `begin` is like `try` in other languages. The `else`, here, means, do this if no exceptions have been thrown in that `begin` (`try`) block. @AntarrByrd With one difference: the exception handlers will be disabled in the `else` (while still being run before the `ensure`). @sjamaan Thanks for the correction! Is there a way to use `syntax-case` in 4.9, and if so, how? Scheme (and Lisp) isn't C; it doesn't have addresses per se. It has object references, which (conceptually) always refer to a whole object, not parts thereof. So, an object reference to a cons cell refers to the whole cons cell (even if it's typically implemented as a pointer to the location of the start of the cons cell), an object reference to a string refers to the whole string (and not individual characters in the string), an object reference to a vector refers to the whole vector, etc. It is, in fact, very much like the question of whether sin π = 0. Again, no FP implementation I have here shows it to be 0, thus, I suppose the "dispute" cannot fully be resolved 100%. But since we're talking about FP, approximate solutions will have to do. :-P Many programming languages have a complex-number class, that simply holds two `double`s. To me, that's good enough, if the language also has facilities for doing (some sort of) overloaded operations on them (e.g., the use of `cmath` in Python is okay, despite not being strictly an overload). I haven't used Maple, so I can't comme Bingo! My question indeed is to see which implementations employ some sort of fudge factor to make the answer closer to 0 than others. One way to do this, for example, is to have a special quantity π, much like many languages have a special quantity i for complex numbers; numbers are then stored in terms of multiples of 1, i, and π, as appropriate. Of course this probably shouldn't be built into the central language, but a library module to do this transparently would be nice. And it will make a variety of trigonometric operations more precise (if special versions are provided by said library @Benj Thanks! Upvoted. @sawa I agree, but, then the list won't look very randomised. So the second shuffle is for...cosmetic appeal. ;-) @DJGummikuh Nice! I've updated the post to use the newer-style `-agentlib` option for your cutting-and-pasting pleasure. :-) I find that an explanation of named `let` in terms of `letrec` to be too unwieldly. I usually prefer to make reference to `rec` (from SRFI 31), which is a nicer syntactic sugar around `letrec`. The translation from unnamed to named `let`, in terms of simply adding a `rec`, is simple and easy to reason about. Also, with `rec`, you don't need to explain the acrobatics around "notice that the body of the `letrec` just evaluates to the named procedure so that the name isn't in the environment of the first call". `rec` is easy to reason about. Just use that. :-) Scheme has warts?!! :-O I actually just explained the code in terms of an internally defined function. That is `lambda` without actually saying the word `lambda`. :-) Anyway, yes, `letrec` is the most powerful of the three (since you can use it to create mutually recursive functions), but it's often overkill (syntactically speaking). In the same way, `case-lambda` is (syntactically) overkill when you have only one "case", and can just use `lambda`. (Don't laugh. In Guile, all lambdas are represented as case-lambdas behind the scenes.) [How is `letrec` implemented without using `set!`?](http://stackoverflow.com/q/8468421/13) Also see: [Fixing Letrec (reloaded)](http://www.cs.indiana.edu/~dyb/pubs/letrec-reloaded.pdf) @ScottHunter Yes, download the Gist that the OP has posted, and run it in a DrRacket instance. Let us [continue this discussion in chat](http://chat.stackoverflow.com/rooms/86562/discussion-between-chris-jester-young-and-sylwester). @connexo Okay. How would you program your pizza rotator to get 36 degrees? What is 36 degrees? (Hint: if you are able to define this in an exact fashion, you also have a slices-an-exact-tenth pizza cutter.) In other words, you can't actually have 1/360 (a degree) or 1/10 (36 degrees) with only binary floating point. @connexo Also, "every idiot" can't rotate a pizza _exactly_ 36 degrees. Humans are too error-prone to do anything quite so precise. @ErwinRooijakkers Glad you like. Yep, use `list->vector` to convert to vector afterwards (better to do it yourself than make the original functions do it). [*My* sieve implementation](http://codereview.stackexchange.com/q/75058/216) (linked in my answer) does put in a 2, but the Community Scheme Wiki one (that you copied, and that I adapted for this answer, mostly to show you how I would refactor it) doesn't, so I edited it to put in the 2 there too. :-) @ErwinRooijakkers As for needing to have fast lookups, are you using a binary search on the vector? If so, and if you're using Racket, consider using Racket's sets (you can use `list->set`, or, since we're holding numbers only, `list->seteqv` is faster). There are mutable sets (based on hashtables) and immutable sets (based on AVL trees), so choose whichever type you prefer based on the performance characteristics (and ordering, if needed) you like. @ErwinRooijakkers If you're talking about the `prime-sieve` in this post, it returns all primes below 2n. It does **not** return n prime numbers; there is no efficient method for doing that (at least, not based on Sieve of Eratosthenes). Even [my implementation](http://codereview.stackexchange.com/q/75058/216) is named `primes-up-to-about` for a reason: the n specifies an upper limit of the search, not the number of primes. In other words, assuming a hypothetical SQL table named `primes`, you can query for `SELECT val FROM primes WHERE val < n`, but you cannot query for `SELECT val FROM primes LIMIT n`. :-) But! If you know a priori the number of primes you want, you can use https://primes.utm.edu/nthprime/ to look up what the nth prime is, and then use _that_ as an upper bound for the function here. :-) (Hint: the function here uses a _lot_ of memory if you're doing a big search. [My implementation](http://codereview.stackexchange.com/q/75058/216) is more space-efficient, since it uses a bitset instead of a vector (i.e., uses one bit per odd number, rather than one pointer per odd number).) You can use an internal `define`, which allows you to define a function without using the word `lambda`. @Caesar Please go to https://racket-slack.herokuapp.com/ for your invite! You say the `string-append` approch is more elegant, but I cringe when I see it. It's like seeing string `+=` in a loop (versus using a `StringBuilder`), which is a Schlemiel the Painter problem. @JacekCz I think the OP means that he wants implementations of that interface to automatically inherit those annotations, so "not work" means that those annotations didn't get inherited. @StephenDundas Yep, anchor all the regexes with `^` and `$`. I'll edit my answer to incorporate. @PeterLawrey Right, that's exactly what the OP is asking. She wants to know how to work out the time complexity (hence my retagging of the question). You can do recursion using `cons`. Doing recursion with `append` (or anything related to it) is just asking for Schlemiel the Painter. :-) You can, for example, cons up a list of strings, then do one single `string-append` with the results (using `apply`). @Anders I did that for the OP. @Olaf No need to close; homework questions are okay on SO: http://meta.stackoverflow.com/a/253794/13 @KatherineKewl Still O(n), so Peter's answer still applies. @KatherineKewl No, it'd only be O(n³) if the `k` loop were nested _inside_ the `j` loop. @KatherineKewl You should still look at all the loops, but you'd take the highest-order one. For example, both the `j` and `k` loops are O(n), so the highest-order is still O(n). Don't downcast if you can help it. It's a code smell. Hence, my answer mentions adding enough methods in the interface to allow the type-specific operations to be done without downcasting. The compiler won't let you assign a `Question` to a `MCQ` or `TrueFalse` without downcasting; so if you don't downcast, a `ClassCastException` won't result. ;-) @Olaf That explains how Robert does things, not how he thinks everyone else should do things. Shog's answer is higher-voted anyway, so it seems the community agrees with him more. @Byte `(list null)` returns a list of one element. `(list)` returns a list of zero elements. `(list null)` returns the same thing as `(list (list))`. It's not idiomatic because Racket (and Scheme) people tend to prefer to write code in functional style (as little mutation as possible). Of course, some data structures, like vectors, will probably require mutation to be efficient, but there are only limited circumstances (like random access) where vectors are useful. Most of the time, you can use standard lists, and for those, you can be 100% immutable/functional. The `for` is actually a comprehension (and is not related to the C-style `for` loop), and does not involve any mutation. So it's totally functional and idiomatic too. You look like you're trying to parse CSV. You should use the `csv` gem. Don't try to manually parse CSV; it's complicated and most of the time it's better to use the gem. @Amadan Thanks, fixed. (Technically stdlib != core, either, but that's just being pedantic.) I don't know, but my script makes it so that it works correctly whether it's a pipe or not. Pretty much. Test it and see! If it doesn't work, link a Gist here and I can try to debug. @user3366240 `(list v w)` is a list of two elements (the first element is `v`, and the second element is `w`). It is more idiomatic to write `a.inject(:+)`, however (or `a.inject(&:+)` if you're really attached to passing in a proc). No, you have too few parens around the variable bindings in the `let`. This is not Clojure. :-) What terminal program are you running your Python code in? Most standard terminals know how to handle `\b` correctly. Sounds like you should send an IDLE bug report. ;-) @Joshua Thanks! I'll remove that comment then. @Joshua That's awesome. That behaviour is not permissible in Scheme (for better or worse). @πάνταῥεῖ Actually, the semantics are pretty straightforward given the function names and types. It's defining an "interface" of sorts (albeit not with pure virtual functions) for subclasses to override. The `uint` is probably the property ID, the `QVariant const&` is probably the new value for setting with, and I have no idea what the optional `IContact` is for. Also, although I haven't done any Googling, `QVariant` is probably a variant type from Qt so this is probably from a KDE program or library. It's still just a guess, of course, but in a minute I'll Google it and I'll get a clearer picture. :-) Yeah, Googling for `"qvariant getproperty" icontact` didn't return any useful results. :-( @psychedelic_alex `malloc` doesn't clear the memory first. This is usually faster than `calloc`, and since your program doesn't rely on cleared memory, it works just fine. The + 1 is because you need to allocate the extra character for the NUL terminator. Or, you know, what Weather Vane just said. ;-) Did you enter the command _exactly verbatim_ with no spaces before and after the first `*` and no spaces before the second `*`? I figured that's what your question was about. You don't need to use `eval` at all. Please don't use `eval` unless you really have to. You can invoke functions `f` and `g` by just calling them, no `eval` needed. :-) @Jac You have to use `(F 1 2 '(2 3 4) (lambda (x) (+ x 1)) (lambda (x) (- x 1)))` (or just `(F 1 2 '(2 3 4) add1 sub1)`), not the notation you have. @Jac Here's one possible way to define `even?`: `(define (even? x) (zero? (remainder x 2)))`. Here's one possible way to define `odd?`: `(define (odd? x) (not (even? x)))`. `while (foo) { break; }` makes no sense. It's literally equivalent to running `foo;` directly. You could have just said `while (!foo) {}`. ;-) The new approach? It's just more verbose, that's all. (I've already explained what's wrong with the old approach.) Alternatively, the OP intended to do `(list "foo" "baa" "baz")` instead, but just had sloppy punctuation placement. That depends on what's inside the loop, doesn't it? You need to show what you plan to run inside the loops in question. @Blorgbeard It may not be nothing if it the content of the loop involves accessing `foo[i][k]`, for example, and one order causes a column-major iteration (which is slower). But, it really depends on the specifics of what's being done in the loop. Classes in Java belong in _packages_. If you try to use a class in a different package from the one your class is defined in, you have to either: 1. import that class (or package), or 2. specify the class's fully-qualified name. Yep, that's the standard way to do it these days. But even if that method didn't exist, it's easy enough to just use `comparator = E::compareTo;`. Except, in this situation, you can (and should) use `flet` instead of `labels` because your `double` procedure is not recursive. @William In this case, there's no difference between using `flet` or `labels`. The main difference comes when you're referring to the name that is being defined (`double`, in this case): if you use `flet`, any references to `double` refers to a `double` that was defined before the `flet`; whereas if you use `labels`, any references to `double` refers to the function you're defining here. @William To make it easier for people to read your code, it's better to reserve the use of `labels` for cases where a recursive function is really being defined, so that when people see `labels`, they automatically think "recursive function". Can you send me your current code in a gist? I did the fixes I mentioned and it worked for me. (Note, `@tasks = {...}` or `self.tasks = {...}`, not just `tasks = {...}`.) I updated my Rake to 10.4.2. With the `optparse.parse!(ARGV[2..-1])`, it worked for me, but I used the `rake` command _exactly_ as I wrote it. (No space within `-c1` or `-e42`, and using `=` instead of space in `--from_date=foo`. If you use spaces, `rake` will cry.) Although not directly related to your question, I wrote in depth about left- and right-folding some time ago: http://codereview.stackexchange.com/a/87626/216. It even includes an implementation of things that are very much like `map` and `filter`. @PiotrSkotnicki It's C++/CLI syntax, IIRC. (C++/CLI is an ECMA standard so while it's not standard C++, it's still a standard nonetheless.) @Alex No, that's why namespaces. :-P @PiotrSkotnicki Yep, that's why `auto` is so useful, less risk of getting it wrong. (But the OP was copy-constructing `std::pair` from it so that was still valid.) @Alex Putting anything in the global namespace is an antipattern. ;-) @jay But you should still use `auto` (see my answer)! @NathanOliver C++/CLI is actually an ECMA standard so it's not correct to call it nonstandard, but of course it's not standard C++. ;-) @ChristianHackl Thank you! I will edit. That would still be creating 3 instances. In the OP's case, a value type seems more appropriate, anyway. @ryanyuyu But if the OP made `StatsFile` a value type, as suggested in my answer (and yantaq's answer), then the objects won't need to be "distinct", since value types don't have identity. @DanBryant I agree that creating a mutable value type _just_ to avoid creating instances is a bad idea, but in this case, looking at the problem domain, it does seem a value type is appropriate. Each user can set which sites they will allow geolocation for. When your phone/device/computer first accesses a site which requests geolocation, you will be prompted for permission. If you deny the permission, then no geolocation information will be returned. Well, since I don't know anything about Codepen, and it seems Duncan knows what he's talking about, I guess that's the situation. @ChristopherDumas Don't delete questions (within 30 days of posting); [doing that may damage your ability to ask questions in future](http://meta.stackexchange.com/q/86997/13). Instead, just let someone answer the question (or answer it yourself), and you can accept the answer if you want. I actually wouldn't `set!` `a-word`; I'd just tail-call the function with the new parameter value. @soegaard They'd also have to change the base case to 1, if you want to change the base case test from -1 to 0. ;-) There is no builtin way to do this. You need to manually pick apart the `PATH` elements and search for `notepad.exe` in each. @duffymo It is brittle, but there is no alternative (unless you shell out to `where`, as noted in Amila's answer). Even the [`which`](http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/which/which.c?rev=HEAD&content-type=text/x-cvsweb-markup) command-line utility (Unix version of `where`) is implemented that way (i.e., there's no library function for doing `execvp`-style lookups). @ÓscarLópez It's probably a good idea to mention that using `(append lst (list x))` in a loop is, in general, an antipattern, and that the better pattern is to use `(cons x lst)` in the loop and reverse afterwards. Well, of course eager comprehensions are much more lightweight than streams. ;-) I should actually write an `in-iterate` sequence generator that can be used directly with `for` comprehensions. I've posted my `in-iterate` as a new answer. What I like about it is that it handles multiple values without making the user do funky argument packing and unpacking (unlike Óscar's answer and my initial answer). Actually, I'd like to see that become part of Racket's standard library someday...(my code is released under "public-domain-style" CC0, use freely with or without attribution). Except, `DataOutputStream.writeUTF` writes busted output ("modified UTF") if you use non-BMP characters. @interstar There's no really easy way to digest `in-*` implementations; they're written using a special domain-specific language (whether that's `make-do-sequence` as I used, or `define-sequence-syntax` as soegaard suggested). But if you like to learn something new, it'll definitely serve that purpose! As for the _usage_ of `in-iterate`, that's easier. For the one-argument case (the `(curry * 2)` example above, which by the way is the same as `(lambda (x) (* 2 x))`), that should be pretty straightforward. The two-argument case just extends the concept (and the function you pass in) to use two arguments, and two return values. @soegaard I wrote a first cut of a `define-sequence-syntax` version. I'm a total noob at this, though, so I welcome any critique you have! (Actually, I should post this to Code Review Stack Exchange and see what feedback I get. :-P) @weima If you don't want to use it, just don't use it. There are some things, as mentioned in my answer, that you can't easily do without an `ObjectFactory`, so suppressing its generation is not something people generally want to do. Why so many O(n) operations? ;'( (That's Rosetta Code for you, I guess.) Very nice! You're quite a `format` wizard. :-) (Yes, I did test this for you.) I +1'd your answer in that it works, but I can't imagine why you'd want to do such a thing (unless you're implementing a reader for a custom, non-Scheme language). In Scheme, using `|` in a symbol is a way to "quote" a symbol so that it can contain arbitrary characters (e.g., `|foo bar|` is read in as the symbol corresponding to `(string->symbol "foo bar")`); by redefining `|`, you take away the ability read in symbols with arbitrary characters. @ÓscarLópez `(apply string-append acc)` is fine for Scheme implementations (like Racket, IIRC) that accept very large lists for `apply`. `string-concatenate` is the internal loop used by `string-append`, essentially. Relevant to @immibis's comment, if your list type is one of the Guava immutable types, or is one of the `java.util.concurrent` container types, those are known to forbid storing nulls. @Jack All updated. Enjoy! @AqShvartz R5RS mode implements the R5RS Scheme standard strictly. And, standard Scheme does not permit using square brackets as an alternative to round brackets. This is by design. @rwst I can't comment on MSVC specifically, but if it implements the C++ and C standards faithfully, then that will indeed be the case. See also: http://stackoverflow.com/questions/2376448/the-written-versions-of-the-logical-operators#comment37306872_20642363 @user5500724 Alexis's comments are all correct, but, I've posted a wholly new answer just for reference. You should still follow her advice if you want to use your solution approach. @legends2k 2dd just means "2 decimal digits" (by which we mean significant digits, so e.g., in 0.5, only the 5 is significant, and the 0 is not). In the first table, the "2dd" refers to (in the case of 1.2, for example) the digits 1 and 2. @user3610137 Sure. For example, use `(cons (car X) (testFunc (cdr X) (cdr Z)))`. @user3610137 On Stack Overflow, we are supposed to turn a blind eye as to whether questions are for coding puzzles or homework or what not. That means that I write answers the way a professional programmer would solve the problem. "Can't use map/min" is irrelevant to that aim; to a professional programmer, basic language functionality is definitely not out-of-bounds. @user3610137 As for whether you can do `(cdr (testFunc X Z))`, it's syntactically valid, but you'll find that you'll be doing infinite recursion.... ;-) The JIT compiler could indeed make such an optimisation on the basis that `i` is dead after the increment. Whether it actually makes such an optimisation is another question. The Java-to-bytecode compiler will not optimise that for you, though; the increment will be in the bytecode. It's 100% up to the JIT compiler to optimise. That's not answering the OP's question, which is whether the `++i` gets optimised to `i + 1` on the basis that `i` is dead after the call. Of course the OP already knows what `++i` does. That's not answering the OP's question, which is whether the `++i` gets optimised to `i + 1` on the basis that `i` is dead after the call. Of course the OP already knows what `++i` does. Also, some patience please: I downvote first and explain later, not the other way around. ;-) Of course it does. But the OP's question centres around the `i`-is-dead-after-`++i` case. The OP's question could be clearer, but if you read carefully, you'll see what's actually being asked. True, "in general" there is a difference, and I think the OP should clarify the question to narrow it down. I'll retract my downvote on the basis of your "in general". The bytecode is of course different. `javac` in general does not optimise the bytecode that's generated; it leaves the optimisation work to the JIT compiler. The question of interest is whether the JIT compiler actually does optimise out the increment. The question does not say that it's the last instruction. That's not relevant, anyway: it revolves around the OP's assumption that `i`'s value is not used after the `++i`. In such a case, the JIT compiler could indeed optimise out the increment. @M.M My original answer did use `vector`, but I didn't want to risk any danglingness, so.... (Granted, a non-problem for `argv`, but in general.) @nodakai Great! Then just use the appropriate `vector` type and go from there. It's the common way to do variable-sized-array-like things in C++. I went the opposite way in my answer: my constructor has an explicit `Objects.requireNonNull` call in it. That way, `equals` and `hashCode` don't need to worry about nulls. @R.DM The hash code is used when using your object as a hash key. The "contract" of hash codes is that equal objects (all objects `a` and `b` where `a.equals(b)` returns true) must have the same hash code. If you don't override `hashCode`, the default hash code is the "identity hash code", which is different for each object, even when they compare equal using `equals`. That's why it's important for `hashCode` to compare exactly the same fields as `equals` does. Why would you only compare the first character of the name? Also, all the nested `if`s could be done away with more extensive use of `&&`. @PaulBoddington Thanks, I added `final` to the fields too so the hash code is invariant. @Jester Ah, thanks! The indentation threw me off, sorry. (That's what being a Schemer does to you.) It's more akin to `eax += 200`, `eax += ebx`, and `eax += ecx`. Sure, but I wanted to avoid the `a = b + c` construction because x86 does not have 3-operand add. [`eval`](http://www.lispworks.com/documentation/HyperSpec/Body/f_eval.htm) does not have access to lexical variables. This behaviour is by design. `((lambda (x) (+ 1 x)) 10)` is the expression you want to run. You *can* use `eval` to splice in the `(+ 1 x)` into the lambda, though that's still pretty hacky. What are you trying to do? @mloskot It works again. But the whole point of a BST is that the elements are ordered. So you can stop the traversal once you see an element that's greater. @coredump- Or don't quote in the first place. The OP said they have to use `cons`, not that they have to quote everything. A 64-bit application can't use an in-process 32-bit COM object directly; you'll need to use an out-of-process COM object. It's possible to write a 32-bit out-of-process COM object that consumes the in-process COM object, and exposes an out-of-process interface for your 64-bit application to use. @RussAbbott Did you include any modules that did redefine it? You may wish to post your code in a Gist and link it here, because that error message does imply that it was redefined one way or another. @MichaelCole _Conformant_ implementations of `Intl` are supposed to return `undefined` for the `timeZone` property if you didn't manually specify a timezone in constructing the `DateTimeFormat`. Chrome deviates from the standard by returning the system's timezone instead; that's what Johannes's answer exploits, but also why he said "doesn't actually follow the standard". @user3171597 Not easily. You can sort the result afterwards (by length then lexicographically), but trying to build that order into the function itself would make it much more complicated than it should be. Wow, I just realised I had already written an identical implementation (including the same ordering) two years ago: http://stackoverflow.com/a/20623486/13 That order that you want is really really hard to do in recursive way, and I think trying to do a non-recursive solution is blasphemous (Scheme is generally about doing stuff recursively). @DavidAldridge I agree the gains may not be worth it, but FWIW you don't have to rewrite much of anything. That's one area where Ruby's support for monkey patching really shines. @DavidAldridge The strings aren't being copied or anything, whether or not you freeze them. If you're really trying to minimise memory usage, you don't have anything to do. @KevinKuegler Because in C (and C++), you can't pass arrays to functions; they decay to pointers. So the length is lost. The `size_t` parameter allows you to specify the length. This is an alternative to the "C strings" approach in my answer. In Scheme, the "single datum" version is not valid; the clauses must always consist of a list of datums. Also, these datums are always compared using `eqv?`, so strings and non-empty lists will never (reliably) match. Cool! You should also either remove the `(lambda "equal")` case or mark it CL-only. @Tanin It is if you round the result to double-precision (53-bit mantissa) afterwards. If you use an arbitrary-precision calculator, like the one you linked to, of course you'll get different results. "Checksum"? Do you mean the commit number/"hash" of the revision that your current Racket installation was built on? @3noch Speaking of "sweet", I must confess to mentally reading `irange` as `orange`. ;-) `(define (sum-alt-squares n) (* 1/3 n (sub1 (* 4 n n))))` (thanks, [WolframAlpha](http://www.wolframalpha.com/input/?i=sum_i%3D1%5En+%282i-1%29%5E2)!) @marwei Yes, without a doubt. Repetitious code is a maintenance nightmare. @Diligent The only other exception-safe "proper way" is to dispose in a finally block, and in most cases `using` is more preferable to _that_. (I reread your answer and it doesn't suffer from the O(n²) problem I mentioned. But a naive implementation using the accumulated list as the left-hand argument to `append` would be wrong.) Here, have a +1. Your answer is fine (sorry for misreading your answer in the first place). A wrong answer would be something like `(define (append* . lsts) (foldl (lambda (lst acc) (append acc lst)) '() lsts))`, which would be O(n²) (where n is the total length of all-but-the-last input list), because of the way `append` works. @oren Huh. In doing research for an upcoming blog post to answer naomik's question, I've discovered that standard Scheme `append` is already variadic and already does what you seek. Are you sure you need to write any code at all? (Edit: Oh, I reread your question. You're implementing your _own_ `append`. Today's not a good day for my reading comprehension, it seems. :-P) The blog post is up now: http://qr.ae/ROZpq7. I hope this explains the situation better! /cc @oren Manual searching is not necessary. You can use `Collections.max` as suggested by Steve Kuo, or in Java 8, use `Arrays.stream` to convert the array into a stream, then call `Stream.max`. @Neuron On the contrary, in professional code (which I always assume questions on SO are about, unless the OP says otherwise) it's important to use library code rather than reinventing the wheel. :-) @Neuron I've just added a Java 8 solution. Between your answer and mine, I think we have all bases covered. :-P @Neuron To test your claim of "if performance is not a big issue", I decided to write [a little program](https://gist.github.com/cky/ac45ccc5e1548b86075e) to test the various solution approaches. There are some surprising results in there.... On my computer, from fastest to slowest: nullable (2.4 ms), collections (3.1 ms), stream (4.6 ms), optional double (5.7 ms), optional (15.8 ms). The optional double and optional results actually surprised me a lot. Worst-case (elements in ascending order) performance on my computer: nullable (2.2 ms), collections (3.2 ms), stream (4.6 ms), optional double (8.5 ms), optional (17.6 ms). This appreciably slowed down the optional double and optional results! I don't fully understand your question, but from what I can understand, it sounds like syntax parameters is the way to implement it. If you can post what your expected before-and-afters are, I can try to cook something up. :-) Do you have the code to your `nodeToDotFormat` member function? Warnings that aren't useful can be suppressed, with `-Wno-incompatible-pointer-types` (for gcc) and `-Wno-incompatible-pointer-types-discards-qualifiers` (for clang) in this case (that's why the warning message shows the warning flag that activates it: so you can suppress it if it isn't useful to you). Then you can continue with `-Werror` without problems. @ayshee Show us your code. We can help you make it work with "The Racket Language". @texasbruce I'm aware. I can't tell the OP why the warning is shown by default in C but not in C++, since I'm not a gcc or clang developer and I didn't implement the warning criteria. What is `the` (in `(the y ...)`)? It's not defined in default Racket. Is it from a library you're using? That's missing the point. Even in C#, where type erasure doesn't happen, a `List` can still hold both strings and integers, because strings and integers are both objects. `obj.toString()` is not null-safe (`String.valueOf(obj)` is). But anyway, the `%s` format specifier can work with any object, so just use `String.format("%s%n", obj)`. Here's an answer in Google Spreadsheets: https://docs.google.com/spreadsheets/d/1wi8_m1nQWtXhzG6dHFRUeT36vRGO3n5mAG5gAKUNWdI/edit?usp=sharing If you use the numbers (7.5% per annum interest rate, compounded monthly) and formulas in that spreadsheet, you'll quickly figure out how to code that in C++. You cannot do it with only 2 variables. You need a third variable, that keeps the element count, while retaining the skip count. Here's an example solution: http://stackoverflow.com/a/35366463/13 @g-v While technically true, that post doesn't answer what a return code of >=128 means. :-) @g-v Jonathan Leffler's answer on that thread is excellent and I upvoted it. Thanks for the pointer! That's because `t` is an lvalue (of type `T&&`, which simply means it will match an rvalue argument, not that `t` is itself an rvalue), not an rvalue. The `std::move` is to make it an rvalue. @vaxquis See [`AbstractList.clear`](http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/e2117e30fb39/src/share/classes/java/util/AbstractList.java#l233) and [`SubList.removeRange`](http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/e2117e30fb39/src/share/classes/java/util/AbstractList.java#l666). :-) @vaxquis I've edited the post to add those links. Re `ArrayList.removeRange`, yeah, since the `numMoved > 0` check is already in `ArrayList.remove`, it should also be in `removeRange` for consistency. @Arc676 1. `equal?` in Ruby does identity comparison. Each string literal, like `"foo"`, creates a new string instance. It works that way because strings in Ruby are mutable. 2. Symbols are global, but more like global constants than global variables, since symbols do not have state. Thus using symbols is not an antipattern in the way that global variables are. Try this: . See  for useful background information too. @KrissyMichaelsson Can you edit the question to include the code you wrote, that caused the infinite loops? @KrissyMichaelsson I edited my answer with a (hopefully) fixed version. Good luck! Deleting answered questions isn't the Stack Overflow way—we want answers to be able to help others with the same problem! So I'm going to revert your most recent edit. @molbdnilo [You can convert a named `let` into a `rec`+`lambda`](http://qr.ae/RUymgf), but `rec` still uses `letrec` behind the scenes. :-) Can you paste the contents of your `config.log` file to a [Gist](https://gist.github.com/), and link it here? I mean that I believe your local copy of libtool (in `$PREFIX/lib`) is misconfigured somehow to refer to `/usr/lib/libdl.so`. It should just use `-ldl`, without reference to `/usr/lib`. (Not sure what platform you're on, but on my Debian system, `libdl.so` is in `/usr/lib/x86_64-linux-gnu`.) As for your second question, I have used Guile for a long time and know the GNU build tools fairly well. :-) Yeah, you should probably rebuild libtool, and run `make check` to ensure it works correctly. If you're using pretty standard flags and it still creates a borked `libltdl`, Gist the libtool `config.log` and I'll take a peek at it when I find the time. Yep, feel free to post a new question with your new problem (again with the new `config.log` output). :-) @ScottHunter `('())` is clearly erroneous, as are the double brackets around `convert` in the 4th line. ;-) @ScottHunter Actually, many newcomers to Scheme don't realise that brackets are syntactically significant until someone points it out to them, especially if they come from other languages. I see questions about this on SO all the time. @TimothyWalker You're getting close. You just need to replace `'(modulo n b)` with `(list (modulo n b))`. (There are very important differences between `'(foo bar)` and `(list foo bar)`.) Technically, `fma` is defined in `libm`. But it seems Racket already has `libm` preloaded (I checked by running `ldd /usr/bin/racket`), which is why you were able to use it without having to explicitly load it. I would, as explained in my answer, clarify the comparing vs modifying of literals: comparing literals may give you unexpected results, but won't actually cause nasal demons, whereas modifying literals is totally nasal demon territory. @naomik JS, Ruby, and PHP are not homoiconic ("code is data") languages, so they don't have a quoting facility. My favourite explanation of `quote` is to go into "data mode", where the quoted stuff is treated as data rather than as code. Feel free to ask more questions to help things make sense—I really want to help. :-) @naomik I especially like the approach taken by The Little Schemer books, where code and data are rendered in different fonts. It makes it immediately visually obvious which is which. Anyway, any time you want to embed data in code, you'd use `quote`. @einpoklum But it is exception-safe, unlike the other answer. ;-) @WillNess There is `do`, but a standard implementation of the `do` macro is to expand into a named `let` that calls itself via tail recursion. :-) @WillNess The standard suggested implementation of `do` (at the bottom of section 7.3, in the case of R5RS) does use tail recursion. It doesn't specifically use a named `let`, though what it does have can, of course, very easily be written as a named `let`. @WillNess Correct. I still conceptually consider that a tail-recursive approach. @WillNess If we're talking about code-as-written, then I could extend your point to say that code using `foldr` does not recurse, syntax-wise, and that code using `foldl` does not tail-recurse, syntax-wise. But that seems like BS, because behind the scenes, it's obvious what actually happens. @AlexisKing Or, if the whole loop is being interpreted in the same function, it's possible to avoid `call/cc` entirely by making the (Scheme-level) loop take an extra parameter, that could take on values `'break` and `'continue` (for example). The test condition is then evaluated only if the mode is `'continue`. @ShadowRanger 100% agree with using `with`! @naomik A simple way to implement memoisation is to create a hash table, with the argument(s) as the key, and the result(s) as the value. The fun part is to write a function adapter to do all that behind the scenes so that you can memoise a function as simply as `(define func (memoise (lambda ...)))`. :-D @naomik That is indeed my plan. :-) @Jacket Yep, it's a protocol 31 feature. @Yakk C++11 lambdas are not like Scheme closures. In Scheme, locations have "unlimited extent" and it's not possible to cause a dangling reference. Whereas in C++ lambdas, you have to say whether a free variable reference is by reference or value; the former can cause dangling references. @jkiiski Not just "no need for that `lambda`", but that it actively causes the code to not work since `lambda` returns a procedure, which is always truthy. @tfb `first`, `second`, etc. are built into Racket. They're also available in SRFI 1 for other Scheme implementations. Exactly. :-) :-) @Elliott Not to pick on you or anything, but given that recursive mutex (as mentioned in my answer) is just another name for reentrant mutex, I'm not sure what "additional info" your comment provides. :-) Note that it's [more Lispy to use `~%`](http://www.lispworks.com/documentation/HyperSpec/Body/22_cab.htm) instead of `~n`, so I tend to prefer that to be kinder to others. But if your code isn't intended for reading by anyone other than Racketeers, then `~n` is of course fine. @JoachimPileborg That _is_ the definition of the mean. The OP asked for a **modern** C++ way to achieve this. A hand-written loop does not feel very modern. ;-) In Racket, you can also use `empty`. That might be easier to understand than trying to explain to people why empty lists aren't self-evaluating in Scheme (unlike CL and Clojure). Alas, using initial values of `-inf.0` and `+inf.0` forces everything to be inexact. :-( Try `(max -inf.0 0)` and see what you get in return. @naomik Interesting, [that's not what rudybot told me](https://botbot.me/freenode/racket/msg/63403827/). Maybe rudybot is running an older version of Racket? \*checks\* (Update: it currently runs 6.2.1.) It did. It evaluated `list-ref` as the truthiness condition (which is always true), and the `(cdr items)` and `(- n 1)` as the "then" expressions. The value of the last is returned. In Scheme, only `#f` is considered false. Every other value is considered true. No, `cond` clauses have an implicit `begin`, so more like `(if list-ref (begin (cdr items) (- n 1)))`. A `for` comprehension will stop when the shortest sequence runs out, so the `drop-right` is unnecessary and wasteful. :-) @Mars I actually understand Scheme streams very well, and I've looked at transducers a while ago and thought they were the bees' knees. So I'd be qualified to answer this question (heh, notwithstanding the OP's clarification that the question isn't really about streams or transducers). However, I'm also super busy and finding time to answer it has been challenging for me lately. But I have starred this question and will get to it when I can. Note that `and` and `or` work the same way when called with no arguments: `(and)` returns `#t` and `(or)` returns `#f`. Like Alexis's answer says, it makes the language more internally consistent and reduces the corner cases your code has to deal with. What didn't work with your remainder? What did you expect, and how did the program's behaviour differ from your expectation? It sounds like a straightforward operation. React doesn't have any querying capabilities. You'd have to use something like jQuery (or even plain Ajax) to "query information from a webpage", then feed _that_ to React components. @ssice Thanks! Edited the post. An added upside of using the `string->list` and `list->string` approach (compared to `string-ref`) is that on R7RS, `string-ref` (and `string-set!`) is allowed to be O(n) (for implementations where strings are represented internally as UTF-8, and so each character can occupy a different number of bytes). @flup Thanks for your kind comment, and for bumping up the post so I know to update it to current. :-) @AlexKnauth Thanks, that makes sense. I was trying to explain the concept of object aliasing and clearly I wasn't doing a fantastic job of it. :-) @Daniel My answer explains why: all your columns are actually aliased to the same object. I also provided a solution. @Daniel Pretty much. @benrudgers Thanks! Implemented. @benrudgers The question already says he's using Pretty Big; I just didn't know that Pretty Big doesn't have `for*` and I didn't bother to check. :-P Of course, Pretty Big doesn't have `thunk*` either. @LeifAndersen Ah, dynamically allocated call frames. I like. (I've always considered that a much more ideal way to implement continuations, as opposed to, say, stack copying.) Do you mean just connecting to servers on the Internet? It seems to be `com.apple.security.network.client`. If your app wants to _configure_ Wi-Fi, that's a different story (and I don't know which key to use for that). By using a [page table](https://en.wikipedia.org/wiki/Page_table). See also: [paging](https://en.wikipedia.org/wiki/Paging). Read ruthafjord's most recent edit: the segments are technically used to convert to linear addresses, which is then looked up in the page table. No, it's better to use `std::vector` (storing the `MData` by value) than `std::vector` (storing the `MData` by _raw_ pointer). Containers of raw pointer are an antipattern. If you must use a container of pointers, use a smart pointer like `std::unique_ptr`. But in this instance, it's not called for (it's just a struct with 2 `int`s); storing by value is better. The cast to `int` is superfluous: `printf` is a variadic function which means that the `char` is auto-promoted to `int` when passed in. @TrungNguyen In relation to your updated code: you should _not_ use containers of raw pointers like `std::vector`; it's too easy to leak resources, as your question alludes to. In this case, you should preferably use `std::vector`, but in general cases where you don't want to store by value, use `std::vector>`. @JohnColeman In Java, when you say `'a' + 1`, the `'a'` (a `char`) is promoted to an `int` first, before being added to the 1 (which is also an `int`). In C, `'a'` is an `int`. @BenjaminLindley It's true that if what you're containing is, semantically, just pointers, there's no problem. But people using it to hold dynamically allocated objects is such a common theme that when I see code where containers of raw pointers are used, alarm bells go off. And 100% agree that the real problem is using raw pointers to hold dynamically allocated objects, containers or no. You can also use `eqv?` to compare characters. But for good readability, I do prefer `char=?` unless there's a good reason to do otherwise. @formalizm I'm not sure what you're actually trying to do. You may wish to ask a new question about that, with details of what you're trying to do. :-) @Michael It's not as simple as that. If it were, you'd get a javac error and not a link error, as here. It's that the Selenium libraries got upgraded and it seems there's some binary-incompatible changes in the upgrade, where the old version had a final class that became un-final in the newer version (or vice versa). @AndrewParra Contrary to your expectations, your reorganisation of your jars probably _was_ what caused the issues. ;-) The stack trace helped me see that Selenium's `JsonHttpCommandCodec` was trying to load a class that failed to load; in the current version of `JsonHttpCommandCodec`, [on line 64](https://github.com/SeleniumHQ/selenium/blob/master/java/client/src/org/openqa/selenium/remote/http/JsonHttpCommandCodec.java#L64), it's trying to load `JsonToBeanConverter`, which isn't final. So I have nothing further to go on, unless you know which version of Selenium is being used. No, it's not common to see vectors used in this way. You'll have to look at the existing code to see why it used a vector. Maybe there's a valid reason. Are you able to use [Boost.Format](http://www.boost.org/libs/format/)? If so, your conversion would be much more straightforward. `printf("test %d\n", var);` becomes `std::cout << boost::format("test %d\n") % var;`, so you don't have to change the format string at all. BTW, I just saw your question on #racket on IRC. You should definitely stick around for longer than 2 minutes. IRC is mostly a lurk-oriented medium; you get best results if you just post the actual question (without waiting for anyone to respond to a "can anybody help?" solicitation) and then wait 24 hours for a response. :-) (But, as you can tell, both lexi-lambda and I were able to answer here, so that worked out after all.) As Alexis's answer explains, module-level `define`s affect everything in the module ("mutually recursive" was the wording she used, but still, same meaning), not just what comes after. As for internal `define` in a function, [those are transformed into `letrec`](https://docs.racket-lang.org/guide/define.html#%28part._intdefs%29) and are not treated the same way as module-level `define`. @signonsridhar No, we're only talking about computation methods that give the exact same result as `M_PI` when truncated to double-precision. Interesting side note: `getEnumConstants()` is actually implemented by [calling `values()` in the enum class via reflection](http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/96393e490afd/src/share/classes/java/lang/Class.java#l3307). :-) (The reflection happens only once per class: the values are cached, and `getEnumConstants()` returns a defensive copy of those values on each call.) `E extends Comparable`. Or, actually, what Elliott Frisch already got. :-P @M.S What Leon means is, you should usually use `echo` instead of `echo -n`. Also, the `if` and `elif` branches all need a `then`. tripleee's suggestion of shellcheck is excellent. @dmsbilas The thread linked to is a long one, but [this answer](http://stackoverflow.com/a/15030117/13) is the one you need. Anyway, here's my solution that uses `splice` instead of `concat`, which may reduce memory usage: https://gist.github.com/cky/db218f63441e292fabf50d03c0f1b722 @JeremyJackson That assumes all the array elements are single-digit numbers. I believe the OP wants something more general than that. @TarunMaganti You can't create a standalone binary in Guile, at least not in 2.0 or below. With the shebang lines I recommended, you can simply make the script file executable and run it. @JoelMWard From some brief testing, Emacs seems to follow the same rules as Scheme in this regard, so I'll quote you what R7RS says about it: _A quasiquote expression may return either newly allocated, mutable objects or literal structure for any structure that is constructed at run time during the evaluation of the expression. **Portions that do not need to be rebuilt are always literal.**_ (Emphasis mine.) @JoelMWard In other words, unless you know how quasiquote expressions are built, it's best to assume it's immutable too. But if you know what you're doing, you can get away with it. :-) In the case of your code above, `\`(,'BUF)` works (from my testing), but not `\`(BUF)`. @Don Indeed, there is no difference between the two snippets you had. @Tarun Whoops, you're right! Lemme fix my answer. Or, more likely, `eqv?`. `iota` is not actually a primitive. It's provided by SRFI 1. Racket, for example, provides `range` instead (with different argument order to `iota`). Of course, a function that's really recursive and only becomes tail-recursive via CPS transformation doesn't really fulfil the "unbounded tail recursion doesn't result in unbounded memory consumption" requirement of proper tail recursion. ;-) @Rubby Great! So implement that method, and just have `throw new UnsupportedOperationException();` in its body. (Note: `UnsupportedOperationException` is an unchecked exception and does not need to be declared in the `throws` clause.) @spirit Correct. Sadly there is no fancy convenience function on the `String` class for it. :-( @KevinEsche Well yes, but `find` is a much closer analogue to `matches` in terms of functionality. @Barmar It's funny how often I hear "we can achieve tail recursion using CPS". It's not actually true for the Scheme definition of proper tail recursion, which specifies that unbounded tail recursion should not use unbounded memory. If the CPS describes a true tail-recursive process, that would indeed apply; otherwise, your chain of continuations would be of unbounded length. It's not "standard" in the sense of not being specified in RnRS, but it's actually compatible with [SRFI 89](http://srfi.schemers.org/srfi-89/srfi-89.html), which is standard enough for my taste, and in any event more standard than, say, Guile's style for optional arguments (which is partly based on DSSSL's syntax for optional arguments, as mentioned in sjamaan's answer). @AlexKnauth Having reread the OP's case, I see their base cases would have worked too. Yes, their implementation of `sub-nat` is busted and won't type-check, and since `add-nat` already uses `Succ-n`, `multiply-nat` should use it too. @AlexKnauth Done. @Misha Thanks, I just learnt about `boxed()`. It's an improvement over `mapToObj(Integer::valueOf)`, for sure. :-) @HattrickNZ Sort from second column onwards. @Lyudmila Glad to be of help. You can click on the big tick next to the up/down vote arrows to tell the site the problem is solved. @JefferyShivers User input can't actually specify functions. Unless you want `car` in the user input to actually map to the `car` procedure: in that case, you might want a symbol-to-procedure hashtable (or alist, if small). The alist would look like this: `\`((car . ,car) (cdr . ,cdr) ...)`. (This is a bit difficult to explain in detail in a comment box, but I'll be happy to try to explain anything that you ask about.) I've always translated `do` as `begin`. Why prefer `let`? Curious. Ah, thanks for the explanation! Allowing internal definitions definitely makes it more user-friendly. BTW, `((lambda (x) (* x x)) (read))` is more idiomatically written as `(let ((x (read))) (* x x))`.. Option 4: use `cut` from `srfi/26`. @Lousy It's not a callback, since callbacks are usually called asynchronously while the main code continues running. With CPS, the main code is _never_ returned to. So all your lambdas are being called in tail position, in Scheme at least. @Sylwester That's as good of an advertisement as there is for IronScheme, which I'm sure uses the tailcall opcode. Right, leppie? @Sylwester Well, if you internally implement continuations via CPS-transformation, things like tail calls and multiple values are trivially implemented in terms of CPS. ;-) (Again, not sure how IronScheme does it, and I'd love to hear from leppie on this.) @Lousy That's continuations in general, not CPS. In normal CPS-transformed code, the lambdas are indeed tail-called just once (except in looping contexts and such like), sequentially, never returning to the caller (they're always passed a continuation which they then tail-call). @Lousy The purpose of CPS-transformation is indeed to enable things like tail calls (and general continuations) and various other control flow optimisations, but continuations in general can be used to snapshot call-flow states (which is what is meant by being able to save and invoke continuations later on, multiple times). @leppie Right, my question is about whether IronScheme already generates that `tail.` prefix without having to postprocess like you say you have to for C#. If it's helpful for you at all, I also wrote a "pizza cutter analogy" for binary floating numbers here: http://stackoverflow.com/a/27030789/13. In this analogy, you can only halve pizza slices (and add up slices in any combination you like). You will find that it is **impossible** to create 1.1 using any combination of slices, because no combination of slices will create exactly 0.1. The standard solution to this, in Scheme, is to use rational numbers. So instead of using `1.1`, use `11/10`. Then it doesn't touch floating-point at all. @WillNess `(cons ... (delay ...))` creates odd streams, whereas `(delay (cons ...))` creates even streams. The issue with odd streams is that you always materialise one element too many. With even streams, you can materialise exactly as many elements as you need to. See the Rationale section of [SRFI 41](http://srfi.schemers.org/srfi-41/srfi-41.html) for more details. I vastly prefer to use `'()` over `null`. Two reasons: 1. `'()` is a datum literal, not an identifier like `null` is. That means you _know_ the contents of `'()`, unlike `null` which can be rebound: `(let ((null #f)) null)`. 2. `'()` works in all Scheme implementations. `null` only works in implementations (like Racket) which define it. @jackmott Right, exactly as my answer noted: "this probably doesn't apply to managed languages, where the runtime system can relocate objects at will". `define-values` is specified in R7RS section 5.3.3. @user3705478 The code won't compile, to avoid that kind of erroneous situation. In general, you're not allowed to have a catch for a subclass after a catch of its superclass in the same try block. @Sylwester I think she's saying you should write `#lang racket` and not `#!racket` or just `racket`. @Sylwester Huh, nice. If using a hash set, that's even amortised linear time. The constant factor is bigger than the "n-1 pairwise comparisons" approach (and it's linear-space rather than constant-space), of course, but it's still technically feasible. @Sylwester I agree that the tagging is not very precise. However, I would say that the _community_ of users who would answer questions about `#lang racket` isn't so far off from the community of users who would answer questions about DrRacket, Beginning Student, etc., so it's not considered broken enough to fix. @rnso It worked for the example you posted. @rnso Okay, updated the code. Prefer to use `for/hash` for this (`(for/hash ((needle (in-list needles)) (new-value (in-list new-values))) (values needle new-value))`). Otherwise, excellent answer. +1 @rnso Sylwester already posted a hash version, so I won't bother to do so. ;-) As regard the `=>`, it's a `cond` syntax that stores the test value, and if truthy, passes it to the given function. In this case, it's equivalent to: `(let ((value (assoc item replace-alist))) (if value (cdr value) ...))` where the `...` represents the failure case. @Sylwester It's a micro-optimisation. Without specifying the generator, the system has to look at the object's type at runtime to decide on the generator to use. @Vishal You'd have to use linear-time lookup (`std::find`) unless you retain the original map. @bmargulies You cannot directly serialise a class not marked Serializable. End of story. My answer allows you to write a Serializable wrapper around a non-Serializable class, that preserves its essential state. @bmargulies I like the idea behind your edit, so I've changed the wording some to better reflect how I write. :-) What happens if you used `(define player (start-game))`? It's more readable (and portable, though I know this question is about Racket specifically) to use `(char->integer #\a)` instead of 97. Also, it's `integer->char`, not `number->char`. @Thayne [British spelling](https://en.wiktionary.org/wiki/spelt#Etymology_1) isn't misspelling! The world does not revolve around the US. :-) (Don't feel bad. I revert Americanisation edits all the time.) @JohnClements My usual remedy to such questions is to answer the way a seasoned Schemer would answer, using any SRFIs or modules that we would normally solve it with. The OP would then be forced to actually adapt the code to whatever restricted subset of the language their professor requires them to use. I'm okay with that, as long as they're actually doing _that_ work rather than offloading it to someone else. The question is inconsistent. In one example, `(- int real)` returns `real` (which is fine), but then in another example, `(+ real int)` throws an error instead of returning `real`. This is probably bogus. Your `base` needs to be squared in the even case. Also, BTW, Scheme provides a built-in `even?` predicate and you don't need to define your own. @AndrewDunn I don't think that's what user3705478's question is about, but rather, what happens if a parent exception `catch` clause is listed _before_ a child exception `catch` clause. My understanding is that Java disallows this, and it's caught at compile time. Try writing a version that operates on a list instead of a stream. That is, your function should consume a list, and produce a list with spaces collapsed. If you can write that successfully, the stream version is easy to convert to. @PeterCordes I appreciate the intention, but I'm going to revert your edit. 1. Your "voice" is very different from mine, and right now it reads a lot more like your answer than mine. 2. More problematic is the bold assertion that the flags come out exactly the same way between `test` and `cmp`. Yes, I understand that's your belief based on your comments to Cody. However, putting it in my post is a different matter; it's not an assertion I'm willing to stand by, simply because _I don't know_ if it's identical in all cases. @PeterCordes I understand the wish to have a "canonical" answer, but I think your answer has to swim or sink on its own merits, rather than piggyback on an accepted answer. I've had to do that for some of my answers to very popular questions too, like [the floating-point primer one](http://stackoverflow.com/a/27030789/13), which at the time of posting my answer already had other answers with 500+ upvotes. @PeterCordes If I find some spare time, I do want to flesh this answer out to be more canonical. I would write it like I write it, though, and I'm quite particular about how I write things. :-) For example, I'd write `je`, `jz`, `cmp`, and `test`, and not JE, JZ, CMP, or TEST. I'm picky like that. @AlexanderMills sh is not the same as bash. sh is the [Bourne shell](https://en.wikipedia.org/wiki/Bourne_shell); its behaviour is specified in POSIX. [bash](https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29) (Bourne again shell) is a GNU project that provides numerous extensions above and beyond what the standard Bourne shell provides. Clearly, it seems one of those extensions is allowing people to use `==` in its `test` builtin, something which is not standard and would not be tolerated by the standard Bourne shell. @thebugfinder The book is correct: it is called the **conditional** operator. Which is actually the point that @JörgWMittag is making. `` It may be the only ternary operator Ruby offers, but that does not make "the ternary operator" the correct name for it. @Stefan Thank you, that is very true. And is in fact the key to doing what I need to do: I don't need the lazy-loading aspects of autovivification, just need some fields to be set up to be non-nil. And it turns out that setting up an `initialize` method to set up the initial field values will do just that. Thanks again. :-) @mudasobwa Thanks for your answer! I ended up going a different path (since I don't need the lazy-loading aspects, only need the values to not be nil, so I just defined an `initialize` method), but your answer does make a lot of sense for situations where some kind of lazy-loading is useful, and I like the module approach. I suspect the OP is hoping that Racket can support array literals such that its use doesn't constitute 3D syntax. I say this because in Guile, regexps aren't simple datums and so you can't use precompiled regexps in Guile macros without creating 3D syntax, whereas Racket does support regexp literals directly in macros without 3D syntax. @TimMB Another major benefit is that it doesn't cause your exception object to be sliced, so that virtual functions like `what()` actually work. @KarlRichter I've read their answer. It does not say it's a bad idea, other than that `Cloneable` in general is a broken idea, as explained in Effective Java. The OP already expressed that they have to use `Cloneable`. So I have no idea how else my answer could be improved upon, except perhaps deleting it outright. @AndrewBainbridge The choice of 1.5x isn't because it's faster than 2x. It's that for non-relocating memory allocators, it doesn't leave large unusable gaps in the memory. Obviously, if you're using a platform (like JVM) that _does_ relocate memory, this doesn't matter. @FelipeMicaroniLalli I finally got around to writing a portable implementation of the `string->exact` function you're hoping to see. Granted, it's nearly 3 years late, but I hope you find it useful anyway. :-) @RainerJoswig Thanks! Applied. (I tried looking for `atomp`, but missed `atom`, lol. As you know, Scheme doesn't have `atom?`; `(not (pair? ...))` is pretty much it.) @JonathP `nconc` stands for non-consing concatenate. It's like `append` but by mutating the incoming lists rather than copying. In many cases, you can safely replace `nconc` with `append`; it'll just do more copying. You cannot always replace `append` with `nconc`, though; it may modify things you didn't expect. In this case, all the lists I `nconc`ed were either fresh lists generated with the `(list x)` expression (on the `(atom x)` case), or nil, so I know those are safe. (In contrast, in Scheme, `nconc` is called `append!`, and the latter has the _option_ of doing mutation, which means the caller cannot assume mutation. So in Scheme, it's always safe to replace `append!` with `append`, and in fact, in some implementations like Racket, `append!` is defined as `append`.) @Mahi Yes, you need to install JRE to run Eclipse. 5GB? That would mean each word has an average of 10737.4 characters, including the intervening space. @A.J. Must I pull out Strunk and White? http://www.bartleby.com/141/strunk.html#1 @jww The IO Stream State Saver library has multiple classes, for saving different parts of the stream state, of which `ios_flags_saver` is just one. @CarlosHeuberger If you can add something to the bootclasspath (or into the endorsed extensions directory), that wouldn't qualify as "user" code. :-) `group-by` is defined here: https://github.com/racket/racket/blob/v6.12/racket/collects/racket/list.rkt#L772Basically, it: 1. builds a hash, keyed by the result of the keying function, with the value being a list of values with the same key; 2. returns the values of that hash, ordered by the location of first appearance in the original list. No, it should be either `(list f g h)` or `\`(,f ,g ,h)`. Your example of `\`(f g h)` will contain the _symbols_ `f`, `g`, and `h`, rather than the actual function objects. @Daniel It is equivalent to `echo "The quick brown fox jumps over the lazy dog." | wc` @Daniel I normally don't edit posts without something substantive to change, but in this case I think a little added explanation didn't hurt. ;-) Because Lisp is a family of languages, and the kinds of questions you want to see on SO generally needs to be about the specific language in use (i.e., questions about Lisp in general are not good SO material, generally), I am on the tip of my tongue to propose that the [lisp] tag be blacklisted entirely, so people can't use it for questions. @Radon Of course, you are correct. I will edit this post later. @q-l-p: It's not nice to refer to British spellings as incorrect. Not my fault your spellchecker was localised (not "localized", lol) for the wrong country. ;-) I'm disappointed at the state of things too. Unfortunately, bounties are permanent once assigned, and I don't feel good about awarding the bounty in this case. :-( (But, because the OP accepted your answer, you'll still be auto-awarded the bounty anyway. So don't fret! :-)) @Hi-Angel That's _exactly_ why I use `xargs -0` *in conjunction with* `find -print0`. The latter prints filenames with a NUL terminator and the former receives files that way. Why? Filenames in Unix can contain newline characters. But they cannot contain NUL characters. @frank Personally I would use macros for all such situations that I can think of, but feel free to post examples that you feel are better served by `eval` and I'll let you know. :-D @frank You can always put your code in a Gist, then link to it here. And, always my pleasure; I'm glad to be of help. :-) Start here: [STL Complexity Specifications](https://web.archive.org/web/20171026054855/http://www.sgi.com/tech/stl/complexity.html). Then read through all the container types on that site, and look at the complexity requirements stated. Hope this helps! I'm looking for the fastest way to obtain the value of π, as a personal challenge. More specifically, I'm using ways that don't involve using #define constants like M_PI, or hard-coding the number in.The program below tests the various ways I know of. The inline assembly version is, in theory, the fastest option, though clearly not portable. I've included it as a baseline to compare against the other versions. In my tests, with built-ins, the 4 * atan(1) version is fastest on GCC 4.2, because it auto-folds the atan(1) into a constant. With -fno-builtin specified, the atan2(0, -1) version is fastest.Here's the main testing program (pitimes.c):#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#define ITERS 10000000#define TESTWITH(x) { \ diff = 0.0; \ time1 = clock(); \ for (i = 0; i &lt; ITERS; ++i) \ diff += (x) - M_PI; \ time2 = clock(); \ printf("%s\t=&gt; %e, time =&gt; %f\n", #x, diff, diffclock(time2, time1)); \}static inline doublediffclock(clock_t time1, clock_t time0){ return (double) (time1 - time0) / CLOCKS_PER_SEC;}intmain(){ int i; clock_t time1, time2; double diff; /* Warmup. The atan2 case catches GCC's atan folding (which would * optimise the ``4 * atan(1) - M_PI'' to a no-op), if -fno-builtin * is not used. */ TESTWITH(4 * atan(1)) TESTWITH(4 * atan2(1, 1))#if defined(__GNUC__) &amp;&amp; (defined(__i386__) || defined(__amd64__)) extern double fldpi(); TESTWITH(fldpi())#endif /* Actual tests start here. */ TESTWITH(atan2(0, -1)) TESTWITH(acos(-1)) TESTWITH(2 * asin(1)) TESTWITH(4 * atan2(1, 1)) TESTWITH(4 * atan(1)) return 0;}And the inline assembly stuff (fldpi.c) that will only work for x86 and x64 systems:doublefldpi(){ double pi; asm("fldpi" : "=t" (pi)); return pi;}And a build script that builds all the configurations I'm testing (build.sh):#!/bin/shgcc -O3 -Wall -c -m32 -o fldpi-32.o fldpi.cgcc -O3 -Wall -c -m64 -o fldpi-64.o fldpi.cgcc -O3 -Wall -ffast-math -m32 -o pitimes1-32 pitimes.c fldpi-32.ogcc -O3 -Wall -m32 -o pitimes2-32 pitimes.c fldpi-32.o -lmgcc -O3 -Wall -fno-builtin -m32 -o pitimes3-32 pitimes.c fldpi-32.o -lmgcc -O3 -Wall -ffast-math -m64 -o pitimes1-64 pitimes.c fldpi-64.o -lmgcc -O3 -Wall -m64 -o pitimes2-64 pitimes.c fldpi-64.o -lmgcc -O3 -Wall -fno-builtin -m64 -o pitimes3-64 pitimes.c fldpi-64.o -lmApart from testing between various compiler flags (I've compared 32-bit against 64-bit too, because the optimisations are different), I've also tried switching the order of the tests around. But still, the atan2(0, -1) version still comes out on top every time. Many years ago, to provide an age calculator gimmick on my website, I wrote a function to calculate age to a fraction. This is a quick port of that function to C# (from the PHP version). I'm afraid I haven't been able to test the C# version, but hope you enjoy all the same!(Admittedly this is a bit gimmicky for the purposes of showing user profiles on Stack Overflow, but maybe readers will find some use for it. :-))double AgeDiff(DateTime date1, DateTime date2) { double years = date2.Year - date1.Year; /* * If date2 and date1 + round(date2 - date1) are on different sides * of 29 February, then our partial year is considered to have 366 * days total, otherwise it's 365. Note that 59 is the day number * of 29 Feb. */ double fraction = 365 + (DateTime.IsLeapYear(date2.Year) &amp;&amp; date2.DayOfYear &gt;= 59 &amp;&amp; (date1.DayOfYear &lt; 59 || date1.DayOfYear &gt; date2.DayOfYear) ? 1 : 0); /* * The only really nontrivial case is if date1 is in a leap year, * and date2 is not. So let's handle the others first. */ if (DateTime.IsLeapYear(date2.Year) == DateTime.IsLeapYear(date1.Year)) return years + (date2.DayOfYear - date1.DayOfYear) / fraction; /* * If date2 is in a leap year, but date1 is not and is March or * beyond, shift up by a day. */ if (DateTime.IsLeapYear(date2.Year)) { return years + (date2.DayOfYear - date1.DayOfYear - (date1.DayOfYear &gt;= 59 ? 1 : 0)) / fraction; } /* * If date1 is not on 29 February, shift down date1 by a day if * March or later. Proceed normally. */ if (date1.DayOfYear != 59) { return years + (date2.DayOfYear - date1.DayOfYear + (date1.DayOfYear &gt; 59 ? 1 : 0)) / fraction; } /* * Okay, here date1 is on 29 February, and date2 is not on a leap * year. What to do now? On 28 Feb in date2's year, the ``age'' * should be just shy of a whole number, and on 1 Mar should be * just over. Perhaps the easiest way is to a point halfway * between those two: 58.5. */ return years + (date2.DayOfYear - 58.5) / fraction;} I've had no trouble using the BSD sockets API in C++, in GNU/Linux. Here's the sample program I used:#include &lt;sys/socket.h&gt;intmain(){ return AF_INET;}So my take on this is that z/OS is probably the complicating factor here, however, because I've never used z/OS before, much less programmed in it, I can't say this definitively. :-P Math.Floor rounds down, Math.Ceiling rounds up, and Math.Truncate rounds towards zero. Thus, Math.Truncate is like Math.Floor for positive numbers, and like Math.Ceiling for negative numbers. Here's the reference.For completeness, Math.Round rounds to the nearest integer. If the number is exactly midway between two integers, then it rounds towards the even one. Reference.See also: Pax Diablo's answer. Highly recommended! @Jax: The extern "C" thing matters, very very much. If a header file doesn't have one, then (unless it's a C++-only header file), you would have to enclose your #include with it:extern "C" {#include &lt;sys/socket.h&gt;// include other similarly non-compliant header files}Basically, anytime where a C++ program wants to link to C-based facilities, the extern "C" is vital. In practical terms, it means that the names used in external references will not be mangled, like normal C++ names would. Reference. For C++, Boost.Random is probably what you're looking for. It has support for MT (among many other algorithms), and can collect entropy via the nondet_random class. Check it out! :-) I'll add to the excellent answers given above, and talk about boxing and unboxing, and how this applies to Java (although C# has it too). I'll use just Java terminology, because I am more au fait with that.As the answers mentioned, int is just a number (called the unboxed type), whereas Integer is an object (which contains the number, hence a boxed type). In Java terms, that means (apart from not being able to call methods on int), you cannot store int or other non-object types in collections (List, Map, etc.). In order to store them, you must first box them up in its corresponding boxed type.Java 5 onwards have something called auto-boxing and auto-unboxing which allow the boxing/unboxing to be done behind the scenes. Compare and contrast: Java 5 version:Deque&lt;Integer&gt; queue;void add(int n) { queue.add(n);}int remove() { return queue.remove();}Java 1.4 or earlier (no generics either):Deque queue;void add(int n) { queue.add(Integer.valueOf(n));}int remove() { return ((Integer) queue.remove()).intValue();}It must be noted that despite the brevity in the Java 5 version, both versions generate identical bytecode. Thus, although auto-boxing and auto-unboxing is very convenient because you write less code, these operations do happen behind the scenes, with the same runtime costs, so you still have to be aware of their existence.Hope this helps! Ryan's advice is generally good, however, if following step 3, don't move the temporary file; it'll have the wrong ownership and permissions. Instead, sudoedit the correct file and read in the contents (using :r or the like) of the temporary file.If following step 2, use :w! to force the file to be written. Most mathematicians agree that: eπi + 1 = 0However, most floating point implementations disagree. How well can we settle this dispute?I'm keen to hear about different languages and implementations, and various methods to make the result as close to zero as possible. Be creative! Here's a short list of implementations and languages I've tried. It's sorted by closeness to zero:Scheme: (+ 1 (make-polar 1 (atan 0 -1)))⇒ 0.0+1.2246063538223773e-16i (Chez Scheme, MIT Scheme)⇒ 0.0+1.22460635382238e-16i (Guile)⇒ 0.0+1.22464679914735e-16i (Chicken with numbers egg)⇒ 0.0+1.2246467991473532e-16i (MzScheme, SISC, Gauche, Gambit)⇒ 0.0+1.2246467991473533e-16i (SCM)Common Lisp: (1+ (exp (complex 0 pi)))⇒ #C(0.0L0 -5.0165576136843360246L-20) (CLISP)⇒ #C(0.0d0 1.2246063538223773d-16) (CMUCL)⇒ #C(0.0d0 1.2246467991473532d-16) (SBCL)Perl: use Math::Complex; Math::Complex-&gt;emake(1, pi) + 1⇒ 1.22464679914735e-16iPython: from cmath import exp, pi; exp(complex(0, pi)) + 1⇒ 1.2246467991473532e-16j (CPython)Ruby: require 'complex'; Complex::polar(1, Math::PI) + 1⇒ Complex(0.0, 1.22464679914735e-16) (MRI)⇒ Complex(0.0, 1.2246467991473532e-16) (JRuby)R: complex(argument = pi) + 1⇒ 0+1.224606353822377e-16i No.See A Pragmatic Look at Exception Specifications for reasons why not. The only way you can "help" this is to document the exceptions your function can throw, say as a comment in the header file declaring it. This is not enforced by the compiler or anything. Use code reviews for that purpose. I like Orion's responses. I'll add two things:The left-to-right still applies firstThe inner-to-outer to ensure that all arguments are resolved before calling the functionSay we have the following example:a = Foo(5, GetSummary("Orion", GetAddress("Orion")), GetSummary("Chris", GetAddress("Chris")));Here's the order of execution:GetAddress("Orion")GetSummary("Orion", ...)GetAddress("Chris")GetSummary("Chris", ...)Foo(...)Assigns to aI can't speak about C#'s legal requirements (although I did test a similar example using Mono before writing this post), but this order is guaranteed in Java.And just for completeness (since this is a language-agnostic thread as well), there are languages like C and C++, where the order is not guaranteed unless there is a sequence point. References: 1, 2. In answering the thread's question, however, &amp;&amp; and || are sequence points in C++ (unless overloaded; also see OJ's excellent answer). So some examples:foo() &amp;&amp; bar()foo() &amp; bar()In the &amp;&amp; case, foo() is guaranteed to run before bar() (if the latter is run at all), since &amp;&amp; is a sequence point. In the &amp; case, no such guarantee is made (in C and C++), and indeed bar() can run before foo(), or vice versa. I remember reading an article that may be of help to you: Cheney on the M.T.A. :-)Some implementations of Scheme I know of, such as SISC, allocate their call frames on the heap.@ollie: You don't need to do the hoisting if all your call frames are on the heap. There's a tradeoff in performance, of course: the time to hoist, versus the overhead required to allocate all frames on the heap. Maybe it should be a tunable runtime parameter in the interpreter. :-P According to the documentation for GetPrivateProfileString, you should use the registry for storing initialisation information.However, in so saying, if you still want to use .ini files, and use the standard profile APIs (GetPrivateProfileString, WritePrivateProfileString, and the like) for accessing them, they provide built-in ways to automatically provide "virtual .ini files" backed by the registry. Win-win! My experience is with Java, not C#, so apologies if these solutions don't apply.The immediate solution I can think up off the top of my head would be to have an executor that runs 3 threads (using Executors.newFixedThreadPool, say). For each line/record read from the input file, fire off a job at the executor (using ExecutorService.submit). The executor will queue requests for you, and allocate between the 3 threads.Probably better solutions exist, but hopefully that will do the job. :-)ETA: Sounds a lot like Wolfbyte's second solution. :-)ETA2: System.Threading.ThreadPool sounds like a very similar idea in .NET. I've never used it, but it may be worth your while! You can't do it without any static variables, however if you are willing to tolerate one, you can use Boost.Thread for this purpose. Read the "one-time initialisation" section for more info.Then in your singleton accessor function, use boost::call_once to construct the object, and return it. ImageMagick delegates the PDF->bitmap conversion to GhostScript anyway, so here's a command you can use (it's based on the actual command listed by the ps:alpha delegate in ImageMagick, just adjusted to use JPEG as output):gs -q -dQUIET -dPARANOIDSAFER -dBATCH -dNOPAUSE -dNOPROMPT \-dMaxBitmap=500000000 -dLastPage=1 -dAlignToPixels=0 -dGridFitTT=0 \-sDEVICE=jpeg -dTextAlphaBits=4 -dGraphicsAlphaBits=4 -r72x72 \-sOutputFile=$OUTPUT -f$INPUTwhere $OUTPUT and $INPUT are the output and input filenames. Adjust the 72x72 to whatever resolution you need. (Obviously, strip out the backslashes if you're writing out the whole command as one line.)This is good for two reasons:You don't need to have ImageMagick installed anymore. Not that I have anything against ImageMagick (I love it to bits), but I believe in simple solutions.ImageMagick does a two-step conversion. First PDF->PPM, then PPM->JPEG. This way, the conversion is one-step.Other things to consider: with the files I've tested, PNG compresses better than JPEG. If you want to use PNG, change the -sDEVICE=jpeg to -sDEVICE=png16m. I'll take a different definition of defensive programming, as the one that's advocated by Effective Java by Josh Bloch. In the book, he talks about how to handle mutable objects that callers pass to your code (e.g., in setters), and mutable objects that you pass to callers (e.g., in getters).For setters, make sure to clone any mutable objects, and store the clone. This way, callers cannot change the passed-in object after the fact to break your program's invariants.For getters, either return an immutable view of your internal data, if the interface allows it; or else return a clone of the internal data.When calling user-supplied callbacks with internal data, send in an immutable view or clone, as appropriate, unless you intend the callback to alter the data, in which case you have to validate it after the fact.The take-home message is to make sure no outside code can hold an alias to any mutable objects that you use internally, so that you can maintain your invariants. @Derek: Oh, but with trusted computing, you can use memory curtaining! :-P&lt;/devils-advocate&gt; @Nathan: I've upmodded the Common Lisp links, because you asked about Lisp (especially with reference to Emacs Lisp). However, Common Lisp is very different from Scheme. A program written for one is unlikely to run on the other.As you mentioned, SICP is for learning Scheme, not Lisp (or at least, not Common Lisp and not Emacs Lisp). There are some overlap in principles, however you can't simply cut and paste code from SICP and expect it to run on any Common Lisp or Emacs Lisp system. :-) Since the question asked for a non-C way, here's a Scheme implementation, cheerfully plagiarised from SLIB:(define (bit-reverse k n) (do ((m (if (negative? n) (lognot n) n) (arithmetic-shift m -1)) (k (+ -1 k) (+ -1 k)) (rvs 0 (logior (arithmetic-shift rvs 1) (logand 1 m)))) ((negative? k) (if (negative? n) (lognot rvs) rvs))))(define (reverse-bit-field n start end) (define width (- end start)) (let ((mask (lognot (ash -1 width)))) (define zn (logand mask (arithmetic-shift n (- start)))) (logior (arithmetic-shift (bit-reverse width zn) start) (logand (lognot (ash mask start)) n))))Rewritten as C (for people unfamiliar with Scheme), it'd look something like this (with the understanding that in Scheme, numbers can be arbitrarily big):intbit_reverse(int k, int n){ int m = n &lt; 0 ? ~n : n; int rvs = 0; while (--k &gt;= 0) { rvs = (rvs &lt;&lt; 1) | (m &amp; 1); m &gt;&gt;= 1; } return n &lt; 0 ? ~rvs : rvs;}intreverse_bit_field(int n, int start, int end){ int width = end - start; int mask = ~(-1 &lt;&lt; width); int zn = mask &amp; (n &gt;&gt; start); return (bit_reverse(width, zn) &lt;&lt; start) | (~(mask &lt;&lt; start) &amp; n);} And here's a version directly cut and pasted from OpenJDK, which is interesting because it involves no loop. On the other hand, unlike the Scheme version I posted, this version only works for 32-bit and 64-bit numbers. :-)32-bit version:public static int reverse(int i) { // HD, Figure 7-1 i = (i &amp; 0x55555555) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x55555555; i = (i &amp; 0x33333333) &lt;&lt; 2 | (i &gt;&gt;&gt; 2) &amp; 0x33333333; i = (i &amp; 0x0f0f0f0f) &lt;&lt; 4 | (i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f; i = (i &lt;&lt; 24) | ((i &amp; 0xff00) &lt;&lt; 8) | ((i &gt;&gt;&gt; 8) &amp; 0xff00) | (i &gt;&gt;&gt; 24); return i;}64-bit version:public static long reverse(long i) { // HD, Figure 7-1 i = (i &amp; 0x5555555555555555L) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x5555555555555555L; i = (i &amp; 0x3333333333333333L) &lt;&lt; 2 | (i &gt;&gt;&gt; 2) &amp; 0x3333333333333333L; i = (i &amp; 0x0f0f0f0f0f0f0f0fL) &lt;&lt; 4 | (i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f0f0f0f0fL; i = (i &amp; 0x00ff00ff00ff00ffL) &lt;&lt; 8 | (i &gt;&gt;&gt; 8) &amp; 0x00ff00ff00ff00ffL; i = (i &lt;&lt; 48) | ((i &amp; 0xffff0000L) &lt;&lt; 16) | ((i &gt;&gt;&gt; 16) &amp; 0xffff0000L) | (i &gt;&gt;&gt; 48); return i;} @John: I think that the question relates to an algorithm that actually recognises patterns in log files and automatically "guesses" appropriate format strings and data for it. The *scanf family can't do that on its own, it can only be of help once the patterns have been recognised in the first place. I trained my typing on GNU Typist. It comes with exercises for various languages and keyboard layouts, if you're so inclined.One of the most fun typing programs I used is dvorak7min. It has a nastiness mode where for each typo you make, the cursor goes back by 1. So if you don't watch your typing, you'll be back to square 1…. Many years ago, people advertised new code releases on Freshmeat. I don't know if that's still commonplace anymore. (I just read their about page, and it seems to be more for Unix-orientated and cross-platform software projects. If your software is more for Windows, there may be better forums.)Another thing I just thought of is the licensing aspects of your code. Again, I can't speak for the Windows open source crowd, however, in Linux circles, generally your code must use GPL, or at least a GPL-compatible licence, to get much traction.Good luck with growing your project! I usually go to the System control panel, then Advanced tab, then Environment. You can then add the requisite _NT_SYMBOL_PATH variable. Then you don't have to do anything on the command-line before running WinDbg.The setting of srv*C:\Windows\Symbols*http://msdl.microsoft.com/download/symbols as suggested by staffan is fine. I usually prefer to use my own profile for storing symbols though (so that I don't need to edit the permissions for C:\Windows\Symbols, since I intentionally run as a limited user, for good security hygiene). Thus (in my case) my _NT_SYMBOL_PATH is srv*C:\Documents and Settings\cky\symbols*http://msdl.microsoft.com/download/symbols.Hope this helps. :-) Which users and/or groups are in your "Debug programs" right (under User Rights Assignment)? Maybe that setting got overridden by group policy (Daniel's answer), or just got out of whack for some reason. It should, obviously, include the "Debug Users" group. #ifdef TONGUE_IN_CHEEKPerl has a goto that allows you to implement poor-man's tail calls. :-Psub factorial { my ($n, $acc) = (@_, 1); return $acc if $n &lt; 1; @_ = ($n - 1, $acc * $n); goto &amp;factorial;}#endifOkay, so that has nothing to do with C's goto. More seriously, I agree with the other comments about using goto for cleanups, or for implementing Duff's device, or the like. It's all about using, not abusing.(The same comment can apply to longjmp, exceptions, call/cc, and the like---they have legitimate uses, but can easily be abused. For example, throwing an exception purely to escape a deeply-nested control structure, under completely non-exceptional circumstances.) LANG=en_NZ is correct. However, you must make locale files for en_NZ.For Ubuntu, edit /var/lib/locales/supported.d/local and add en_NZ ISO-8859-1 to the file. If your system is another distribution (including Debian), the location will be different. Look at /usr/sbin/locale-gen and see where it stores this info.Afterwards, run locale-gen to create the en_NZ locale file. Hope this helps! According to the Timer documentation, in Java 1.5 onwards, you should prefer the ScheduledThreadPoolExecutor instead. (You may like to create this executor using Executors.newSingleThreadScheduledExecutor() for ease of use; it creates something much like a Timer.)The cool thing is, when you schedule a task (by calling schedule()), it returns a ScheduledFuture object. You can use this to cancel the scheduled task. You're then free to submit a new task with a different triggering time.ETA: The Timer documentation linked to doesn't say anything about ScheduledThreadPoolExecutor, however the OpenJDK version had this to say: Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the Timer/TimerTask combination, as it allows multiple service threads, accepts various time units, and doesn't require subclassing TimerTask (just implement Runnable). Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer. Here's my really naive solution. Your mileage may vary.Keep a sign bit, which is sign(dividend) ^ sign(divisor). (Or *, or /, if you're storing your sign as 1 and -1, as opposed to false and true. Basically, negative if either one is negative, positive if none or both are negative.)Then, call the unsigned division function on the absolute values of both. Then tack the sign back onto the result.P.S. That is actually how __divdi3 is implemented in libgcc2.c (from GCC 4.2.3, the version that's installed on my Ubuntu system). I just checked. :-) readelf will indeed help. You can use the -S option; that will show the sizes of all sections. .text is (the bulk of) your executable code. .data and .rodata is your static data. There are other sections too, some of which are used at runtime, others only at link time. Well, 100% managed could be going the hard route, however, you can use the Office PIAs from your .NET code. Joel Spolsky has an article discussing your various options. To add to aku's excellent answer, for English speakers, IDA Pro is available at http://www.hex-rays.com/. In JavaMail, you can use imaps as the URL scheme to use IMAP over SSL. (See SSLNOTES.txt in your JavaMail distribution for more details.) For example, imaps://username%40gmail.com@imap.gmail.com/INBOX.Similarly, use smtps to send emails via Gmail. e.g., smtps://username%40gmail.com@smtp.gmail.com/. Again, read SSLNOTES.txt for more details. Hope it helps! Assertions are not for parameter checking. Parameter checking should always be done (and precisely according to what pre-conditions are specified in your documentation and/or specification), and the ArgumentOutOfRangeException thrown as necessary.Assertions are for testing for "impossible" situations, i.e., things that you (in your program logic) assume are true. The assertions are there to tell you if these assumptions are broken for any reason.Hope this helps! I don't think POSIX itself has facilities for that. The closest to cross-platform I've seen is FAM, which seems to work for Linux, BSD, and Irix, but I'm not how easy it would be to port it to Windows and MacOS. I know of some people using a bunch of winmodems (some of them have Linux support now, mostly thanks to reverse engineering) and hooking them into the phone lines. Of course this is not as cool as having a trunk (if I remember the terminology correctly; this was a long time ago) at home, but it's definitely very cheap. :-) To commemorate the public launch of Stack Overflow, what's the shortest code to cause a stack overflow? Any language welcome.ETA: Just to be clear on this question, seeing as I'm an occasional Scheme user: tail-call "recursion" is really iteration, and any solution which can be converted to an iterative solution relatively trivially by a decent compiler won't be counted. :-PETA2: I've now selected a “best answer”; see this post for rationale. Thanks to everyone who contributed! :-) My current best (in x86 assembly) is:push eaxjmp short $-1which results in 3 bytes of object code (50 EB FD). For 16-bit code, this is also possible:call $which also results in 3 bytes (E8 FD FF). Here's my C contribution, weighing in at 18 characters:void o(){o();o();}This is a lot harder to tail-call optimise! :-P I loved Cody's answer heaps, so here is my similar contribution, in C++:template &lt;int i&gt;class Overflow { typedef typename Overflow&lt;i + 1&gt;::type type;};typedef Overflow&lt;0&gt;::type Kaboom;Not a code golf entry by any means, but still, anything for a meta stack overflow! :-P Remote Installation Services and/or Windows Deployment Services. One or the other comes "free" with Windows Server (RIS with Windows Server 2003 SP1 or earlier; WDS with Windows Server 2003 SP2 or later), and is pretty easy to set up and use. :-) Requires your computers to support PXE booting, however. A portable and robust solution is to use iconv, with the understanding that you have to know what encoding your system wchar_t uses (UTF-16 on Windows, UTF-32 on many Unix systems, for example).If you want to minimise your dependency on third-party code, you can also hand-roll your own UTF-8 converter. This is easy if converting to UTF-32, somewhat harder with UTF-16 because you have to handle surrogate pairs too. :-P Also, you must be careful to reject non-shortest forms, or it can open up security bugs in some cases. This is my version, which, unlike the OP's version, doesn't assume that std::basic_string has its data in contiguous region:#include &lt;string&gt;using std::string;static char const* digits("0123456789ABCDEF");stringtohex(string const&amp; data){ string result(data.size() * 2, 0); string::iterator ptr(result.begin()); for (string::const_iterator cur(data.begin()), end(data.end()); cur != end; ++cur) { unsigned char c(*cur); *ptr++ = digits[c &gt;&gt; 4]; *ptr++ = digits[c &amp; 15]; } return result;} What is the purpose of:while (usec &gt;= 1000) usec /= 10;I gather that you want the most significant three digits of the usec; in that case, the most straightforward way I can think of is to divide usec by 1000, and be done with that.Test cases:999999 ⇒ 99999999 ⇒ 999 (should be 099)9999 ⇒ 999 (should be 009)999 ⇒ 999 (should be 000) I'm selecting the “best answer” after this post. But first, I'd like to acknowledge some very original contributions:aku's ones. Each one explores a new and original way of causing stack overflow. The idea of doing f(x) ⇒ f(f(x)) is one I'll explore in my next entry, below. :-)Cody's one that gave the Nemerle compiler a stack overflow.And (a bit grudgingly), GateKiller's one about throwing a stack overflow exception. :-PMuch as I love the above, the challenge is about doing code golf, and to be fair to respondents, I have to award “best answer” to the shortest code, which is the Befunge entry; I don't believe anybody will be able to beat that (although Konrad has certainly tried), so congrats Patrick!Seeing the large number of stack-overflow-by-recursion solutions, I'm surprised that nobody has (as of current writing) brought up the Y combinator (see Dick Gabriel's essay, The Why of Y, for a primer). I have a recursive solution that uses the Y combinator, as well as aku's f(f(x)) approach. :-)((Y (lambda (f) (lambda (x) (f (f x))))) #f) Now that the answer I like has been accepted as the correct answer, I'll now move into another topic: how to use IFS for personal gain. :-Pfruits="apple,orange,kiwifruit,dried mango"(IFS=, for fruit in $fruits; do echo "$fruit" done)I've put the code in brackets so that the IFS change is isolated into its own subprocess; thus at the end of the bracketed section, IFS is reverted back to its old value. :-) To be non-intrusive, you can also put serialize in the namespace of the class being serialised, or of the archive class, thanks to Koenig lookup. See Namespaces for Free Function Overrides for more details. :-)Opening up any given namespace to implement a free function is Simply Wrong. (e.g., you're not supposed to open up namespace std to implement swap for your own types, but should use Koenig lookup instead.) Okay. Second try. It's okay if you don't like this one either, I'm looking for more ideas.Herb Sutter's article talks about traits. So you can have a traits class whose default instantiation has the fallback behaviour, and for each class where your member function exists, then the traits class is specialised to invoke the member function. I believe Herb's article mentions a technique to do this so that it doesn't involve lots of copying and pasting.Like I said, though, perhaps you don't want the extra work involved with "tagging" classes that do implement that member. In which case, I'm looking at a third solution.... If you are storing function pointers only (and not other functors that match the signature required), this is easy (see code below). But in general, the answer, like other posters have said, is no. In that case, you probably want to store your functors in a hash, as values, with keys being something the user supplies on adding and removing.The code below demonstrates how to get the functor/pointer object that is to be called. To use it, you must know the exact type of the object to extract (i.e., the typeid of the type you specify must match the typeid of the contained functor/pointer).#include &lt;cstdio&gt;#include &lt;functional&gt;using std::printf;using std::tr1::function;int main(int, char**);static function&lt;int (int, char**)&gt; main_func(&amp;main);intmain(int argc, char** argv){ printf("%p == %p\n", *main_func.target&lt;int (*)(int, char**)&gt;(), &amp;main); return 0;} I will get lynched for saying this answer, but it works under Windows: RCS.You simply make an RCS directory in each of the directories with your code. When time comes to check things in, ci -u $FILE. (Binary files also require you to run rcs -i -kb $FILE before the first checkin.)Inside the RCS directory are a bunch of ,v files, which are compatible with CVS, should you wish to "upgrade" to that one day (and from there to any of the other VCS systems other posters mentioned). :-) I don't have a very good name for the function. I'm pasting my implementation below (I've called it map-traversing; others should suggest a better name). I've made the argument order mirror that of map itself.(define (map-traversing func data) (if (list? func) (map map-traversing func data) (func data)))Using your sample data, we have:(map-traversing `((,car ,cdr) ,cadr) '(((aa . ab) (bb . bc)) (cc cd . ce)))The second sample requires SRFI 26. (Allows writing (cut * 2 &lt;&gt;) instead of (lambda (x) (* 2 x)).)(map-traversing `(,(cut * 2 &lt;&gt;) (,(cut * 3 &lt;&gt;) ,(cut * 5 &lt;&gt;))) '(100 (10 1)))The most important thing is that your functions must all be unquoted, unlike your example. Type punning via pointer casts (as opposed to using a union) is a major example of breaking strict aliasing. In this context, a const member function means that this is treated as a const pointer also. In practical terms, it means you aren't allowed to modify the state of this inside a const member function.For no-side-effect functions (i.e., what you're trying to achieve), GCC has a "function attribute" called pure (you use it by saying __attribute__((pure))): http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html I believe you can use \uXXXX to insert specified codes into your string.ETA: I just tested it and it works. :-)using System;class Uxxxx { public static void Main() { Console.WriteLine("\u20AC"); }} Generally licences work using a public-key system. Your licence string is simply some info (perhaps with info on which domain name this licence is valid for, for example), signed by your private key. The web app contains the public key, which is used to check the validity of the signature.I'm sure there are other ways, but this seems to be one of the more robust ones that I know of. :-)I haven't coded anything in ASP, so I have no examples for you, sorry. When I Googled for NI:Max:GetTaskInterface I couldn't find anything. In general, how a window will handle a given message depends entirely on the window concerned. Does the window (specified by hWnd) even support the NI:Max:GetTaskInterface message? @Branan: My current understanding of LGPL's section 4 (IANAL):AFAIK, the onus of making the dynamic library is on the party distributing a binary-only version (or otherwise LGPL-incompatible version), not on the licensor (assuming the licensor doesn't distribute a binary-only/LGPL-incompatible version).Static LGPL library is fine too if the binary-only version is distributed with a bunch of object files (corresponding to the permissively-licensed code) that the user can then relink with their customised version of the LGPL library.In any case, the binary-only code must permit reverse engineering, to allow the LGPL library to be customised by the user and still be linkable to the object files. A JTable uses a TableModel to hold its data. Your hash/vector of data will need to be adapted to be used; you can write a TableModel implementation, using the hash/vector as backing data, or, if you won't be dynamically updating the hash/vector and needing it to show automatically, you can simply copy everything into an instance of DefaultTableModel, and use that.If you do use an adapter, and dynamically update the hash/vector, remember that all updates must be done in the event dispatch thread. :-) To add to my previous answer, for what it's worth, I've actually written a table model that uses (essentially) an ArrayList&lt;Row&gt; as backing data, where Row is a HashMap&lt;String, Object&gt;, mapping column names to values.The whole thing is about 1500 lines of code, although my code may be overkill for your purposes, and you probably don't have to write nearly as much code. All the best! Most kinds of smart pointers handle disposing of the pointer-to object for you. It's very handy because you don't have to think about disposing of objects manually anymore.The most commonly-used smart pointers are std::tr1::shared_ptr (or boost::shared_ptr), and, less commonly, std::auto_ptr. I recommend regular use of shared_ptr.shared_ptr is very versatile and deals with a large variety of disposal scenarios, including cases where objects need to be "passed across DLL boundaries" (the common nightmare case if different libcs are used between your code and the DLLs). Write your own! (The point here is that the autoflush ($|) setting is turned on, so every line seen is flushed straight away. This may perhaps be what the real tee command lacked.)#!/usr/bin/perl -wuse strict;use IO::File;$| = 1;my @fhs = map IO::File-&gt;new("&gt;$_"), @ARGV;while (my $line = &lt;STDIN&gt;) { print $line; $_-&gt;print($line) for @fhs;}$_-&gt;close for @fhs;You can call the script anything you want. I call it perlmilktee! :-P As far as I understand (although no reference seems to mention it), iptables-restore is atomic. At the end, when the COMMIT line is read, iptables calls iptc_commit in libiptc (which in an internal interface you aren't supposed to use), which then calls setsockopt(SO_SET_REPLACE) with your new rulesets.That sounds about as atomic as you can get: with one kernel call. However, more knowledgeable parties are invited to dispute this. :-)Edit:I can confirm that your description is correct. iptables-restore is done as an atomic operation in the kernel.To be even more specific the operation "only" is atomic on a per CPU basis. As we store the entire ruleset blob per CPU (due to cache optimizations). I think one way is to look for ones that reputable sites use. For example, I learnt about Slicehost through Refactor my Code using it, and I love it. :-) You can sort by multiple columns by specifying more than one sort key when calling setSortKeys in the RowSorter you're using. The SGI STL has an extension called select1st. Too bad it's not in standard STL! Yes, that works (with the class name as a string, as jonah mentioned). Also, you can set style attributes directly on an object, using the DOM Level 2 Style interface. e.g.,button.style.fontFamily = "Verdana, Arial, sans-serif";where button is (presumably) a button object. :-) [If you want some ready-to-use code, please scroll to my "Edit3" (after the cut). The rest is here for posterity.]To flesh out Dustman's idea:List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(array));list.removeAll(Arrays.asList("a"));array = list.toArray(array);Edit: I'm now using Arrays.asList instead of Collections.singleton: singleton is limited to one entry, whereas the asList approach allows you to add other strings to filter out later: Arrays.asList("a", "b", "c").Edit2: The above approach retains the same array (so the array is still the same length); the element after the last is set to null. If you want a new array sized exactly as required, use this instead:array = list.toArray(new String[0]);Edit3: If you use this code on a frequent basis in the same class, you may wish to consider adding this to your class:private static final String[] EMPTY_STRING_ARRAY = new String[0];Then the function becomes:List&lt;String&gt; list = new ArrayList&lt;&gt;();Collections.addAll(list, array);list.removeAll(Arrays.asList("a"));array = list.toArray(EMPTY_STRING_ARRAY);This will then stop littering your heap with useless empty string arrays that would otherwise be newed each time your function is called.cynicalman's suggestion (see comments) will also help with the heap littering, and for fairness I should mention it:array = list.toArray(new String[list.size()]);I prefer my approach, because it may be easier to get the explicit size wrong (e.g., calling size() on the wrong list). Is this close to what you want: The first class contains the second class, but the second class (that is to be created first) just has a reference to the first class? Yes. Think of how a RPN calculator works. Now, instead of calculating the value, instead you add the operation to the tree. So, for example, 2 3 4 + *, when you get to the +, then rather than putting 7 on the stack, you put (+ 3 4) on the stack. And similarly when you get to the * (your stack will look like 2 (+ 3 4) * at that stage), it becomes (* 2 (+ 3 4)).This is prefix notation, which you then have to convert to infix. Traverse the tree left-to-right, depth first. For each "inner level", if the precedence of the operator is lower, you will have to place the operation in brackets. Here, then, you will say, 2 * (3 + 4), because the + has lower precedence than *.Hope this helps!Edit: There's a subtlety (apart from not considering unary operations in the above): I assumed left-associative operators. For right-associative (e.g., **), then you get different results for 2 3 4 ** ** ⇒ (** 2 (** 3 4)) versus 2 3 ** 4 ** ⇒ (** (** 2 3) 4).When reconstructing infix from the tree, both cases show that the precedence doesn't require bracketing, but in reality the latter case needs to be bracketed ((2 ** 3) ** 4). So, for right-associative operators, the left-hand branch needs to be higher-precedence (instead of higher-or-equal) to avoid bracketing.Also, further thoughts are that you need brackets for the right-hand branch of - and / operators too. Rethrowing the same exception is useful if you want to, say, log the exception, but not handle it.Throwing a new exception that wraps the caught exception is good for abstraction. e.g., your library uses a third-party library that throws an exception that the clients of your library shouldn't know about. In that case, you wrap it into an exception type more native to your library, and throw that instead. The only main difference I know of is that, since you're not using a concrete class, inlining is (much?) harder to do. The world's at your fingertips! Comparison of issue tracking systems Parrot is a bytecode interpreter (possibly with a JIT at a future stage). Think Java and its virtual machine, except that Java is (at the moment) more geared towards static languages, and Parrot is geared towards dynamic languages from the beginning.Also see Cody's excellent answer! Highly recommended. jQuery has a lot of useful iteration features that may be able to use for that. :-) I haven't used jQuery, but find and attr look promising for your purposes. Unless you're (becoming) an expert in the field, do not use home-made crypto in production products. Enough said. You can use %w0 if I remember right. I just tested it, too. :-)inttest(int x){ int y; asm ("rorw $8, %w0" : "=q" (y) : "0" (x)); return y;}Edit: In response to the OP, yes, you can do the following too:inttest(int x){ int y; asm ("xchg %b0, %h0" : "=Q" (y) : "0" (x)); return y;}At present, the only place (that I know of) it's documented in is gcc/config/i386/i386.md, not in any of the standard documentation. I've used java.util.prefs before, and it seems to do the trick for me. Your mileage may vary. Try Ctrl-Alt-F9, and Ctrl-Alt-F10. :-) Yes, you can. Explicit Reg Vars talks about the syntax you need to pin a variable to a specific register. It's normal behaviour of the language. Quoting the perlsyn manpage: The number 0, the strings '0' and "", the empty list (), and undef are all false in a boolean context. All other values are true. Negation of a true value by ! or not returns a special false value. When evaluated as a string it is treated as "", but as a number, it is treated as 0.Because of this, there needs to be a way to return 0 from a system call that expects to return 0 as a (successful) return value, and leave a way to signal a failure case by actually returning a false value. "0 but true" serves that purpose. I'm only a newbie to Python, but here's my approach.def mkgmtime(fields): now = int(time.time()) gmt = list(time.gmtime(now)) gmt[8] = time.localtime(now).tm_isdst disp = now - time.mktime(tuple(gmt)) return disp + time.mktime(fields)There, my proposed name for the function too. :-) It's important to recalculate disp every time, in case the daylight-savings value changes or the like. (The conversion back to tuple is required for Jython. CPython doesn't seem to require it.)This is super ick, because time.gmtime sets the DST flag to false, always. I hate the code, though. There's got to be a better way to do it. And there are probably some corner cases that I haven't got, yet. Since you used the words Java and architect in the same sentence, may I suggest the study materials used in the SCEA certification? In particular, I've found Core J2EE Patterns a really helpful book for thinking about bigger-picture architectural issues. Are you able to use Boost (Smart Pointers, Bind, Function) directly? From the GCC changelogs, the actual std::tr1 stuff is only available from 4.0 onwards. :-(I know there are differences between the Boost and std::tr1, but hopefully these can be worked around satisfactorily. Let me know how it works for you. :-) On a different topic, I'm installing the g++-3.4 package on my Ubuntu laptop now, and I'm going to see if I can compile libstdc++ from the Subversion trunk on it. If so, I'll let you know! (If not, I'll let you know too. :-P) In C++, using the != test is preferred for generality. Iterators in C++ have various concepts, like input iterator, forward iterator, bidirectional iterator, random access iterator, each of which extends the previous one with new capabilities. For &lt; to work, random access iterator is required, whereas != merely requires input iterator. As long as each execution of the function is in its own thread (i.e., the local variables number, urandom, bytes_read are not shared between threads), I don't see any thread-safety problems. Each thread will then have its own file descriptor into /dev/urandom. /dev/urandom can be opened simultaneously from multiple processes, so that's okay.By the way, /dev/urandom can fail to open, and your code should deal with it. Some causes are: running out of available file descriptors; /dev not properly mounted (although in this case you have bigger problems); your program is being run in a special chroot which denies access to any devices; etc. If you're using C++11, you have access to the &lt;unordered_map&gt; and &lt;unordered_set&gt; headers. These provide classes std::unordered_map and std::unordered_set.If you're using C++03 with TR1, you have access to the classes std::tr1::unordered_map and std::tr1::unordered_set, using the same headers (unless you're using GCC, in which case the headers are &lt;tr1/unordered_map&gt; and &lt;tr1/unordered_set&gt; instead).In all cases, there are corresponding unordered_multimap and unordered_multiset types too. const helps you isolate code that "change things" behind your back. So, in a class, you'd mark all methods that don't change the state of the object as const. This means that const instances of that class will no longer be able to call any non-const methods. This way, you're prevented from accidentally calling functionality that can change your object.Also, const is part of the overload mechanism, so you can have two methods with identical signatures, but one with const and one without. The one with const is called for const references, and the other one is called for non-const references.Example:#include &lt;iostream&gt;class HelloWorld { bool hw_called;public: HelloWorld() : hw_called(false) {} void hw() const { std::cout &lt;&lt; "Hello, world! (const)\n"; // hw_called = true; &lt;-- not allowed } void hw() { std::cout &lt;&lt; "Hello, world! (non-const)\n"; hw_called = true; }};intmain(){ HelloWorld hw; HelloWorld* phw1(&amp;hw); HelloWorld const* phw2(&amp;hw); hw.hw(); // calls non-const version phw1-&gt;hw(); // calls non-const version phw2-&gt;hw(); // calls const version return 0;} 1199059200 represents December 31 2007 in UTC. Sample Python session:&gt;&gt;&gt; import time&gt;&gt;&gt; time.gmtime(1199059200)(2007, 12, 31, 0, 0, 0, 0, 365, 0)Remember that all time_t values are against UTC. :-) You have to adjust accordingly to your timezone.Edit: Since you and I are both in New Zealand, here's how you might have got the 1199098800 value:&gt;&gt;&gt; time.localtime(1199098800)(2008, 1, 1, 0, 0, 0, 1, 1, 1)This is so because in New Year (summer in New Zealand), the timezone here is +1300. Do the maths and see. :-)For January 1 2008 in UTC, add 86400 to 1199059200, and get 1199145600.&gt;&gt;&gt; time.gmtime(1199145600)(2008, 1, 1, 0, 0, 0, 1, 1, 0) I've tested your code on my system, and it works fine. I think that there's a mismatch between your compiler, and the compiler that your Boost.Signals library is built on. Try to download the Boost source, and compile Boost.Signals using the same compiler as you use for building your code.Just for my info, what compiler (and version) are you using? Don't use const char* as the key for maps. That means the map is ordered by the addresses of the strings, not the contents of the strings. Use a std::string as the key type, instead.std::map is not a hash table, it's usually implemented as a red-black tree, and elements are guaranteed to be ordered by some criteria (by default, &lt; comparison between keys). Jython has a compiler targeting JVM bytecode. The bytecode is fully dynamic, just like the Python language itself! Very cool. (Yes, as Greg Hewgill's answer alludes, the bytecode does use the Jython runtime, and so the Jython jar file must be distributed with your app.) I decided I had to have a look at tree.com and figure out why it's not respecting the Unicode setting of the console. It turns out that (like many of the command-line file utilities), it uses a library called ulib.dll to do all the printing (specifically, TREE::DisplayName calls WriteString in ulib).Now, in ulib, the WriteString method is implemented in two classes, SCREEN and STREAM. The SCREEN version uses WriteConsoleW directly, so all the Unicode characters get correctly displayed. The STREAM version converts the Unicode text to one of three different encodings (_UseConsoleConversions ⇒ console codepage (GetConsoleCP), _UseAnsiConversions ⇒ default ANSI codepage, otherwise ⇒ default OEM codepage), and then writes this out. I don't know how to change the conversion mode, and I don't believe the conversion can be disabled.I've only looked at this briefly, so perhaps more adventurous souls can speak more about it! :-) argv points to writable strings. Just write stuff to them:#include &lt;string.h&gt;#include &lt;unistd.h&gt;intmain(int argc, char** argv){ strcpy(argv[0], "Hello, world!"); sleep(10); return 0;} In my opinion, it's best if Foo and Bar subclass off a common ancestor class (maybe AbstractFoo), which has all the functionality. What difference in behaviour should exist between Foo and Bar? Code that difference as an abstract method in AbstractFoo, not by using a if statement in your code.Example: Rather than this:if (foo instanceof Bar) { // Do Bar-specific things}Do this instead:class Bar extends AbstractFoo { public void specialOp() { // Do Bar-specific things }}// ...foo.specialOp();The benefit of this approach is that if you need a third class, that's much like Foo but has just a little bit of difference, you don't have to go through all your code and add edit all the if statements. :-) If you're using condition variables correctly, this won't matter.The basic flow of your code should be (in pseudocode):lock(lockobj);while (!signalled) { wait(condvar);}signalled = false;unlock(lockobj);on the waiting side, and:lock(lockobj);signalled = true;notify(condvar);unlock(lockobj);on the signalling side. (Of course, the lock object and condition variable used have to be the same on both sides.) Hope this helps! Alternative answer (also in pseudocode) if you want multiple signallings (i.e., if signalled twice, then two threads can wait before the state is unsignalled again).Waiting side:lock(lockobj);while (signalled != 0) { wait(condvar);}--signalled;unlock(lockobj);Signalling side:lock(lockobj);++signalled;notify(condvar);unlock(lockobj); find . -print0 | grep --null 'FooBar' | xargs -0 ...I don't know about whether grep supports --null, nor whether xargs supports -0, on Leopard, but on GNU it's all good. No, since the new throw is not in the try block directly. Have a look at those other bindings, and write a PHP extension! :-) If you can (if you're running Unix), I suggest using the tr facility for this: it's custom-built for this purpose. Remember, no code == no buggy code. :-)Edit: Sorry, you're right, tr doesn't seem to work. How about sed? It's a pretty stupid script I've written, but it works for me.#!/bin/sed -fs/á/a/g;s/é/e/g;s/í/i/g;s/ó/o/g;s/ú/u/g;s/ñ/n/g; execvp :-)Edit: Okay. Here's a Perl version, which can serve as pseudocode for your problem.use List::Util qw(first);my @path = split /:/, $ENV{PATH};my $dir = first {$_ ||= '.'; -x "$_/$name"} @path or die "Can't find program $name\n";exec "$dir/$name", @args;split splits a string into an array of strings, using the given separator. first finds the first item that matches some criterion; here, that the concatenation of the directory and the name being sought after is executable (-x). It then runs that.Hope it helps! It tests whether eax is 0, or above, or below. In this case, the jump is taken if eax is 0. if (as[n] &lt;= 0) is the check. If valid values can be negative like you say, then you need a different sentinel to check against. Can valid values ever be zero? If not, then just make the test if (as[n] == 0). This makes your code easier to write, because by default vectors of ints are filled with zeroes. In the comments, Robert Gould asked for a working version for posterity:#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;boost/random.hpp&gt;struct bar : std::unary_function&lt;unsigned, unsigned&gt; { boost::mt19937 &amp;_state; unsigned operator()(unsigned i) { boost::uniform_int&lt;&gt; rng(0, i - 1); return rng(_state); } bar(boost::mt19937 &amp;state) : _state(state) {}};void foo(std::vector&lt;unsigned&gt; &amp;vec, boost::mt19937 &amp;state){ bar rand(state); std::random_shuffle(vec.begin(), vec.end(), rand);} According to RFC 2046, section 5.1.1: boundary := 0*69&lt;bchars&gt; bcharsnospace bchars := bcharsnospace / " " bcharsnospace := DIGIT / ALPHA / "'" / "(" / ")" / "+" / "_" / "," / "-" / "." / "/" / ":" / "=" / "?"So it can be between 1 and 70 characters long, consisting of alphanumeric, and the punctuation you see in the list. Spaces are allowed except at the end. According to the 1.8 ChangeLog, the function has been renamed scm_c_locale_stringn_to_number. #include &lt;stdint.h&gt;#include &lt;stdio.h&gt;union ui64 { uint64_t one; uint16_t four[4];};intmain(){ union ui64 number = {0x123456789abcdef0}; printf("%x %x %x %x\n", number.four[0], number.four[1], number.four[2], number.four[3]); return 0;} Why would you want to restrict the types in this case? Templates allow "static duck typing", so anything allowed by what your sum function in this case should be allowed. Specifically, the only operation required of T is add-assignment and initialisation by 0, so any type that supports those two operations would work. That's the beauty of templates.(If you changed your initialiser to T result = T(); or the like, then it would work for both numbers and strings, too.) You can use the codecvt locale facet. There's a specific specialisation defined, codecvt&lt;wchar_t, char, mbstate_t&gt; that may be of use to you, although, the behaviour of that is system-specific, and does not guarantee conversion to UTF-8 in any way. #!/bin/sed -f1,/^#include/ { /^#include/i\#include "newfile.h"}How this script works: For lines between 1 and the first #include (after line 1), if the line starts with #include, then prepend the specified line.However, if the first #include is in line 1, then both line 1 and the next subsequent #include will have the line prepended. If you are using GNU sed, it has an extension where 0,/^#include/ (instead of 1,) will do the right thing. GCC has some built-ins for atomic accesses, too. Sutter's Mill template &lt;typename K, typename V&gt;V get(std::map&lt;K, V&gt; const&amp; map, K const&amp; key){ std::map&lt;K, V&gt;::const_iterator iter(map.find(key)); return iter != map.end() ? iter-&gt;second : V();}Improved implementation based on comments:template &lt;typename T&gt;typename T::mapped_type get(T const&amp; map, typename T::key_type const&amp; key){ typename T::const_iterator iter(map.find(key)); return iter != map.end() ? iter-&gt;second : typename T::mapped_type();} Try this:my %myhash;$myhash{$key} ||= {};You can't declare a hash element in a my clause, as far as I know. You declare the hash first, then add the element in.Edit: I see you've taken out the my. How about trying ||= instead of |=? The former is idiomatic for "lazy" initialisation. Let's turn this into code golf! Based on David's excellent answer, here's mine:perl -ane 'print "@F[0,1]\n";'Edit: A real golf submission would look more like this (shaving off five strokes):perl -ape '$_="@F[0,1]"'but that's less readable for this question's purposes. :-P Here's a general solution (if we step away from code-golfing a bit).#!/usr/bin/perl -nchop; # strip newline (in case next line doesn't strip it)s/#.*//; # strip commentsnext unless /\S/; # don't process line if it has nothing (left)@fields = (split)[0,1]; # split line, and get wanted fieldsprint join(' ', @fields), "\n";Normally split splits by whitespace. If that's not what you want (e.g., parsing /etc/passwd), you can pass a delimiter as a regex:@fields = (split /:/)[0,2,4..6];Of course, if you're parsing colon-delimited files, chances are also good that such files don't have comments and you don't have to strip them. By default, iostreams and stdio are synchronised. Reference.This doesn't mean that manually adjusting the stdio buffering is a good idea, though! You may wish to utilise std::endl or std::flush (from &lt;ostream&gt;), which may help you. e.g.,std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;orstd::cout &lt;&lt; "Hello, world!\n" &lt;&lt; std::flush;Both of these do the same thing. (std::endl = print endline, then flush.) As far as I know, the standard Unix way of dealing with non-ASCII characters is to encode them as UTF-8. Well, apart from Common Lisp (labels) and Scheme (letrec) which you've already mentioned, JavaScript also allows you to name an anonymous function:var foo = {"bar": function baz() {return baz() + 1;}};which can be handier than using callee. (This is different from function in top-level; the latter would cause the name to appear in global scope too, whereas in the former case, the name appears only in the scope of the function itself.) Mike B's answered your question, so I'll just comment on your code. If TTF_OpenFont doesn't return null, or if TTF_CloseFont can handle nulls harmlessly, you don't need a CloseFont class at all, just use &amp;TTF_CloseFont. Informally, it means that compilers are allowed to graft the contents of the function onto the call site, so that there is no function call. If your function has big control statements (e.g., if, switch, etc.), and the conditions can be evaluated at compile time at the call site (e.g., constant values used at call site), then your code ends up much smaller (the unused branches are dropped off).More formally, inline functions have different linkage too. I'll let C++ experts talk about that aspect. As other posters have said, comdef.h comes with Visual C++. It supplements the VC-specific builtin COM support. Since you say you're using GCC, you will probably have to adapt your code to use "low-level COM", since GCC doesn't have the kind of builtin COM support that VC has (in specific, using #import for importing type libraries into convenient wrapper classes). Since ray asked, I thought I'd rewrite my whole program without using Perl's implicitness (except the use of &lt;ARGV&gt;; that's hard to write out by hand). This will probably make Python people happier (braces notwithstanding :-P):while (my $line = &lt;ARGV&gt;) { chop $line; $line =~ s/#.*//; next unless $line =~ /\S/; @fields = (split ' ', $line)[0,1]; print join(' ', @fields), "\n";}Is there anything I missed? Hopefully not. The ARGV filehandle is special. It causes each named file on the command line to be read, unless none are specified, in which case it reads standard input.Edit: Oh, I forgot. split ' ' is magical too, unlike split / /. The latter just matches a space. The former matches any amount of any whitespace. This magical behaviour is used by default if no pattern is specified for split. (Some would say, but what about /\s+/? ' ' and /\s+/ are similar, except for how whitespace at the beginning of a line is treated. So ' ' really is magical.)The moral of the story is, Perl is great if you like lots of magical behaviour. If you don't have a bar of it, use Python. :-P Looks like QEMU does enough emulation for you to install a SPARC Linux on: http://www.bellard.org/qemu/status.htmlIn which case, just grab a SPARC distribution (e.g., Debian), and you're all set! You can write a special heap allocator for specific sizes of objects that is very performant. However, the general heap allocator is not particularly performant.Also I agree with Torbjörn Gyllebring about the expected lifetime of objects. Good point! ln -f /bin/bash /bin/sh:-P (No, it's not a serious answer. Please don't hose your system by doing it!) I'm assuming that you're using a Transformer to do the actual writing (to a StreamResult). In which case, do this before you call transform:transformer.setOutputProperty(OutputKeys.INDENT, "yes");transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2"); Try:bu 0xff3c6100If I remember right, WinDbg allows setting breakpoints by address too. big is called max. Use standard library functionality when it's there.My approach is different. Rather than lots of tests, I simply add the squares of all three, then subtract the square of the smallest one.(define (exercise1.3 a b c) (let ((smallest (min a b c)) (square (lambda (x) (* x x)))) (+ (square a) (square b) (square c) (- (square smallest)))))Whether you prefer this approach, or a bunch of if tests, is up to you, of course.Alternative implementation using SRFI 95:(define (exercise1.3 . args) (let ((sorted (sort! args &gt;)) (square (lambda (x) (* x x)))) (+ (square (car sorted)) (square (cadr sorted)))))As above, but as a one-liner (thanks synx @ freenode #scheme); also requires SRFI 1 and SRFI 26:(define (exercise1.3 . args) (apply + (map! (cut expt &lt;&gt; 2) (take! (sort! args &gt;) 2)))) Use this:Runtime.getRuntime().exec(new String[] {"sh", "-l", "-c", "./foo"});Main point: don't put the double quotes in. That's only used when writing a command-line in the shell!e.g., echo "Hello, world!" (as typed in the shell) gets translated to:Runtime.getRuntime().exec(new String[] {"echo", "Hello, world!"});(Just forget for the moment that the shell normally has a builtin for echo, and is calling /bin/echo instead. :-)) I've had a chance to look at fdlibm's implementation. The comments describe the algorithm used: * n * Method: Let x = 2 * (1+f) * 1. Compute and return log2(x) in two pieces: * log2(x) = w1 + w2, * where w1 has 53-24 = 29 bit trailing zeros. * 2. Perform y*log2(x) = n+y' by simulating muti-precision * arithmetic, where |y'|&lt;=0.5. * 3. Return x**y = 2**n*exp(y'*log2)followed by a listing of all the special cases handled (0, 1, inf, nan).The most intense sections of the code, after all the special-case handling, involve the log2 and 2** calculations. And there are no loops in either of those. So, the complexity of floating-point primitives notwithstanding, it looks like a asymptotically constant-time algorithm.Floating-point experts (of which I'm not one) are welcome to comment. :-) You can use %llu for long long. However, this is not very portable either, because long long isn't guaranteed to be 64 bits. :-) From the GNU C Library manual: Here is an example showing how to read the mask with umask without changing it permanently:mode_tread_umask (void){ mode_t mask = umask (0); umask (mask); return mask;} However, it is better to use getumask if you just want to read the mask value, because it is reentrant (at least if you use the GNU operating system).getumask is glibc-specific, though. So if you value portability, then the non-reentrant solution is the only one there is.Edit: I've just grepped for -&gt;umask all through the Linux source code. There is nowhere that will get you the umask of a different process. Also, there is no getumask; apparently that's a Hurd-only thing. No, J# programs are designed to run on the .NET platform. See the J# FAQ. I think a lot of other languages (ones that don't have delete, for example) don't give the programmer quite the same control over object lifetimes, and so there must be other means to provide for deterministic disposal of resources. In C#, for example, using using with IDisposable is common. For people who are commenting in this thread about RAII (resource acquisition is initialisation), here's a motivational example.class StdioFile { FILE* file_; std::string mode_; static FILE* fcheck(FILE* stream) { if (!stream) throw std::runtime_error("Cannot open file"); return stream; } FILE* fdup() const { int dupfd(dup(fileno(file_))); if (dupfd == -1) throw std::runtime_error("Cannot dup file descriptor"); return fdopen(dupfd, mode_.c_str()); }public: StdioFile(char const* name, char const* mode) : file_(fcheck(fopen(name, mode))), mode_(mode) { } StdioFile(StdioFile const&amp; rhs) : file_(fcheck(rhs.fdup())), mode_(rhs.mode_) { } ~StdioFile() { fclose(file_); } StdioFile&amp; operator=(StdioFile const&amp; rhs) { FILE* dupstr = fcheck(rhs.fdup()); if (fclose(file_) == EOF) { fclose(dupstr); // XXX ignore failed close throw std::runtime_error("Cannot close stream"); } file_ = dupstr; return *this; } int read(std::vector&lt;char&gt;&amp; buffer) { int result(fread(&amp;buffer[0], 1, buffer.size(), file_)); if (ferror(file_)) throw std::runtime_error(strerror(errno)); return result; } int write(std::vector&lt;char&gt; const&amp; buffer) { int result(fwrite(&amp;buffer[0], 1, buffer.size(), file_)); if (ferror(file_)) throw std::runtime_error(strerror(errno)); return result; }};intmain(int argc, char** argv){ StdioFile file(argv[1], "r"); std::vector&lt;char&gt; buffer(1024); while (int hasRead = file.read(buffer)) { // process hasRead bytes, then shift them off the buffer }}Here, when a StdioFile instance is created, the resource (a file stream, in this case) is acquired; when it's destroyed, the resource is released. There is no try or finally block required; if the reading causes an exception, fclose is called automatically, because it's in the destructor.The destructor is guaranteed to be called when the function leaves main, whether normally or by exception. In this case, the file stream is cleaned up. The world is safe once again. :-D Not that I'm aware of, but you can use hash tables for something quite similar. See the top answer on this thread. Nope, it's no different in VB! :-) Your library should be named libfoo.so.2.y.z, with symlinks of libfoo.so.2 and libfoo.so both pointing to that. The library should be created using -soname libfoo.so.2 in the linker command line (or -Wl,-soname,libfoo.so.2 on the gcc command line).Hope that helps! In the Wikipedia example, those instances can be passed into a function that doesn't have to care which class those instances belong to. The function just calls execute on the object passed, and know that the Right Thing will happen.A typical example of the Strategy Pattern is how files work in Unix. Given a file descriptor, you can read from it, write to it, poll it, seek on it, send ioctls to it, etc., without having to know whether you're dealing with a file, directory, pipe, socket, device, etc. (Of course some operations, like seek, don't work on pipes and sockets. But reads and writes will work just fine in these cases.)That means you can write generic code to handle all these different types of "files", without having to write separate code to deal with files versus directories, etc. The Unix kernel takes care of delegating the calls to the right code.Now, this is Strategy Pattern as used in kernel code, but you didn't specify that it had to be user code, just a real world example. :-) std::vector&lt;double&gt;(n).swap(vec);This has the advantage of actually compacting your vector too. (In your first example, clear() does not guarantee to compact your vector.) Arrays.asList cannot be used with arrays of primitives. Use this instead:Integer[] randomizer = new Integer[] {200,300,212,111,6,2332}; Collections.shuffle(Arrays.asList(randomizer));The same rule applies to most classes in the collections framework, in that you can't use primitive types.The original code (with int[]) compiled fine, but did not work as intended, because of the behaviour of the variadic method asList: it just makes a one-element list, with the int array as its only member. Unless you have a specific font named Helvetica, you should realise that on some platforms (such as Windows, via FontSubstitutes), Helvetica is aliased to Arial. That might be the source of the problem. Try another font and see. You can join both t1 and t2 (in either order), then run task3 after the join. To supplement Mitch Wheat's comment, here's a Java implementation (which does a single block only). I'm sure you'll find a way to convert it into C#, and to do multiple blocks.int sum = 0;for (byte b : buffer) { sum += (int) b &amp; 255;}return sum % 32767;Hope this helps! You could ask for documentation to be in OOXML (.docx, in the case of Word) format. Not as ideal as using ODT, in my opinion, however, it's still just a zip file with a bunch of XML files inside. :-) grep -r REGEX .Replace . with whatever directory you want to search from. If you're using the Java platform, you can use ImageIO to read the image, then use getHeight and getWidth on the BufferedImage returned from the read operation.I admit this is quite a heavyweight approach, so I'm sure there is an even better approach. I just have to find it. :-PAs for .NET, I have no idea. :-) This doesn't help you directly, however, IMAP connections in JavaMail do support SASL (and thus CRAM-MD5, see the Java SASL documentation) if you set the mail.imap.sasl.enable boolean property to true.Unfortunately, there is no mail.smtp.sasl.enable property, and SASL cannot be enabled for SMTP in JavaMail. :-(However, you can download the JavaMail source code, and you can try to edit the SMTP code to support SASL in a similar manner to the IMAP code. Good luck! Some threads do background tasks, like sending keepalive packets, or performing periodic garbage collection, or whatever. These are only useful when the main program is running, and it's okay to kill them off once the other, non-daemon, threads have exited.Without daemon threads, you'd have to keep track of them, and tell them to exit, before your program can completely quit. By setting them as daemon threads, you can let them run and forget about them, and when your program quits, any daemon threads are killed automatically. You don't need to use a custom allocator if you are using C++, and you wrap all allocations around std::tr1::shared_ptr (where you can specify a deallocation function). This ensures that even when clients release the last reference to the shared pointer, it's still code in your library (or your library's CRT) that gets called when the object is to be freed.This is one way to solve "DLL boundary hell". Hope it helps! :-)Edit: I think I misread the intent of your question. Rather than not wanting any dependency on a CRT because you are worried about DLL boundary hell, I suppose you just wanted a version of your DLL that you can install anywhere. In that case, you can make your program link to msvcrt.dll. That's available on any Windows system.You didn't hear this from me, but apparently in the Driver Development Kit you can find some sort of import library that allows newer versions of Visual Studio to link to msvcrt. The Open Group Base Specifications explains why this is: for compatibility with existing C code. Neither the pointers nor the string contents themselves are intended to be changed, though. Thus, in this case, you can get away with const_cast-ing the result of c_str().Quote: The statement about argv[] and envp[] being constants is included to make explicit to future writers of language bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state that idea in standard C. Specifying two levels of const- qualification for the argv[] and envp[] parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the array of pointers is noted as constant.The table and text after that is even more insightful. However, Stack Overflow doesn't allow tables to be inserted, so the quote above should be enough context for you to search for the right place in the linked document. I think you should profile your application, both with and without interning. You will then see exactly what the effect is.I don't believe there is a way to see the size of the string constant pool. In some cases, this can be done. For example, part of the Emacs build process is to load up all the Lisp libraries and then dump the memory image on disk for quick loading. Some other language interpreters do that too (I'm thinking of Lisp and Scheme implementations, mostly). However, they're specially designed for that kind of use, so I don't know what special things they have to do to allow that to work.I think this would be very hard to do for a random program, but if you wrote a framework where all objects supported serialisation/deserialisation, you can then serialise all objects used by your program, and then ship that elsewhere, and deserialise them at the other end.The other people's answers about virtualisation are on the spot, too. Collect prime factors for all numbers between 1 and 20. Counting the maximal exponents of each prime factor, we have 16 = 2**4, 9 = 3**2, as well as 5, 7, 11, 13, 17, 19 (each appearing only once). Multiply the lot, and you have your answer. The obvious downside to me is that you always have to build all the code at once. With .cpp files, you can have separate compilation, so you're only rebuilding bits that have really changed. If you have money to spare, Hex-Rays Decompiler could be worth your while. :-) call is for calling non-virtual, static, or superclass methods, i.e., the target of the call is not subject to overriding. callvirt is for calling virtual methods (so that if this is a subclass that overrides the method, the subclass version is called instead). The Java API documentation explains why (http://java.sun.com/javase/6/docs/api/java/lang/Class.html#newInstance()): Note that this method propagates any exception thrown by the nullary constructor, including a checked exception. Use of this method effectively bypasses the compile-time exception checking that would otherwise be performed by the compiler. The Constructor.newInstance method avoids this problem by wrapping any exception thrown by the constructor in a (checked) InvocationTargetException.In other words, it can defeat the checked exceptions system. Does this work in IE?document.getElementById("putItHere") .appendChild(document.createTextNode("first line\nsecond line"));I tested it with Firefox and it works. :-) In this specific case, the switch can be turned into a jump table. The if statement (if you write your = as == :-P) could still do the same thing if the compiler could tell that x isn't changing between the if clauses (which is usually the case, unless x is volatile or something). Usually, the recommendation (see What about shared memory? in the memcached page) is to run memcached on the same machines as web servers, on the premise that web applications are CPU-heavy (which memcached is not), whereas memcached is memory-heavy (which most web applications are not, at least in comparison).So, if your web server has plenty of memory, it's a good idea to run memcached on it. YMMV. You can do this:Create a list, 0..1000.Shuffle the list. (See Fisher-Yates shuffle for a good way to do this.)Return numbers in order from the shuffled list.So this doesn't require a search of old values each time, but it still requires O(N) for the initial shuffle. But as Nils pointed out in comments, this is amortised O(1). Generally, the C library handles the implementation of malloc, requesting memory from the OS (either via anonymous mmap or, in older systems, sbrk) as necessary. So your kernel side of things should handle allocating whole pages via something like one of those means.Then it's up to malloc to dole out memory in a way that doesn't fragment the free memory too much. I'm not too au fait with the details of this, though; however, the term arena comes to mind. If I can hunt down a reference, I'll update this post. Option 2 works, if you write a new value for $PQRHOME after resolving its real path and check its security. That way very little of your code needs changing thereafter.As far as keeping the setuid privileges, it would help if you can do some sort of privilege separation, so that any operations involving input from the real user runs under the real uid. The privileged process and the real-uid process then talk using a socketpair or something like it. Notice that if iter-&gt;arrivalTime == 0, then the list iterator gets incremented twice: once before element removal, and once again at the end of the loop.If the item to be removed is the last item in the list, this will obviously not work correctly. I dare say that it never did work correctly even in VS2003, but VS2005 alerts you about it better. :-)Remember, it's undefined behaviour to iterate past end(). Absolutely anything can happen, such as program crash, or (in this case) an error message. I believe that "wrap all pointers in shared_ptr" should indeed be the default mode, and is suitable advice to give to your junior coders. However, in the special ownership cases that you mentioned, auto_ptr is indeed more appropriate and its use should be encouraged under such circumstances. Dinkumware supposedly produces one of the most standards-compliant implementations of the C++ standard library. You can get a binary licence for VS2005 for $200. Compile and run this with -cp tools.jar (where you have to specify the location of your tools.jar, obviously).import com.sun.source.util.Trees;import javax.tools.JavaCompiler;import javax.tools.StandardJavaFileManager;import javax.tools.ToolProvider;public class JCTreeTest { private static final JavaCompiler javac = ToolProvider.getSystemJavaCompiler(); public static void main(String[] args) { final StandardJavaFileManager jfm = javac.getStandardFileManager(null, null, null); final JavaCompiler.CompilationTask task = javac.getTask(null, jfm, null, null, null, jfm.getJavaFileObjects(args)); final Trees trees = Trees.instance(task); // Do stuff with "trees" }}It compiles and runs for me, though I have not played with the trees stuff myself, so you'll have to read the javadoc yourself. :-) Good luck! Look in $JAVA_HOME/jre/lib/fontconfig.properties for everything (well, almost) you'd ever want to know about font mapping in Java. :-) In bash:!!:gs/9241/9243/Yes, it uses gs///, not s///g. :-)(zigdon's answer uses the last command starting with pop, such as populate.sh. My answer uses the last command, full stop. Choose which works for you.) Each object (that belongs to a class with at least one virtual function) has a pointer, called a vptr. It points to the vtbl of its actual class (which each class with virtual functions has at least one of; possibly more than one for some multiple-inheritance scenarios).The vtbl contains a bunch of pointers, one for each virtual function. So at runtime, the code just uses the object's vptr to locate the vtbl, and from there the address of the actual overridden function.In your specific case, Polygon, Rectangle, and Triangle each has a vtbl, each with one entry pointing to its relevant area method. Your ppoly1 will have a vptr pointing to Rectangle's vtbl, and ppoly2 similarly with Triangle's vtbl. Hope this helps! According to the WritePrivateProfileString documentation, there is a Unicode version: WritePrivateProfileStringW. Use that, and you should be able to use Unicode characters. It depends on which case is "typical", because exceptions should model, well, atypical conditions. So, if the typical case is that the instance attribute should exist, then use the second code style. If not having instance is as typical as having instance, then use the first style.In the specific case of creating a singleton, I'm inclined to go with the first style, because creating a singleton the initial time is a typical use case. :-) To directly answer your question, the answer is at the bottom of the page you linked to, namely that if a package defines an isa method, then calling UNIVERSAL::isa directly will not call the package isa method. This is very unintuitive behaviour from an object-orientation point of view.The rest of this post is just more questions about why you're doing this in the first place.In code like the above, in what cases would that specific isa test fail? i.e., if it's a method, in which case would the first argument not be the package class or an instance thereof?I ask this because I wonder if there is a legitimate reason why you would want to test whether the first argument is an object in the first place. i.e., are you just trying to catch people saying FooBar::method instead of FooBar-&gt;method or $foobar-&gt;method? I guess Perl isn't designed for that sort of coddling, and if people mistakenly use FooBar::method they'll find out soon enough.Your mileage may vary. I advise returning a std::tr1::shared_ptr (or boost::shared_ptr, if your C++ implementation does not have TR1) instead of a raw pointer. So, instead of using Animal*, use std::tr1::shared_ptr&lt;Animal&gt; instead.Shared pointers handle reference tracking for you, and delete the object automatically if there are no references left to it. pax is a replacement for tar and cpio, with a sane set of command-line options: -r to read from an archive, -w to write to an archive, -rw to do tree-to-tree copies. It also provides a -s option to allow you to perform substitutions on filenames before reading/writing a file from/to an archive. :-)Edit: Mark Baker makes an interesting point (in comments) that I should clarify. pax makes pax archives (which are an extension of ustar, and can be unpacked by most tar programs) by default. But, with the -x option, it can be made to create cpio archives and ustar archives (these two are guaranteed by the standard). Some implementations, such as the BSD one, support creating even more types, such as old-style (pre-ustar) tar archives. With templated classes, the definitions must be available for each translation unit that uses it. The definitions can go in a separate file, usually with .inl or .tcc extension; the header file #includes that file at the bottom. Thus, even though it's in a separate file, it's still #included for each translation unit; it cannot be standalone.So, for your example, rename template_test.cpp to template_test.inl (or template_test.tcc, or whatever), then have #include "template_test.inl" (or whatever) at the bottom of template_test.h, just before the #endif of the include guard.Hope this helps! If you're using SGI STL (or a derivative, such as STLPort), you can use iota. :-)void IndexArray(unsigned int length, vector&lt;unsigned int&gt;&amp; v){ vector&lt;unsigned int&gt;(length).swap(v); iota(v.begin(), v.end(), 0);} Does this code even compile? 10 isn't convertible to an int *, unless you cast it like so:int *a = (int *) 10;*a = 100;In that case, you're trying to write 100 into the memory address at 10. This isn't usually a valid memory address, hence your program crashes. Specify the w option twice, if you're using BSD-style ps. e.g., ps auwwx. A different set of options apply when using System V ps. Commons CLI Do you have to use a sequential list? If a map-type structure is more appropriate, you can use a ConcurrentHashMap. With a list, a ReadWriteLock is probably the most effective way.Edit to reflect OP's edit: Binary search on insertion order? Do you store a timestamp and use that for comparison, in your binary search? If so, you may be able to use the timestamp as the key, and ConcurrentSkipListMap as the container (which maintains key order). If you read the Javadoc for acquiredQueued, you will noticed that it returns true if the thread was interrupted while waiting. Thus, the call to selfInterrupt (as it's called in the OpenJDK source code) is to propagate the interrupt to the calling thread, which would otherwise get swallowed. Try this:${0%/*} Java 2D (Graphics2D and friends) is indeed the best choice that I know of. Swing is actually implemented on top of Java 2D, so yes, if you want non-GUI-type graphics, Java 2D is the way to go. The systems I run have a sudo-only policy. i.e., the root password is * (disabled), and people have to use sudo to get root access. You can then edit your sudoers file to grant/revoke people's access. It's very granular, and has lots of configurability---but has sensible defaults, so it won't take you long to set up. On Unix, I suggest the use of iconv -futf-16le -tutf-8 to filter your output. :-) Perhaps this article will help you? Writing Custom Exit Modules Write your own syslog implementation. :-PThis can be accomplished in two ways.Write your own LD_PRELOAD hook to override the syslog functions, and make them output to stderr instead. I actually wrote a post about this many years ago: http://marc.info/?m=97175526803720 :-PWrite your own syslog daemon. It's just a simple matter of grabbing datagrams out of /dev/log! :-POkay, okay, so these are both facetious answers. Have you profiled syslogd to see where it's choking up most? print.37**$_.$/for 0..823 strokes if you chop the program before submitting. :-P Given a sample document of:&lt;foo&gt; &lt;bar&gt; &lt;baz/&gt; &lt;baz&gt;Hello, world!&lt;/baz&gt; &lt;baz&gt;&lt;qux/&gt;&lt;/baz&gt; &lt;/bar&gt;&lt;/foo&gt;This expression tells you which children of foo/bar have any child elements:foo/bar/*[count(*)&gt;0]This expression tells you which children of foo/bar have any child text nodes:foo/bar/*[text()]So to ensure that all children are empty (no child elements or text nodes), ensure that this expression returns true:not(foo/bar/*[count(*)&gt;0 or text()]) Really lightweight? Executors. :-) So you set up an executor (B, in your description), and A simply submits tasks to the executor. You can.However, for the HMAC, you actually want to store the key somewhere. Without the key, there is no way for you to verify the hash value later. :-) I agree with Viktor's Jython suggestion. Other than that and JavaScript (which you've mentioned, and is built into Java 6+ via the javax.script package), Groovy and JRuby are also worth looking at too.By the way, you should look at Wyvern, also an MMORPG written in Java and using Jython for scripting. Steve Yegge, its author, has much to say about it from time to time. :-) Here's a make-keyword function which packages up keyword creation process (interning of a name into the KEYWORD package). :-)(defun make-keyword (name) (values (intern name "KEYWORD"))) Like you say, you need to show some code. :-)A stack overflow error usually happens when your function calls nest too deeply. See the Stack Overflow Code Golf thread for some examples of how this happens (though in the case of that question, the answers intentionally cause stack overflow). I want to bring up something in response to the comments (from the OP and Colomon, mainly) about efficiency etc. Often times copying stuff around really doesn't matter, in terms of real performance.I have written programs that do a lot of defensive copying. It's an idiom in Java, where, because all objects are passed by pointer, there's lots of aliasing going on, so you copy anything going into/out of your class to break the aliasing, ensuring that clients of your class cannot violate your class invariants by modifying an object after the fact.The programs I've written have defensively copied whole structures in places, including entire lists and maps. Just to be sure that performance isn't affected, I profiled the program extensively. The main bottlenecks were elsewhere (and even then, I tuned those other places so that the main bottleneck left is the network). Nowhere did this defensive copying figure into the hot spots of the program.ETA: I feel the need to clarify the point of my message, since one commenter read it differently from how I intended, and quite possibly others have done too. My point isn't that it's okay to copy stuff around willy-nilly; but rather, one should always profile the performance of their code, rather than guess wildly at how it will perform.Sometimes, when copying whole structures still gives acceptable performance, and at the same time make the code easier to write, then in my opinion, that is a better tradeoff (in most cases) than code that's only marginally faster but much more complicated. I tried your approach, and it worked for me. A few things though: I'm using the C++ interface (though that shouldn't make a difference), and I'm using Java 6 update 10, x64 edition, on Ubuntu 8.04. Perhaps the Java version and/or platform used will make a difference.#include &lt;cstdio&gt;#include &lt;jni.h&gt;intmain(int argc, char** argv){ if (argc != 3) { std::fprintf(stderr, "usage: %s class message\n", argv[0]); return 1; } JavaVM* jvm; void* penv; JavaVMInitArgs args = {JNI_VERSION_1_6}; if (jint res = JNI_CreateJavaVM(&amp;jvm, &amp;penv, &amp;args)) { std::fprintf(stderr, "Can's create JVM: %d\n", res); return -res; } JNIEnv* env(static_cast&lt;JNIEnv*&gt;(penv)); jint vers(env-&gt;GetVersion()); std::printf("JNI version %d.%d\n", vers &gt;&gt; 16, vers &amp; 0xffff); env-&gt;ThrowNew(env-&gt;FindClass(argv[1]), argv[2]); jthrowable exc(env-&gt;ExceptionOccurred()); std::printf("Exception: %p\n", exc); if (exc) { jclass exccls(env-&gt;GetObjectClass(exc)); jclass clscls(env-&gt;FindClass("java/lang/Class")); jmethodID getName(env-&gt;GetMethodID(clscls, "getName", "()Ljava/lang/String;")); jstring name(static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(exccls, getName))); char const* utfName(env-&gt;GetStringUTFChars(name, 0)); jmethodID getMessage(env-&gt;GetMethodID(exccls, "getMessage", "()Ljava/lang/String;")); jstring message(static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(exc, getMessage))); char const* utfMessage(env-&gt;GetStringUTFChars(message, 0)); std::printf("Exception: %s: %s\n", utfName, utfMessage); env-&gt;ReleaseStringUTFChars(message, utfMessage); env-&gt;ReleaseStringUTFChars(name, utfName); } return -jvm-&gt;DestroyJavaVM();}I've used jnitest java/lang/InternalError 'Hello, world!' for my testing; feel free to try with different exception types! I say the first one is more bug-proof. You're not going to have to remember to clear it (it'll just go out of scope and be done). :-)Performance-wise there isn't much of a difference, but you should nevertheless measure both cases and see for yourself. I think the Java enum would be a good model to follow. Essentially, the Java form would look like this:public enum Result { OK("OK"), CANCEL("Cancel"); private final String name; Result(String name) { this.name = name; } public String getName() { return name; }}What's interesting about the Java approach is that OK and CANCEL are immutable, singleton instances of Result (with the methods that you see). You cannot create any further instances of Result. Since they're singletons, you can compare by pointer/reference---very handy. :-)ETA: In Java, instead of doing bitmasks by hand, instead you use an EnumSet to specify a bit set (it implements the Set interface, and works like sets---but implemented using bitmasks). Much more readable than hand-written bitmask manipulation! Here's my implementation. I've refactored it to have a function taking a long and returning a string. :-)import java.math.BigInteger;class UInt64Test { public static void main(String[] args) { for (String arg : args) System.out.println(toUnsignedString(Long.parseLong(arg))); } private static final BigInteger B64 = BigInteger.ZERO.setBit(64); public static String toUnsignedString(long num) { if (num &gt;= 0) return String.valueOf(num); return BigInteger.valueOf(num).add(B64).toString(); }} It's called require_order, according to the manpage I have here. :-) Yes, this is safe, because the value of i will have been set to the next value, before the current value is erased.According to the SGI documentation about hashed containers invalidation does not occur for non-erased elements, nor even for resizing (there is no word on whether insertions cause resizing, so to be careful I admit that as a possibility)---but in the latter case, the iteration order will be changed. But this doesn't apply here, unless you go out of your way to resize the container during traversal or something. :-) getBooleanAttributes0 calls stat (or stat64, if available). If you have the OpenJDK source code, this is listed in file jdk/src/solaris/native/java/io/UnixFileSystem_md.c.So the real question is, why is stat frozen? Is the file being accessed a network file on a server that's down, for example? If this is a reproducible problem, you may wish to use strace to attach to the Java process, just prior to the freezing. Then look in the output for calls to stat, to see what's being accessed. Hahahaha. I shouldn't do homework problems for people, but this is too fun. :-PThis is just the naive implementation. I can answer this without giving the rest of the questions away.(define (tttpo n) (if (zero? n) 1 (+ (tttpo (- n 1)) (tttpo (- n 1)))))Obviously this is a really stupid implementation, but you're asked to give its asymptotic complexity.Think of how to avoid calling tttpo twice per iteration. Since you're asked to avoid using *, you may need to stash the result of tttpo.Read up on tail recursion. To be specific, you need to know how to convert a general recursive algorithm to its equivalent iterative (or tail-recursive, since this is Scheme) version.Obvious once you've written the code for 3. (Or else, show me your answer to 3 and I'll help you further.)Good luck! You can use:System.getProperty("os.name")P.S. You may find this code useful:class ShowProperties { public static void main(String[] args) { System.getProperties().list(System.out); }}All it does is print out all the properties provided by your Java implementations. It'll give you an idea of what you can find out about your Java environment via properties. :-) Quite apart from the fact that any decent compiler does the right thing, and apart from that fact that in modern architectures there's no speed difference between &gt; and &gt;= comparisons, the bigger picture says that this is a "micro-optimisation" that doesn't affect runtime performance in the vast majority of cases.In the case of comparisons it usually doesn't affect readability whichever way you write it, but there are occasions when picking one boundary over the other is clearer: e.g.,if (length &gt;= str.size())versusif (length &gt; str.size() - 1)I don't know about you, but I'd pick option 1 any day. :-) In cases that don't appreciably affect performance, such as this, the more readable option should win. I haven't figured out what's causing the exception so far, but you may wish to have return *value++ in your operator(). :-) How about this (I don't claim to know much about Python, by the way, but this looks like an obvious first step):for path in ('//xhtml:h1', '//xhtml:title'): elemHolder = dom.createXPath(path) elemHolder.namespaceURIs = map elem = elemHolder.selectSingleNode(dom) if elem is not None: return (elem.localName, elem.text)return (None, "Page does not contain h1 or title tag") Thunderbird has a neat plugin called Enigmail for doing just what you want.There are two systems for encrypting emails (and for assuring the authenticity of keys), S/MIME and PGP/MIME. The former uses a traditional PKI (public key infrastructure), meaning that your key has to be signed by a certificate authority to be usable.Thawte has a Freemail service for signing email certificates for free, if you can find people in your area who can certify your identity in person (you will need to take at least one form of government-issued photo ID, preferably two, when you are being certified, such as passport and driving licence).The PGP system uses a more grass-roots style of authenticating. You simply find other people who are already well known in the PGP "web of trust", and get them to verify you (again with similar documentary requirements, though different signers have different requirements).To find such other people, you should seek out "PGP keysigning parties". They're occasions where everybody brings their ID, and everybody signs everybody else's key.So to answer your question about how to trust keys you download: in the S/MIME model, a trusted CA (such as Thawte) has to sign it. In the PGP model, people who are "well known" (to you, at least, and preferably to most PGP users) have to sign it.I happen to be a Thawte Web of Trust notary, so if you want to go the S/MIME route, live near Auckland, and happen to want to be verified, write a comment here or something. :-P You don't want to work with arrays directly. Consider using a vector, instead. Then, you can call the push_back function to add things to the end, and it will automatically resize the vector for you.#include &lt;iostream&gt;#include &lt;vector&gt;intmain() { double value; std::vector&lt;double&gt; values; // Read in values while (std::cin &gt;&gt; value) { values.push_back(value); } // Print them back out for (std::size_t i(0), len(values.size()); i != len; ++i) { std::cout &lt;&lt; values[i]; }} Multipleton?&lt;/facetious&gt;A more serious answer: if there is such a term, I've never heard of it; I would just say non-singleton (or even, I dare say, normal/standard/regular :-P) myself. 13 chars of Golfscript:2,~{..p@+.}doUpdate to explain the operation of the script:2, makes an array of [0 1]~ puts that array on the stackSo, at the time we run the do, we start the stack off with 0 1 (1 at top of stack)The do loop:Each . duplicates the top item of the stack; here, we do this twice (leaving us with 0 1 1 1 on initial run)p prints the topmost value (leaving us with 0 1 1)@ rotates the top 3 items in the stack, so that the third-topmost is at the top (1 1 0)+ adds the top 2 items in the stack (leaving 1 1). duplicates the top value, so that the do loop can check its truthiness (to determine whether to continue)Tracing this mentally a couple of loops will be enough to tell you that this does the required addition to generate the Fibonacci sequence values.Since GolfScript has bignums, there will never be an integer overflow, and so the top-of-stack value at the end of the do loop will never be 0. Thus, the script will run forever. Do not use Class.newInstance(); see this thread: Why is Class.newInstance() evil?Like other answers say, use Constructor.newInstance() instead. Look at the optionsExample.html in your WMD distribution. There's an option to send the result to the server as Markdown. In that case (of using default settings), you're correct, the default security manager does not allow access to local files. I wrote a quick program that takes one argument, how many A characters to print to standard output per second (negative argument means no rate limiting). Hope this helps! :-) (On GNU libc, you will need to link your program with -lrt.)Edit: revised to print dot by default, unless a second argument is specified, in which case the first character of that is used. (And that means, if you want to print the NUL character, just specify an empty string as the second argument. :-))#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;unistd.h&gt;intsleeptill(const struct timespec *when){ struct timespec now, diff; clock_gettime(CLOCK_REALTIME, &amp;now); diff.tv_sec = when-&gt;tv_sec - now.tv_sec; diff.tv_nsec = when-&gt;tv_nsec - now.tv_nsec; while (diff.tv_nsec &lt; 0) { diff.tv_nsec += 1000000000; --diff.tv_sec; } if (diff.tv_sec &lt; 0) return 0; return nanosleep(&amp;diff, 0);}intmain(int argc, char **argv){ double rate = 0.0; char *endp; struct timespec start; double offset; if (argc &gt;= 2) { rate = strtod(argv[1], &amp;endp); if (endp == argv[1] || *endp) rate = 0.0; else rate = 1 / rate; if (!argv[2]) argv[2] = "."; } if (!rate) { fprintf(stderr, "usage: %s rate [char]\n", argv[0]); return 1; } clock_gettime(CLOCK_REALTIME, &amp;start); offset = start.tv_nsec / 1000000000.0; while (1) { struct timespec till = start; double frac; double whole; frac = modf(offset += rate, &amp;whole); till.tv_sec += whole; till.tv_nsec = frac * 1000000000.0; sleeptill(&amp;till); write(STDOUT_FILENO, argv[2], 1); }} Here are some differences between the two languages:Java is a statically typed language; JavaScript is dynamic.Java is class-based; JavaScript is prototype-based.Java constructors are special functions that can only be called at object creation; JavaScript "constructors" are just standard functions.Java requires all non-block statements to end with a semicolon; JavaScript inserts semicolons at the ends of certain lines.Java uses block-based scoping; JavaScript uses function-based scoping.Java has an implicit this scope for non-static methods, and implicit class scope; JavaScript has implicit global scope.Here are some features that I think are particular strengths of JavaScript:JavaScript supports closures; Java can simulate sort-of "closures" using anonymous classes. (Real closures may be supported in a future version of Java.)All JavaScript functions are variadic; Java functions are only variadic if explicitly marked.JavaScript prototypes can be redefined at runtime, and has immediate effect for all referring objects. Java classes cannot be redefined in a way that affects any existing object instances.JavaScript allows methods in an object to be redefined independently of its prototype (think eigenclasses in Ruby, but on steroids); methods in a Java object are tied to its class, and cannot be redefined at runtime. Try this to get setxkbmap working: http://bugs.opensolaris.org/view_bug.do?bug_id=6676221Good luck! volatile tells the compiler that your variable may be changed by other means, than the code that is accessing it. e.g., it may be a I/O-mapped memory location. If this is not specified in such cases, some variable accesses can be optimised, e.g., its contents can be held in a register, and the memory location not read back in again. That's a lot of questions!You can generate JPEG and PNG files from C using libjpeg and libpng, respectively. (Yes, I'm dodging your GIF question on purpose. You don't need to do that; PNG is well-supported by mainstream browsers now and should be preferred. :-P)Browsers generally only support JavaScript for client-side scripting. Using anything else will only destroy the portability of your webpages. Yes, like you say you can use plugins, but some people are averse to installing plugins, and others are behind corporate policies that don't allow such things. You can use shared_ptr from C++11 or Boost:stringfoo(){ shared_ptr&lt;char&gt; p(get_string(), &amp;free); string str(p.get()); return str;}This uses a very specific feature of shared_ptr not available in auto_ptr or anything else, namely the ability to specify a custom deleter; in this case, I'm using free as the deleter. Looks like ASCII to me! On a big-endian system, you get the string "4692543758208515549". :-)Anyway, to actually answer your question, Ruby is useful for that purpose:ruby -e 'p 0x34363932353433373538323038353135353439' Josh Bloch had a talk at Google I/O this year, called Effective Java Reloaded, which you may find interesting. It talks about a mnemonic called "Pecs" (producer extends, consumer super), which explains why you use ? extends T and ? super T in your input parameters (only; never for return types), and when to use which. sieve(BST&lt;int&gt;&amp; t, int n)The &amp; specifies passing by reference rather than value. :-) find . -type f -exec grep $'\r' {} +The $'\r' probably requires bash to function correctly. You can specify different spacings for horizontal and vertical edges for border-spacing or related properties. Just specify more than one measurement. e.g.,border-spacing: 1px 2px; C++ has long double, but there is no guarantee that it's any more precise than a plain double. On an x86 platform, usually double is 64 bits, and long double is either 64 or 80 bits (which gives you 19 significant figures, if I remember right).Your mileage may vary, especially if you're not on x86. Boost has a utility called next (and its inverse, prior) for just that purpose.*itr == *next(itr)Edit: But, if we step back to look at the forest, the real question is, why custom-write your adjacent_find function? (I recommend Nicola Bonelli's answer to be accepted.) That's part of the STL, and doesn't require using Boost, if your code doesn't use Boost (thanks to the commenters for pointing this out). Well, as far as I know, the whole purpose of using backticks is so you can use names that coincide with reserved keywords. So, if the name isn't colliding with a reserved keyword, I don't see any reason to use backticks. But, that's no reason to ban them, either. bools are promotable to ints and can participate in arithmetic operations. This is often not the desired outcome, when a value should just be used for truth testing.A convertible-to-bool is usually something like a void*, where the null pointer is false, and anything else is true, and yet can't be used for arithmetic operations. The dates you print from Calendar are local to your timezone, whereas the epoch is defined to be midnight of 1970-01-01 in UTC. So if you live in a timezone west of UTC, then your date will show up as 1969-12-31, even though (in UTC) it's still 1970-01-01. The kind of loop you describe is called a "busy wait". In real operating systems, sleeping does not cause a busy wait; it tells the operating system to not schedule the process in until the sleep period is over. I can't speak about CAs in general, but I once ran a Windows Server 2003 network with its own CA, and it's definitely possible to make certreq (through the -attrib option) add additional fields to the CSR before it gets to the CA. Thus, it looks to me like it's possible for the CA itself to do much the same thing.Your mileage may vary. I don't agree with using the global namespace at all (well, except for main, of course). For things that are used across the whole application, you can simply use using namespace at the top of your .cpp files, after all the relevant #include lines. When you're accessing the same resource from more than one thread, locking is necessary. If you don't, you have all sorts of strange behaviour, like you're seeing.Since you're using Boost, an easy way to use locking is to use the Boost.Thread library. The best kind of locks you can use for this scenario are reader/writer locks; they're called shared_mutex in Boost.Thread.But yes, what you're seeing is essentially undefined behaviour, due to the lack of synchronisation between the threads. Hope this helps!Edit to answer OP's second question: You should use a reader lock when reading the smart pointer out of the vector, and a writer lock when writing or adding an item to the vector (so, the mutex is for the vector only). If multiple threads will be accessing the pointed-to object (i.e., what the smart pointer points to), then separate locks should be set up for them. In that case, you're better off putting a mutex object in the object class as well. Settings that you want to have available in a user's roaming profile should probably go in the registry, unless you actually want to go to the effort of looking for the user's Application Data folder by hand. :-) You can trace a program. Think about how strace works. Hint: it doesn't use LD_PRELOAD tricks. I would like to add to Nicola's excellent answer. Yes, you must never return a dangling reference (e.g., reference to a local variable), however, there are three useful ways to improve performance in those cases:Return-value optimisation (RVO): You return by value, but eliminate copying by having only one return statement, which creates the return value on the spot. Here's an example of RVO being used: How can I tokenize a C++ string?Named return-value optimisation (NRVO): You return by value, and declare the return value variable first, at the top of the function. All return statements return that variable. With compilers that support NRVO, that variable is allocated in the return-value slot, and does not get copied upon return. e.g.,stringfoobar(){ string result; // fill in "result" return result;}Use a shared_ptr or the like as the return type; this necessitates creating your object on the heap, rather than the stack. This prevents dangling-reference problems while still not requiring the whole object to be copied, just the smart pointer.By the way, I can't take credit for the information about RVO and NRVO; they come straight out of Scott Meyers's More Effective C++. Since I don't have the book with me at the moment, any errors in my description are my doing, not Scott's. :-) Here's how you might implement setAttribute using reflection (I've renamed the function; there are different reflection functions for different field types):public void setIntField(String fieldName, int value) throws NoSuchFieldException, IllegalAccessException { Field field = getClass().getDeclaredField(fieldName); field.setInt(this, value);} See: Secure Deletion of Data from Magnetic and Solid-State Memory What is your function trying to do, just out of curiosity? Is it to run f, n times? If so, you can do this.(define (repeated f n) (for-each (lambda (i) (f)) (iota n))) std::atan2 allows calculating the arctangent of all four quadrants. std::atan only allows calculating from quadrants 1 and 4. If you have the file descriptor, you can use fstat to find out the size, if any. A more generic solution is to seek to the end of the file, and read its location there. Uh oh---generics are not C++ templates. Because of type erasure, the Double in your example won't even show through to the runtime system.In your particular case, if you just want to be able to add various types together, may I suggest method overloading? e.g., double add(double, double), float add(float, fload), BigDecimal add(BigDecimal, BigDecimal), etc. There's a crossover to daylight savings on that day.Are you in New Zealand? If so, that means your timezone files are out of date. Better go to the Java download site and download new ones; look for "JDK DST Timezone Update Tool". Don't use URL.equals. As the documentation says, Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP. C++ does have swapping.#include &lt;algorithm&gt;#include &lt;cassert&gt;intmain(){ using std::swap; int a(3), b(5); swap(a, b); assert(a == 5 &amp;&amp; b == 3);}Furthermore, you can specialise swap for custom types too! It doesn't appear to be built into Boost.Asio (as of current Boost SVN), but, if you're willing to write your own classes to simulate the boost::asio::detail::socket_option ones, you can always follow the examples in boost/asio/socket_base.hpp and do the following:typedef boost::asio::detail::socket_option::timeval&lt;SOL_SOCKET, SO_SNDTIMEO&gt; send_timeout;typedef boost::asio::detail::socket_option::timeval&lt;SOL_SOCKET, SO_RCVTIMEO&gt; receive_timeout;(Obviously, I'm not suggesting you inject the timeval class into the boost::asio::detail::socket_option namespace, but I can't think of a good one to use at the moment. :-P)Edit: My sample implementation of socket_option::timeval, based on socket_option::integer:// Helper template for implementing timeval options.template &lt;int Level, int Name&gt;class timeval{public: // Default constructor. timeval() : value_(zero_timeval()) { } // Construct with a specific option value. explicit timeval(::timeval v) : value_(v) { } // Set the value of the timeval option. timeval&amp; operator=(::timeval v) { value_ = v; return *this; } // Get the current value of the timeval option. ::timeval value() const { return value_; } // Get the level of the socket option. template &lt;typename Protocol&gt; int level(const Protocol&amp;) const { return Level; } // Get the name of the socket option. template &lt;typename Protocol&gt; int name(const Protocol&amp;) const { return Name; } // Get the address of the timeval data. template &lt;typename Protocol&gt; ::timeval* data(const Protocol&amp;) { return &amp;value_; } // Get the address of the timeval data. template &lt;typename Protocol&gt; const ::timeval* data(const Protocol&amp;) const { return &amp;value_; } // Get the size of the timeval data. template &lt;typename Protocol&gt; std::size_t size(const Protocol&amp;) const { return sizeof(value_); } // Set the size of the timeval data. template &lt;typename Protocol&gt; void resize(const Protocol&amp;, std::size_t s) { if (s != sizeof(value_)) throw std::length_error("timeval socket option resize"); }private: static ::timeval zero_timeval() { ::timeval result = {}; return result; } ::timeval value_;}; Indeed, some priority levels can map to the same "native" priority level. Here's the list (based on the Hotspot code in OpenJDK 6):Solaris1 ⇒ 02 ⇒ 323 ⇒ 644 ⇒ 965 – 10 ⇒ 127Of note is that on Solaris, you can't raise the thread priority above normal, only lower it: the priority value for 5 is the same as any of the higher values.Linux1 – 10 ⇒ 4 – -5 (nice values)Of note is that on Linux, different thread priorities in Java do map to distinct priority values at native level.Windows1 – 2 ⇒ THREAD_PRIORITY_LOWEST3 – 4 ⇒ THREAD_PRIORITY_BELOW_NORMAL5 – 6 ⇒ THREAD_PRIORITY_NORMAL7 – 8 ⇒ THREAD_PRIORITY_ABOVE_NORMAL9 – 10 ⇒ THREAD_PRIORITY_HIGHEST Will this work?echo (-1580033017 + -2072974554) &amp; 0xffffffffTo generalise, you could do (pardon any syntax errors, I've not touched PHP for a long time):function s32add($a, $b) { return ($a + $b) &amp; 0xffffffff;} No, rsyncd is specifically designed not to reveal the physical path of the modules. Now, if you have shell access to the rsyncd server, you can read /etc/rsyncd.conf for that information.(But, there may be ways to exploit rsyncd to reveal the path, if the use chroot setting is off. Don't quote me on that, though.) If you are able to use a reference, you can retain the same use syntax. However, your reference has to be initialised straight away in the constructor, so your ctor absolutely must be defined out-of-line. (You will also need to free the object in the destructor too.)// bar.hclass foo;class bar { foo&amp; foo_;public: bar(); ~bar();};// bar.ccbar::bar() : foo_(*new foo){ // ...}bar::~bar(){ // ... delete &amp;foo_;}Your mileage may vary. :-) If you can live with killing a process group, you can use the following:kill -$signum, $pgid;where $signum is the signal number, and $pgid is the process group ID. However, signal numbers aren't very portable, in which case you can (on some platforms; read perlfunc for explanation) do the following (to send SIGTERM, for example):kill 'TERM', -$pgid; I'm not a Python expert, but does this work?testFunc.__self__.__class__It seems to work for bound methods, but in your case, you may be using an unbound method, in which case this may work better:testFunc.__objclass__Here's the test I used:Python 2.5.2 (r252:60911, Jul 31 2008, 17:31:22) [GCC 4.2.3 (Ubuntu 4.2.3-2ubuntu7)] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import hashlib&gt;&gt;&gt; hd = hashlib.md5().hexdigest&gt;&gt;&gt; hd&lt;built-in method hexdigest of _hashlib.HASH object at 0x7f9492d96960&gt;&gt;&gt;&gt; hd.__self__.__class__&lt;type '_hashlib.HASH'&gt;&gt;&gt;&gt; hd2 = hd.__self__.__class__.hexdigest&gt;&gt;&gt; hd2&lt;method 'hexdigest' of '_hashlib.HASH' objects&gt;&gt;&gt;&gt; hd2.__objclass__&lt;type '_hashlib.HASH'&gt;Oh yes, another thing:&gt;&gt;&gt; hd.im_classTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'builtin_function_or_method' object has no attribute 'im_class'&gt;&gt;&gt; hd2.im_classTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'method_descriptor' object has no attribute 'im_class'So if you want something bulletproof, it should handle __objclass__ and __self__ too. But your mileage may vary. Here's an exact translation of that function (except, like your case, using bin instead of reserved keyword in).from jarray import zerosfrom java.io import BufferedInputStream, FileInputStream, FileOutputStreamfrom java.util.zip import ZipEntry, ZipOutputStreamdef test(file): zos = ZipOutputStream(FileOutputStream(file + ".zip")) buf = zeros(1024, 'b') zipEntry = ZipEntry(file) fin = FileInputStream(file) bin = BufferedInputStream(fin) zos.putNextEntry(zipEntry) len = bin.read(buf) while len &gt;= 0: zos.write(buf, 0, len) len = bin.read(buf) bin.close() zos.closeEntry() Wow, that's surprising. In GCC 4.2.4, the results are 1, 4, and 4, respectively, both in C and C++ modes. Here's the test program I used that works in both C99 and C++.#ifndef __cplusplus#include &lt;stdbool.h&gt;#endif#include &lt;stdio.h&gt;struct test1 { bool test_a:1; bool test_b:1; bool test_c:1; bool test_d:1; bool test_e:1; bool test_f:1; bool test_g:1; bool test_h:1;};struct test2 { int test_a:1; int test_b:1; int test_c:1; int test_d:1; int test_e:1; int test_f:1; int test_g:1; int test_h:1;};struct test3 { int test_a:1; bool test_b:1; int test_c:1; bool test_d:1; int test_e:1; bool test_f:1; int test_g:1; bool test_h:1;};intmain(){ printf("%zu %zu %zu\n", sizeof (struct test1), sizeof (struct test2), sizeof (struct test3)); return 0;} I had a freelance project that used Interactive Brokers, which provided both a proprietary API as well as a FIX-based one. The proprietary API is somewhat painful to use (and they probably can't change it much, for compatibility), but you can easily code a "translation layer" to make it much more pleasant. I haven't tried the FIX-based API, so no comments there.And yes, I reopened the question. I happen to think it's a fair question to ask. You can make sparse files on NTFS, as well as on any real filesystem. :-)Seek to (10 GB - 10 kB), write 10 kB of data. There, you have a so-called 10 GB file, which in reality is only 10 kB big. :-) In this case, I'd say your code is wrong (and the Sun compiler is right). There is nothing in your input arguments to readObject to actually infer the type T. In that case, you're better off to let it return Object, and let clients manually cast the result type.This should work (though I haven't tested it):public static &lt;T&gt; T readObject(String file) throws Exception { return GenericsTest2.&lt;T&gt;readObject(new ObjectInputStream(new FileInputStream(file)));} To make life easier for yourself, never use a return type that contains wildcards. Wildcard types, in general, are for method parameters only.So, try this:public static &lt;TKey, TValue, TMap extends Map&lt;TKey, TValue&gt;&gt; TMap map(TMap map, Pair&lt;? extends TKey, ? extends TValue&gt;... pairs) { for (Pair&lt;? extends TKey, ? extends TValue&gt; pair: pairs) { map.put(pair.getKey(), pair.getValue()); } return map;}public static &lt;TKey, TValue&gt; HashMap&lt;TKey, TValue&gt; map(Pair&lt;? extends TKey, ? extends TValue&gt;... pairs) { return map(new HashMap&lt;TKey, TValue&gt;(), pairs);}I haven't tested it, but give it a go and see how you fare.P.S., rather than using a made-up Pair type, you may find it easier to use Map.Entry. This doesn't directly answer your question, but if you ever decide you want to try writing a game in JavaFX, the JavaFX site has a bunch of sample code, including a couple of games (as of current writing). You can also, for reflection mostly, use Class.isInstance.Class&lt;?&gt; stringClass = Class.forName("java.lang.String");assert stringClass.isInstance("Some string");Obviously, if the type of the class is known at compile-time, then instanceof is still the best option. CONIN$ is the console input device. Normally, stdin is an open file handle to this, but if stdin is redirected for some reason, then using CONIN$ will allow you to get access to the console despite the redirection. Reference. The question is why you aren't using http://referencesource.microsoft.com/ instead; it's much easier to access the BCL source code that way, if you're good with their licence agreement. int oldfl;oldfl = fcntl(sockfd, F_GETFL);if (oldfl == -1) { /* handle error */}fcntl(sockfd, F_SETFL, oldfl &amp; ~O_NONBLOCK);Untested, but hope this helps. :-) Perl, 19 strokes. Guaranteed to work for values between 1 and 12.sub r{chr 8543+pop} Perl, 145 strokes (if you strip out all the newlines, which are optional), valid for 1..3999:%t=qw(1000 M 900 CM 500 D 400 CD 100 C 90 XC 50 L 40 XL 10 X 9 IX 5 V 4 IV 1 I);$d=pop;for(sort{$b&lt;=&gt;$a}keys%t){$r.=$t{$_}x($d/$_);$d%=$_}print$rSome would say I could use say, but I don't have a say-capable Perl version here. Feel free to subtract 2 off the stroke count if using say works. :-)For non-Perl programmers, this program exploits a number of useful Perl features:Hashes are constructed from lists of even length.Lists of strings can be specified in a compact syntax, using qw.Strings can auto-coerce into integers, as used in the &lt;=&gt; comparison operator in sorting the keys.There is an x operator which makes copies of strings/lists. Unfortunately for golfing here, x has identical precedence to /; if / were higher, the brackets would have been optional too. See this question: Convert HTML back to Markdown for editing in wmd (yay for the "Related" box on the right-hand nav!). The "canonical" Java IMAP solution would, in my experience, be JavaMail. And yes, that's open-source now, too: https://maven-repository.dev.java.net/nonav/repository/javax.mail/java-sources/ IllegalArgumentException I would recommend sudo. Be sure to tighten your sudoers file appropriately; and yes, you can allow some commands to be executed with no password being requested. There is an assertion: "I'm asserting that this constructor will never be called". So, indeed, AssertionError is correct here. Two of the most widely used parsers are Expat and libxml.If you are okay with using C++, there's Xerces-C++ too. You can think about using scripting from Java 6. The reference JDK comes with a JavaScript implementation, and you can plug in other languages too. I recommend you read the book Effective Java cover to cover. Not only will you learn lots of good programming practices, but you will also learn more about Java than you otherwise would. Highly recommended. :-)As a simple example, in Java, rather than rolling bitfields by hand (which is rather painful to do in Java, and for good reason), you use an EnumSet instead. This is documented in Item 32.BTW, if you don't mind reading a PDF (no DRM) version, it's cheaper than hardcopy too: http://www.informit.com/title/0132345285 Like you said, because of reordering done at cache or processor level, you actually do need some sort of memory barrier to ensure proper synchronisation, especially for multi-processors (and especially on non-x86 platforms). (I am given to believe that single-processor systems don't have these issues, but don't quote me on this---I'm certainly more inclined to play safe and do the synchronised access anyway.) The comments below relate to Sun's implementation, in particular OpenJDK 6. Your mileage may vary with other Java platform implementations.java.lang.Class does some caching itself, so implementing your own cache may not improve things very much. Do timing tests with and without manual caching.The actual invocation mechanism is optimised too. The first 15 runs (by default) of your reflected method is called using JNI; after that, bytecode is generated and calling that reflected method would perform identically to calling that method directly in Java code. Use the /g modifier in your match. From the perlop manual: The "/g" modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern. In scalar context, each execution of "m//g" finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the pos() function; see "pos" in perlfunc. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the "/c" modifier (e.g. "m//gc"). Modifying the target string also resets the search position. In C++, this is a pointer (as opposed to a reference). So you have to say this-&gt;isVal instead. I haven't tried writing such a program myself, however I've just looked at the following two links (thanks Google!), which I think will be of help:dbus-python tutorial (which talks about how to use Python to access D-Bus)HAL 0.5.10 Specification (which talks about how HAL publishes events to D-Bus)In particular, read about the org.freedesktop.Hal.Manager interface, and its DeviceAdded and DeviceRemoved events. :-)Hope this helps! Most sites requiring logins seem to do it using method A. For example, on Stack Overflow, if you access a page requiring login, you get redirected to /users/login?returnurl=..., which causes a returnurl field to be emitted as a hidden field in the login form. LWP is the standard HTTP library for Perl. I haven't used it very much, but I do use its companion command-line utilities (GET, POST, etc.) a bit, and they have a useful set of functionality. Adding to Crashworks's answer, you call with these arguments in the cmdarray:new String[] {"find", "/dnbusr1/ghmil/BDELogs/import", "-type", "f", "-mtime", "+120", "-exec", "rm", "-f", "{}", ";"}If your find supports the -exec ... {} + syntax, change the ";" at the end to "+". It will make your command run faster (it will call rm on a batch of files at once, rather than once for each file). I would presume it means "konstant". :-) To protect the high score as it's being sent to your server, either digitally sign it with a key embedded in your app, or else send an HMAC of the data (again, key embedded in app).This suggestion assumes that people do not reverse-engineer your flash game. Not that this is hard, but in most cases, there are much easier ways to attack flash games, so this will raise the bar a little higher. To the excellent responses posted, I want to add one more point of difference between using calloc(nelem, elsize) versus malloc(nelem * elsize): quality implementations of calloc will ensure that if your nelem and elsize were big enough to cause an integer overflow when multiplied together, it will fail rather than cause an undersized allocation, as a naive malloc invocation would.Just this feature alone would be enough for me to prefer calloc to malloc. Background reading. Peter's answer and John's answer are correct: just casting the static type will do nothing if the real type of the object (which client code can cast to, call reflection methods on, etc.) is still available. You have to mask the real type somehow (as Peter's answer mentions).There is actually a pattern for doing this: have a look at the unconfigurable* methods in the Executors class, if you have access to the JDK source code. Also, don't be tempted to think that you can hide methods in an anonymous class either. For example, this won't provide the privacy you expect:Runnable run = new Runnable() { @Override public void run() { System.out.println("Hello, world!"); } public void secretSquirrel() { System.out.println("Surprise!"); }}You may not be able to name the real type of run (in order to cast to it directly), but you can still get its class with getClass(), and you can call secretSquirrel using reflection. (Even if secretSquirrel is private, if you have no SecurityManager, or if it's been set up to allow accessibility, reflection can invoke private methods too.) Synchronous I/O works on a polling basis: you poll, data is returned (when available---if not available, then: for blocking I/O, your program blocks until data is available; for non-blocking I/O, a status code is returned saying no data is available, and you get to retry).Asynchronous I/O works on a callback basis: you pass in a callback function, and it gets called (from a different thread) when data becomes available. You need a way to use the same PrintWriter between the threads (t1.writer == t2.writer, not just PrintWriters created from the same OutputStream). With the same PrintWriter, all writing operations are synchronized. Looking at the Linux source code, shutdown(sock, SHUT_RD) doesn't seem to cause any state changes to the socket. (Obviously, shutdown(sock, SHUT_WR) causes FIN to be set.)I can't comment on the window size changes (or lack thereof). But you can write a test program to see. Just make your inetd run a chargen service, and connect to it. :-) In some scripting languages (e.g., shell, Perl, Ruby, and PHP), single-quoted strings do not support character escapes (except, in some languages, to escape the quote and backslash characters) nor variable interpolation. Double-quoted strings support both.Example in Perl:my $name = 'Barney';print "Hello, $name\n"; # "Hello, Barney" (followed by newline)print 'Hello, $name\n'; # "Hello, $name\n"So, if you want your JavaScript to be consistent with the above, you'd probably want to use single-quoted strings---but, character escapes are still supported in single-quoted strings in JS, but not in the other languages mentioned above. C++ with wxWidgets! *grins, ducks, and runs* This is a well-documented behaviour in Python, that you aren't supposed to modify the list being iterated through. Try this instead:for i in x[:]: x.remove(i)The [:] returns a "slice" of x, which happens to contain all its elements, and is thus effectively a copy of x. Google Code Jam had an extended version of this problem last year (in Round 1C), called Ugly Numbers. You can visit that link and click "Contest Analysis" for some approaches to that problem, when extended to large numbers of digits. You need to write a META-INF/MANIFEST.MF file for this; the file should sit within the jar file you're distributing (i.e., the one that people use with java -jar). Here's an example for a recent "project" I wrote:Manifest-Version: 1.0Ant-Version: Apache Ant 1.7.0Created-By: 11.3-b02 (Sun Microsystems Inc.)Main-Class: com.hedgee.simonsays.MainClass-Path: lib/libthrift.jarThe main fields to care about are Main-Class (which specifies which class to look for your main method), and Class-Path (which specifies the external jar files you're using). Your function shouldn't take vector&lt;int&gt;*; it should take vector&lt;int&gt;::iterator or vector&lt;int&gt;::const_iterator as appropriate. Then, just pass in foo.begin() + 1. Try this:Server client = new Server(socket);clients.add(client);client.start();where clients has type List&lt;Server&gt;. Then, add a sendMessage method (or whatever) to your Server class. Then:for (Server client : clients) { client.sendMessage("...");}Hope this helps! (BTW there is a distinct reason I call the variables client and clients. They're really abstractions for incoming clients, not servers as such, even though the code inside Server is really a server for interacting with said clients.) If you're downloading files using a URL, you can specify the username and password in the URL: http://user:pass@host/pathObviously, if your username or (more likely) password has funny characters, these need to be %XX encoded appropriately. my @hash1s = sort {$a-&gt;{count} &lt;=&gt; $b-&gt;{count}} values %hash2; Well, as you say, that's just an implementation detail. std::list can be implemented either with a stored size (constant-time size() but linear-time splice()), or without (constant-time splice() but linear-time size()). By choosing to use empty(), you avoid betting on an implementation detail, when you don't need to know the size. It's the correct syntax, however, Foo::bar must be defined separately, outside of the header. In one of your .cpp files, say this:int Foo::bar = 0; // or whatever value you want I like Jon Skeet's answer; it's seeing the forest instead of the trees. But to answer the question:Assuming that the instance belongs to some interface, it's easy to use java.lang.reflect.Proxy to do this.public final class SynchronizedFactory { private SynchronizedFactory() {} public static &lt;T&gt; T makeSynchronized(Class&lt;T&gt; ifCls, T object) { return ifCls.cast(Proxy.newProxyInstance( object.getClass().getClassLoader(), new Class&lt;?&gt;[] {ifCls}, new Handler&lt;T&gt;(object))); } private static class Handler&lt;T&gt; implements InvocationHandler { private final T object; Handler(T object) { this.object = object; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { synchronized (object) { return method.invoke(object, args); } } }}This code is not tested, by the way. Use at your own risk. No. Copy constructors must take a reference, not pointer, if it's to be useful for passing-by-value, etc. A PMF (pointer to member function) is like a normal (static) function pointer, except, because non-static member functions require the this object to be specified, the PMF invocation syntax (.* or -&gt;*) allow the this object to be specified (on the left-hand side).Here's an example of PMFs in use (note the "magic" line with the .* operator being used: (lhs.*opit-&gt;second)(...), and the syntax for creating a PMF, &amp;class::func):#include &lt;complex&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;string&gt;namespace { using std::cin; using std::complex; using std::cout; using std::invalid_argument; using std::map; using std::stack; using std::string; using std::underflow_error; typedef complex&lt;double&gt; complexd; typedef complexd&amp; (complexd::*complexd_pmf)(complexd const&amp;); typedef map&lt;char, complexd_pmf&gt; opmap; template &lt;typename T&gt; typename T::reference top(T&amp; st) { if (st.empty()) throw underflow_error("Empty stack"); return st.top(); }}intmain(){ opmap const ops{{'+', &amp;complexd::operator+=}, {'-', &amp;complexd::operator-=}, {'*', &amp;complexd::operator*=}, {'/', &amp;complexd::operator/=}}; char op; complexd val; stack&lt;complexd&gt; st; while (cin &gt;&gt; op) { opmap::const_iterator opit(ops.find(op)); if (opit != ops.end()) { complexd rhs(top(st)); st.pop(); // For example of -&gt;* syntax: complexd&amp; lhs(top(st)); // complexd* lhs(&amp;top(st)); (lhs.*opit-&gt;second)(rhs); // (lhs-&gt;*opit-&gt;second)(rhs); cout &lt;&lt; lhs &lt;&lt; '\n'; // cout &lt;&lt; *lhs &lt;&lt; '\n'; } else if (cin.unget() &amp;&amp; cin &gt;&gt; val) { st.push(val); } else { throw invalid_argument(string("Unknown operator ") += op); } }}[Download]It's a simple RPN calculator using complex numbers instead of real numbers (mostly because std::complex is a class type with overloaded operators). I've tested this with clang; your mileage may vary with other platforms.Input should be of the form (0,1). Spaces are optional, but can be added for readability. If you are interested in removing adjacent duplicate lines, use uniq.If you want to remove all duplicate lines, not just adjacent ones, then it's trickier. The other answers are correct, about putting the function prototype first.Additionally, to be portable, do not access the ... arguments by using a direct pointer to the last (non-vararg) argument, because then you have to care about the alignment and stack direction of your target platform. Instead, use &lt;stdarg.h&gt; and the va_* macros for working with varargs. Without using (or manually calling Dispose()), the object will eventually be disposed of, just not at a deterministic time. That is, it can happen straight away, in two days' time, or (in some cases) never.For things like, say, network connections, you want the connection to close when you're done with it, not "whenever", otherwise it'll idle around hogging up a socket.Further, for things like mutex locks, you do not want those to be released "whenever", or else deadlock is likely to result. This is totally subjective, but I think that this makes the difference between, say, Perl (which allows you to express something in many different ways, to varying degrees of...clarity), and Java (which is more-or-less quite a bondage-and-discipline language). Some people like (or need) the structure, in which case Java suits them better. Others like the creativity that a freer language allows.If you have a team of seasoned programmers, then a creative language would allow them to get more work done. And if you have coworkers who like "tighter" languages, well maybe that says something too, or maybe not. But that's just my opinion. :-P I think XML with XSL is the future. Graphical designer tools would come with their own XSL stylesheets, tailored to the strengths of the tool, and the tool would generate XML files that use the stylesheets.But I'm no clairvoyant; what's going to be hot in the next 5 years, who knows. :-P You can write a custom InputStream implementation that does this. Example:import java.io.IOException;import java.io.InputStream;import java.util.Collections;import java.util.Deque;import java.util.LinkedList;public class CatInputStream extends InputStream { private final Deque&lt;InputStream&gt; streams; public CatInputStream(InputStream... streams) { this.streams = new LinkedList&lt;InputStream&gt;(); Collections.addAll(this.streams, streams); } private void nextStream() throws IOException { streams.removeFirst().close(); } @Override public int read() throws IOException { int result = -1; while (!streams.isEmpty() &amp;&amp; (result = streams.getFirst().read()) == -1) { nextStream(); } return result; } @Override public int read(byte b[], int off, int len) throws IOException { int result = -1; while (!streams.isEmpty() &amp;&amp; (result = streams.getFirst().read(b, off, len)) == -1) { nextStream(); } return result; } @Override public long skip(long n) throws IOException { long skipped = 0L; while (skipped &lt; n &amp;&amp; !streams.isEmpty()) { int thisSkip = streams.getFirst().skip(n - skipped); if (thisSkip &gt; 0) skipped += thisSkip; else nextStream(); } return skipped; } @Override public int available() throws IOException { return streams.isEmpty() ? 0 : streams.getFirst().available(); } @Override public void close() throws IOException { while (!streams.isEmpty()) nextStream(); }}This code isn't tested, so your mileage may vary. GNU Classpath also has their own JCE implementation, however, whether they support IBE is another story. There's also Project DReaM, Sun's open source DRM framework. This is my best understanding of how to do this using Groovy syntax (but see lfaraone's response too):import java.util.regex.Matcherdef txt = 'abc : groovy : def'if (txt =~ ~/ : (.+?) : /) { def match = Matcher.lastMatcher[0][1] println "MATCH=$match"} See also this question: Pythonic macro syntax Remember that the target of tee is not restricted to regular files, but can be to devices, FIFOs, etc. Also, you can pipe to another tee invocation, and so on. :-) Registry! :-P This may not be the answer you need, but I'll try anyway: how hard is it to port your assembly sections into C? I know there is stuff that C can't do, but perhaps you can use inline assembly to accomplish that. When you did your ln -s /usr/lib/libfreetype.so.6.3.18 libfreetype.so, did you make sure that the libfreetype.so symlink ended up in /usr/lib too? To be sure, run ls -l /usr/lib/libfreetype.so and make sure it says what you expect it to. Just for the record, zeroing the bits in an object won't affect whether the destructor gets called (unless the compiler has a special quirk that enables this behaviour). Just write some logging statements in your destructor to test this out.Structuring your program not to allocate anything is probably the way the system was designed. I've not worked with embedded systems before, however I have read some experienced embedded shops that discourage use of dynamic memory because the runtime environment has scarce amounts of it.However, if you must, you can still use placement new. If you don't have the &lt;new&gt; header, here are the relevant lines directly from it on my version of GCC:// Default placement versions of operator new.inline void* operator new(std::size_t, void* __p) throw() { return __p; }inline void* operator new[](std::size_t, void* __p) throw() { return __p; }// Default placement versions of operator delete.inline void operator delete (void*, void*) throw() { }inline void operator delete[](void*, void*) throw() { }Stick that somewhere in a header file included by every source file that uses placement new/delete.Sample file that tests this:#include &lt;cstdio&gt;#include &lt;new&gt;intmain(int argc, char** argv){ typedef char const* cstr; char foobar[16]; cstr* str = new (&amp;foobar) cstr(argc &gt; 1 ? argv[1] : "Hello, world!"); std::puts(*str); str-&gt;~cstr();}On my version of GCC, this does not use libstdc++ at all (if -fno-exceptions is used).Now, if you want to combine that with malloc (if your platform provides this), then you can do this:#include &lt;cstdio&gt;#include &lt;cstdlib&gt;inline void* operator new (std::size_t n) {return std::malloc(n);}inline void* operator new[](std::size_t n) {return std::malloc(n);}inline void operator delete (void* p) {std::free(p);}inline void operator delete[](void* p) {std::free(p);}intmain(int argc, char** argv){ typedef char const* cstr; cstr* str = new cstr(argc &gt; 1 ? argv[1] : "Hello, world!"); std::puts(*str); delete str;}This allows you to use the standard new/delete that you're familiar with, without requiring use of libstdc++.Good luck! Java is a much, much more mature platform, with a lot of existing class libraries that could be "dropped in" and used, than, say, Ruby or Python (or even Perl, for that matter). So for people who like using existing code, rather than writing everything themselves, Java is a huge win.For example, recently I've been looking for something like JAXB for Python or Ruby. In the end, I ended up using JRuby just because I haven't found any mature, widely-used XML-binding libraries. d1 is a stack object, copy-constructed from the reference returned from getData(). d1 is freed, but the object created in getData() is leaked. Not all InputStreams are guaranteed to be selectable, so there is no straightforward way to do this. It's unfortunate that the CommPort class doesn't have a method for returning a SelectableChannel; there is no easy, portable way to accomplish this (i.e., without completely breaking encapsulation). With NIO, java.nio.channels.FileChannel has a read(ByteBuffer dst, long position) method, which internally uses pread.Oh wait, your question is about C++, not Java. Well, I just looked at the JDK source code to see how it does it for Windows, but unfortunately on Windows it isn't atomic: it simply seeks, then reads, then seeks back.For Unix platforms, the punchline is that pread is standard for any XSI-supporting (X/Open System Interface, apparently) operating system: http://www.opengroup.org/onlinepubs/009695399/functions/pread.html I like James Black's answer, but for diversity, I'll post an alternative approach.You can use java.lang.reflect.Proxy to do this. See this post for some code I wrote (for a different question) that uses Proxy; you can use similar code, if you strip out the synchronization stuff. You can create a table with those 400+ random tokens, and select on those. e.g.,SELECT * FROM inventory WHERE inventory_id IN (SELECT id FROM inventory_ids WHERE tag = 'foo')You still have to maintain the other table, but at least you're not having one ginormous query. Not 100%. Ruby blocks require you to name all your parameters (as far as I know). A block in Groovy that doesn't specify parameters has one implied parameter, it. It doesn't work on GCC either.However, outside of a language-compliance viewpoint, it's nice that the compiler optimiser does treat it as a character constant, pretty much. I exploited that fact to allow preprocessor-generated character constants (by using *#foo). See http://cvs.openbsd.org/cgi-bin/query-pr-wrapper?full=yes&amp;numbers=1652, in file hdr.h. With that macro, you could writeDECR(h, e, l, l, o)rather thanDECR('h', 'e', 'l', 'l', 'o')Much more readable, in my view. :-) Okay, let's step through your program line by line. I'm also assigning unique numbers (think of them as object addresses, if you're used to C-like languages) for each newly-created object so you can see what's what. :-)(define x (list 1 2 3)) ; =&gt; #1 = (1 . #2), #2 = (2 . #3), #3 = (3 . ())(define y (list 4 5)) ; =&gt; #4 = (4 . #5), #5 = (5 . ())(define z (cons (car x) (cdr y))) ; =&gt; #6 = (1 . #5)(define w (append y z)) ; =&gt; #7 = (4 . #8), #8 = (5 . #6)(define v (cons (cdr x) (cdr y))) ; =&gt; #9 = (#2 . #5)(set-car! x 6) ; =&gt; #1 = (6 . #2)(set-car! y 7) ; =&gt; #4 = (7 . #5)(set-cdr! (cdr x) (list 8)) ; =&gt; #2 = (2 . #10), #10 = (8 . ())Now, let's look at your values (for each reference, use the last assigned value):x ; #1 =&gt; (6 . #2) =&gt; (6 . (2 . #10)) =&gt; (6 2 8)y ; #4 =&gt; (7 . #5) =&gt; (7 5)z ; #6 =&gt; (1 . #5) =&gt; (1 5)w ; #7 =&gt; (4 . #8) =&gt; (4 . (5 . #6)) =&gt; (4 . (5 . (1 . #5))) =&gt; (4 5 1 5)v ; #9 =&gt; (#2 . #5) =&gt; ((2 . #10) 5) =&gt; ((2 8) 5)Edit: I'm adding a diagram to explain my answer, since you can't have diagrams in a comment. I don't have time to make a diagram showing the values above, but this hopefully explains a few things.Each pair has two "slots", car and cdr, represented as the left and right boxes in the diagram above. Each of these slots, as you see, has three possible things:An atom (a number in your examples, or symbols in the diagram, such as let, s5, and sqrt)A reference (represented as an arrow in the diagram)Null (represented as a black box in the diagram)You can put any of these in any of the slots. So, in my explanation above, each of the # items is an arrow, each of the non-# numbers is an atom, and each of the () is a black box. So, in the line(define v (cons (cdr x) (cdr y)))you are creating a pair, where the left-hand slot has the same contents as the right-hand slot of x (i.e., an arrow going to pair 2), and the right-hand slot has the same contents as the right-hand slot of y (an arrow going to pair 5). In other words, both boxes in v contain arrows, each going off a different pair.Hope this makes more sense. :-) You can do this with the location facility in djbdns. Your task in making the web interface is writing out (and parsing, if you don't want to have a separate database backend) the DNS data files in the right format.Here's another resource on a related topic, "split horizon DNS". It's not the same as your question, but the ideas in the article can be adapted to your needs: http://jdebp.eu./FGA/dns-split-horizon.html Join an open source project. You will learn a lot about how they use a version control system to manage their releases, such as tagging/branching/merging, and the like. That's how I learnt to use CVS ten years ago, from looking at the OpenBSD release process. :-POf course, these days few projects still use CVS; you'll likely be learning about Subversion, Git, or Mercurial. Code points up to 0x7ff is stored as 2 bytes; up to 0xffff as 3 bytes; everything else as 4 bytes. (Technically, up to 0x1fffff, but the highest codepoint allowed in Unicode is 0x10ffff.)When decoding, the first byte of the multi-byte sequence is used to determine the number of bytes used to make the sequence:110x xxxx => 2-byte sequence1110 xxxx => 3-byte sequence1111 0xxx => 4-byte sequenceAll subsequent bytes in the sequence must fit the 10xx xxxx pattern. See: http://java.sun.com/performance/reference/whitepapers/6_performance.html JAXB allows you to convert an XML Schema (XSD) file into a collection of Java classes. This may be more "structured" than the XMLEncoder/Serializable approach that Andy's (excellent, by the way) answer provides. Let's consider the range [0, 2π).For acos, each value x also has another possible value at 2π - x. (Picture the cosine graph and you'll see it.)For asin, each positive value x has another possible value at π - x; each negative value has a possible value at 3π - x.Feel free to draw further graphs to generalise to greater ranges. :-) The sensible answer is that you should use a "serious" logging package, such as Commons Logging.However, to answer your question, in this case you should use a static method (unless you're wanting to maintain logging class instances in your code, in which case you should follow the other answers in this thread). Additionally, you should have a static field that's initialised to, say, a Map&lt;String, PrintWriter&gt;. (You don't have to use String as the key: if you want a finite number of logging target types, use an enum.)Then, when your method sees a key that's not existent in the map yet, it'd create the PrintWriter on the spot, and sticks it in the map. You probably want to use a ConcurrentHashMap as the backing map type, so it's thread-safe.You also need to provide a way to close a logging target (which will also clear the associated entry from the map).Good luck! In this case, I'd usually make them as private as possible, and then promote their accessibility when the need arises (e.g., code from other classes would benefit from being able to access those methods directly). It's easy to add methods to an API, and much harder to remove them (without breaking other code). Iterator classes can define overloaded == operators, if they want. So the result depends on the implementation of operator==.You're not really supposed to compare iterators from different containers. I think some debug STL implementations will signal a warning if you do this, which will help you catch cases of this erroneous usage in your code. Well, in theory at least, you still do a read for a socket, and for a device, and for a pipe, and.... :-PIf you want more data from the socket, such as the socket addresses, you can just call the functions for doing that. It will simply fail for non-sockets, and it's up to you to decide how you want to deal with that.If you really must know, do an fstat on your file descriptor, then look at its mode (st_mode):mode_t type;struct stat fdstat;/* ... */if (fstat(fd, &amp;fdstat) == -1) /* error out */type = fdstat.st_mode &amp; S_IFMT;switch (type) {case S_IFSOCK: /* socket */case S_IFIFO: /* FIFO *//* other cases */} If you're more familiar with Python, then you should do Django. Google App Engine is a big user of Django, and you can use that to "sharpen your saw" in Django skills, for a cost-free investment. Have your first breakpoint change the value of some variable to a magic value (you can use a conditional breakpoint, with an expression which changed the variable and then returned true). Then, have the second breakpoint break when the variable is at that magic value. e.g.,int debug_flag = 0;First breakpoint condition:debug_flag = 0xdeadbeef, trueSecond breakpoint condition:debug_flag == 0xdeadbeef The CPU is easy. Use the cpuid instruction. I'll leave other posters to find a portable way to determine how much RAM a system has. :-)For Linux-specific methods, you can access /proc/meminfo (and /proc/cpuinfo, if you can't be bothered to parse cpuid responses). No, it's not obsolete advice. Dangling references are still a problem, especially if you're, say, implementing an expandable array container (ArrayList or the like) using a pre-allocated array. Elements beyond the "logical" size of the list should be nulled out, or else they won't be freed.See Effective Java 2nd ed, Item 6: Eliminate Obsolete Object References. Sure. Classes are first-class objects in Python.Although, in your example, you should use the @classmethod (class object as initial argument) or @staticmethod (no initial argument) decorator for your method. Often, in event handlers, such as onsubmit, returning false is a way to tell the event to not actually fire. So, say, in the onsubmit case, this would mean that the form is not submitted. Mediawiki, the Wiki software used by Wikipedia, is skinnable. I think, based on your mention of Visual C# Express, that what you're looking for is an IDE (integrated development environment), not a compiler as such. Go to http://java.sun.com/javase/downloads/ and get the NetBeans bundle. But but but...a empty string is not a valid lexical representation for a date, so you can't do that. i.e., if you generated an XML document with an empty value for a date field, it won't validate properly.In other words, if your date element has a minOccurs of 1 or more and not nillable, then you absolutely must have (1 or more) dates, which can't be null (or blanks, or other non-values). In C# (since that's mentioned in the question tags), the two shouldn't be too different, if used standalone.In C++, ++x is to be preferred over x++, because (for classes with overloaded operators), best practice is for post-increment to be implemented in terms of the pre-increment.// pre-increment (note, return by reference)T&amp; operator++() { // ... do its thing}// post-increment (note, return by value)T operator++(int) { T saved(*this); ++*this; // or: operator++(); return saved;} Apart from the loop in hypoxide's answer, also consider using variable interpolation:sqlite_db.execute "insert into smnt (#{SQLITE_SCHEMA}) values (#{entry.map {|e| "'#{e.to_s}'"}.join(',')})"Note that your entry elements had better all be sanitised, or be prepared for a world of pain, Bobby Tables style. Cody didn't want to be bothered answering this, so I'm passing this on on his behalf. :-P For some examples of OSs written in managed languages, as opposed to C or assembly, look at:SingularitySharpOSCosmosMOSAPhantomOf course, Cody also didn't want to mention this:Renraku className.settings = {move: false, remove: false, edit: false}; You say the i is your own type, and you just need to generate j out of i, right? Easy. Add a member function to i's class to generate the j value, and use that always. You can probably even make a macro to "hide" the call to that member function, if you want. :-) You should use C++'s standard sort function, std::sort, declared in the &lt;algorithm&gt; header.When you sort using a custom sorting function, you have to provide a predicate function that says whether the left-hand value is less than the right-hand value. So if you want to sort by name first, then by ID, then by amount due, all in ascending order, you could do:bool customer_sorter(Customer const&amp; lhs, Customer const&amp; rhs) { if (lhs.Name != rhs.Name) return lhs.Name &lt; rhs.Name; if (lhs.Id != rhs.Id) return lhs.Id &lt; rhs.Id; return lhs.AmountDue &lt; rhs.AmountDue;}Now, pass that function to your sort call:std::sort(customers.begin(), customers.end(), &amp;customer_sorter);This assumes you have an STL container (and not an array, like you have in your sample code) called customers containing customers. See Extracting Rails from Basecamp for David Heinemeier Hansson's take on how Rails came to be, from its origins as the framework used in Basecamp. Given the popularity of Rails, you may learn a thing or two from how DHH pulled this off. :-)(Well, maybe not so much a how, as a why. But still entertaining. :-)) They are stored in Signature attributes; see section 4.8.8 of the updated Java Virtual Machine Specification, as well as section 4.4.4 for the format of the field type signature.Here's an example using javap -verbose java.util.Map:public interface java.util.Map SourceFile: "Map.java" Signature: length = 0x2 00 1E [other attributes omitted]The Signature attribute here specifies (if you read this as big-endian, like all integer quantities in the JVM class file format are) constant pool value #30 (30 = 0x1E). So let's have a look there:const #30 = Asciz &lt;K:Ljava/lang/Object;V:Ljava/lang/Object;&gt;Ljava/lang/Object;;Read this in the context of the grammar specified in 4.4.4. So, this uses two type parameters, K extends java.lang.Object and V extends java.lang.Object. The type itself (Map) also extends class java.lang.Object, and no interfaces. How about:my $str = '[[2],[1]]';my $data = [map {$_-&gt;[0]} @{decode_json($str)}]; You can't use parameter markers for column names, table names, data type names, or basically anything that isn't data. If you're using POSIX threads (pthreads), then pthread_cond_wait and (in your case) pthread_cond_broadcast are your friends. :-) The usual way to test for a NaN is to see if it's equal to itself:def isNaN(num): return num != num If you're dealing with an actual floating-point number, as opposed to a string representation of such, you should use modf for splitting out the integral and fractional parts.Perl's split splits by regex, so to replicate full functionality you'd need a regex library. For general string-splitting, you may be able to use strtok, but because it changes the string in-place, strtok_r (described on the same page) is recommended instead. When you pass in %diet and %iq, they both get flattened into the arg array, so in your print_result, %d contains all items in %diet and %iq.To solve, use references of the %diet and %iq:print_result($id, \%diet, \%iq);Then in print_result:my $id = shift;my %d = %{+shift};my %i = %{+shift}; Since the OP asked which approach has more overhead, here's a quick profile I used to compare the two. Feel free to edit the entry with ways to improve the measurement:#!/usr/bin/perl -wuse strict;use Benchmark qw(cmpthese);sub count(\$$) { ${$_[0]} += @{$_[1]};}sub a() { count($a, [map {$_ + 1} 1..1000000]);}sub b() { my @d = map {$_ + 1} 1..1000000; count($b, \@d);}cmpthese(-10, {a =&gt; \&amp;a, b =&gt; \&amp;b}); For pointers, always use %p---it's a format specifier specially designed for printing pointers in the right format. :-) Sure! Just set a breakpoint on main, and go to your project properties (under the Debug section if I remember right), then set the command-line arguments you want to debug with. Although you can use condition variables for this, the problem description suggests the use of a message queue instead. Then, thread A and thread C can inject messages into B's queue, and B processes them accordingly. (Of course, to differentiate between the two threads, you should arrange for A and C to send different messages.)I don't know what support for message queues ACE has, however, in (say) the Java concurrency framework, you can build your own poor-man's message queue using ConcurrentLinkedQueue. :-) You should use non-blocking sockets, but rather than polling them manually, you should have the kernel do it for you. Use either poll or select for this (the former is preferred, because it can handle more sockets at once). When you do this, you will end up with 1 thread in option 1, or 2 threads in option 2. :-P Here's a quick Perl script to do it, using the Font::FreeType module:#!/usr/bin/perl -wuse strict;use Font::FreeType;for my $file (@ARGV) { printf "%s is %s\n", $file, Font::FreeType-&gt;new-&gt;face($file)-&gt;is_italic ? 'italic' : 'not italic';}You can probably use a different language, if it has an extension for using FreeType. Backward compatibility isn't the only reason. :-PWith more complicated schemas, such as ones that have complicated constraints on the values that an element's contents can take on, sometimes you need to create actual JAXBElement objects. They are not usually trivial to create by hand, so the create* methods do the hard work for you. Example (from the XHTML 1.1 schema):@XmlElementDecl(namespace = "http://www.w3.org/1999/xhtml", name = "style", scope = XhtmlHeadType.class)public JAXBElement&lt;XhtmlStyleType&gt; createXhtmlHeadTypeStyle(XhtmlStyleType value) { return new JAXBElement&lt;XhtmlStyleType&gt;(_XhtmlHeadTypeStyle_QNAME, XhtmlStyleType.class, XhtmlHeadType.class, value);}This is how you get a &lt;style&gt; tag into a &lt;head&gt; tag:ObjectFactory factory = new ObjectFactory();XhtmlHtmlType html = factory.createXhtmlHtmlType();XhtmlHeadType head = factory.createXhtmlHeadType();html.setHead(head);XhtmlStyleType style = factory.createXhtmlStyleType();head.getContent().add(factory.createXhtmlHeadTypeStyle(style));The first three uses of the ObjectFactory could be considered superfluous (though useful for consistency), but the fourth one makes JAXB much, much easier to use. Imaging having to write a new JAXBElement out by hand each time! If you are able to use Boost in your work code at all, you should use the shared_mutex class, which implements read/write locking.Even if it doesn't 100% suit your needs, you should use the ideas in the code for your code, and, if the Boost code has tests for the shared_mutex (I haven't checked), you should add them to the tests you have. Regex matching is probably not the best way. I say you probably want to use a "string distance" algorithm, like Levenshtein or Jaro-Winkler to decide how close the user's input is to the expected one.Though, to address Victor's point about not being too flexible, make sure to require a very high matching threshold. Short of using space-sensitive languages (like Python, as you said), I don't see why any sensible interpretation would match the outermost if block.Some languages prohibit this potential ambiguity by:Requiring braces for all blocks, andProviding special "else if" syntax, usually elsif, elif, or elseif. If you specify the directory as a constant string, and you're writing the path using backslashes instead of forward slashes, you need to use raw strings. e.g.,CAPTCHA_ROOT = r'D:\captcha' Edit: I noticed that some people are cutting and pasting the invocation here. The answer I originally gave was relevant for the OP only. Here's a more modern invocation style (including using the more conventional port of 8000):java -agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=n &lt;other arguments&gt;Original answer follows.Try this:java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=4000,suspend=n myappTwo points here:No spaces in the runjdwp option.Options come before the class name. Any arguments you have after the class name are arguments to your program! The current beta version of the Comeau compiler seems to have good C++0x support. I like using databases for logging. Four useful features:You don't lose the time-ordering, as you'd experience when looking at multiple log files at once.You can still filter by specific message types, if you want to.You get integrity, so if your computer crashed just as you were writing a log file, you won't get a corrupted log, and it'll be replayed off the journal when your database starts up again.Pruning the log is really easy! No need to use hacky log rotation programs that require your daemons to be SIGHUPed or anything.Your mileage may vary. :-) You can write your code generator to target Jasmin. You can use goto in Jasmin as much as you like. :-) The other answers are technically correct, but not very useful for someone with no JNI experience. :-)Normally, in order for the JVM to find your native functions, they have to be named a certain way. e.g., for java.lang.Object.registerNatives, the corresponding C function is named Java_java_lang_Object_registerNatives. By using registerNatives (or rather, the JNI function RegisterNatives), you can name your C functions whatever you want.Here's the associated C code (from OpenJDK 6):static JNINativeMethod methods[] = { {"hashCode", "()I", (void *)&amp;JVM_IHashCode}, {"wait", "(J)V", (void *)&amp;JVM_MonitorWait}, {"notify", "()V", (void *)&amp;JVM_MonitorNotify}, {"notifyAll", "()V", (void *)&amp;JVM_MonitorNotifyAll}, {"clone", "()Ljava/lang/Object;", (void *)&amp;JVM_Clone},};JNIEXPORT void JNICALLJava_java_lang_Object_registerNatives(JNIEnv *env, jclass cls){ (*env)-&gt;RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(methods[0]));}(Notice that Object.getClass is not in the list; it will still be called by the "standard" name of Java_java_lang_Object_getClass.) For the functions listed, the associated C functions are as listed in that table, which is handier than writing a bunch of forwarding functions.Registering native functions is also useful if you are embedding Java in your C program and want to link to functions within the application itself (as opposed to within a shared library), or the functions being used aren't otherwise "exported", since these would not normally be found by the standard method lookup mechanism. Registering native functions can also be used to "rebind" a native method to another C function (useful if your program supports dynamically loading and unloading modules, for example).I encourage everybody to read the JNI book, which talks about this and much more. :-) javax.servlet.http.HttpServletRequest is not part of the OpenJDK, and so the OpenJDK documentation would not contain information on it.You need to install the Servlet API documentation instead, then, in the library section of your Package Explorer tab, right-click servlet-api.jar, and select Properties. You will then be able to select a javadoc location for that.Alternatively, for an Ubuntu-friendly solution, install the libservlet2.5-java-doc package, then add the javadoc to your Servlet API jar file using the procedure above. You can use System.arraycopy, if all you want to do is shuffle things around in an array.Specifically, that function permits the source and target to be in the same array, and the ranges are allowed to overlap; so in that sense it's like memmove. I usually use :.,$!sort; does that work for you?Original Poster Edit G is not the proper range specification. From the :help range output see below.Line numbers may be specified with: *:range* *E14* *{address}* {number} an absolute line number . the current line *:.* $ the last line in the file *:$* % equal to 1,$ (the entire file) *:%* 't position of mark t (lowercase) *:'* 'T position of mark T (uppercase); when the mark is in another file it cannot be used in a range /{pattern}[/] the next line where {pattern} matches *:/* ?{pattern}[?] the previous line where {pattern} matches *:?* \/ the next line where the previously used search pattern matches \? the previous line where the previously used search pattern matches \& the next line where the previously used substitute pattern matchesEach may be followed (several times) by '+' or '-' and an optional number.This number is added or subtracted from the preceding line number. If thenumber is omitted, 1 is used. Signal handlers aren't inherited across exec because exec overwrites your whole address space, and any signal handlers that aren't reset would then be pointing to the wrong place. The only time it's not reset is if it's set to, say, SIG_IGN, which is not dependent on the address space of the pre-exec process. Assuming no code gets sent out to users, it's not distribution. Understand, though, that if your code has client-side JS components, and those JS components are using GPLed code, then the code must be sent either unobfuscated/unminified, or have an accompanying link to the corresponding source (unobfuscated/unminified) version. multipart/form-data is a lot bulkier than application/x-www-form-urlencoded; the latter is just a bunch of keys and values (and can be parsed the same way whether for GET or POST), whereas the former requires full MIME support, and is thus more useful when you have data that can't simply be represented as key/value pairs. If you don't mind ugly auto-generated code, and assuming you just want lines between TARGET and the next empty line, and want all the other lines to be dropped, you can use the output of this command:s2p -ne '/TARGET/,/^$/p'(Yes, this is a hint that this problem is usually much more easily solved in sed. :-P) You can use a pure regex match rather than using split:my ($label, $type) = /(.*)\s+(\S+)/; I remember reading many years ago why 1.5 is preferred over two, at least as applied to C++ (this probably doesn't apply to managed languages, where the runtime system can relocate objects at will).The reasoning is this:Say you start with a 16-byte allocation.When you need more, you allocate 32 bytes, then free up 16 bytes. This leaves a 16-byte hole in memory.When you need more, you allocate 64 bytes, freeing up the 32 bytes. This leaves a 48-byte hole (if the 16 and 32 were adjacent).When you need more, you allocate 128 bytes, freeing up the 64 bytes. This leaves a 112-byte hole (assuming all previous allocations are adjacent).And so and and so forth.The idea is that, with a 2x expansion, there is no point in time that the resulting hole is ever going to be large enough to reuse for the next allocation. Using a 1.5x allocation, we have this instead:Start with 16 bytes.When you need more, allocate 24 bytes, then free up the 16, leaving a 16-byte hole.When you need more, allocate 36 bytes, then free up the 24, leaving a 40-byte hole.When you need more, allocate 54 bytes, then free up the 36, leaving a 76-byte hole.When you need more, allocate 81 bytes, then free up the 54, leaving a 130-byte hole.When you need more, use 122 bytes (rounding up) from the 130-byte hole. recv and send allow you to specify flags, such as for out-of-band packets. If you don't need to specify the flags, read and write are perfectly adequate. If you're using CDC, you have access to java.text.DateFormat, which is (as far as I know) the "standard" way to deal with dates/times for non-Joda-Time-using code.If you're using CLDC, you'll probably have to roll something by hand, because it has no java.text package. You want opinions? My opinion is that you should use a text-based protocol, where each of the commands is a keyword. Whether and how you want to convert them to/from enums in your program is up to you, but on the network level, using text-based commands means your protocol is more extensible.A lot of real-life protocols are text-based, and I dare say they're pretty efficient for what they do. e.g., HTTP, FTP, SMTP, etc., are all text-based.  size_t may have different size to int.For things like number of employees, etc., this difference usually is inconsequential; how often does one have more than 2^32 employees? However, if you a field to represent a file size, you will want to use size_t instead of int, if your filesystem supports 64-bit files.Do realise that object sizes (as obtained by sizeof) are of type size_t, not int or unsigned int; also, correspondingly, there is a ptrdiff_t for the difference between two pointers (e.g., &amp;a[5] - &amp;a[0] == ptrdiff_t(5)). Write two stored procedures, one using IN, the other using OR, on a test server. Run each procedure 10,000 (or 1,000,000, or whatever) times, and compare the timings.In general, this is pretty much the "only" way to have a good answer to the question of which approach is faster: write simple timing test cases, and run them many, many times. Try:/\\wordin command mode. If you use require to load your file, it will only be included once (assuming you're not loading the same file by different names/paths), so in general Ruby files do not use include guards. In my experience, when I'm passing the object to a function that doesn't need to store a reference to the object (or otherwise, that calling the function does not affect the lifetime of the object in any way), then it's safe to pass the object by reference. This makes the code less "tied" to the smart pointer type.On the other hand, always using the smart pointer type is "always safe", so when in doubt.... Python is a dynamically-typed language, so the concept of "casting" doesn't exist. If the object is already an UnapprovedUser, then you can already call all methods that exist in that class, without having to cast. The exception stack trace indicates it's not a file permission error, but rather you're running Tomcat under a security manager, for which you have not set up the permission to allow it to write to that path.policytool is a neat program to help you create policy files that you can configure the security manager with. xcopy is in your system32 directory; make sure that's in your PATH. If you've done Java programming a lot, and are familiar with the Java collection framework, think of lists like LinkedList, and vectors like ArrayList. So you can pretty much choose containers the same way.For further clarification: if you intend to add items individually to the front or the back of the sequence a lot, a linked list is much better than a vector, because the items don't need to be shuffled around each time. However, if you want to get at specific elements (not near the front or back of the list) frequently (i.e., random access), you will want to use vector.By the way, vectors can easily be turned into seqs.user=&gt; (def v (vector 1 2 3))#'user/vuser=&gt; v[1 2 3]user=&gt; (seq v)(1 2 3)user=&gt; (rseq v)(3 2 1) Other posters are correct: you must have a way to specify the length of the packets yourself. One concrete, practical way to do this is with netstrings. It's simple to create and parse, and it's supported by some common frameworks such as Twisted. OpenJDK has a very comprehensive set of conformance tests that are required to pass in order to be considered a valid implementation of Java. :-) I'm new to Python, so this may not the most optimal in Python, but I'd use the same technique for Perl, Scheme, etc.def func(x): delta = x - laser_wav return sum(laser_flux * exp(-delta * delta))result = map(func, wav) Apart from @hobodave's good answer, another benefit of "forking per connection" is that you could implement your server very simply, by using inetd or tcpserver or the like: you can then use standard input and standard output for communicating with the socket, and don't have to do any listening-socket management (listening for connections, etc.), etc. If your program is licensed under one of the licences listed in the EXCEPTIONS-CLIENT file in the MySQL distribution, then your program doesn't have to be GPL-compatible to use the MySQL client library.But in general, yes, if you want to link to a GPL library then your program has to be GPL-compatible. I believe you want to use threads; processes are not threads (although at one point in time Linux threads were implemented using a special type of process which shared memory with its parent). I highly recommend NetBeans's Matisse GUI editor. Do you have to use /home/$USER, or will $HOME do the trick? IIRC, sudo doesn't override the value of $HOME. If you don't need to trim the first and final element, this will do the trick:@email_list = split /\s*;\s*/, $file_data;If you do need to trim the first and final element, trim $file_data first, then repeat as above. :-P Yes, SFTP has a protocol for doing this. Read through the most recent document here: http://tools.ietf.org/wg/secsh/draft-ietf-secsh-filexfer/ Markdown can contain arbitrary HTML; this is explicitly allowed. So you should sanitise it too, or at least sanitise the result of converting it to HTML, before sending to web clients.I remember that one of the exploits possible with SO in the early days is that you could put JS content in the Markdown, and whoever edited your article would trigger those scripts in the preview. I don't know if this is fixed yet. Directories are files. Well, I suppose in some operating systems they aren't, but in all Unix-based ones they are.Of course, in Unix systems, directories in "regular" file systems (i.e., ones that have real files, not /proc or the like) have non-zero size too.File.size('/etc')=&gt; 12288 In DES, some bits of the key are parity bits, and don't actually affect the encryption/decryption. Stand-alone, ? does mean {0,1}, however, when it follows something like *, +, ?, or {3,6} (for example), ? means something else entirely, which is that it does minimal matching. So, no, you can't rewrite /\[\[(.+?)\]\]/ as /\[\[((.+){0,1})\]\]/. :-) I'd use inet_ntop. Maybe something like the Boost I/O Stream State-saver library? Sure. Try this:template&lt;&gt;void foo&lt;char*&gt;(char* const&amp; value) {...}This is because const char* means pointer to const char, not a const pointer to char. This sort of detail is not specified by the C++ standard. However, read through the C++ ABI for gcc (and other C++ compilers that follow the C++ ABI). Try (something like) this:use List::Util qw(shuffle);my @list1 = qw(a b c d e);my @list2 = qw(f g h i j);my @order = shuffle 0..$#list1;print @list1[@order];print @list2[@order]; You don't have to use a home directory if you specify an XAUTHORITY environment variable, which specifies the location of the .Xauthority file. Read the xauth man page.But, in general, it's hard to locate the auth file, for the reasons you mentioned; also, this "fishing for auth tokens" approach would only work for local displays.With regard to letting root (or some other user) connect to an X server willy-nilly, you'd probably have to patch the source code to do this, and you'd have to use something like getpeereid to obtain the connecting user's uid/gid (this only works on Unix-domain sockets, which I presume would be the type used for local connections, anyway). It's true that you can't (or shouldn't) subclass boost::thread. You can use thread-local storage to put your own thread-specific stuff though.Arguably, you should use the same technique for Java code. Java has ThreadLocal for that purpose. You should do this:char *tempdna = makedna();strcpy(guy-&gt;dna, tempdna);free(tempdna);But for the strcpy to work, your makedna function needs to zero-terminate the string. At the end, just before the return, have:dna[DNALEN] = 0; If you want your function to be generic, which you clearly want to, you will want to be able to use user-defined types too, which won't have the keyword unsigned. Instead, you should use std::numeric_limits to test for signedness (or, in this case, lack thereof).You should also not use 8 * sizeof (T), but instead use numeric_limits (again) to determine how many bits your type has. :-) On Linux, you can do something like ls -l /proc/$$/fd, which will show you what file descriptors are open in your shell.Of course, substitute $$ with other numbers to inspect other processes (at least, the ones you own). In this case, none.If you had declarations:byte[] a, b;byte c[], d;then a, b, and c are byte[], and d is byte. In Google Code Jam 2009, Round 1B, there is a problem called Decision Tree that lent itself to rather creative solutions.Post your shortest solution; I'll update the Accepted Answer to the current shortest entry on a semi-frequent basis, assuming you didn't just create a new language just to solve this problem. :-PCurrent rankings:107 Perl121 PostScript (binary)132 Ruby154 Arc160 PostScript (ASCII85)170 PostScript192 Python196 JavaScript199 Common Lisp212 LilyPond273 Scheme280 R281 sed w/ bc312 Haskell314 PHP 339 m4 w/ bc346 C381 Fortran462 Java718 OCaml759 F#1554 sedC++ not qualified for now Scheme (Guile 1.8)Here's my version at 278 bytes (with improvements from KirarinSnow to bring it down to 273), after stripping off all the newlines (except ones in string literals, of course). It only works on Guile 1.8 (since in standard Scheme, define is a syntax, not an object, but Guile represents it as an object anyway).(define ! define)(!(c f p w . r)(if(null? r)(* p w)(apply c f(* p w)((if(memq(car r)f)cadr caddr)r))))(!(d . l)(map display l))(!(r . x)(read))(! n(r))(do((i 1(1+ i)))((&gt; i n))(r)(let((t(r)))(d"Case #"i":")(do((a(r)(1- a)))((= a 0))(r)(d(apply c(map r(iota(r)))1 t)"")))) Double-precision numbers do not have more than 15 significant (decimal) figures of precision. There is absolutely no way you can get "an arbitrary number of digits correctly"; doubles are not bignums.Since you say you're happy with 17 significant figures, use long double; on Windows, I think, that will give you 19 significant figures. I'd just use a regex for that:my ($dir, $name, $file, $ext) = $path =~ m:(.*)/(.*)/(.*)\.(.*):;Or, to match your specific example:my ($dir, $name, $file, $ext) = $example =~ m:^(\d{4})(\d{4})(\d{4})\.(.{3})$:; Some languages do allow the compiler to enter an infinite loop. Java isn't one of those languages. :-) I suggest that, instead of using a "raw" pointer to std::string, you use a boost::shared_ptr&lt;std::string&gt;, and pass that around. When you're done, call its reset() function; it will decrement the usage count, and free the string automatically when the count is 0.As a bonus, you can attach boost::weak_ptr objects to those strings (you can stick them into a vector maybe), and monitor how many of them are still "live". This way you'll know if something's causing the strings to not be decremented to 0 for any reason.To be clear:if (_tickersQueue.size() &gt; 0){ boost::shared_ptr&lt;std::string&gt; ticker(new std::string(PopNextTicker())); if (!ticker-&gt;empty()) _threads.create_thread(boost::bind(&amp;TAFYahooFinanceParadigm::ExecuteNextRequest, this, ticker)); else ticker.reset(); // optional; ticker will drop out of scope anyway}Yes, you have to adjust the function type of ExecuteNextRequest appropriately. :-) With regard to your assembly solution, don't hard-code the mov instructions! Let the compiler do it for you. Here's a modified version of your code:static long mull_hi(long inp1, long inp2) { long output; __asm__("imulq %2" : "=d" (output) : "a" (inp1), "r" (inp2)); return output;}Helpful reference: Machine Constraints Here's one that uses GCC assembly extensions, as an alternative to Steve's Delphi answer:uint16_t atomic_inc(uint16_t volatile* ptr){ uint16_t value(1); __asm__("lock xadd %w0, %w1" : "+r" (value) : "m" (*ptr)); return ++value;}Change the 1 with -1, and the ++ with --, for decrement. No, but it's easy to write one:bool is_perfect_square(int n) { if (n &lt; 0) return false; int root(round(sqrt(n))); return n == root * root;}bool is_perfect_cube(int n) { int root(round(cbrt(n))); return n == root * root * root;} If you use Google Collections, its MapMaker class has a makeComputingMap method that does exactly what you described. As a free bonus, it's also thread-safe (implements ConcurrentMap).As for the two-keys thing, you will have to make a class that contains the two keys, and implement a suitable implementation of equals, hashCode, and (if applicable) compareTo that does the key comparison the way you want it. If you used new File("."), you should get the correct results for the current directory. This doesn't answer your question directly, but you may find it easier to just use Collections.sort, passing in your list and comparator. Saves using a TreeSet. STL containers copy the objects they contain. There is no way to work around this.You can, however, have a std::vector&lt;std::shared_ptr&lt;Student&gt; &gt;, which allow you to have a container of smart pointers. For this to work, though, your objects must all be attached to the shared_ptr at the time of construction.So, something like:std::vector&lt;std::shared_ptr&lt;Student&gt; &gt; m_students;std::shared_ptr&lt;Student&gt; targetStudent;for each (std::shared_ptr&lt;Student&gt; student in m_students){ if (student-&gt;Name() == strName) { targetStudent = student; break; }}// If the Student didn't exist, add it.if (!targetStudent){ // creates a new Student and attaches it to smart pointer targetStudent.reset(new Student(strName)); m_students.push_back(targetStudent);}std::shared_ptr is defined in the &lt;memory&gt; header in C++11. (In TR1, you can use std::tr1::shared_ptr instead.) If you're using C++98 without TR1, or need to be portable with it, you can use boost::shared_ptr instead; download from Boost. The EVP cipher functions look like the closest parallel. You can use POSIX::mktime to turn broken-up time into a timestamp. Be aware that the month is 0-based, and the year is 1900-based, so adjust accordingly. :-)use POSIX qw(mktime);$timestamp = mktime($sec, $min, $hour, $day, $month - 1, $year - 1900); C-style strings (char*) are meant to be zero-terminated. So instead of new char[tokens[i].size()], you need to add 1 to the allocation: new char[token[i].size() + 1]. Also, you need to set new_args[i][tokens[i].size()] = 0 to zero-terminate the string.Without the zero-terminator, programs would not know when to stop printing, as char* does not hold a string length, unlike std::string. header("HTTP/1.1 500 Internal Server Error"); Well, if you ensure that you never accidentally use a keyword as an identifier, you don't need the backticks. :-) As a complement to cletus's answer, here's a version using a CompareToBuilder (from Apache Commons Lang):public int compare(Person lhs, Person rhs) { return new CompareToBuilder() .append(lhs.getGender(), rhs.getGender()) .append(lhs.getLastName(), rhs.getLastName()) .toComparison();} I don't think WinDbg works at the IL level. You'd probably have to use ildasm to get an IL disassembly. You need to obtain a code-signing certificate (which is different from an SSL server certificate) from a certificate authority, and sign your programs with it. There are certain requirements for obtaining such a certificate; for example, some certificate authorities will require your company documentation, etc. For robustness, I recommend using prepared statements to send user-entered values, no matter what language you use. :-) You might want to try this version (uses reduce from SRFI 1):(define (compose . fns) (define (make-chain fn chain) (lambda args (call-with-values (lambda () (apply fn args)) chain))) (reduce make-chain values fns))It's not rocket science: when I posted this on the #scheme IRC channel, Eli noted that this is the standard implementation of compose. :-) (As a bonus, it also worked well with your examples.) In most programming languages, you can determine NaN values by comparing a value with itself.(define (nan? x) (not (= x x))) Passing by reference is indeed a correct answer, however, C++ sort-of allows multi-values returns using std::tuple and (for two values) std::pair:#include &lt;cmath&gt;#include &lt;tuple&gt;using std::cos; using std::sin;using std::make_tuple; using std::tuple;tuple&lt;double, double&gt; trans(double x, double y, double theta){ double m = cos(theta)*x + sin(theta)*y; double n = -sin(theta)*x + cos(theta)*y; return make_tuple(m, n);}This way, you don't have to use out-parameters at all.On the caller side, you can use std::tie to unpack the tuple into other variables:using std::tie;double xc, yc;tie(xc, yc) = trans(1, 1, M_PI);// Use xc and yc from here onHope this helps! Vectors store items by value, not by reference. If you want to be able to store MathStudent, ArtStudent, and the like, you should think about using a vector of (smart) pointers to Student instead:typedef vector&lt;shared_ptr&lt;Student&gt; &gt; friends;(where shared_ptr is either std::tr1::shared_ptr or boost::shared_ptr, depending on whether your C++ system supports TR1.) You can't use the f(g(o)) syntax, but you can use (with a suitable interface) f.call(g.call(o)).public interface UnaryFunction&lt;Arg, Ret&gt; { Ret call(Arg arg);}Example usage (this is as close as you can get to functors in Java, at least until closures make it into the language):public class Exp implements UnaryFunction&lt;Double, Double&gt; { public Double call(Double arg) { return Math.exp(arg); }}If you don't want to create a zillion classes, a reflection-based approach may work better (example for double -> double functions in java.lang.Math, but easily adaptable to other scenarios):public class MathUnary implements UnaryFunction&lt;Double, Double&gt; { private final Method method; public MathUnary(String funName) { try { method = Math.class.getMethod(funName, double.class); } catch (NoSuchMethodException exc) { throw new IllegalArgumentException(exc); } if (method.getReturnType() != double.class) throw new IllegalArgumentException(); } public Double call(Double arg) { try { return (Double) method.invoke(null, arg); } catch (IllegalAccessException exc) { throw new AssertionError(exc); } catch (InvocationTargetException exc) { throw new AssertionError(exc); } }}(Exception messages have been left out for brevity. Obviously, I'd put them in for production code.)Sample usage:MathUnary[] ops = { new MathUnary("sin"), new MathUnary("cos"), new MathUnary("tan")};for (UnaryFunction&lt;Double, Double&gt; op1 : ops) { for (UnaryFunction&lt;Double, Double&gt; op2 : ops) { op1.call(op2.call(arg)); }} The OP mentioned (in a comment to my answer) that his implementation of Scheme does not have call-with-values. Here's a way to fake it (if you can ensure that the &lt;values&gt; symbol is never otherwise used in your program: you can replace it with (void), (if #f #f), or whatever you like that's not used, and that's supported by your implementation):(define (values . items) (cons '&lt;values&gt; items))(define (call-with-values source sink) (let ((val (source))) (if (and (pair? val) (eq? (car val) '&lt;values&gt;)) (apply sink (cdr val)) (sink val))))What this does is that it fakes a multi-value object with a list that's headed by the &lt;values&gt; symbol. At the call-with-values site, it checks to see if this symbol is there, and if not, it treats it as a single value.If the leftmost function in your chain can possibly return a multi-value, your calling code has to be prepared to unpack the &lt;values&gt;-headed list. (Of course, if your implementation doesn't have multiple values, this probably won't be of much concern to you.) No, you can't put anything in the GPL to prohibit what you're describing. People are free to make their distribution request donations for them, but, you then have to ask whether that would net them any money.Remember that they are not allowed to take out copyright messages that say the software was written by you. So unless their version is significantly enhanced from yours, why would users pay them, and not you? Personally, I'd prefer option 1, because that doesn't require constructing a new CComBSTR object. (Whether their code does so behind the scenes is a different story, of course.) It sounds like you want to capture the output from test.pl. Using system or exec will not achieve that (and with exec, your main script will no longer be running by the time test.pl is run).Instead, you could use backticks:my $message = `$base_path/test.pl`; I can't speak about what's idiomatic in COM, but in C++, Java, etc., there's an expectation that if you new an object, it will not compare equal (as far as address/object identity is concerned) to any other object. This property is useful when you use identity-based mapping, e.g., as keys in an IdentityHashMap in Java. For that reason, I don't think empty strings/objects should be an exception to this rule.Well-written COM objects will allow you to pass NULL to a BSTR parameter and treat it as equivalent to an empty string. (This will not work with MSXML though, as I've learnt the hard way. :-P) "4-byte encoded UTF-8 characters" refers to characters with code point &gt; 0xFFFF, i.e., ones whose code points don't fit within 16 bits (are outside the basic multilingual plane (BMP)). Many older systems don't support characters outside the BMP.Characters outside the BMP are usually CJK characters; I don't know if that's the case with you here. :-) To create any kind of non-Object array, you need to pass a type key to the toArray method. This is because for generic types (e.g., ArrayList), the type argument is erased (so, at runtime, ArrayList&lt;String&gt; is treated as a plain ArrayList), whereas for arrays, the type is not.It seems you already have the Object array creation sorted, so with that and the use of the type key, I think you're all sorted! :-) I'm surprised no one has mentioned quasiquotation. :-) In Scheme, you could say:`(,+ ,- ,* ,/)or in Common Lisp:`(,#'+ ,#'- ,#'* ,#'/)In some cases, especially involving complex lists, quasiquotation makes the code much simpler to read than the corresponding list version. I'd write a custom table model (as opposed to trying to shoehorn your design into the default table model implementation). This model then holds your actual objects, and in its method implementations (such as getValueAt), it'd consider each of the fields as a column.Simple example (not tested, but should illustrate the idea nicely):import java.util.List;import java.util.ArrayList;import javax.swing.table.AbstractTableModel;/** * Simple table model for displaying properties common to all objects. * Note that all methods must run inside the event dispatch thread. */public class ObjectPropertyTableModel extends AbstractTableModel { private final List&lt;Object&gt; objects = new ArrayList&lt;Object&gt;(); public void addObject(Object obj) { addObject(obj, objects.size()); } public void addObject(Object obj, int index) { objects.add(index, obj); fireTableRowsInserted(index, index); } public void removeObject(Object obj) { int index = objects.indexOf(obj); objects.remove(index); fireTableRowsDeleted(index, index); } public Object getObject(int rowIndex) { return objects.get(rowIndex); } @Override public int getRowCount() { return objects.size(); } @Override public int getColumnCount() { return 3; } @Override public String getColumnName(int columnIndex) { switch (columnIndex) { case 0: return "toString"; case 1: return "hashCode"; case 2: return "class"; default: throw new IndexOutOfBoundsException(); } } @Override public Class&lt;?&gt; getColumnClass(int columnIndex) { switch (columnIndex) { case 0: return String.class; case 1: return Integer.class; case 2: return Class.class; default: throw new IndexOutOfBoundsException(); } } @Override public Object getValueAt(int rowIndex, int columnIndex) { Object obj = objects.get(rowIndex); switch (columnIndex) { case 0: return obj.toString(); case 1: return obj.hashCode(); case 2: return obj.getClass(); default: throw new IndexOutOfBoundsException(); } }} This way is cheap, but it works. :-PRead in all the data past the hole you want, into memory (or another file, or whatever).Truncate the file to the start of the hole (ftruncate is your friend).Seek to the end of the hole.Write the data back in. sprintf("%+d", 5); # should give +5sprintf("%+d", -5); # should give -5Quick reference: http://www.php.net/sprintf The static initializer for a class gets run when the class is first accessed, either to create an instance, or to access a static method or field.So, for multiple classes, this totally depends on the code that's run to cause those classes to get loaded. No, a class containing T1 and T2 is not guaranteed the same layout or alignment as std::pair&lt;T1, T2&gt;, at least in C++98 (since std::pair is not a POD type). The story may be different in C++0x. You should perform both the compilation and linkage with the -pthread option, to be portable. On some systems, the compilation will have specific flags added (e.g., -D_REENTRANT) with -pthread specified.If you're curious to see what -pthread will do to your compile and link flags, run gcc -dumpspecs. You need to use = instead of == in the [ $? == 0 ] line. .NET has reified generics; Java has erased generics.The difference is this: if you have an ArrayList&lt;String&gt; object, in .NET, you can tell (at runtime) that the object has type ArrayList&lt;String&gt;, whereas in Java, at runtime, the object is of type ArrayList; the String part is lost. If you put in non-String objects into the ArrayList, the system can't enforce that, and you'll only know about it after you try to extract the item out, and the cast fails. Surely you jest:asec(x) = acos(1 / x)acsc(x) = asin(1 / x)acot(x) = atan(1 / x):-P I would suggest using Google Collections, and in particular, the Sets.filter method. Much easier than trying to subclass a collection. From experimentation it seems that, for example, List&lt;?&gt; and List&lt;? extends Object&gt; are assignment-compatible both ways, and a method that has a signature using one of them can be overridden with a signature using the other. e.g.,import java.util.List;class WildcardTest&lt;T&gt; { public void foo(List&lt;? extends T&gt; bar) {}}class WildcardTest2 extends WildcardTest&lt;Object&gt; { @Override public void foo(List&lt;?&gt; bar) {super.foo(bar);}} Before the big block, say:state_abbreviation.chomp!As an alternative to sepp2k's excellent suggestion to use case, consider making a hash with the state abbreviations as keys. Here's one way to help you "get a more concrete idea". Imagine if the collector were defined thus:(define (collector l p s) (display l) (newline) (display p) (newline) (display s) (newline))You can see in the base case, if you pass in an empty list, it will call your function with arguments '(), 1, and 0. Now, work with a one-element list, and see what it'll call your function with. Keep working up with longer and longer lists, until you figure out what's going on.Good luck! JavaBeans is all about "convention over configuration". :-P Events are made by simply having methods that are named addXXXListener, removeXXXListener, and getXXXListeners, where the types involved derive from a listener interface.In the same way, a property is made by simply having methods named getXXX and setXXX (either can be omitted for read-only or write-only properties).How does a program locate events and properties? By using java.beans.Introspector, which puts those naming conventions into good use.Sometimes, simplest is best. :-D Yes, Java has memory-mapped files with the NIO framework.If you're trying to avoid JNI because you didn't want to write stubs, you can also interface with C++ code (at least ones that are extern "C") using JNA. For best performance, use direct mapping (concrete classes with native methods, not a mapped interface)---see documentation for more details. :-) Use this on your hash:hash.values.maxIf you only need the highest element, there is no need to sort it! Apart from System.getProperty, there's also Integer.getInteger and Boolean.getBoolean, if you want to get an integral or boolean value instead. :-) That's implementation-dependent. Usually, it gets called every time, but, if the compiler can see that word never changes, and that strlen is a pure function (no side effects), it can lift the call.See: http://underhanded.xcott.com/?page_id=15 for a well-known example of this being exploited. :-) Your Python version prints the checksum in hex, while your Java version prints it in decimal. You should make your Java version print in hex, too. 0x1c0 == 448.To use the cksum=0x%4.4x format string as you had in your Python version, use this:System.out.printf("cksum=0x%4.4x%n", ...);or even betterSystem.out.printf("cksum=%#04x%n", ...);Also, you don't need a DataInputStream for this. Just use bis.read(buffer) instead of dis.read(buffer). For basic functionality, use tty. For example, calling tty.setraw(sys.stdin) will put standard input's terminal into raw mode.For the more general case, Python comes with a termios library, but you probably need some experience with termios to know how to use it.Alternatively, a cheap way is to shell out to stty, which is a command-line interface to termios. Iterate backwards, if you can:for x in range(subjectlength - 1, -1, -1):and similarly for y. $a in this case is an alias to the array element. Just don't have $a = in your code and you won't modify the array. :-)If I remember correctly, map, grep, etc. all have the same aliasing behaviour. You should set up your sudoers not to require a password (NOPASSWD:) for the user that your PHP is running as. Be sure to completely lock down the commands that that user can run via sudo! It ought to be. If nothing else, params[:task] is only evaluated once when using the &amp;&amp;= form.To clarify:params[:task][:completed_at] = params[:task][:completed_at] &amp;&amp; ...calls [](:task) on params twice, [](:completed_at) and []=(:completed_at) once each on params[:task].params[:task][:completed_at] &amp;&amp;= ...calls [](:task) on params once, and its value is stashed away for both the [](:completed_at) and []=(:completed_at) calls.Actual example describing what I'm trying to illustrate (based on Marc-Andre's example code; much thanks):class X def get puts "get" @hash ||= {} endendirb(main):008:0&gt; x = X.new=&gt; #&lt;X:0x7f43c496b130&gt;irb(main):009:0&gt; x.getget=&gt; {}irb(main):010:0&gt; x.get[:foo] = 'foo'get=&gt; "foo"irb(main):011:0&gt; x.get[:foo]get=&gt; "foo"irb(main):012:0&gt; x.get[:foo] &amp;&amp;= 'bar'get=&gt; "bar"irb(main):013:0&gt; x.get[:foo] = x.get[:foo] &amp;&amp; 'bar'getget=&gt; "bar"Note that using the "expanded" form causes "get" to be printed out twice, but using the compact form causes it to only be printed once. You should use Java generics:Map&lt;Integer, Object&gt; myHashMap = new HashMap&lt;Integer, Object&gt;();// ...for (int key : myHashMap.keySet()) { // ...} I have no relationship to Debian and cannot speak about their policies. However, for your framework, this seems a reasonable approach:Define a simple header file that expresses the functionality you need from these pluginsCreate a useful GPL/LGPL/BSD plugin that uses that interfaceHave your main program load that using libdl, as you mentioned (if your main program is GPL, you need to have a licence exception to allow linking proprietary plugins)Submit those for inclusion in Debian, and don't mention about the proprietary stuffThe main point is that your plugin system should be useful for free software, and not just be a Trojan horse to allow proprietary code to be loaded. I'd go for direct access. It's all "keeping it within the family", so to speak. This is language-dependent, but as far as I know in Java, if no exception is thrown, there is next to no performance cost to having a try/catch.So in your example of using pre-validated email addresses, what you have is fine. Try this:foo(@$args); import rere.sub(r'(..)(..)', r'\2\1', '12345678')re.sub(r'(....)(....)', r'\2\1', '34127856') Each platform has some "calling conventions" that each C implementation must adhere to in order to be able to talk to the operating system correctly. For Windows, for example, all OS-based functions have to be called using stdcall convention, as opposed to the default C convention of cdecl.In Linux, since the standard C library (and kernel) is compiled using GCC, any other compilers for Linux must make sure their calling conventions are compatible to the one used by GCC. typedef std::pair&lt;int, int&gt; score_entry; // score, timestamp/serialtypedef std::map&lt;score_entry, std::string, std::greater&lt;score_entry&gt; &gt; score_map;It's ordered by the score and timestamp/serial (in descending order), and allows duplicates of the same high score. (If you want earlier timestamp/serial to be listed first, put in negative numbers.)Using a serial number instead of a timestamp means that you can allow duplicates without having to use multimap. Thanks to Steve Jessop for the suggestion! For micro-optimisation freaks:if ($num % 6 != 0) $num += 6 - $num % 6;More evaluations of %, but less branching/looping. :-P Private inheritance is usually used for mixins---where people inherit to get functionality from the base class, rather than because of "is-a" inheritance.Protected inheritance can also be used for mixins, where the mixed-in functionality is to be available to downstream classes too. If all the common code is in one function, a function taking your config variables as parameters, and returning the result variables (either as return values, or as in/out parameters), will do. Otherwise, making a class ("package") is a good idea, too.sub common_func { my ($config, $result) = @_; # ... $result-&gt;{foo} += do_stuff($config-&gt;{bar}); # ...}Note in the above that both the config and result are hashes (actually, references thereto). You can use any other data structure that you feel will suit your goal. Like you say, every iterative approach can be turned into a "recursive" one, and with tail calls, the stack will not explode either. :-) In fact, that's actually how Scheme implements all common forms of looping. Example in Scheme:(define (fib n) (do ((x 0 y) (y 1 (+ x y)) (i 1 (+ i 1))) ((&gt; i n) x)))Here, although the function looks iterative, it actually recurses on an internal lambda that takes three parameters, x, y, and i, and calling itself with new values at each iteration.Here's one way that function could be macro-expanded:(define (fib n) (letrec ((inner (lambda (x y i) (if (&gt; i n) x (inner y (+ x y) (+ i 1)))))) (inner 0 1 1)))This way, the recursive nature becomes more visually apparent. UTC forever! Seriously, it means you don't have to mess with daylight savings (or locality) adjustments in your model, only in the view. struct tm get_current_localtime() { time_t now = time(0); return *localtime(&amp;now);}struct tm Indice::dataTime = get_current_localtime(); Try running this command before you run Perl:export COLUMNS LINES Try:gcc -dumpspecs | grep pthreadand look for anything that starts with %{pthread:.On my computer, this causes files to be compiled with -D_REENTRANT, and linked with -lpthread. On other platforms, this could differ. Use -pthread for most portability.Using _REENTRANT, on GNU libc, changes the way some libc headers work. As a specific example, it makes errno call a function returning a thread-local location. Yes, the compiler "chooses the older style over the newer style", because of compatibility requirements. Imagine some code, written before Java 5 came out, that suddenly had a change of behaviour when compiled under Java 5! That would be bad.Widening conversions have been around since the dawn of Java, but autoboxing and varargs are new to Java 5. JavaMail is open source. You can use that as a basis of an in-house project if you need to buff it up some.If you want to use something commercial, be sure you have the source if you need to tweak it to local needs. Step 3 just means add 1 to the value. It's really as simple as it sounds. :-)Example with 0xFF72 (assumed 16-bits here):First, invert it: 0x008D (each digit is simply 0xF minus the original value)Then add 1: 0x008E If you want to use your own licence, you have to rip out all the bits that actually came from the GPL'd script. This is because the GPL is a "strong copyleft" (or as some would call it, "viral") licence that requires anything that it's merged with to be licensed under GPL also. In XHTML (served with Content-Type of application/xhtml+xml), &lt;div /&gt; would indeed work. But in HTML mode (text/html), then no; HTML is not XML, and XML empty tag syntax is not recognised. using is applied to objects that implement IDisposable. It ensures that, when leaving the using block (whether normally, or via an exception, or whatever), the disposable object's Dispose method is called. If you want your Java program to have no console window, you need to launch Java using javaw, not java. You need to use the -d option to specify where you want the .class files to end up. Just specify the base directory; javac will create any directories necessary to correspond to the right package.Example (based on your question):javac -d ~/java/classes KeyEventDemo.java Type safety means that the compiler can check whether you're using the right types. For example, if you're using printf, you could accidentally crash your program by writing this:printf("The meaning of life is %s", 42);because 42 is an integer, not a string. Because I think you meant to say this:public abstract class AbstractServiceTest&lt;T extends AbstractIndex&gt; { abstract IService&lt;T&gt; getService();}There's no purpose to making the separate V type variable, other than adding constraints that your subclasses can't fulfil. :-P As Nick's answer says, there is no specific "physical" location stipulated by the language specification, but in terms of a logical mental model that you can reason about, it may help you to think of static fields as being attached to the class object (Foo.class) of the class those fields belong to.As an aside, the class object is used in other ways (that are stipulated by the language spec) when dealing with static entities: for example, when calling a synchronized static method, the lock is held on the class object of the class that method belongs to. The cancelled attribute is attached to the task object. So, either the task hasn't started when you call cancel, and it won't get run; or the task has already started when you call cancel, and it gets interrupted.How to handle interruption is up to you. You should regularly poll Thread.interrupted() (which, by the way, resets the interrupted flag, so beware) if you aren't calling any interruptible function (ones that declare InterruptedException in their throws clause).Of course, if you are calling such functions, you should handle InterruptedException sensibly (which includes reasserting the interrupted flag (Thread.currentThread().interrupt()) before your task returns). :-)To answer your edit, object creation is cheap, as long as your object doesn't have a lot of state. I personally wouldn't worry about it too much unless profiling shows it to be a bottleneck. I'm not convinced that any of the reasons I've heard are good ones.See, in C++, you can return a void function's result:void foo() { // ...}void bar() { // ... return foo();}Yes, it's exactly the same as:foo();return;but is much more consistent with generic programming, so that you can make a forwarding function work without having to worry about whether the function being forwarded has void return.So, if a similar system applied so that a void return constituted a nullary call in a function composition scenario, that could make function composition more generic too. You can use Boost.Random. It uses a different generator than the one provided with most standard libraries, that should be more robust.In specific, most standard libraries provide linear congruential generators, which don't perform very well when you mod their results with small numbers. Boost.Random has a Mersenne twister generator.As sharptooth says, though (good spotting!), only seed the generator once, at the very start of your program. Seeding it every time you want something random is counter-productive. When you use substring, it doesn't actually create a new string. It still refers to your original string, with an offset and size constraint.So, to allow your original string to be collected, you need to create a new string (using new String, or what you've got). In response to your last question: Being an entrant in the SHA-3 contest, it's supposed to be much better than SHA-2, let alone SHA-1.(Not even mentioning MD5: it's already broken, and you should not use it in any new code.) Try this:ImmutableSet.&lt;String&gt;of()This will work too:Collections.&lt;String&gt;emptySet()This syntax is useful for manually specifying type arguments any time the type inference fails. :-) Yes, this is the standard way to do that. See Effective STL, Item 9 (p. 46). Here's how you use a smart pointer. For the sake of example, I'll be using a shared_ptr.{ shared_ptr&lt;Foo&gt; foo(new Foo); // do things with foo}// foo's value is released herePretty much all smart pointers aim to achieve something similar to the above, in that the object being held in the smart pointer gets released at the end of the smart pointer's scope. However, there are three types of smart pointers that are widely used, and they have very different semantics on how ownership is handled:shared_ptr uses "shared ownership": the shared_ptr can be held by more than one scope/object, and they all own a reference to the object. When the last reference falls off, the object is deleted. This is done using reference counting.auto_ptr uses "transferable ownership": the auto_ptr's value can be held only in one place, and each time the auto_ptr is assigned, the assignee receives ownership of the object, and the assigner loses its reference to the object. If an auto_ptr's scope is exited without the object being transferred to another auto_ptr, the object is deleted. Since there is only one owner of the object at a time, no reference counting is needed.unique_ptr/scoped_ptr uses "nontransferable ownership": the object is held only at the place it's created, and cannot be transferred elsewhere. When the program leaves the scope where the unique_ptr is created, the object is deleted, no questions asked.It's a lot to take in, I'll grant, but I hope it'll all sink in soon. Hope it helps! Okay, the OP talked about wanting to know about both stack overflow and arithmetic overflow, as well as their corresponding underflow. Here goes....Arithmetic overflow happens when a number gets too big to fit in its value type. For example, an int holds values between -231 and 231-1, inclusive. If your number goes over these limits, an overflow occurs, and the number "wraps around". These do not cause an exception to be generated in Java.Arithmetic underflow happens when a floating point number gets too small to distinguish very well from zero (the precision of the number got truncated). In Java, these do not cause an exception either.Stack overflow happens when you call a function, that calls another function, that then calls another, then another...and the function call stack gets too deep. You get a StackOverflowError when that happens.Stack underflow doesn't happen in Java. Its runtime system is supposed to prevent that sort of stuff from happening.To answer the OP's other question (see comments), when you overstep the boundaries of an array, an IndexOutOfBoundsException is issued. There are public-domain implementations of MD5 that you should use, instead of writing your own. I hear that Colin Plumb's version is widely used. system 'somescript', dataMulti-argument calls to system are not passed to the shell for processing. cin is not an ifstream, but if you can use istream instead, then you're in to win. Otherwise, if you're prepared to be non-portable, just open /dev/stdin or /dev/fd/0 or whatever. :-)If you do want to be portable, and can make your program use istream, here's one way to do it:struct noop { void operator()(...) const {}};// ...shared_ptr&lt;istream&gt; input;if (filename == "-") input.reset(&amp;cin, noop());else input.reset(new ifstream(filename.c_str()));The noop is to specify a deleter that does nothing in the cin case, because, well, cin is not meant to be deleted. Years ago, I've heard of Chili!ASP. I don't know if that's still around anymore. To use a weak_ptr, you normally have to grab a strong reference by constructing a shared_ptr with it. This last step is atomic: you either get a strong reference back, or you get a bad_weak_ptr exception thrown. (Alternatively, call lock() on the weak_ptr, and either get a strong reference or null.)Example (with lock(); easy enough to adapt to the other style):void do_something(weak_ptr&lt;foo&gt; weak) { // Grab strong reference shared_ptr&lt;foo&gt; strong(weak.lock()); if (strong) { // We now have a strong reference to use } else { // No strong references left; object already freed }} If your document is served as XHTML (application/xhtml+xml), then there is no difference. If it's served as HTML (text/html), only the first form is going to be parsed "correctly" by an HTML parser.See this post for a related question. I'll just answer the last part of the question.vector is a container in the C++ standard library. It's like an array that can automatically resize itself when it gets full.A vector&lt;vector&lt;int&gt; &gt; is a vector containing vector objects, and the latter holds int.A vector&lt;vector&lt;int&gt; &gt;&amp; is a reference to same. A reference is like a pointer, except that you do not use * to access the actual contents. So you treat mat "as if" it's a vector object directly, except that it's really aliased to another instance, so any changes you make to it will "reflect back" and affect what the caller can see.Simple example of references:void add1(int&amp; n) { ++n;}int main() { int num = 5; add1(num); // num is 6 here} A lot of answers talk about how iterators are not iterables. That's true, but such an answer doesn't touch on why.The reason for-each loops require an iterable is to allow the same object to be traversed multiple times (so that you can use multiple for-each loops over the same object without surprising behaviour), whereas an iterator only allows one traversal. If for-each allowed iterators to be used, the behaviour would be surprising to programmers who didn't realise that their iterators would be exhausted after the loop is run.If you're using an API that only gives you iterators, and you want to use iterables, you have two ways to solve this:Make an anonymous iterable class, whose iterator() method calls the API function that returns the iterator. That way, each time you use a for-each loop on the iterable object, that API function is called again, returning a new (and unexhausted) iterator.Make a one-pass iterable wrapper class that takes an iterator and allows one call to iterator(). On subsequent calls, throw an AssertionError or IllegalStateException as appropriate. Yes, this can be done (sort of; see below). (In the C++ world, this is called the "Curiously Recurring Template Pattern", but it applies in Java too):public interface Recur&lt;T extends Recur&lt;T&gt;&gt; { // ...}(Note the second mention of T. That's an essential part of the CRTP.)Also, this is how java.util.Enum is defined, so that an enum type called Foo must derive from Enum&lt;Foo&gt;, so it's not an uncommon pattern in Java either.I'd like to say that the above is the end of the story, but tangens rightly points out in their revision that it's not totally robust, and really not all that different from their answer in character.There is one difference (that I can think of) between the Recur&lt;T&gt; solution I have, and the Recur&lt;?&gt; solution that tangens has:public interface Recur&lt;T extends Recur&lt;T&gt;&gt; { T foo();}class A implements Recur&lt;B&gt; { @Override public B foo() { return new B(); }}class B implements Recur&lt;A&gt; { @Override public A foo() { return new A(); }}With &lt;T&gt;, the above would not compile; with &lt;?&gt;, it would. But that's just splitting hairs; it doesn't change tangens's central point which is that given an already valid Recur implementation, you can make subsequent implementations use the already-valid type, rather than itself. I still say that's worth something, but that's not worth any more of a something than tangens's answer.In closing, go ahead and upvote tangens's answer too, if you can. (tangens, you should touch your post so I can upvote you too.) They have a very good point, and I'm sorry that I missed it the first time around. Thanks, tangens! bool to_bool(std::string const&amp; s) { return s != "0";} s/ /\\ /2gThe 2 specifies that the second one should apply, and the g specifies that all the rest should apply too. (This probably only works on GNU sed. According to the Open Group Base Specification, "If both g and n are specified, the results are unspecified.") The function can only tell you what the FTP server returns. The FTP server, being securely coded, says it's the wrong password. There's nothing the function can do to give you a different result from what the FTP server is telling it. :-PFor FTP servers that do distinguish between invalid usernames and invalid passwords (naughty, naughty), I'm sure the function will also just return you what the server returns, which in that case could be error 12013. Items in STL containers are expected to be copied around all the time; think about when a vector has to be reallocated, for example. So, your example is fine, except that it only works with random iterators. But I suspect the latter is probably by design. :-P Because if Base were allowed (covariant), you could then do this, which is a no-no:Base Class::* ptr = &amp;Class::member;Class obj;obj.*ptr = Base(); // &lt;-- assigned a Base into a Derived field?!At the same time, pointers-to-members cannot be contravariant either, because otherwise you could do this, which is also a no-no:struct Class2 { Base member;};Derived Class2::* ptr2 = &amp;Class2::member;Class2 obj2;obj2.member = Base();Derived&amp; d = obj2.*ptr2; // &lt;-- assigned a Base into a DerivedSo, pointers-to-members are neither covariant nor contravariant, but are invariant: the type must match exactly. After the end of while (*s++);, s points to the character after the null terminator. Take that into account in the code that follows. It's not just that. I think having asserts kept in production builds would add to people's paranoia about what text (and/or source snippets) ends up in shipped binaries (think what code comments would be like if they ended up in shipped binaries!), which in turn would discourage use of assertions.Your mileage may vary. $$ is the process ID. It's named that way to follow Perl, which in turn followed the Bourne shell; both of them also use $$ in the same way. If you want to preserve the zeroes, don't use parseInt on the student IDs; just store them as strings. No, there's no need for all requires to be at the top. Though, if the require fails, your HTML would be halfway sent already. :-P Change the input operand's constraint to "xm", so that memory locations are allowed in addition to SSE registers.However, when I tested it, the compiler generated code that doesn't sit well with Intel syntax. So, in the end, this is what I used:__asm__("pshufb %1, %0" : "+x" (xmm) : "xm" (xmm_shuf)); Here's a really cheap answer:voidchange(){ printf("%d", 5); exit(0);}:-P Personally, I think that's a bad and obnoxious idea.The usual way to encourage people to check for null values is to use annotations like @Nullable (and its opposite, @NotNull, for functions that are guaranteed to return non-nulls). By setting up similar annotations on parameters (so that parameter expectations are set), quality IDEs and bug-checkers (like FindBugs) can then generate all the necessary warnings when the code doesn't do enough checking.Those annotations are available in JSR-305, and apparently there is also a reference implementation.As far as performance goes, creating the exception is the expensive part (I've read that it's due to the stacktrace-filling, among other things). Throwing the exception is cheap, and is a control-transfer technique used in JRuby. You can use Boost.Thread. It provides a type-safe way for you to pass more than one argument into your callable.Yes, it has similar kinds of bookkeeping as your question stated, but it uses C++ mechanisms to ensure that it doesn't leak. In general, you should prefer CoCreateInstance or CoGetClassObject rather than accessing DllGetClassObject directly. But if you're dealing with a DLL that you can't, or don't want to, register, then the below describes (part of) what these function do behind the scenes.Given a CLSID, DllGetClassObject allows you to get the class object, from which you can create instances (via the IClassFactory interface, if I remember correctly).Summary of steps (it's been a while since I've last touched COM, so pardon any obvious errors):Call DllGetClassObject(clsid, IID_IClassFactory, &amp;cf), where clsid is the CLSID you want to get the class object for, and cf is of course the class factory.Call cf-&gt;CreateInstance(0, iid, &amp;obj), where iid is the IID of the interface you'd like to use, and obj is of course the object.???Profit!(CoCreateInstance performs steps 1 and 2. CoGetClassObject performs step 1. You would use CoGetClassObject if you need to create many instances of the same class, so that step 1 doesn't need to be repeated each time.) No, you can't use function overloading in JS.But, you can declare just the version with 3 parameters, and then check whether the third argument === undefined, and provide differentiated behaviour on that basis. Are you wanting to have a salt because you're trying to do password hashing? If so, please consider jBCrypt, a secure, really easy-to-use, password hashing library. You can probably easily hook it in as a Groovy string metamethod. :-PAnd if you're not doing password hashing, I'm not sure where a salt would come in; please feel free to elaborate in that case. :-)Example of how to use HMAC to do keyed hashing (I used HmacMD5 in my example, but you can use HmacSHA1, HmacSHA256, HmacSHA384, or HmacSHA512 also):import javax.crypto.Mac;import javax.crypto.spec.SecretKeySpec;public byte[] hmacMD5(byte[] key, byte[] data) { Mac mac = Mac.getInstance("HmacMD5"); mac.init(new SecretKeySpec(key, "HmacMD5")); mac.update(data); return mac.doFinal();}I'm sorry that this is in Java and not Groovy, but hopefully it'll be easy enough for you to adapt. :-) Anyway, in this example, your constant value would be the key, and the incoming data would be the data.If your data is sizeable (unlikely from what you've described), you can call update multiple times, and the hash would work as though the data from those calls were all concatenated together. You could implement it using a stack. A stack is last-in-first-out (LIFO), just like what you're describing with the display.But if you're looking for something to name your calculation results, I'd agree with most of the answers that said "result" or "display". :-P remove is portable, and unlink is Unix-specific. :-P Alternative solution that uses Multiset from Guava.Multiset&lt;String&gt; words = HashMultiset.create();for (String word : wordList) words.add(word);for (String word : words.elementSet()) System.out.println(word + ": " + words.count(word)); The O() notation considers the highest term; think about which one will dominate for very, very large values of n.In your case, the highest term is c^n, actually; the others are essentially polynomial. So, it's exponential complexity. VALUES '00.00', '01.00', /* ... */, '23.00'should work too, at least for me (on LUW 9.1+). :-) Still kludgey, but more compact.In general, I've found that if you don't need the full power of SELECT, and don't need to name your columns, VALUES is a much simpler alternative.If you do want to name your column, just throw the VALUES within a SELECT:SELECT * FROM (VALUES /* ... */) AS foo (hour)(With some versions of DB2, the foo is optional.)Oh wow, I've just read the DB2 z/OS documentation for VALUES, and it's much wimpier compared to the LUW version. For z/OS, VALUES can only be used in the triggered action of a trigger. Sorry, paxdiablo. :-( This is cheap, but should work (at least according to my testing):public static &lt;T extends Enum&lt;T&gt;&gt; void putItemsInListBox(Class&lt;T&gt; cls, ListBox listbox) { for (T item : EnumSet.allOf(cls)) listbox.addItem(item.toString(), String.valueOf(item.ordinal()));}This works because EnumSet has special magical access to non-public members of Enum, which allows it to enumerate the enum's values despite the lack of a values method. So, basically you want something that works like JS's with? *grins, ducks, and runs*var abc = "value";var context = {abc: 123, xyz: "def"};function test(cx) { with (cx) { println(abc); }}test(context);println(abc);Mind you, some well-known JS practitioners, like Doug Crockford, strongly deprecate the use of with. Just because I'm picking on you Mike :-P, here's another solution:VALUES NEXT VALUE FOR schema.sequence, NEXT VALUE FOR schema.sequence;It will work if you do it as two rows, like here. But if you do it as one row:VALUES (NEXT VALUE FOR schema.sequence, NEXT VALUE FOR schema.sequence);it will return the same sequence value. :-( Standard C++ (at least C++98) does not deal with networking in any way. So, you have to do something platform-specific.Some platforms have IOStreams implementations that allow you to create a stream from a file descriptor. In that case, use the socket descriptor as your file descriptor. Technically, the tag name for &lt;georss:point&gt; is point, not georss:point. Try that. Yes, you need to turn your byte array into a hex string. :-) Look into Apache Commons Codec, especially the Hex class. See: Using SO_REUSEADDR - What happens to previously open socket? You should use libpng. I don't have a Mac, so I can't tell you if it's already pre-installed, but it should be! :-) GotW #76 has fascinating language-lawyery details on how to do some of this stuff. :-) If hashing with GenerateSalt(31) returns almost instantly, that's a bug. You should report that upstream (I have, for jBCrypt). :-)By default, the log-rounds is 10. This means that (if I remember correctly), 1024 rounds is used. Each time you increment the log-rounds, the number of rounds is doubled.At 30 log-rounds, you're doing 1073741824 rounds. That rightfully takes a long time. At 31 log-rounds, 2147483648 rounds should be being done, but I suspect that the particular implementation you're using overflows instead. :-( The &amp; 0xff is required in the Java version because in Java, bytes are signed. (Some argue that this is a bug.)In C#, bytes are unsigned, so the &amp; 0xff is unnecessary. The merging algorithm works on two lists. Unless you somehow adapt the merging algorithm to work on three lists simultaneously, in a way that's "better" than merging list 1 with list 2, then with list 3 (effectively two merging operations), doing partition-by-three method is not going to give better results. Most likely, PHP and ActionScript are using different encodings for strings; one is probably using ISO-8859-1 and the other is using UTF-8.For abcd\x28\xBF, the values are:fcfebaeb81afe401c4b608dc684ad08f under ISO-8859-147ef883a009ddbe01711ece0a0a8764e under UTF-8And for abcd\x28\xBF\x4E (your other example), the values are:ea382d63efca32d8d7861a314a6112e3 under ISO-8859-1dc11cdbaa05aa41640a821fb8e290eae under UTF-8 The number following the 2a specifies the log2 of the number of rounds to perform. For example, 10 means do 1024 rounds. Usually, 10 is normal. Don't use numbers that are too big, or your password will take forever to verify.See Why does BCrypt.net GenerateSalt(31) return straight away? for something related. :-) If you bind to port 0, Java will use a system-generated port. :-) So, that's probably the easiest way to fall back if your desired port is already used.ServerSocket s = new ServerSocket(0);int port = s.getLocalPort(); // returns the port the system selected Speaking only about the provenance of the STL components of the standard C++ libraries used by default:MSVC uses Dinkumware libraries (or apparently a subset thereof, because Dinkumware will sell you addon libraries for MSVC too :-P)GCC uses an extended version of SGI STL as part of libstdc++If you want to swap out the STL, there are other STL implementations like STLport. Pick your poison. :-P The fact that you have a catch for DocumentException means that the loader has to load the class, so that the system can catch it. :-)If you want to avoid having to have the iText jar in your classpath, catch something higher up, or (like you said) don't catch at all. :-P Include other includes in the header file if the contents of the header file uses types defined by such includes. (Sorry, that was a mouthful.)In your case, math.h should definitely include struct.h, although, I argue that neither are good names for user-defined header files (the former because there is already a system-provided math.h; the latter because struct is a keyword). :-PIf your header file uses bool, then yes, it should include stdbool.h. Of course. You get the following events:startElement (element)characters ("here is some ")startElement (b)characters ("mixed content")endElement (b)endElement (element) Not all lib files are static libraries. Some are import libraries, and chances are, that's what you linked with.If your lib file is much smaller than its corresponding dll file, that's a sure sign that it's an import library. You have to wait three times. I suggest you time both and see for yourself, but I don't expect the difference to be huge. Try using elf64 as the output format.Example run:$ cat elf64.asmsection .text jmp [rax]$ nasm -f elf64 elf64.asm$ objdump -Sr elf64.oelf64.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: ff 20 jmpq *(%rax) invokeLater is fine. This puts the call into the AWT event queue, so that it will get executed in the EDT in due course. Your program will continue running, and does not wait for your callable to get called. Yes, you can use Properties. Its load and store methods use a format very similar to the one you described. Yes, you can look at the code; it basically does a Fisher-Yates shuffle. Here it is (thanks OpenJDK, and yay for open source :-P):public static void shuffle(List&lt;?&gt; list, Random rnd) { int size = list.size(); if (size &lt; SHUFFLE_THRESHOLD || list instanceof RandomAccess) { for (int i=size; i&gt;1; i--) swap(list, i-1, rnd.nextInt(i)); } else { Object arr[] = list.toArray(); // Shuffle array for (int i=size; i&gt;1; i--) swap(arr, i-1, rnd.nextInt(i)); // Dump array back into list ListIterator it = list.listIterator(); for (int i=0; i&lt;arr.length; i++) { it.next(); it.set(arr[i]); } }}The swap method: private static void swap(Object[] x, int a, int b) { Object t = x[a]; x[a] = x[b]; x[b] = t;} Here's what I've got. It's not tested, but hopefully would be less gnarly for you to work with. :-)doubleroundd(double n, short mode){ short cw, newcw; __asm__("fstcw %w0" : "=m" (cw)); newcw = cw &amp; 0xf3ff | mode; __asm__("fldcw %w0" : : "m" (newcw)); __asm__("frndint" : "+t" (n)); __asm__("fldcw %w0" : : "m" (cw)); return n;}Although, if you're not required to use assembly to achieve your rounding mode, think about using the functions in &lt;fenv.h&gt; instead. :-) You can store the same nonce in each of the forms. The easiest way to do it is to tie the nonce to the session ID, so that those forms only work in that session.You will want to make it hard for attackers to snarf session IDs and create their own nonces. So, one way to go about it is to use HMAC-SHA256 (or the like) to hash the session ID, using a key that you do not expose to the public.(Obviously if the attacker can get the actual session ID itself, they can already do session hijacking. So that's not what I'm talking about, but rather the ability for an attacker to craft a script (that runs on the victim's computer) that can somehow grab the session ID and use that to dynamically generate a URL with the nonce pre-filled.)ETA: Whether the above approach is enough on its own depends on how long you expect your typical sessions to last. If users usually use long-lasting sessions spanning longer than a few hours, you'll need to use something more sophisticated.One approach is to create a new nonce for each form, that contains the timestamp, as well as hash(timestamp . sessionid) (where hash is some variant of HMAC as described above, to prevent forgery, and . is string concatenation). You then verify the nonce by:checking the timestamp to ensure that the nonce is fresh enough (this is up to your policy, but a few hours is typical)then, calculating the hash based on the timestamp and session ID, and comparing against the nonce, to verify that the nonce is authenticIf the nonce check fails, you'll want to display a new form, pre-populated with the user's submission (so that if they took a whole day to write their post, they won't lose all their hard work), as well as a fresh nonce. Then the user can resubmit straight away successfully. In the "not working" case, the block is actually attached to the puts call, not to the collect call. {} binds more tightly than do. The explicit brackets below demonstrate the difference in the way Ruby interprets the above statements:puts(test = [1, 1, 1].collect) do |te| te + 10endputs test = ([1, 1, 1].collect {|te| te + 10}) If your function is called from the same translation unit as where it's defined (which static functions are obviously required to be), compilers can already easily inline such calls, whether the function is declared static or not.Some quality compilers will also perform whole-program optimisation, so that inlining and other optimisations can occur even for calls to functions in a different translation unit. opendir DIR, '.';$num_items = @{[readdir DIR]};closedir DIR;The central point is that readdir returns all the directory entries when called in list context. Unless you're implementing your own hand-rolled RTTI (and bypassing the system one), it's not possible to implement dynamic_cast directly in C++ user-level code. dynamic_cast is very much tied into the C++ implementation's RTTI system.But, to help you understand RTTI (and thus dynamic_cast) more, you should read up on the &lt;typeinfo&gt; header, and the typeid operator. This returns the type info corresponding to the object you have at hand, and you can inquire various (limited) things from these type info objects. You can use reflection:if (Modifier.isAbstract(FooBar.class.getModifiers())) { // ...} Just include &lt;stdbool.h&gt; if your system provides it. That defines a number of macros, including bool, false, and true (defined to _Bool, 0, and 1 respectively). See section 7.16 of C99 for more details. Aside from Brock's excellent answer (+1), any decent hashing library allows you to update the hash in increments, so you should be able to update with each string sequentially, instead having to build up one giant string.See: hash_update Yes and yes. The order of destruction is always opposite to the order of construction, for member variables. May I suggest cdb? (Python bindings: python-cdb.)It's a format used for read-only data, like you have; it's basically 256 giant hash tables, each able to have a different number of buckets. The cool thing about cdb is that the file doesn't need to be loaded into memory; it's structured in a way that you can do lookups by just mmaping in the bits you need.The cdb spec is a good read, not least because the lines are formatted to create a uniform right margin. :-D You need to use &amp;&amp; instead of ||. You are asking whether "none" of those characters match, not simply whether any one of the four fail to match. (A value cannot simultaneously be Y, y, N, and n.) Besides Darin's excellent answer (+1), ASM is worth checking out too. The whole distinction between "presentation" elements versus "structure" element is, in my opinion, a matter of common sense, not something defined by W3C or anyone else. :-PAn element that describes what its content is (as opposed to how it should look) is a structure element. Everything else is, by definition, not structural, and therefore a presentation element.Now, I'll answer the second part of your post. I understand this is a contentious topic, but I'll speak my mind anyway.Well-made HTML should not concern itself with how it should look. That's the job of the stylesheet. The reason it should leave it to the stylesheet, is so you can deliver one stylesheet for desktop computers, another one for netbooks, smartphones, "dumbphones" (for lack of a better term), Kindles, and (if you care about accessibility, and you should) screen readers.By using presentation markup in your HTML, you force a certain "look" across all these different types of media, removing the ability of the designer to choose a look that works best for such devices. This is micromanagement of the worst sort, and designers will hate you for it. :-)To use your example, instead of using &lt;b&gt;, you should ask yourself what the boldness is supposed to express. If you're trying to express a section title, use one of the header tags (&lt;h1&gt; through &lt;h6&gt;). If you're trying to express strong emphasis, use &lt;strong&gt;. You get the idea. Express the what, not the how; leave the how to the stylesheet designers.&lt;/soapbox&gt; You have two ways to fix this. The preferred way is to use:string answer;(instead of char). The other possible way to fix it is:if (answer == 'y') ...(note single quotes instead of double, representing a char constant). Templates are more flexible because (like you say) your designers can edit them without having to touch the code. More importantly, it enforces a separation between the business logic and the view.So, this is definitely my preference. To prevent accidental changes, use pass-by-const-reference; that way, by default*, the passed-in array can't get changed by the called function.* Can be overridden with const_cast. The Boost IO Stream State Saver seems exactly what you need. :-)Example based on your code snippet:void printHex(std::ostream&amp; x) { boost::io::ios_flags_saver ifs(x); x &lt;&lt; std::hex &lt;&lt; 123;} When an array is created, all the array elements are null. In your case, you need to fill the array with new anEvent() instances. Eclipse has its own built-in compiler (called ecj), which is probably the reason you could get away with not having the JDK installed to use it. It does not use javac.Google App Engine uses the javac that comes with the JDK. Where is add2.png? If it's on your local filesystem (as opposed to the server that has the .jnlp file), then this is not allowed, to protect the user's privacy. Also, getting the resource from another web server is not allowed either.Remember that JWS and applet code is generally untrusted (unless it's been digitally signed, and accepted by the user). So, the default permissions applying to them have to be fairly restrictive.Edited to add: It seems from the stacktrace that your program is still trying to read the local file, rather than using the URL to the remote server. Make sure your code does not make any references to java.io.File; this will help you pinpoint any problematic areas of code. var matches = "Item number #8937 and #6723".match(/#\d+/g);print(matches[0]); // #8937print(matches[1]); // #6723 C strings are null-terminated, so passing strings containing NUL characters is not possible in C. :-PNow, if you just wanted a way to convert \0 (in the user input, i.e., "\\0" as a C string) into actual NUL characters, that's another matter. In that case, your program just needs a parser to treat \0 as separators. It returns a string because 0.1, and powers thereof (which are used to display decimal fractions), are not representable (at least not with full accuracy) in binary floating-point systems.For example, 0.1 is really 0.1000000000000000055511151231257827021181583404541015625, and 0.01 is really 0.01000000000000000020816681711721685132943093776702880859375. (Thanks to BigDecimal for proving my point. :-P)Therefore (absent a decimal floating point or rational number type), outputting it as a string is the only way to get it trimmed to exactly the precision required for display. Using integer formats (%x, %d, or the like) for printing pointers is not portable. So, for any of the pointer ones (px, py, and &amp;px, but not *px and *py), you should be using %p as your format instead. Yes, because that's not how you remove a range from outside code. Instead, do this:list.subList(start, end).clear();This actually calls removeRange behind the scenes.†The OP asks why removeRange is not part of the List public API. The reason is described in Item 40 of Effective Java 2nd ed, and I quote it here: There are three techniques for shortening overly long parameter lists. One is to break the method up into multiple methods, each of which requires only a subset of the parameters. If done carelessly, this can lead to too many methods, but it can also help reduce the method count by increasing orthogonality. For example, consider the java.util.List interface. It does not provide methods to find the first or last index of an element in a sublist, both of which would require three parameters. Instead it provides the subList method, which takes two parameters and returns a view of a sublist. This method can be combined with the indexOf or lastIndexOf methods, each of which has a single parameter, to yield the desired functionality. Moreover, the subList method can be combined with any method that operates on a List instance to perform arbitrary computations on sublists. The resulting API has a very high power-to-weight ratio.One can argue that removeRange doesn't have that many parameters and is therefore probably not a candidate for this treatment, but given that there's a way to invoke removeRange through the subList, there is no reason to clutter up the List interface with a redundant method.† The AbstractList.removeRange documentation says: This method is called by the clear operation on this list and its subLists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its subLists.Also, see OpenJDK's implementation of AbstractList.clear and SubList.removeRange. In my own limited testing (running uniq | sort then trying to snoop on both ends of the pipe via /proc/XXX/fd), it seems that I can't read what gets sent into the pipe, but I can inject data into it.In other words, do your own testing to see what you can and can't do. :-) I looked at the link, and it looks like UTF-8 to me. i.e., in Firefox, if you pick View, Character Encoding, UTF-8, it will appear correctly.So, you just need to figure out how to get your PHP code to process that as UTF-8. Good luck! You can look at the source code for OpenJDK (licensed under GPLv2 with Classpath Exception). Probably the best way to study the JDK implementation internals, unless you want to be bound by the Java Research Licence, in which case you can access the actual JDK 6 source. Probably, you want this:for (int i = 0; i &lt; 8; ++i) md5[i] ^= md5[i + 8];return Arrays.copyOf(md5, 8);This way, only the first 64 bits (which are used by OTP) is returned. If you don't have the specific type you want to work with at compile time, you will have to invoke the clone method by reflection.private static &lt;T&gt; T cloneByReflection(T object) { try { return (T) object.getClass().getMethod("clone").invoke(object); } catch (Exception e) { return null; // or whatever you want to do }}public static &lt;T&gt; void fillWithClones(T[] array, T template) { for (int i = 0; i &lt; array.length; ++i) array[i] = cloneByReflection(template);} C++ allows pass by reference (note the &amp;, which signifies that a reference is used):void foo(char&amp; bar) { bar = 42;}int main() { char a; foo(a); // a == 42 here} Portable edition, still with only one division, no branching, and no multiplication:unsigned umod(int a, unsigned b) { int rem = a % (int) b; return rem + (-(rem &lt; 0) &amp; b);} The way your code works is pretty close to the "canonical" way to write it. I'd throw an AssertionError within the catch, though. It signals that that line should never be reached.catch (CloneNotSupportedException e) { throw new AssertionError(e);} Mainstream Java implementations use "native threads", which means that thread scheduling is done through the operating system. Java thread priorities simply map to OS-specific values. You should read your OS documentation to figure out what those levels mean, though. :-) It's done at the language level. The Java Language Specification is very specific about what string addition must do. There is one usual answer to questions about performance, and this applies whether you're doing serial or parallel programming. Use a profiler. :-) You shouldn't use a Java applet for forms. It's bad for accessibility.JavaScript can indeed read files from remote locations, such as via Ajax. You should use an Ajax toolkit like http://jquery.com to help you. :-) No, at least not in a portable way.GCC's libstdc++ has a class called stdio_filebuf that you can use with a stream, and it does allow you to directly get the associated FILE*, but, stdio_filebuf is not a basic_filebuf, and cannot be used with basic_fstream. Stack unwinding is a mostly C++ concept, dealing with how stack-allocated objects are destroyed when its scope is exited (either normally, or through an exception).Say you have this fragment of code:void hw() { string hello("Hello, "); string world("world!\n"); cout &lt;&lt; hello &lt;&lt; world;} // at this point, "world" is destroyed, followed by "hello" Example that demonstrates how pointer references are used:int items[] = {42, 43};int* a = &amp;items[0];int* b = &amp;items[1];swap(a, b);// a == &amp;items[1], b == &amp;items[0]// items in the array stay unchanged The usual way to avoid cycles is to use weak references in any one point of the cycle. shared_ptr has a companion type, weak_ptr, which is designed for this purpose.Which part of the cycle to weaken is a matter of design. In designs where "parent" objects own "children", then the reference from parent to child should be strong (shared_ptr), and the reference from child back to parent should be weak (weak_ptr). It's a long and complicated piece of code, which I'm not keen to try to grok. :-)Have a look at the inet_csk_get_port function (in net/ipv4/inet_connection_sock.c) for TCP, and udp_lib_get_port (in net/ipv4/udp.c) for UDP. It's valid, at least, for 2.6.31, though it may vary for different versions. Don't use java.net.URL. That's the simple answer to your question. Use java.net.URI instead, which won't do hostname resolution. The minified version is for deployment, to minimise the size of downloads a user's browser has to make.The uncompressed version is for development, since the minified version is very hard to debug with. Unfortunately, for a stock pkg-config installation (for version 0.23), there is no way to extract the default "pc path", short of running strings on the binary (e.g., strings /usr/bin/pkg-config | grep '/usr/.*/pkgconfig').If you are able to install a custom build, just patch it to write out the value of PKG_CONFIG_PC_PATH when run with the appropriate option.Another option, which probably won't help you (but that I'd mention anyway for completeness), is to set the PKG_CONFIG_PATH environment variable when calling pkg-config. I'd just write:vector&lt;string&gt; args(argv + 1, argv + argc + !argc);This will exclude argv[0], but in a way that's robust even if argc == 0 (possible under Linux, and maybe other OSs too). You can use the Module#const_get method. Example:irb(main):001:0&gt; ARGV=&gt; []irb(main):002:0&gt; Kernel.const_get "ARGV"=&gt; [] import osos.system('sh') # or bash, tcsh, zsh, whatever. :-P chomp has no meaningful return value that you can then pass onto opendir. You need to chomp your string in a separate statement, above the opendir. chomp; opendir DIR, $_ or die ... You didn't hear this from me (because I disagree with the premise of the question), but, you can use java.text.Normalizer, and normalize with NFD: this splits off the accent from the letter it's attached to. You can then filter off the accent characters and compare. This is cheating (because it uses Perl), but works. :-Pecho cba | perl -pe 'chomp; $_ = join "", sort split //' There is no "quick check" mechanism that is secure, by definition. The whole point of using PBKDF2 or related techniques is to make password checking slow, to foil password cracking programs. If you added a quick check system, password crackers would be able to guess passwords in bulk very quickly. On x86, usually most calculations happen with 80-bit quantities, unless otherwise forced to be double-precision. Most other architectures I know of do all calculations in double-precision (again, unless otherwise overridden).I don't know if you're running Solaris on SPARC or x86, but if the former, then I highly suspect that to be the cause of the difference. That program is called xargs.ls | grep foo | xargs -I %s mv %s bar/ You can use popen, which returns you a stream that you can read the output from. By reading until end-of-file, into a string (probably one that dynamically grows as necessary), you can implement what you're asking for. Well, if _test has not been assigned any value, then it has undefined value. You can't use that value for anything, if you want sane behaviour. Variables need to be assigned before being used.Incidentally, delete and delete[] is safe to call on null pointers, so the == 0 check is redundant. In C++, they are real keywords. In C, they're macros defined in &lt;iso646.h&gt;. See http://web.archive.org/web/20120123073126/http://www.dinkumware.com/manuals/?manual=compleat&amp;page=iso646.html. Java 5 had a lot of syntactic changes: the most significant (that I remember) are:GenericsEnumsFor-each loopsAuto-boxing and auto-unboxingCovariant returnsVariadic functions(And of course, as noted in the question, static imports and annotations.)As Zwei's answer mentioned, java.util.concurrent is a major Java 5 feature too, and also, JSR-133 and its memory model changes (that allowed volatile to work in a sane way, so you could implement double-checked locking safely if you wanted to).Java 6 didn't feature any syntax changes (that I remember); many of its high-impact changes were performance-related. Library-wise, my favourite "new to Java 6" library was the scripting support (javax.script). Sure: just use fdopen on the socket to create a FILE* stream, and use fprintf appropriately. Collections.addAll(myVector, myArray);This is the preferred way to add the contents of an array into a collection (such as a vector).https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#addAll-java.util.Collection-T...- Adds all of the specified elements to the specified collection. Elements to be added may be specified individually or as an array. The behavior of this convenience method is identical to that of c.addAll(Arrays.asList(elements)), but this method is likely to run significantly faster under most implementations. If your XML conforms to a specific schema (and you have an XSD file for it), you can use JAXB to convert the XSD into a bunch of Java classes for conveniently manipulating the data. You could start by using &lt;C extends A&lt;B&gt;&gt; and List&lt;A&lt;B&gt;&gt; in those first two instances. Passing a type key is, in this case, counterproductive (see how the cls parameter is never used), so, just strip it out.(You can always say B.&lt;Foo&gt;getList() to specifically instantiate it with a specific type, assuming you're happy for the type to be non-reified of course.)Update to incorporate OP's edit: Will using A&lt;?&gt; work for your code? In limited cases, you may not need to fully specify the type. Unfortunately, I don't have your code, so only you can find out whether it'll work. You should use try/finally:Reader inp = new BufferedReader(new FileReader(inputFile));try { // Do stuff with "inp"} finally { IOUtils.closeQuietly(inp);}IOUtils is from Apache Commons IO. Its closeQuietly method is like your code snippet above: it calls close, and ignores any exceptions thrown. After much searching on Google Code Search, I've discovered that the program name is stashed in the gnu.gcj.progname property. Sample program:public class ProgName { public static void main(String... args) { System.out.println(System.getProperty("gnu.gcj.progname")); }}Edited to add: gnu.gcj.progname is documented in libgcj Runtime Properties too, so luckily this isn't just an internal implementation detail. No. The bounds-checking of std::vector::at is specified by the standard, and there is no standard-conforming C++ implementation that can deviate from that. Expect may be of help there. I've never used it myself, but I understand that it allows you to specify pre-programmed responses to specific prompts. Valgrind. :-) It's not a malloc library, but, it's really good at finding memory management and memory usage bugs. cmpl $0x0,-0x4(%esp); setg %al means compare -0x4(%esp) (floop_id in your code) against 0, and set %al to 1 if it's greater, or 0 otherwise.test %al, %al here isn't doing anything. I don't know why it's in the assembly. (Normally, testing a value with itself is used to get the signum of the value (i.e., zero, positive, or negative), but the result of this isn't being used here. Chances are, it was going to do a conditional branch (to implement the loop), but seeing as your loop is empty, it got removed.) Don't use exception specifications in C++. It's very counter-intuitive compared to, say, Java's ones.Having a wider specification in the derived class breaks LSP (Liskov Substitution Principle).To expand on point 2: A's callers expect that only int comes out, but if you use a B (which, because it's publicly derived from A, also means it's usable as an A), suddenly double can come out too, and that would break A's contract (that only int gets thrown). I'll answer point 2, and leave the rest for others. The main reason why pop doesn't return the removed value is due to exception safety.First, understand that C++ containers (unlike, say, Java's ones) hold their objects by value. That means that if you want the container to return the object at popping time, it has to return you that object by value, by copying the object being removed. In contrast, by having you access top before pop, it can simply return a reference to the top element, and you can copy it to your heart's content before popping it. (Whereas, if pop returned the element by reference, it'd be a dangling reference, as the object is no longer in the container.)The consequence of making pop return by value (aside from the inefficiency involved in copying the object being removed) is that it jeopardises exception safety. Ideally, if an operation throws an exception, the state of the objects involved is unchanged. But if pop were to return the removed object by value, what if the copy constructor for that object failed? The object would already have been removed from the container, and thus the state is already changed.This is wordier than I wanted to make it, but hopefully gives you an idea why pop returning a value is a bad idea. You can't just install a new libgtk package willy-nilly; you need to upgrade the packages that it depends on, at the same time (in this case, libglib, libcairo, and their respective dev packages).(This question is more appropriate for Super User, and I've voted to migrate the question there.) You can use JAXB without open-sourcing your code (if you follow the other terms of the CDDL). You can't distribute JAXB itself without source, though.Update in response to question edit: Assuming that your code isn't a modification to JAXB, nor does it contain any portion of JAXB, then it's not covered. (I am not a lawyer, though. Take my opinion with a grain of salt.) -Wmissing-prototypes is not applicable for C++, because C++ always requires prototypes.Take the following declaration for example:void foo();In C, foo can be called with any number and type of arguments.In C++, foo does not take any arguments (compilation error if any arguments passed in). Technically, you should update a copyright year only if you made contributions to the work during that year. So if your website hasn't been updated in a given year, there is no ground to touch the file just to update the year. The recommended (by Effective Java 2nd ed) way is to do the "enum singleton pattern":enum MyClass { INSTANCE; // rest of singleton goes here}The key insight here is that enum values are single-instance, just like singleton. So, by making a one-value enum, you have just made yourself a singleton. The beauty of this approach is that it's completely thread-safe, and it's also safe against any kinds of loopholes that would allow people to create other instances. char16_t and char32_t are supposed to be usable for representing code points. Since there are no negative code points, it's sensible for these to be unsigned.UTF-8 does not represent code points directly, so it doesn't matter whether u8's underlying type is signed or not. You can use HtmlUnit, which features a JavaScript evaluator and can thus work with in-page scripts. You have one too many *s in your crontab. Inside your ready function:window.bar = function bar() { // ...}Then, you can access window['bar']. perl -ane 'print if length($F[1]) &gt; 7' #define UART0CTL ((volatile unsigned int *) (UART0 + 0x30)):-PEdited to add: Oh, in response to all the comments about how the question is tagged C++ as well as C, here's a C++ solution. :-Pinline unsigned volatile&amp; uart0ctl() { return *reinterpret_cast&lt;unsigned volatile*&gt;(UART0 + 0x30);}This can be stuck straight in a header file, just like the C-style macro, but you have to use function call syntax to invoke it. Markdown uses two spaces at the end of a line as a marker for saying that that newline should be turned into a &lt;br&gt;. :-PSeriously, beyond such corner cases, I don't really see a point to keeping leading/trailing spaces around. YMMV. :-) final is not (C++-style) const. Unlike C++, Java does not have const-methods or anything like that, and methods that can change the object can be called via a final reference.Collections.unmodifiable* is a wrapper that enforces (at run time only, not at compile time) the read-only-ness for the collection concerned. Dividing by 1000 is enough to get a Unix timestamp. You don't need any numbers of days or anything like that. Using only a function pointer (and no additional separate object pointer) for a C callback is a broken design, in my humble opinion.If the function were, instead, FMOD_Channel_SetCallback(channel, callbackFunc, callbackObj), then your static method just takes an instance of the object, then calls callbackObj-&gt;func() (which obviously can be non-static). Well, I can definitely help with the password generation part of your question. :-)According to the spec (line 113), it is:Base64(SHA1(nonce + created + password))The documentation also says that the nonce should be converted back to its binary form, and the created timestamp should be used as it appears (lines 129–131).So suppose your password is "supercalifragilisticexpialidocious". Then the value you hash (given the sample document posted in the question) would be UnBase64("QQ3C4HUfO2CyGx7HrjzMzg==") + "2010-03-08T15:32:16Zsupercalifragilisticexpialidocious". I apologise for the long answer (please see comments about how my answer nails the spec). I'm trying to be comprehensive, so you have as good of a leg up as possible. :-)If you are able to install programs (have root access), and are willing to do one-time legwork to set up your script for daemon execution (i.e., more involved than simply specifying the command-line arguments to run on the command line, but only needing to be done once per service), I have a way that's more robust.It involves using daemontools. The rest of the post describes how to set up services using daemontools.Initial setupFollow the instructions in How to install daemontools. Some distributions (e.g., Debian, Ubuntu) already have packages for it, so just use that.Make a directory called /service. The installer should have already done this, but just verify, or if installing manually. If you dislike this location, you can change it in your svscanboot script, although most daemontools users are used to using /service and will get confused if you don't use it.If you're using Ubuntu or another distro that doesn't use standard init (i.e., doesn't use /etc/inittab), you will need to use the pre-installed inittab as a base for arranging svscanboot to be called by init. It's not hard, but you need to know how to configure the init that your OS uses.svscanboot is a script that calls svscan, which does the main work of looking for services; it's called from init so init will arrange to restart it if it dies for any reason.Per-service setupEach service needs a service directory, which stores housekeeping information about the service. You can also make a location to house these service directories so they're all in one place; usually I use /var/lib/svscan, but any new location will be fine.I usually use a script to set up the service directory, to save lots of manual repetitive work. e.g.,sudo mkservice -d /var/lib/svscan/some-service-name -l -u user -L loguser "command line here"where some-service-name is the name you want to give your service, user is the user to run that service as, and loguser is the user to run the logger as. (Logging is explained in just a little bit.)Your service has to run in the foreground. If your program backgrounds by default, but has an option to disable that, then do so. If your program backgrounds without a way to disable it, read up on fghack, although this comes at a trade-off: you can no longer control the program using svc.Edit the run script to ensure it's doing what you want it to. You may need to place a sleep call at the top, if you expect your service to exit frequently.When everything is set up right, create a symlink in /service pointing to your service directory. (Don't put service directories directly within /service; it makes it harder to remove the service from svscan's watch.)LoggingThe daemontools way of logging is to have the service write log messages to standard output (or standard error, if you're using scripts generated with mkservice); svscan takes care of sending log messages to the logging service.The logging service takes the log messages from standard input. The logging service script generated by mkservice will create auto-rotated, timestamped log files in the log/main directory. The current log file is called current.The logging service can be started and stopped independently of the main service.Piping the log files through tai64nlocal will translate the timestamps into a human-readable format. (TAI64N is a 64-bit atomic timestamp with a nanosecond count.)Controlling servicesUse svstat to get the status of a service. Note that the logging service is independent, and has its own status.You control your service (start, stop, restart, etc.) using svc. For example, to restart your service, use svc -t /service/some-service-name; -t means "send SIGTERM".Other signals available include -h (SIGHUP), -a (SIGALRM), -1 (SIGUSR1), -2 (SIGUSR2), and -k (SIGKILL).To down the service, use -d. You can also prevent a service from automatically starting at bootup by creating a file named down in the service directory.To start the service, use -u. This is not necessary unless you've downed it previously (or set it up not to auto-start).To ask the supervisor to exit, use -x; usually used with -d to terminate the service as well. This is the usual way to allow a service to be removed, but you have to unlink the service from /service first, or else svscan will restart the supervisor.Also, if you created your service with a logging service (mkservice -l), remember to also exit the logging supervisor (e.g., svc -dx /var/lib/svscan/some-service-name/log) before removing the service directory.SummaryPros:daemontools provides a bulletproof way to create and manage services. I use it for my servers, and I highly recommend it.Its logging system is very robust, as is the service auto-restart facility.Because it starts services with a shell script that you write/tune, you can tailor your service however you like.Powerful service control tools: you can send most any signal to a service, and can bring services up and down reliably.Your services are guaranteed a clean execution environment: they will execute with the same environment, process limits, etc., as what init provides.Cons:Each service takes a bit of setup. Thankfully, this only needs doing once per service.Services must be set up to run in the foreground. Also, for best results, they should be set up to log to standard output/standard error, rather than syslog or other files.Steep learning curve if you're new to the daemontools way of doing things. You have to restart services using svc, and cannot run the run scripts directly (since they would then not be under the control of the supervisor).Lots of housekeeping files, and lots of housekeeping processes. Each service needs its own service directory, and each service uses one supervisor process to auto-restart the service if it dies. (If you have many services, you will see lots of supervise processes in your process table.)In balance, I think daemontools is an excellent system for your needs. I welcome any questions about how to set it up and maintain it. You can simply create a large character array.char[] data = new char[1000000];If you need to make a real String object, you can:String str = new String(data);Don't use += to build strings in a loop. That has O(n²) memory and time usage, as String objects are immutable (so that each time you call +=, a new String object has to be made, copying the entire contents of the old string in the process). Pretty close to the right idea. However, in your catch (InterruptedException) you should have:Thread.currentThread().interrupt();so that the interrupted status goes on again, and doesn't do the stuff in the second block.Edit to make my point clearer (because the OP's edit seems to have missed my initial point :-P): you should write your code like this:try { for (int = 40; i &gt; 0; --i) { updateGUI(i, label); Thread.sleep(1000); }} catch (InterruptedException e) { Thread.currentThread().interrupt(); // &lt;-- THIS LINE IS IMPORTANT}Second edit to explain what interruption does. :-)When you call thread.interrupt(), that thread's interrupted flag is set. That flag doesn't do anything on its own; it's just a variable. The reason for this is because interruption supports something called "cooperative thread management", where the thread's running code decides what to do when interrupted (rather than being forced to quit on the spot).Some functions built into the JDK, like Thread.sleep, or Object.wait, or Lock.lockInterruptibly, will check the flag, and if it's set, then it'll throw an InterruptedException after clearing the flag.So, if you're calling one of those functions, you don't need to manually check the interrupted flag. But if you're not, e.g., if you're doing intensive processing instead of waiting for something, then you should periodically check the flag.There are two ways to check the flag:interrupted()isInterrupted()The first one clears the interrupted flag; the second one doesn't. You have to decide which version is "more correct" for your application logic. First off, std::map isn't constant-time lookup. It's O(log n). Just thought I should set that straight.Anyway, you have to specify your own comparison function if you want to use a different ordering. There isn't a built-in comparison function that can order by insertion time, but, if your object holds a timestamp field, you can arrange to set the timestamp at the time of insertion, and using a by-timestamp comparison. jint, jdouble, etc. are not jobjects. As you say, they're primitive variables. Just fill them in!jint someInt = 1;jdouble someDouble = 3.14159;Re edit: I see, you want to return boxed types like Integer, Double, etc. Yeah, the wrapper function you posted is probably the way to go. What class are you trying to run? If you're using the class territory, that will work. Risk has no main method, though. Arrays are not resizable.Java Collections Framework provides lots of different useful data types, such as linked lists (allows insertion anywhere in constant time), resizeable array lists (like Vector but cooler), red-black trees, hash-based maps (like Hashtable but cooler).Java Collections Framework provides abstractions, so you can refer to a list as a List, whether backed by an array list or a linked list; and you can refer to a map/dictionary as a Map, whether backed by a red-black tree or a hashtable.In other words, Java Collections Framework allows you to use the right data structure, because one size does not fit all. In Unix systems, it's customary to run long-running processes with memory limits (using ulimit) so that it doesn't eat up all of a system's memory. If your program hits that limit, you will get std::bad_alloc.Update for OP's edit: the most typical case of programs recovering from an out-of-memory condition is in garbage-collected systems, which then performs a GC and continues. Though, this sort of on-demand GC is really for last-ditch efforts only; usually, good programs try to GC periodically to reduce stress on the collector.It's less usual for non-GC programs to recover from out-of-memory issues, but for Internet-facing servers, one way to recover is to simply reject the request that's causing the memory to run out with a "temporary" error. ("First in, first served" strategy.) Try this (tested and works for me):call mystring.assign("hello world")The key is that instead of modifying memory directly, you call the object's functions to change its state. It so happens that std::basic_string has a member function called assign which does the job. You should shuffle an array of numbers (of values [0, ..., 49] in your case; you can also exclude your x and y from that array if you already know their values), then grab the first N values (however many you're seeking) from the shuffled array. That way, all the numbers are randomly of that range, and not "seen before". The algorithm you have is O(n²). Unless you have a way to make your algorithm do something significantly better than doing pairwise comparisons, performance is unlikely to appreciably improve. :-( First, the class &lt;&lt; foo syntax opens up foo's singleton class (eigenclass). This allows you to specialise the behaviour of methods called on that specific object.a = 'foo'class &lt;&lt; a def inspect '"bar"' endenda.inspect # =&gt; "bar"a = 'foo' # new object, new singleton classa.inspect # =&gt; "foo"Now, to answer the question: class &lt;&lt; self opens up self's singleton class, so that methods can be redefined for the current self object (which inside a class or module body is the class or module itself). Usually, this is used to define class/module ("static") methods:class String class &lt;&lt; self def value_of obj obj.to_s end endendString.value_of 42 # =&gt; "42"This can also be written as a shorthand:class String def self.value_of obj obj.to_s endendOr even shorter:def String.value_of obj obj.to_sendWhen inside a function definition, self refers to the object the function is being called with. In this case, class &lt;&lt; self opens the singleton class for that object; one use of that is to implement a poor man's state machine:class StateMachineExample def process obj process_hook obj endprivate def process_state_1 obj # ... class &lt;&lt; self alias process_hook process_state_2 end end def process_state_2 obj # ... class &lt;&lt; self alias process_hook process_state_1 end end # Set up initial state alias process_hook process_state_1endSo, in the example above, each instance of StateMachineExample has process_hook aliased to process_state_1, but note how in the latter, it can redefine process_hook (for self only, not affecting other StateMachineExample instances) to process_state_2. So, each time a caller calls the process method (which calls the redefinable process_hook), the behaviour changes depending on what state it's in. Your version must be wonky. :-P When tested on OpenJDK (as distributed with Ubuntu 9.10), this is what I get:ParensTest.java:4: not a statement (main(null)); ^1 errorUpdate based on OP's edit: Eclipse uses its own Java compiler, called ecj; it does not use the JDK compiler (javac). That is why you get different output sometimes. (And yes, the bytecode generated is sometimes different too, causing funky differences in behaviour depending on whether you compiled your code in Eclipse.)(As an aside, another difference between ecj and javac in my experience: javac will tell you to get lost if you have a string constant over 65535 bytes long (this is a limitation in the class file format). ecj will actually try to emulate such a long string constant, by piecing together shorter parts, each fitting within the 64k limit, with a StringBuilder, then finally interning the result---just as would happen with a "real" string constant.) Pseudocode:$base = log($size) / log(1024);$suffix = array("", "k", "M", "G", "T")[floor($base)];return pow(1024, $base - floor($base)) . $suffix; If your one-time pad is completely random, then anything XOR'd with it also is (assuming your message has no/low correlation with the contents of the one-time pad). a='sample.txt.pgp'echo ${a%.*} # sample.txt (minimal match)echo ${a%%.*} # sample (maximal match) The asterisk performs apply (as it's known in Lisp and Scheme). Basically, it takes your list, and calls the function with that list's contents as arguments. See RFC 3875 for the CGI spec, which has all the info you need. :-)From the RFC: meta-variable-name = "AUTH_TYPE" | "CONTENT_LENGTH" | "CONTENT_TYPE" | "GATEWAY_INTERFACE" | "PATH_INFO" | "PATH_TRANSLATED" | "QUERY_STRING" | "REMOTE_ADDR" | "REMOTE_HOST" | "REMOTE_IDENT" | "REMOTE_USER" | "REQUEST_METHOD" | "SCRIPT_NAME" | "SERVER_NAME" | "SERVER_PORT" | "SERVER_PROTOCOL" | "SERVER_SOFTWARE" | scheme | protocol-var-name | extension-var-name protocol-var-name = ( protocol | scheme ) "_" var-name scheme = alpha *( alpha | digit | "+" | "-" | "." ) var-name = token extension-var-name = token Yes, if only to test that the framework generates sufficient test coverage. In Ruby, continue is spelt next. You should take the enum by value, rather than by const reference. It's small enough to fit into an int, so there is no performance penalty or anything like it.But, from what you're describing, it sounds like somebody has #defined INCORRECT_FRAME to 0 elsewhere. You should put something like the following in the line above it:#ifdef INCORRECT_FRAME#error Whoops, INCORRECT_FRAME already defined!#endifBTW, the #ifndef thingy (for your header files) is called an include guard. :-) You need to say &lt;E extends Addable&lt;E&gt;&gt;, not &lt;E extends Addable&gt;.This is because when using a raw type, all references to its (non-existent) type parameters get erased. You probably should put real newlines (\n) into your text to be converted. Then, if the HtmlGenerator doesn't convert those to &lt;br&gt; afterwards, you can use a standard string replace yourself. Not tested, but:UPDATE my_table SET name = 'notify5-' || SUBSTR(name, 9) WHERE name LIKE 'notify4-%'This should work for database servers that don't support regex matching. :-) (But, I see your post is tagged with Oracle, so, I presume Klaus's answer will work for you too.) According to the FFMPEG FAQ, you have to convert your .mov files to MPEG format before you can concatenate them in that fashion.Yes, you can use FFMPEG to do the conversion, both to and from MPEG. :-P Dump out all the key-value pairs into a set&lt;pair&lt;K, V&gt; &gt; first, where the set is constructed with a less-than functor that compares the pair's second value only. That way, your code still works even if your values aren't all distinct.Or dump the key-value pairs into a vector&lt;pair&lt;K, V&gt; &gt;, then sort that vector with the same less-than functor afterwards. You need to use gethostbyname, not gethostbyaddr (which does reverse lookup).&gt;&gt;&gt; socket.gethostbyname('car.spillville.com')'209.20.76.192'&gt;&gt;&gt; socket.gethostbyaddr('209.20.76.192')('car.spillville.com', [], ['209.20.76.192']) Try:g++ -fPIC -rdynamic -o testexe testexe.cpp -ldlWithout the -rdynamic (or something equivalent, like -Wl,--export-dynamic), symbols from the application itself will not be available for dynamic linking. How about this:SELECT c.*, u.* FROM collections cJOIN users u ON c.mid = ? AND c.mid = u.user_idORDER BY u.user_id(where ? is the parameter marker, of course). As noted in an Adobe blog post, Flash's ActionScript engine has a JIT compiler, that compiles the ActionScript code into native code.x64 has a very different instruction set from x86. Therefore, making the JIT compiler generate x64 code is a non-trivial task, and is far more complicated than just making all the words 64 bits. :-) Yes. You need to assign a real string array to operand first.String[] operand = new String[3]; // or whatever number of elements you want Well, your function actually takes its arguments in eax and ebx, rather than using arguments pushed onto the stack. If this isn't what you want, put these two instructions after the mov ebp, esp:mov eax, [ebp + 8]mov ebx, [ebp + 12] Yes. Use caches from Guava.Example:import java.math.BigInteger;import com.google.common.base.Preconditions;import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;public class Fibonacci { private static final LoadingCache&lt;Integer, BigInteger&gt; CACHE = CacheBuilder.newBuilder().build(CacheLoader.from(Fibonacci::fib)); public static BigInteger fib(int n) { Preconditions.checkArgument(n &gt;= 0); switch (n) { case 0: return BigInteger.ZERO; case 1: return BigInteger.ONE; default: return CACHE.getUnchecked(n - 1).add(CACHE.getUnchecked(n - 2)); } }} Of course not.Take the identity function for example. All 32-bit values have an identity in the 64-bit value space (just use 0 in the top 32 bits, using only the bottom 32 bits for the value). However, any 64-bit value where the top 32 bits is not 0, will not have a corresponding value in the 32-bit value space.The above is a layman's explanation, and is probably not rigorous enough as a homework solution (as intended). You'd do well to read up on the pigeonhole principle. Set&lt;K&gt; set = Collections.newSetFromMap(new ConcurrentHashMap&lt;K, Boolean&gt;()); This is thoroughly discussed in the Boost.Function FAQ. :-) this is the DOM object, whereas $(this) is the jQuery wrapper around same.When using this, you can call DOM methods on it, but not jQuery methods. When using $(this), you can call jQuery methods on it, but not DOM methods. var xdiff = targetSpeed.x - speed.x;var ydiff = targetSpeed.y - speed.y;var angle = Math.atan2(ydiff, xdiff);speed.x += speedStep * Math.cos(angle);speed.y += speedStep * Math.sin(angle); For most Unix-style C programs, the incantation is:./configuremakesudo make installThis should already be documented in the INSTALL file, which additionally may contain further useful information. for a in *.txt; do b=$(printf %04d.txt ${a%.txt}) if [ $a != $b ]; then mv $a $b fidone Here's a non-homework way to answer this: Integer.bitCount:-P Since your $roption represents more than one argument, you should use $roption, not "$roption".Of course, using a scalar to hold multiple values is just wrong. If you are using bash, consider using an array instead:roptions=(-a --recursive --progress --exclude='class' --delete --exclude='exclude' --exclude='.svn' --exclude='.metadata' --exclude='*.class')rsync "${roptions[@]}" /media/CORSAIR/workspace ~ Yes, javac already does this (assuming your static final fields are for a primitive type or String): the constant value is "pasted in" directly at the point of use.Of course, the downside to this is that if you change the field and forget to recompile the classes that use that field, then the value will be stale.... Well, memmove has to copy backwards when the source and destination overlap, and the source is before the destination. So, some implementations of memmove simply copy backwards when the source is before the destination, without regard for whether the two regions overlap.A quality implementation of memmove can detect whether the regions overlap, and do a forward-copy when they don't. In such a case, the only extra overhead compared to memcpy is simply the overlap checks. my @files = grep {!/^\./} readdir DIR;This will exclude all the dotfiles as well, but that's usually What You Want. L'ÿ' is of type wchar_t, which can be implicitly converted into an unsigned short. L"ÿ" is of type wchar_t[2], which cannot be implicitly converted into unsigned short[2]. It returns the average of a and b, rounded down. So, if a is 5 and b is 8, then the result is 6.ETA: This method is busted if a and b add up to a negative number, like if both are negative, or if integer overflow occurs. Less repetition, for starters. Which one do you like more:IDictionary&lt;string, object&gt; foo = new SortedDictionary&lt;string, object&gt;();orvar foo = new SortedDictionary&lt;string, object&gt;();Personally, I find the latter much more readable. User code is never allowed to put classes into one of the standard Java packages. That way, user code cannot access any package-private classes/methods/fields in the Java implementation. Some of those package-private objects allow access to JVM internals. (I'm thinking of SharedSecrets in particular.) To directly answer your question about comparing numbers:if [ "$duration" -lt 1000 ]; thenYou get the idea. :-)Amber's answer is, of course, much better from a forest-instead-of-trees point of view:printf "cap_%06d.png" "$duration" For ecx repetitions, stores the contents of eax into where edi points to, incrementing or decrementing edi (depending on the direction flag) by 4 bytes each time. Normally, this is used for a memset-type operation.Usually, that instruction is simply written rep stosd. Experienced assembly coders know all the details mentioned above just by seeing that. :-)ETA for completeness (thanks PhiS): Each iteration, ecx is decremented by 1, and the loop stops when it reaches zero. For stos, the only thing you will observe is that ecx is cleared at the end. But, for scas or the like, where the repz/repnz prefixes are used, ecx can be greater than zero if the operation stopped before exhausting ecx bytes/words/whatevers.Before you ask, scas is used for implementing strchr-type operations. :-P At least for the most recent version, try this:(cairo-pdf-surface-create 100.0 100.0 "foo.pdf")See the source, which specifies the arguments in the order (sx sy filename), with the filename being optional (using the current output port if not specified). Is your daylight savings about to end? If so, your timezone files may be out of date, thinking it's already ended. (I don't know about the UK, but in the US, the scope of daylight savings was expanded 3 years ago, and many installations still don't have the updated data.)In short, make sure your timezone data is up to date. :-) Well, if your class is an inner class (non-static nested class), it has an outer, enclosing instance. Two objects of an inner class type aren't really equal unless the enclosing instances are equal, too; the outer instance like a hidden field (usually named this$0 by javac). Racket has classes and methods, and you should use it!(define circle% (class object% (init radius) (define r radius) (super-new) (define/public (area) (* pi r r))))(define rectangle% (class object% (init width height) (define w width) (define h height) (super-new) (define/public (area) (* w h))))(define unit-circle (new circle% [radius 1]))(define unit-square (new rectangle% [width 1] [height 1]))(send unit-circle area) ; =&gt; 3.141592653589793(send unit-square area) ; =&gt; 1Much less hacky than name-based dispatch. [This answer is written with Scheme programmers in mind (the OP has asked other Scheme questions here before, so that's a safe bet). If you're here because you're a Ruby programmer with no Scheme background, read the footnote for some context. :-)]MRI doesn't (see below); and if MRI doesn't, that means there is no portable way to use any such functionality even if another implementation provides it.I actually inspected the MRI 1.9.1 source code, just to be sure. In any case, here is some code to demonstrate that even the normal unwind protection (ensure) doesn't work correctly with continuations on MRI (tested with both 1.8.7 and 1.9.1). (It does work correctly with JRuby (I tested with 1.5), so it goes to show it's an implementation-specific thing. But note that JRuby only provides escape continuations, not general-purpose ones.)callcc do |cc| begin puts 'Body' cc.call ensure puts 'Ensure' endend(To test with MRI 1.9+, you need to either run with the -rcontinuation option, or put require 'continuation' at the top of the file.)For readers who don't know what a dynamic-wind is, it's a way to specify code to be run when the code being covered is exited (much like ensure), as well as code to to be run when the covered code is re-entered. (This can happen when you use call/cc inside the covered code, and invoke the continuation object after the covered code has been exited.)Totally contrived example:def dynamic_wind pre, post, &amp;block raise 'Replace this with a real implementation, kthx'enddef redirect_stdout port, &amp;block saved = $stdout set_port = lambda {$stdout = port} reset_port = lambda {$stdout = saved} dynamic_wind set_port, reset_port, &amp;blockendcc = nil# cheap way to nuke all the output ;-)File.open '/dev/null' do |null| redirect_stdout null do callcc {|cc|} puts 'This should not be shown' end puts 'This should be shown' cc.callendSo, a properly-functioning dynamic_wind implementation would ensure that $stdout would be set back to the /dev/null stream when the continuation is invoked, so that at all instances where puts 'This should not be shown' is run, that text is indeed not shown. Does your code work? If so, here's a better-looking version of the same code:(let ((smaller-edge (min width height))) (gimp-image-resize image smaller-edge smaller-edge 0 0)) If you can use a valarray instead of a vector, it has builtin operators for doing a scalar multiplication.v *= 3;If you have to use a vector, you can indeed use transform to do the job:transform(v.begin(), v.end(), v.begin(), _1 * 3);(assuming you have something similar to Boost.Lambda that allows you to easily create anonymous function objects like _1 * 3 :-P) Potatoswatter's answer is all right, but I prefer to use find or lower_bound instead. lower_bound is especially useful because the iterator returned can subsequently be used for a hinted insertion, should you wish to insert something with the same key.map&lt;K, V&gt;::iterator iter(my_map.lower_bound(key));if (iter == my_map.end() || key &lt; iter-&gt;first) { // not found // ... my_map.insert(iter, make_pair(key, value)); // hinted insertion} else { // ... use iter-&gt;second here} Try this:sed -i -e 's/&lt;em\:update.*//g' install.rdfWhen you redirect output to a file in truncate mode, the file is truncated first, before it's read. Thus, the result is an empty file. Using sed -i avoids this.Portable (and hopefully not too insecure) solution:(set -C &amp;&amp; sed -e 's/&lt;em\:update.*//g' install.rdf &gt; install.rdf.$$ &amp;&amp; mv install.rdf.$$ install.rdf):-) In 32-bit mode, esi.In specific, movsb copies one byte from ds:esi to es:edi, the adjusts both esi and edi by 1, either up or down depending on the direction flag. .a files are meant to be statically linked, and so are not compiled with -fPIC. Consequently, you cannot make a shared library from it. You can privately derive from concrete classes. Private inheritance doesn't require Liskov substitutability; it's essentially just a convenient way to "mix in" a class's functionality.Public inheritance, on the other hand, does require Liskov substitutability. So, usually, publicly inheriting from concrete classes is a bad thing, unless such a class is designed to be used as a base class (many are not). You can run ssh-add to add your key to your current ssh-agent. This will prompt for your passphrase.Normally, when ssh-agent is running, and you add a key to it, you won't have to unlock your key any more when you connect to hosts that recognise that key. If that isn't what you want, just run ssh-add -d to remove it off your ssh-agent when you're done testing. You can't access local files with applets---this is by design!You can (and should) embed the font file inside your .jar file, and use Class.getResourceAsStream or the like to access it (Font.createFont has an overload that takes an InputStream, which is exactly the type that Class.getResourceAsStream returns). Scheme version, just for target practice. :-) (Requires SRFI 1's fold function.)(define (unzip l) (define (iter e v) (list (not (car v)) (caddr v) (cons e (cadr v)))) (define (swap-if p a b) (if p (list b a) (list a b))) (map reverse (apply swap-if (fold iter '(#t () ()) l))))To change the order of the returned lists (i.e., even-indexed elements first), simply change the #t to #f. I'm not sure what you mean by "items", so I will assume "directory entries". Assuming you have no files with newlines in their name, echo "$abc" | wc -l will do the trick.If you want to count the number of characters, use wc -c instead. def self.up execute "DELETE FROM notes WHERE note_type = 'short_note'"end:-PJust kidding. I'm sure you could do this:Note.delete_all :note_type =&gt; 'short_note' That is because of the way two's complement encoding works: 0 is treated as a "positive" number (signed bit off), so, therefore, the number of available positive values is reduced by one.In ones' complement encoding (which is not very common nowadays, but in the olden days, it was), there were separate values for +0 and -0, and so the range for an 8-bit quantity is -127 to +127. Here's an example to better illustrate why you should choose constraints carefully (same function as yours, but perhaps written a little more succinctly):bool add_and_check_overflow(int32_t&amp; a, int32_t b){ bool result; __asm__("addl %2, %1; seto %b0" : "=q" (result), "+g" (a) : "r" (b)); return result;}So, the constraints used were: q, r, and g.q means only eax, ecx, edx, or ebx could be selected. This is because the set* instructions must write to an 8-bit-addressable register (al, ah, ...). The use of b in the %b0 means, use the lowest 8-bit portion (al, cl, ...).For most two-operand instructions, at least one of the operands must be a register. So don't use m or g for both; use r for at least one of the operands.For the final operand, it doesn't matter whether it's register or memory, so use g (general).In the example above, I chose to use g (rather than r) for a because references are usually implemented as memory pointers, so using an r constraint would have required copying the referent to a register first, and then copying back. Using g, the referent could be updated directly.As to why your original version overwrote your c with the addition's value, that's because you specified =m in the output slot, rather than (say) +m; that means the compiler is allowed to reuse the same memory location for input and output.In your case, that means two outcomes (since the same memory location was used for b and c):The addition didn't overflow: then, c got overwritten with the value of b (the result of the addition).The addition did overflow: then, c became 1 (and b might become 1 also, depending on how the code was generated). A method like dirty() has more semantic meaning than this.changed = true. If you ever decide you want to handle the dirty-tracking a different way, you only have to change one place---and from the point of view of other code (even if all in the same class), it's still more meaningful (and easier for the reader to grasp).In short, I recommend using dirty() instead of this.changed = true. Okay. Start with Intel syntax first, because most x86 assembly coders use it. Intel's manuals are a great resource for learning about how the x86 handles floating-point stuff.After you learn x86 assembly in general, AT&amp;T syntax isn't so hard to learn. The main things to note are:registers are prefixed by %; numeric constants are prefixed by $register order is swapped for most two-operand instructions (i.e., source first, target last)instruction names specify the size; so instead of mov dword ptr [ebx], 1337, you'd say movl $1337, (%ebx). You cannot. The best you can do is make an ArrayList&lt;Set&lt;Hexagon&gt;&gt;.If you are willing to deal with raw types (which are heavily discouraged), you can make an array of Set (as opposed to Set&lt;Hexagon&gt;, which is not allowed). But you didn't hear this from me. You can create a read-only view of the set by using Collections.unmodifiableSet. Just pass this view to everyone who doesn't need to write to the set. (An UnsupportedOperationException will be thrown for anybody who tries to modify this view.) You cannot, at least not for the process being killed.What you can do is arrange for the parent process to watch for the child process's death, and act accordingly. Any decent process supervision system, such as daemontools, has such a facility built in. system doesn't throw an exception or anything if your command fails to run (which may be why you said "no error was reported").So, you need to check whether java is in your PATH; by default on Windows, it's not, and you need to add the JDK's bin directory to your PATH. I wouldn't bother to try to obfuscate it.Instead, if the two servers can share a common secret, you can use keyed-hashing (see javax.crypto.Mac) to generate keyed hashes for the document number, which is passed to the other server along with the document number.The target server can then easily verify that the keyed hash corresponds to the document number, and easily detect attempts to modify it. You need to write two functions. In Scheme (since I know Scheme much better than Python :-P), those two functions are called string-&gt;number and number-&gt;string, though of course you can name them whatever you like.Each of those functions needs to take a base parameter to do the conversion in. You can make it default to 10, if you like.Once you implement each of those successfully, the rest is a piece of cake.Test cases for you:assert str2num('1234', 10) == 1234assert str2num('1234', 16) == 0x1234assert num2str(1234, 10) == '1234'assert num2str(1234, 16) == '4d2'assert num2str(0x1234, 16) == '1234' Change your inner loop to this:for (int p = w; p &lt;= 6 + w; p++) { System.out.print((p - 1) % 6 + 1 + " ");} This question is a better fit for programmers.stackexchange.com. But anyway. I think this whole "everybody at work must use one editor only" is absurd. Whatever happened to "different strokes for different folks", especially for creative types like programmers?If your work doesn't see programmers as creative types, then you have a bigger problem. Time to visit careers.stackoverflow.com. ;-)As a personal aside, I type with Dvorak. I don't necessarily want to convert all my workmates to Dvorak, but, I would find a different job if work made me use qwerty. There is simply no way I would agree to retrain myself on qwerty given that I type at 100 to 120 wpm on Dvorak, and no amount of qwerty training will get me to that speed. Your C++ implementation probably uses a copy-on-write string implementation, meaning that string copies don't really copy the string (but instead link back to the copy), and only copy the string "for real" when you write to it.To test whether this is the case, put this inside the loop, after the q1.push(st1) line:++st1.a[0];then time again.Obviously, character arrays don't have copy-on-write behaviour, and is copied "for real" every time you ask for it to be copied. It's an email encoding system called "quoted-printable", which allows non-ASCII characters to be represented as ASCII for email transportation.In quoted-printable, any non-standard email octets are represented as an = sign followed by two hex digits representing the octet's value. Of course, to represent a plain = in email, it needs to be represented using quoted-printable encoding too: 3D are the hex digits corresponding to ='s ASCII value (61). When you run the Java compiler or your application itself, you can specify a classpath which lists all the jars and directories you're loading classes from. A jar just contains a bunch of class files; these files have enough metadata in them that no extra header files are necessary. If there's really only logically ever one instance, you can use a singleton. The canonical form of a singleton is:public enum Singleton { INSTANCE; // fields and methods here}That way, you don't have to shoehorn everything into static methods (though, if you want to write static methods that reference INSTANCE, that's fine too). Any code that wants to access the singleton just uses Singleton.INSTANCE, and you don't have to pass it around if you don't want to. Yes, there is a difference between 0.0 and -0.0 (though Python won't let me reproduce it :-P). If you divide a positive number by 0.0, you get positive infinity; if you divide that same number by -0.0 you get negative infinity.Beyond that, though, there is no practical difference between the two values. If your I/O functions don't allow you to specify a port, you may be able to use with-output-to-file instead:(with-output-to-file "test.out" (lambda () (display "Hello, world!") (newline))) Python is a dynamic (latent-typed) language, so there is no such thing as a "map of vector of vector of vector" (or "dict of list of list of list" in Python-speak). Dicts are just dicts, and can contain values of any type. And an empty dict is simply: {} Try using this:response.setContentType("text/html; charset=UTF-16LE");Granted, it doesn't make your text ISO-8859-1, but, most browsers have no problem supporting UTF-16 these days. Sadly, if you're casting from an Object, then you can't dodge the unchecked cast warning. That's because Object doesn't have enough type information by itself to have the T.(Java generics are erasure-based. Therefore there is no way to know whether an object has type argument T at runtime---type arguments are used at compile-time only.) Defining an overloaded &lt; operator is simple in this case:bool operator&lt;(A const&amp; lhs, A const&amp; rhs) { return lhs.i &lt; rhs.i;}In general, defining overloaded operators is as simple as that (though if you want to access non-public members, you will need to friend the function within the class's definition).Some operator overloads (like [], (), =) cannot be defined as free functions, but instead must be member functions. This isn't any harder than defining free-function overloaded operators, but is something to be aware of. public static &lt;T&gt; void mergeKeys(Map&lt;T, Integer&gt; target, Map&lt;T, ?&gt;... sources) { Set&lt;T&gt; newKeys = new HashSet&lt;T&gt;(); for (Map&lt;T, ?&gt; source : sources) newKeys.addAll(source.keySet()); newKeys.removeAll(target.keySet()); for (T key : newKeys) target.put(key, 0);} SRFI 95 provides a sorting library. Many Scheme implementation also have sorting libraries built in, though not all of them conform to the SRFI 95 interface.If you need to write your own implementation (for homework, say), then you should use one of the standard sorting algorithms like mergesort or quicksort. However, both of those algorithms are vector-based algorithms, so you will need to copy the list to a vector, sort that, then copy it back to a list. (You may find SRFI 43 useful for vector manipulation operations, especially vector-swap! for swapping two elements of a vector.)There may be algorithms that are suited for sorting a linked list directly. I'm not au fait with them, so I won't comment on them further. Try this:(if (null? y) (map list x) (map cons x y)) That's not a valid expression. ... simply means the caller can pass in more arguments than the number of parameters the function formally specifies. Faster than using String.split is Pattern.split: i.e., precompile the pattern and store that for subsequent use. If you use the same pattern all the time, and do a lot of splitting using that pattern, it may be worth putting that pattern into a static field or something.Also, if your pattern contains no regex metacharacters, you can pass in Pattern.LITERAL when creating the pattern. This is something you can't do with String.split. :-P If you use two different compilers, then unless they have compatible ABI (application binary interface), you cannot sensibly mix-and-match any object code created by them, whether or not member function pointers are involved. When you use arc4random you avoid one pitfall of using % with linear congruential generators (which is the usual algorithm used by rand): the low-order bits aren't less random.However, you still have truncation issues: i.e., because (1 &lt;&lt; 32) % 83 is 77, that means that numbers between 0 and 76 appear (slightly) more frequently than numbers between 77 and 82. To avoid this, you should throw away the incoming value (i.e., call arc4random again) if it's above (1 &lt;&lt; 32) / 83 * 83.(I assume the range of arc4random is from 0 to 232-1. Adjust the above explanation accordingly.) The other answers in this thread are correct about the purpose of the copy. I will say, though, that Java 5+ already has the right data structure that will do that copying automatically: java.util.concurrent.CopyOnWriteArrayList. Basically this:for (n = 0; n &lt; 121; ++n) { if (n &amp; 8) { n += 7; putchar('\n'); } else { putchar(".?+nkbrq?*?NKBRQ"[b[n] &amp; 15]); }}What that does is, after every 8 board items, print a newline; otherwise, print out the board item indicated by b[n]. You don't need to do anything on the C side. Just change the binary to be owned by the user you want to use, enable the setuid bit in the binary (chmod u+s), and you're all set!(If you don't want any user to be able to run as your designated user willy-nilly, consider using sudo.) A quick grep of the Racket source (for setsockopt) suggests that there is no built-in interface that you can use to specify arbitrary socket options (all uses of setsockopt that I've found use fixed options only). So, I think what you've got is probably the best option available. Sean's answer is correct. However, if you want to be able to type nil, then that's easy too. Just run this once at the start of your session:(define nil '()) That's an interesting way to jump up the stack. It seems to work, but is probably slower than the usual way to implement this technique, which is to throw an exception that is caught $BIGNUM layers up the call stack. OpenPGP is supported by both Java and Ruby.The nice thing about OpenPGP is that key management is all specified upfront, so you don't have to reinvent that particular wheel. (Encrypting and decrypting the data itself isn't hard. Managing the keys in a secure way is.) You could do it like this:inline double dot(const Vec3&amp; lhs, const Vec3&amp; rhs) { return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;}double dot(const Vec3* lhs, const Vec3* rhs) { return dot(*lhs, *rhs);}The benefit of doing it this way is that, if you then declare the "pointer" version as extern "C", then C programs can use it too. (C does not support references, but does support pointers---so you cannot extern "C" the "reference" version.) You should include the C library header in a separate namespace.namespace foo { #include &lt;foo.h&gt;}This way, because external C code does not use namespaces, the program will still link properly, but the names will (at the C++ level) not collide with your other C++ libraries any more. Exactness is simply a property of a number: it doesn't change the value of the number itself. So, for an implementation that uses a flag to indicate exactness, inexact-&gt;exact simply sets the exactness flag on that number. Brian's answer is correct. However, on a "forest instead of trees" level, the code's design needs to be fixed too:If you want a collection of sorted names, and be able to search for existing names, you should be using a TreeMap. An ArrayList (that you sort on each insertion, no less) is totally the wrong data structure for this. From reading the question, I have a feeling that you're barking up the wrong tree.You only need three functions: random-pick, non-same, and arrangements. The last one is already defined in exercise 12.4.2.I presume from your question that you want to implement non-same. You will want to implement a function that you pass into filter (or whatever the HtDP equivalent is). Then, it's as simple as:(define (non-same names arrangements) (define (usable? arrangement) ...) (filter usable? arrangements))(Fill in the ... yourself, of course. That function needs only return a boolean value, and you should not have to touch append at all (as you did in your question).)I hope that's enough of a hint. If you need another hint, just ask. :-) I don't know CL well enough, but will Scheme macros do? Here's a while loop in Scheme:(define-syntax while (syntax-rules () ((while pred body ...) (let loop () (if pred (begin body ... (loop)))))))In this case, the example demonstrates that you can easily write your own control structures using macros. foof-loop is a collection of even more useful looping constructs (probably nothing new given CL's ones, but still good for a demonstration).Another use case: picking values out of associative lists. Say users pass in an alist as options to your function. You can easily pick values out by using this macro:(define-syntax let-assq (syntax-rules () ((let-assq alist (key) body ...) (let ((key (assq-ref alist 'key))) body ...)) ((let-assq alist (key rest ...) body ...) (let ((key (assq-ref alist 'key))) (let-assq alist (rest ...) body ...)))));; Guile built-in(define (assq-ref alist key) (cond ((assq key alist) =&gt; cdr) (else #f)))Example usage:(define (binary-search tree needle (lt? &lt;)) (let loop ((node tree)) (and node (let-assq node (value left right) (cond ((lt? needle value) (loop left)) ((lt? value needle) (loop right)) (else value))))))Notice how the let-assq macro allows picking out the value, left, and right keys from the "node" without having to write a much longer let form. A ClassCastException does not arise from a missing class (that's what NoClassDefFoundError is for); instead, it's thrown because the code attempted to cast an object to an incompatible type.In this instance, it means the new version of NeoDatis is not completely backward-compatible with the version you had.Do you have a full stacktrace for the ClassCastException? I'll update this with some concrete answers after I study the stacktrace. :-) Yes. Use a vector.To insert, simply place at the end, and increment the size. To remove, pick an element at random, swap its contents with the end value, then pop off the end value (i.e., return the end value and decrement the vector's size).Both operations are amortised O(1). You can use:new String(bytearray, "UTF-8")(change UTF-8 to something else (e.g., ISO-8859-1) if your bytes are not UTF-8.) You cannot use two memory operands for mov; one must be a register. So, in your case, you need to have two mov instructions:mov eax, [s.AddrFrame.Offset + 1]mov old_ebp, eaxand analogously for ret_addr. You can use an obfuscator to obfuscate the object code, which makes it harder to decompile (at least with an automatic decompiler). No amount of obfuscation can totally prevent manual decompilation.Use HTTPS to prevent sniffing. Simple! The jar file you have probably contains obfuscated class files. Obfuscated files have identifiers renamed to make them harder to understand by human readers. (Obfuscation does much more than just rename identifiers, but that's one of the things obfuscation usually does.) Yes. Use strtol instead, and specify 0 as the base. Yes, even for single core processors, volatile is still useful. It tells the compiler that the value needs to be reread from memory each time it's read (because another thread may be updating it), and not just be cached in a register. OSX has strlcpy and strlcat. Linux doesn't currently have them, to my knowledge, but it's easy enough to bring those functions in from, say, OpenBSD. Just use pair? to see if you can cdr it. There is no specific check for void, since it's essentially a phantom type. You can use jmap -dump to generate heap dumps. And you can analyse the heap dumps using a variety of programs, such as jhat or VisualVM (both of which come with the JDK).There, lots more things for you to Google up now. :-) You absolutely must read this article: Enough with the rainbow tables.Summary: If you're not using BCrypt, you're doing it wrong. No ifs, no buts. (This also means that all the suggestions to use MD5 or SHA-1 or SHA-512 or anything else are wrong too.) You should be using Formatter or its frontend, String.format, instead. You can do:String.format("%s is much better %s", "this", "indeed");String.format("%1$s provides positional formatting %2$s", "this", "indeed"); You should be using a vector. It will allow you to construct its contents one-by-one (via push_back or the like), which sounds like what you're wanting to do. Is this what you're thinking of?#(#(p b p b p b p b) #(b p b p b p b p) #(p b p b p b p b) #(b p b p b p b p) #(p b p b p b p b) #(b p b p b p b p) #(p b p b p b p b) #(b p b p b p b p)) Consider making a shared-substring implementation of strings (this is how Java does it, for example). So when you want to grab a substring of a given string, rather than copying the characters, simply keep a pointer to (some location in) those characters, and a length. Is the set of your child classes fixed? If so, consider using an enum.public enum Parent { CHILD1 { // class definition goes here }, CHILD2 { // class definition goes here }; // common definitions go here}Since the OP mentioned about state pattern, here are two examples of enum-based state machines: a simple one and a complex one. Heh, sounds like they copied and pasted code from different sources? :-P No, seriously, unless you need to inspect the decompressed data, you can just use a BufferedOutputStream for both compression and decompression. Yep, pretty much. So you can do something like:Google::Search::Web.new do |search| # ...end(Though, from a software design point of view, running user-specified code in a constructor always seemed strange to me. A better approach is what File and IO do, where open does pretty much the same thing as new, except that open runs the passed-in block, whereas new does not.) Try SRFI 49 for size. :-P(Seriously, though, as Rafe commented, "I don't think anybody wants this".) This will tell you:&lt;%= page.getClass() %&gt;:-P No, that creates many instances of one single class. To test, put this within your anonymous class:@Overridepublic String toString() { return getClass().getName();}Then call toString() on various instances of the anonymous class. You'll see they all return the same class name. You only need one keyword-arguments parameter; it receives any number of keyword arguments.def foo(**kwargs): return kwargs&gt;&gt;&gt; foo(bar=1, baz=2){'baz': 2, 'bar': 1} C can only deal with POD types.Consequently, you cannot pass objects of non-POD types to C programs (by value). Also, if you pass pointers of non-POD types to C programs, they can't interact with the objects pointed to. Here's my solution, using a similar approach to the OP's. (In the case of multiple deepest items, they are all returned.)I wrote it in Scheme, which probably won't be immediately translatable to Common Lisp, so I don't feel that it'd be a complete giveaway. Still, it has the potential to be spoilery, so tread with caution.(define (deepest lst) (let ((filtered (filter pair? lst))) (cond ((null? filtered) lst) (else (deepest (concatenate filtered)))))) After intense corporate lobbying, rivalled only by Monsanto, I've decided to amend my position statement.As one of the earliest users of Stack Overflow, I've seen many things come and go, and will, $DEITY willing, continue to. As such, I know what I stand for:A laissez-faire moderation style, where anything that isn't spammy, objectionable, clearly off-topic, or stupid (see below) will be acceptable.Legitimation of code golf as a first-class topic (at least until Code Golf SE is launched). In particular, I will actively reopen (quality) code golf questions (and/or resurrect them on Code Golf SE).Condemnation of MD5-based password salting. scrypt is where the game is at!Of course, I will gladly support the usual stuff about gay marriage for flying pigs and weaponised Trojan ponies. I haven't changed my stance on those. :-D I'll write a different, simpler function that demonstrates looping. Hopefully between that and what you have, you'll get there. :-)(define (member x lst) (cond ((null? lst) #f) ((equal? x (car lst)) lst) (else (member x (cdr lst)))))Another example:(define (assoc x alist) (cond ((null? alist) #f) ((equal? x (caar alist)) (car alist)) (else (assoc x (cdr alist))))) If you are entering your input from the console, try pressing Ctrl+D (in Unix and MacOSX), or Ctrl+Z, then Enter (in Windows). This will signal the end of the input. Surely, this is better:(defun treemax (bilist &amp;optional (op #'max)) (funcall op (COMPLEX_EXPRESSION_1) (COMPLEX_EXPRESSION_2)))Then, simply pass in #'min as argument 2 if you want to use min instead.(Of course, zakovyrya's answer works too.) It's not open source. Read the codecLib licence for more information.(However, caveat emptor: my answer is based on the best of my knowledge, and not on any inside information. I have no relation to jai-imageio-core nor codecLib.) It doesn't have to "remember" the original exactness of the arguments. It can temporarily (internally) convert the numbers to exact during the calculation, and tag the result as inexact if any argument is inexact.Examples:(denominator 1/10) ; 10(denominator 0.1) ; 3.602879701896397e+16(The latter result is implementation-dependent. The number I quoted is from Racket 5.0.2 running on amd64. You'll get different results from other implementations.)For lurkers and archives: the unusual-looking result is because most implementations use IEEE 754 for inexact numbers, which (being a binary floating-point format) cannot represent 0.1 with full precision (only a decimal floating-point format can).In fact, if you use (inexact-&gt;exact 0.1), you will not get 1/10, unless your implementation uses decimal floating-point. Guile 2.0 (to be released in about a few days) has an LALR(1) parsing library. SRFI 1 (activate in Racket using (require srfi/1)) has a drop-right function: (drop-right '(1 2 3 4) 1) ; =&gt; (1 2 3) Sure. Shred the file as you delete it.shred -u $FILEGranted, it doesn't directly answer your question, but I still think it's a solution---whatever's living in the cache is now randomly-generated garbage. :-) I'm going to bring out my favourite dog-and-pony show!Tree of cons cells http://cloud9.hedgee.com/priv/expr1.pngThis corresponds to the following:(let ((s5 (sqrt 5))) (/ (- (expt (/ (1+ s5) 2) n) (expt (/ (- 1 s5) 2) n)) s5))The diagram illustrates your first statement (the empty-list object is denoted as a black box). The code snippet illustrates your second. :-) The key insight to understanding the (lambda args ...) syntax (that other posters have helpfully posted already) is that a lone non-list item (in this case, args) is a degenerate improper list. Example:(define a '(arg1 arg2 . rest))a ; =&gt; (arg1 arg2 . rest) (improper list of length 2)(cdr a) ; =&gt; (arg2 . rest) (improper list of length 1)(cdr (cdr a)) ; =&gt; rest (improper list of length 0) Guile 2.0 has a SRFI 18 implementation that uses POSIX threads. (Guile 1.8 had POSIX threads, but no SRFI 18.) This will do it:char* chartwo = charone + 16; Below is a tail-recursive version. Your professor isn't likely to like it (since it doesn't demonstrate recursion ;-)), but at least it will give you some idea how to go about it.(define (reduce func lst) (let loop ((val (car lst)) (lst (cdr lst))) (if (null? lst) val (loop (func val (car lst)) (cdr lst)))))As hinted in Raph Levien's excellent answer, this version will not work if the incoming list is empty (that'd be what the identity parameter is for). You will, in this case, get an error (since you can't car or cdr an empty list). I've fixed the code formatting for you, which reveals what the problem is: you have too many layers of brackets around the (eq? token 'begin). The fixed version would look like this:(define declarations (lambda (token) (cond ((eq? token 'begin) '()) (else (let* ((name token) (eqsign (read)) (value (read))) (cons (list name value) (declarations (read)))))))) Well, you know, Bjarne Stroustrup did propose such a thing...Generalizing Overloading for C++2000. :-P :-P :-P In Python, characters in strings are simply strings of length 1, not integers. So you must use this:data[i] = chr(ord(data[i]) ^ asConvCode[i % 3])Also, as I wrote in a comment, your return data is at the wrong indentation level, and will cause your function to return after processing the first character. The default Object.clone() is indeed a shallow copy. However, it's designed to throw a CloneNotSupportedException unless your object implements Cloneable.And when you implement Cloneable, you should override clone() to make it do a deep copy, by calling clone() on all fields that are themselves cloneable. Since ++ and -- are not + and - operators:int add(int lhs, int rhs) { if (lhs &lt; 0) while (lhs++) --rhs; else while (lhs--) ++rhs; return rhs;} You cannot do that. Short of using eval, variable names are generally not allowed to be dynamic (basically anything that isn't a symbol literal). This is by design.If your variable names really are literals, and you just want a way to bind multiple variables at once, you can use let-values (SRFI 11) or extended let (SRFI 71).Edit to match OP's edit: What you want to do sounds like the letrec definition given here. However, that macro uses syntax-case, not match-lambda or the like. You may be able to use it as a starting point, though. Yes, if you're allowed to use set-cdr!.(set-cdr! railroad1 station1) CDNs are a kind of web cache, just one operated under your auspices, rather than the web user's. You get full control of the freshness of your content, whereas you don't have any control of the proxy servers "out there". Math.min and Math.max takes any number of numbers, as arguments. Your smallest is trying to pass an array, not numbers.The use of apply (as in largest in your example) pastes the elements of the array as arguments. In this context, -0x7ec55ec0 is just a shorter way to write 0xffffffff813aa140 (in other words, -0x7ec55ec0 + 0x10000000000000000).Presumably, there's a jump table at that address, indexed by rax.If it's any help, the same instruction in Intel assembly syntax is:call qword ptr [0xffffffff813aa140 + rax*8] For most pure virtual functions, you'd be right. However, for a pure virtual destructor, it's actually important to define a corresponding destructor implementation:The "pure virtual" is to require derived classes to implement their destructor.Your base class destructor implementation is so that the derived class destructors can successfully "chain up" afterwards. Aside from setting JAVA_HOME appropriately (which you've done), ensure that you're executing the right version of the java executable. e.g., on Debian or Ubuntu, execute /usr/lib/jvm/java-6-openjdk/jre/bin/java directly, if /usr/bin/java points to the wrong version.You can use the -version option to verify the version of the launcher you're using. Try java -version and /usr/lib/jvm/java-6-openjdk/jre/bin/java -version and see if the output is any different. Conditionals in constructors aren't problematic per se. However, in this instance, I'd be inclined to write your constructor like this:public PDFParagraph(PDFPhrase phrase, boolean isRtl) { super(phrase); setAlignment(isRtl ? Element.ALIGN_RIGHT : Element.ALIGN_LEFT);} You should never implement hashCode using random numbers! It should always be computed using the same fields as equals uses. Otherwise, your objects will be unusable as keys in HashMap, HashSet, etc. I can only comment on Unix, since that's the platform I know best.p.poll() becomes kill(pid, 0)p.terminate() becomes kill(pid, SIGTERM) Generally, you cannot use C++ facilities in C.However, a C++ library may choose to export some of its functionality to C programs, by declaring them extern "C". If your C++ library doesn't do this, you will have to write some wrappers (in C++) that do this.Note that such exported functionality have to conform to C's limitations. For example, you can't use non-POD types, function overloading, operator overloading, conversion operators, RTTI, exceptions, templates, etc. Scheme guarantees no specific order (as Cirno has said). If your code has no side-effects, this doesn't matter.However, your code is side-effecting (because of the set! to an outside variable), so, you have some choices:Use Racket (which is committed to using left-to-right order, last time I talked to a Racket dev)Structure your code to remove side-effects, so that your helper function doesn't change any variable or state outside itUse appropriate lets to ensure the ordering you need (as Cirno suggested); in particular, change (cons (helper (car ls)) (helper (cdr ls))) to:(let ((depth-first (helper (car ls)))) (cons depth-first (helper (cdr ls)))) Your code won't run. :-)I will presume that you mean these instead:(lambda (x) (let ((f 100)) (+ f x)))and(let ((f 100)) (lambda (x) (+ f x)))In both cases, you'll get back the passed-in argument plus 100.However, the main difference (ignoring technicalities about how let is just syntactic sugar over lambda) is that in the second version, f is a free variable. Say we do this:(let ((f 100)) (list (lambda (x) (+ f x)) (lambda (x) (set! f x))))This returns a list with two lambdas: the first of which is just like the ones previously, and the second one which allows you to change the value of f. Both lambdas access the same f, so running the setter will affect later calls to the first lambda. Here's my solution. Requires SRFIs 1 and 26 to be available.(define (cartesian-product first . rest) (define (iter l result) (define (prepend-all x) (map (cut cons &lt;&gt; x) l)) (concatenate (map prepend-all result))) (map reverse (fold iter (map list first) rest))) [Re my retagging: I assumed that you're using Dinkumware STL (given that you mentioned an xtree header). Retag if that's not the case.]Surely, you should be able to make a minimal subclass of _Tree and be done? Then you won't need to modify the _Tree class at all. (I don't have a copy of Dinkumware, so I can't verify that this works. But it seems a sensible thing to try.)My answer only touches on what you can do. As for what you should do, see the other answers. :-) In response to your attempt, I'll provide you some hints to get you through. :-)You don't need to use apply in your case. apply doesn't do what you think it does, notwithstanding that your assignment wants you to make a function called apply-all.cons takes two arguments.'(positive?) is a list that contains a symbol named positive?, not the positive? function. Your assignment used (list ...) for good reason. If you want something more compact than list, use quasiquotation: `(,positive?).You should consider using map, like Marcin's comment suggests.If you can't use map, then remember that when you use the "iterate with accumulator" pattern, your results come out reversed. You must either reverse the input list or the result.Here's my reference solution, which took me half a minute to write. :-) I'm hoping you can use it to fine-tune your existing version. (I'm comfortable with posting it because I'm certain your markers won't let you use cut, and if you can work out how to make my version acceptable to your markers, then you've already won.)(define (apply-all fns . args) (map (cut apply &lt;&gt; args) fns)) 644 is fine too. It just can't be group and/or other writable. Here's my solution---it's seriously cheap in that it reuses the built-in map, using the decorator pattern. (I know, Scheme programs using design patterns? :-O)(define (deep-map f l) (define (deep x) (cond ((null? x) x) ((pair? x) (map deep x)) (else (f x)))) (map deep l))This can be "simplified" even further by using a named let:(define (deep-map f l) (let deep ((x l)) (cond ((null? x) x) ((pair? x) (map deep x)) (else (f x)))))(The two snippets of code are not identical, but for this question, both will work the same if given a list as input.)The null? and pair? checks (both O(1)) are used in order to avoid using list? (which is O(n)). Specify the fully-qualified name of the external B. If B is in package com.acme, then say com.acme.B name = new com.acme.B();. Here's my solution (since the OP's already posted theirs):(define (count-zeroes lst) (let loop ((lst lst) (count 0)) (cond ((null? lst) count) ((zero? (car lst)) (loop (cdr lst) (+ count 1))) (else (loop (cdr lst) count)))))Of course, no treatment of this subject can be considered complete without talking about fold, which is usually used to "summarise" a list down to a single object (like we're doing for this question):(define (count-zeroes lst) (fold (lambda (elem count) (if (zero? elem) (+ count 1) count)) 0 lst)) In the working version, because the macro was already defined, the system will expand the macro, so you effectively get:(define bar (lambda (x) (* 4 x)))However, in the non-working version, the macro wasn't yet defined, and it doesn't get expanded. At run-time, the bar function expects to find the foo procedure, which doesn't exist. Here's an iterative answer for this problem using fold:(define (uniq lst) (fold (lambda (elem result) (if (and (pair? result) (equal? elem (car result))) result (cons elem result))) '() (reverse lst)))(In future, any time you're trying to convert a list to something, consider using fold, and any time you're trying to convert something to a list, consider using unfold. They're very powerful functions!) Your question wasn't very specific about what's being counted. I will presume you want to create some sort of frequency table of the elements. There are several ways to go about this. (If you're using Racket, scroll down to the bottom for my preferred solution.)Portable, pure-functional, but verbose and slowThis approach uses an association list (alist) to hold the elements and their counts. For each item in the incoming list, it looks up the item in the alist, and increments the value of it exists, or initialises it to 1 if it doesn't.(define (bagify lst) (define (exclude alist key) (fold (lambda (ass result) (if (equal? (car ass) key) result (cons ass result))) '() alist)) (fold (lambda (key bag) (cond ((assoc key bag) =&gt; (lambda (old) (let ((new (cons key (+ (cdr old) 1)))) (cons new (exclude bag key))))) (else (let ((new (cons key 1))) (cons new bag))))) '() lst))The incrementing is the interesting part. In order to be pure-functional, we can't actually change any element of the alist, but instead have to exclude the association being changed, then add that association (with the new value) to the result. For example, if you had the following alist:((foo . 1) (bar . 2) (baz . 2))and wanted to add 1 to baz's value, you create a new alist that excludes baz:((foo . 1) (bar . 2))then add baz's new value back on:((baz . 3) (foo . 1) (bar . 2))The second step is what the exclude function does, and is probably the most complicated part of the function.Portable, succinct, fast, but non-functionalA much more straightforward way is to use a hash table (from SRFI 69), then update it piecemeal for each element of the list. Since we're updating the hash table directly, it's not pure-functional.(define (bagify lst) (let ((ht (make-hash-table))) (define (process key) (hash-table-update/default! ht key (lambda (x) (+ x 1)) 0)) (for-each process lst) (hash-table-&gt;alist ht)))Pure-functional, succinct, fast, but non-portableThis approach uses Racket-specific hash tables (which are different from SRFI 69's ones), which do support a pure-functional workflow. As another benefit, this version is also the most succinct of the three.(define (bagify lst) (foldl (lambda (key ht) (hash-update ht key add1 0)) #hash() lst))You can even use a for comprehension for this:(define (bagify lst) (for/fold ((ht #hash())) ((key (in-list lst))) (hash-update ht key add1 0)))This is more a sign of the shortcomings of the portable SRFI 69 hashing library, than any particular failing of Scheme for doing pure-functional tasks. With the right library, this task can be implemented easily and functionally. Here's my solution: first, grab bagify (any version will do). Then:(define (remove-singletons lst) (define (singleton? ass) (&lt; (cdr ass) 2)) (map car (remove singleton? (bagify lst))))remove is from SRFI 1. If you're using Racket, run (require srfi/1) first. Or, use this simple definition:(define remove #f) ; Only needed in Racket's REPL(define (remove pred lst) (cond ((null? lst) lst) ((pred (car lst)) (remove pred (cdr lst))) (else (cons (car lst) (remove pred (cdr lst)))))) Valgrind is the standard open-source memory debugging tool. :-) void. Like so:typedef struct THESTRUCT { void* objectPtr;} THESTRUCT;void* is a "generic" pointer type. (You have to cast it to some other type to use it. Since there is no type to cast it to at the C end, it's effectively an opaque pointer.)Another approach is to make a forward declaration for your C++ type, without defining it (since that's impossible to do at the C end). So if your C++ type is called foo, you could do:struct foo;typedef struct THESTRUCT { struct foo* objectPtr;} THESTRUCT; The inode number is assigned by the system. User code cannot specify it when creating a file. No. C# is not C++; the value isn't actually copied in the code snippet you pasted (unless MyObject is a value type). Oh, you want to compute the run lengths! Guess what! Another problem for fold! :-P(define (run-lengths lst) (fold-right (lambda (elem result) (if (and (pair? result) (equal? elem (caar result))) (cons (cons elem (+ (cdar result) 1)) (cdr result)) (cons (cons elem 1) result))) '() lst))(My version returns the run lengths as dotted pairs, rather than lists of length 2.) Since you're using Racket, you can use foldr instead of fold-right; that way, you won't need to load SRFI 1. That's because floating point numbers cannot represent decimal quantities exactly.The floating-point number format your computer uses is binary. That means it can exactly represent 1/2, 1/4, 1/8, 1/16, ..., and combinations thereof. So, you can say 0.5, or 0.25, or even 0.75 (0.5 + 0.25) and those will be exact in floating point. But, 0.01 cannot be created with combinations of those fractions; therefore, its value is approximate. Similar story with the other numbers you tested.This is an inherent limitation with using binary floating point. It's not "super odd"; this is Floating Point 101. :-) We use DB2 LUW at work (though, I speak only for me, not for work). I like that:It's fast, and has neat tools that help you make your queries faster.It has facilities for high availability (HADR).It has XML support, which may or may not be useful to you (but we don't currently use that at work).Its procedural language is easy to use (if rather lacking in features, especially for versions prior to 9.7).It has excellent documentation.(The decision to use DB2 at work was made long before I started there, so I can't comment on work's rationale for choosing it.) Integer.toBinaryString works for negatives too. :-) For example, Integer.toBinaryString(-2) returns 11111111111111111111111111111110.If you take the rightmost 12 characters, you have the bottom 12 bits, as required. By using divide and conquer, of course!Drop the bottom half of your .emacs. See if the speed improves. (If so, the culprit is within the bottom half; otherwise it's in the top half.) Restore the working half. Chop off half of the broken half, and repeat the process until you have isolated the problem. You can iterate over the same list multiple times concurrently, as long as it's not being modified during any of the iterations. For example:List&lt;Person&gt; people = ...;for (Person a : people) { for (Person b : people) a.getsDrunkAndRegretsHookingUpWith(b);}As long as the getsDrunkAndRegretsHookingUpWith method doesn't change the people list, this is all fine. You can call static functions within the initialisers, and those functions can contain whatever logic you please. fold is from SRFI 1. Many functions have good documentation if you know where it "comes from".Also, since you're using Racket (as mentioned in your previous questions), you should check out the Racket documentation. It has a very nice search facility. (Also, you might like to know about Racket's foldl, which is identical to SRFI 1's fold.) Code objects are described here: Code objects represent byte-compiled executable Python code, or bytecode. The difference between a code object and a function object is that the function object contains an explicit reference to the function’s globals (the module in which it was defined), while a code object contains no context; also the default argument values are stored in the function object, not in the code object (because they represent values calculated at run-time). Unlike function objects, code objects are immutable and contain no references (directly or indirectly) to mutable objects. let always reinitialises variables; it's evident, since you must always provide new binding values. e.g.,(let ((a 42)) ...)Inside the ..., a starts out as 42, always. It doesn't "retain" values from previous invocations.By the way, I think you meant to write (or result (equal? elem x)) rather than (if (eq? elem x) (or result #t) result). :-)(or result (equal? elem x)) translates to the following C++ code:return result || elem == x;(assuming that the == operator has been overloaded to perform what equal? does, of course.) The benefit of this is that if result is already true, no further comparisons are performed. case does matching using eqv?. That means that anything other than symbols, numbers, characters, booleans, or the empty list will never match.In your case, you were trying to match (non-empty) lists. That will never work. :-( (Neither will matching strings or vectors work.) Consider using Arrays.deepEquals. :-) Sure. :-) But first, please note that the function says aantalCijfers(n/100) + 2, not aantalCijfers(n/100 + 2). I have a feeling that you may have misread that.The base cases are 1 or 2 digits. For anything beyond that, divide by 100 (thus stripping away two digits), recalculate, and add 2 to the result.Using 5000 as your example:digits(5000)digits(50) + 22 + 24You can extend that even further. Let's, say, use 1000000.digits(1000000)digits(10000) + 2digits(100) + 2 + 2digits(1) + 2 + 2 + 21 + 2 + 2 + 27 An SSL server's certificate has to be "vouched for" by a certificate authority (CA). Your browser (or other program) contains a list of CAs it trusts. If you're using a site that is not certified by one of the standard CAs, then you'd have to import its CA in order for the verification to succeed.No legitimate site (especially for online banking) should require you to use an "alternative" CA. Only do this for sites where you're not sending super-sensitive data. You need to install either the openjdk-7-jre or oracle-java7-jre package.sudo apt-get install openjdk-7-jreNote that openjdk-7-jre is easier to install, because it's available via the standard Ubuntu repository, whereas you have to build oracle-java7-jre yourself using java-package. Normally class names should start with a capital letter. So you should rename your main class to Main. If it's inside the lab7 package, run this:java lab7.MainThis should be run in the directory that contains the lab7 directory. So if you're in the lab7 directory itself, go up one level first. This conversion happens in the call to printf, because for variadic functions, all the arguments passed in as part of the ... get widened to int (or double, if the argument is a float) first. Well, I can't speak about Apple's compilers, but gcc definitely treats memcpy as a builtin. In gzip, the redundancy is restricted to a specific window size (by default 32k if I remember right). That means that after you process uncompressed data past that window, you can start writing compressed output.You could call that "suboptimal", but the benefits provided, such as the ability to stream, and possibly error recovery (if there are synchronisation marks between windows; not sure how gzip works here), are worth it. Extending Alexander's answer (which is correct), if you genuinely want to write binary data to standard output, here's how you do it:std::cout.write(&amp;m_buff[0], m_buff.size()); Here's my translation:public abstract class Whatever { public abstract int mymethod(int one, int two); public abstract int myothermethod(int one, int two, int three);}public class However extends Whatever { @Override public int mymethod(int one, int two) { int answer = one * two; return answer + 3; } @Override public int myothermethod(int one, int two, int three) { return ...; }}I also like Yanick's answer about using interfaces; that's a better approach. I'm keeping my answer because of the use of @Override, which is useful for Java code. It's legal Java. It looks clunky to me, and I'd probably do it differently, but it's valid and works.Here's how I'd do it:public InetAddress getServerAddress() { for (String address : new String[] {serverSettings.getString("serverIp"), DEFAULT_IP}) { try { return InetAddress.getByName(address); } catch (UnknownHostException e) { Log.e("ERROR:", "Cannot resolve " + address); } } Log.e("ERROR:", "Total fail, exiting"); finish(); return null; // not reached} You should return a std::vector&lt;char&gt;. That way, when the caller finishes using the vector, its contents are freed automatically.std::vector&lt;char&gt; getLastGlslError(){ int size; glShaderiv(hShaderId, GL_INFO_LOG_LENGTH, &amp;size); std::vector&lt;char&gt; buffer(size); // fill in the buffer using &amp;buffer[0] as the address return buffer;} If you can arrange for GetFoos to create the return array using new T[], then you win. If you used new Foo[], then the array's type is fixed at that, regardless of the types of the objects it actually holds. I personally use EXIT_FAILURE, since it's not a normal usage of your program. I don't think it's doable using the SuperProxy approach you linked to.In this case, A.method(:a) is a singleton method. Singleton methods can only be bound to the object it was created with. In particular, it cannot be rebound to B.Here's the first non-working approach I tried:class B &lt; A def self.b A.method(:a).unbind.bind(self).call endendSecond non-working approach:class B &lt; A class &lt;&lt; self define_method :b, A.method(:a) endendBoth generate a "TypeError: singleton method bound for a different object" exception. First, you need to know about A440. This is the "standard" pitch to tune everything else against.Double the frequency to raise an octave; halve the frequency to drop an octave. It's clear from this that the tones are logarithmic relative to the frequencies.There are multiple systems for deciding where on the logarithmic line the rest of the notes fall. A straightforward approach is to divide the semitones geometrically along the logarithmic scale (which is the approach xofon's answer uses), but there may be better ways. &lt;strong&gt; means strong emphasis. The idea is that when using a different medium (e.g., text-to-speech), you can express strong emphasis through changing the tone.&lt;b&gt; means bold. That makes no sense outside of screen display, and more importantly, doesn't explain why something is bold. This defines an abstract class called A, with three type parameters:P, which must be of type B (with any type arguments) or any type derived from itInput, of any typeOutput, of any typeOf interest is the first type parameter. In C++, for a type-based template parameter, you can supply any type; in Java, you have the option to constrain the type by what class and/or interfaces such a type must also extend/implement. declare -x FOO is the same as export FOO. It "exports" the FOO variable as an environment variable, so that programs you run from that shell session would see it. When you fork, the return value is 0 in the child process, and the child's process ID (pid) in the parent process.You can then call kill with that pid to see if it's still running, or request a shutdown. To check if the process is running, use 0 as the signal, then check the return value (0 == running; -1 == not running). To request a shutdown, use SIGTERM as the signal. Of course. Such a thing is called a "virtual framebuffer". Jon Skeet's answer is correct. Another (supposedly faster, according to its documentation) approach is:Set&lt;String&gt; jKeywords = new HashSet&lt;String&gt;();Collections.addAll(jKeywords, aryKeywords);Or to specify them inline (to mirror Jon's answer):Collections.addAll(jKeywords, "abstract", "asset", "boolean", /* ... */); Guava provides map (but it's called transform instead, and is in utility classes like Lists and Collections2). It doesn't provide fold/reduce, however.In any case, the syntax for using transform feels really clunky compared to using map in Scheme. It's a bit like trying to write with your left hand, if you're right-handed. But, this is Java; what do you expect. :-P eval cannot access lexical variables, such as those defined using let.Instead, you have to create an environment, and populate it with the variables you want to make available. For example:(define env (null-environment 5))(eval '(define a #t) env)(wr "a is ..." (eval '(if a "true" "false") env)) Your m_map1 is a local variable, and you're trying to store a pointer to that in your map. This results in a dangling pointer when the block containing that variable exits.You have two ways to solve this:My preferred way is to store the multimap in the map directly (i.e., not using a pointer). As a bonus, this simplifies your code a lot:typedef multimap&lt;int, int&gt; mm;typedef map&lt;int, mm&gt; v_map;v_map map1;map1[23].insert(make_pair(1, 2));That's it!Your other option is to use new to create a persistent copy of the multimap. In this case, your map should hold a shared_ptr&lt;multimap&lt;...&gt; &gt; so that you don't have to deallocate the multimap manually. Is your file written using IOStreams? If so, just do this:stream &lt;&lt; number;If not, and you really need a string, you can use an ostringstream for this. Boost's lexical_cast wraps the string streams in an easy-to-use fashion. No, since all byte values are valid characters in a string. You must keep track of the count of valid bytes, and use the byte[], int, int version of the constructor.If you don't want to keep track of the count manually (perhaps because you are building the byte array piecemeal), consider using a ByteArrayOutputStream. Actually, HashSet is a much better approach than ArrayList. Your code runs in O(n) for HashSet, and O(n²) for ArrayList.But, one thing to keep in mind: elements in HashSet are not kept in any particular order. If you want to keep order and have fast lookups, use LinkedHashSet. (Everything has a cost, though; in this case, LinkedHashSet uses more memory than HashSet.) You should read the comments that the electors have posted with their votes on R6RS ratification. Some of them are very telling.Obviously, reasonable people can disagree about some of them. Try to read them with an open mind. :-) require 'uri'URI.escape str, /[@&amp;]/Obviously, you can widen the regex with more characters you want to escape. Or, if you want to do a whitelisting approach, you can do, say,URI.escape str, /[^-\w]/ Java doesn't have regions, unlike C#. So there is no user-defined means to define regions that you can collapse. It allows you to write macros that simply transform one tree of lists to another. Simple (Scheme) example:(define-syntax and (syntax-rules () ((and) #t) ((and thing) thing) ((and thing rest ...) (if thing (and rest ...) #f))))Notice how the macro invocations are simply matched to the (and), (and thing), and (and thing rest ...) clauses (depending on the arity of the invocation), and handled appropriately.With other languages, macros would have to deal with some kind of internal AST of the code being transformed---there wouldn't otherwise be an easy way to "see" your code in a programmatic format---and that would increase the friction of writing macros.In Lisp programs, macros are generally used pretty frequently, precisely because of the low friction of writing them. If you're trying to hash passwords, look into scrypt. Don't use anything else, and definitely don't roll your own system. Well, you're not really "printing" anything, just returning the last expression (`(bye ,exp) in this case). If you want to print them, use display:(cond ((number? 2) (display `(hi ,var)) (display `(bye ,exp)))) It's stored in a file's metadata, which you can retrieve with stat on POSIX systems. The metadata also includes, for example, when the file was last modified or accessed. I've never known any licensing fees required for deploying C#, Java, C++, or most any other language commercially. For the languages you've named, at least, you should be totally fine. Okay, here goes:It takes the functions given, reverses it (in your example, it becomes (#'sqrt #'round #'list)), then sticks the first item into fn1, and the rest into rest. We have: fn1 = #'sqrt, and rest = (#'round #'list).Then it performs a fold, using (apply sqrt args) (where args are the values given to the resulting lambda) as the initial value, and with each iteration grabbing the next function from rest to call.For the first iteration you end up with (round (apply sqrt args)), and the second iteration you end up with (list (round (apply sqrt args))).Interestingly, only the initial function (sqrt in your case) is allowed to take multiple arguments. The rest of the functions are called with single arguments only, even if any particular function in the chain does a multiple-value return. cat *.csv &gt; mega-merged.csv2mv mega-merged.csv2 mega-merged.csv(The use of the .csv2 is so that the *.csv doesn't catch it.)Re Joce's comment, if you have headers, you can trim off all the headers (on GNU/Linux or any other platform with GNU tools) using something like:tail -qn +2 *.csv &gt; mega-merged.csv2 In general, there is no easy way to tell the size of the gzipped data, other than just going through all the blocks.gzip is a stream compression format, meaning that all the compressed data is written in a single pass. There is no way to stash the compressed size anywhere---it can't be in the header, since that would require more than one pass, and it's useless to have it at the trailer, since if you can locate the trailer, then you already know the compressed size. I don't know anything about OAuth, but you can use javax.crypto.Mac to generate HMAC-SHA1 value (use HmacSHA1 as the algorithm name):Mac hmac = Mac.getInstance("HmacSHA1"); What's inside a $'' expression has to be a literal. You can't expand other variables inside it.But you can do this:echo "${1//\\n/$'\n'}"Jan Hudec has an even better answer:echo -e "$1" By default, unique uniquifies on the object's objectid, which is suitable for actual traced objects, but for strings it returns null. Thus, only the last string is kept (since all the strings have non-unique objectid values).You have two options:Uniquify on the traced objects, rather than their names:map(unique(filter(map(referees(cl), classof), "it.name != ...")), "it.name")Specify the "function" to uniquify with, so that it works for strings:unique(['a', 'b', 'c', 'a'], 'it')This will cause the strings themselves to be uniquified. I believe in using existing quality libraries where available. So, this answer uses SRFI 1 (if you're using Racket, load it using (require srfi/1)):(define (list-range lst start end) (take (drop lst start) (- end start)))Example:(list-range (iota 12 1) 0 4) ; =&gt; (1 2 3 4) Marks don't nest.If you want to reread the stream several times, you might need to copy (a portion of) the stream into a byte array, and make a ByteArrayInputStream of it. You still can't have multiple marks, but you can have multiple ByteArrayInputStreams. (Or just forget about ByteArrayInputStream and pick bytes off the array directly.) You're passing the wrong function to map. Instead of passing ((car fun-list) lst), try passing just (car fun-list). Every time you call WriteToFile.write, it reopens the file for writing, truncating the file's original contents. You should open the file once, in the constructor (and store the PrintWriter in a field), and add a close method that calls close for the PrintWriter.On the calling side, do this:WriteToFile writer = new WriteToFile(filename);try { // writer.write(...);} finally { writer.close();}By having the close call in a finally block, you ensure the file is closed even if an exception causes the function to quit early. Actually, as far as I know, AJP is always uncompressed. It's assumed that your web and application servers are "close" enough (in terms of network topology) to each other that compression is not useful, and just slows things down from the extra CPU processing.If you're using HTTP between Apache and Jetty, then you can configure compression, yes, though I've not use Jetty and can't tell you how to configure that. You're doing something wrong.C++ compilers are smart enough to optimise your loop out, if it does nothing. Actually, a decent JVM (try using java -server) will do that too. ;-) I presume you meant Integer.toHexString, not Ints.toHexString. The latter is not part of java.lang and the compiler would have no way to know anything about it.In theory, the compiler could translate calls of (a + b).toHexString() to Integer.toHexString(a + b), if the Java language specifies such a translation. (For example, auto-boxing of an int a to an Integer is specified to be Integer.valueOf(a).)I guess the Java language maintainers decided that that is too "magical" for Java programmers---in all versions of Java, primitive types do not have methods or fields. Java, in general, is designed to avoid syntactic sugar---that is why it's generally more verbose than most other languages. Sure. Use a BufferedOutputStream. :-PThe setTcpNoDelay changes how the OS sends packets, not how Java sends packets. The only way to change the latter is to buffer your output, as I suggested above.BTW, this doesn't affect how many packets your data is really split up into. Again, that is up to the OS, as well as the window specified by the receiving end. So you can't use packets to delimit data. Iterators are one-traversal-only. Some iterator types are cloneable, and you might be able to clone it before traversing, but this isn't the general case.You should make your function take an Iterable instead, if you can achieve that at all. $(echo "cd /foo/bar")That demonstrates how you might do such a thing with a POSIX shell. It's not portable with the Windows shell, of course. In this case, since Stack::push is non-static, head is a shorthand for this-&gt;head. So the head = newNode is the same as:this-&gt;head = newNode; unsigned int lulz(unsigned char const* nybbles, size_t length){ unsigned int result(0); while (length--) { result = result * 100 + (*nybbles &gt;&gt; 4) * 10 + (*nybbles &amp; 15); ++nybbles; } return result;}length here specifies the number of bytes in the input, so for the example given by the OP, nybbles would be {0x97, 0x65} and length would be 2. You just want to remove all lines that start with HPL_? That's easy!perl -pi -e 's/^HPL_.*//s' myfile.txtYes, it really is just a one-liner. :-) Java has an object serialisation system, which sounds like a good fit for what you want to do. Quick summary:Have your class implement java.io.Serializable, and add a private static final long serialVersionUID field (use any value you like---usually I just start with 1).Mark all fields you don't want to serialise as transient; all non-transient fields will be serialised.Ensure that all fields you want to serialise are either primitive or are also serialisable types---all non-serialisable types must be transient.Change the serialVersionUID whenever you make changes to the fields that get serialised. Usually I just bump the value by 1.For custom serialisation, you can implement the readObject and writeObject methods.For seriously custom serialisation, there's also java.io.Externalizable.To actually serialise or deserialise your objects, use the DataOutputStream and DataInputStream classes. And yes, you can wrap the streams with compression and/or encryption. :-) ArrayDeque is new with Java 6, which is why a lot of code (especially projects that try to be compatible with earlier Java versions) don't use it.It's "better" in some cases because you're not allocating a node for each item to insert; instead all elements are stored in a giant array, which is resized if it gets full. You can't serialise a class that doesn't implement Serializable, but you can wrap it in a class that does. To do this, you should implement readObject and writeObject on your wrapper class so you can serialise its objects in a custom way.First, make your non-serialisable field transient.In writeObject, first call defaultWriteObject on the stream to store all the non-transient fields, then call other methods to serialise the individual properties of your non-serialisable object.In readObject, first call defaultReadObject on the stream to read back all the non-transient fields, then call other methods (corresponding to the ones you added to writeObject) to deserialise your non-serialisable object.I hope this makes sense. :-) On GNU libc, exit is declared with __attribute__((__noreturn__)), which tells gcc that the function does not return. For something even more embeddable than Guile, there's also Chibi.(I &lt;3 Guile BTW, so this answer isn't trying to take away from that---it just offers another option.) You can use QFile::resize to resize the file to the size you want. I bet it uses truncate behind the scenes (see Andrew's post). You can't use popen to use two-way pipes.In fact, some OSs don't support two-way pipes, in which case a socket-pair (socketpair) is the only way to do it. C++ template functions are instantiated at point of use. i.e., it will paste in the types you specify when you specify them, and not sooner. At that point, if the type you specify does not have an Index member function, the compilation will fail. Normally, you should invoke derived-class functionality using virtual functions. However, if you really must test for a type, do this:DataRowChangeEventArgs* foo = dynamic_cast&lt;DataRowChangeEventArgs*&gt;(arg);if (foo) { // is a DataRowChangeEventArgs}Of course, you can also roll that into a single line:if (DataRowChangeEventArgs* foo = dynamic_cast&lt;DataRowChangeEventArgs*&gt;(arg)) { // is a DataRowChangeEventArgs}(If you've used C# at all, a dynamic_cast on a pointer is pretty much like the as operator in C#---it returns a pointer to the target type if appropriate, otherwise null.) You can simply use SRFI 1's lset-difference:(lset-difference = '(1 2 3 4 5) '(3 4 5 5 6)); =&gt; (1 2)The =, in my example, is the comparison function. If your lists contain strings, say, instead of numbers, then you should use string=? in place of =. Intel sells its own compilers which are supposed to generate very performant code...at least on Intel CPUs.The nice thing about ICC compared to GCC is that ICC uses EDG's C++ frontend, which means that it has better support for some advanced C++ features than GCC. In C++, volatile is not used for multithreading (at least as intended in the likes of Java 5, which provides a memory barrier or the like). In C++0x, there's atomic variables, and that comes closest to Java 5-style volatile. You could do:(define mcaar (compose mcar mcar))(define mcadr (compose mcar mcdr));; ...(define mcddddr (compose mcdr mcdr mcdr mcdr))But there is no real getting around the repetition. Even in the Racket source (look in racket/src/list.c), the repetition is there, albeit prettified a little with C macros. Re how to convert your characters to bytes, you can just cast directly:byte[] b = new byte[] {(byte) 0xe2, (byte) 0x82, (byte) 0xac};Or, as a shorthand:byte[] b = {(byte) 0xe2, (byte) 0x82, (byte) 0xac}; I use objdump -d. :-) Does that not work for you? If you look at that page you linked to, the type parameters are actually named Params, Progress, and Result. That's how the class reference those type parameters. In their example, then:Params is bound to the type URLProgress is bound to the type IntegerResult is bound to the type LongSee the documentation on what each of those types is used for. Joining a thread does the same thing in Boost as it does in Java: it waits for the thread to finish running.Plus, if I remember correctly, Boost's threads run upon construction. You don't start them explicitly. Try this:private CPTable(JTable table) { super(table); this.table = table;}public CPTable(Object[] headers, Object[][] data) { this(new JTable(data, headers));}You cannot reassign this, but you can cause the correct superclass constructor to be called by using super (which must be the first statement in your constructor).The this statement is called "constructor delegation"---it chains through to the other constructor so that you can pass the table to the superclass as well as assign it to your table field. I'd do it this way:find . -iname 'thumbs.db' -exec rm -rfv {} +This way, it still works even if your directories contain whitespace in their names. If you're using Guava, you can use Collections2.filter:Collection&lt;User&gt; males = Collections2.filter(users, new Predicate&lt;User&gt;() { @Override public boolean apply(User user) { return user.getSex().equals("Male"); }});And with Java 8, you can do even better:Collection&lt;User&gt; males = Collections2.filter(users, user -&gt; user.getSex().equals("Male")); As the description says, it's only for computers that use EBCDIC. If you've never heard of EBCDIC, that won't apply to you. i.e., don't bother using --ascii.If you're curious, EBCDIC is a family of character encodings that are totally incompatible with ASCII, used on some IBM systems. supervise uses Unix-domain sockets to receive requests. The advantage of using Unix-domain sockets is that access to it can be controlled via the usual filesystem permissions---in this case, it allows only root to access the socket, hence the reason why you normally must run svc as root.However, once you go over the network, you start having to think about network authentication (unless you want any Tom, Dick, and Harry to start and stop your services). If you can solve that, the rest of it is easy:Write a service that runs over tcpserver, that can invoke svc on the remote machine for you. If the access control provided by tcpserver is sufficient for you, then well and good; otherwise your service must handle what's left.To be secure, don't run this service as root (i.e., always specify -u on the tcpserver command line). Instead, just change the (group) ownership of your supervise sockets so that they are readable and writeable by the user that your service runs as.Write a shell script on the client side that wraps around svc. It checks for the "remote server" syntax and if used, it would connect to your remote service (and otherwise just invoke svc as usual). What arguments does BHTimerGUI's constructor take? You might need to add this line to the top of CountDownTimerGUI's constructor:super(control, disp); Your Main constructor should sit outside of the main method. Like so:public class Main extends JFrame { public Main() { super("title bar"); } /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub //JLabel testLabel1 = new JLabel(); }} Here are some functions for translating between unsigned long long and mpz_t. Note that mpz2ull will smash your stack if the number is too big to fit into an unsigned long long:unsigned long long mpz2ull(mpz_t z){ unsigned long long result = 0; mpz_export(&amp;result, 0, -1, sizeof result, 0, 0, z); return result;}void ull2mpz(mpz_t z, unsigned long long ull){ mpz_import(z, 1, -1, sizeof ull, 0, 0, &amp;ull);} All methods in Kernel will be available to all objects of class Object or any class derived from Object. You can use Kernel.instance_methods to list them. str = str.replaceAll("\\s*,\\s*", ","); The else is for when the block completes without an exception thrown. The ensure is run whether the block completes successfully or not. Example:begin puts "Hello, world!"rescue puts "rescue"else puts "else"ensure puts "ensure"endThis will print Hello, world!, then else, then ensure. Hash tables (JSON "objects") do not maintain key order. This is by design. If the server provides a Content-Length header field, then that's easy. If it doesn't, then you're out of luck.Reasonable server implementations provide Content-Length when the content is static and has a known size. If the content is dynamically generated, then it's impossible to know the length a priori, at least without making two passes through the data. Don't use ArrayList for doing contains searching. That has O(n) performance. Instead, use a HashSet, which has O(1) lookup.However, even better is to not query all the rows in the first place. Just make your query:SELECT COUNT(*) FROM users WHERE login_id = ?then seeing if the result is 0 or not. No, it's not safe; you'll cause a buffer overflow. The reason is, memcpy has no way to know the size of your target buffer, other than the size you pass in the third argument. Yes. Use setvbuf with _IONBF:setvbuf(stdout, 0, _IONBF, 0); From the git-add manpage: -f, --force Allow adding otherwise ignored files. Maybe you meant to do something like:SELECT m.Timestamp FROM Measurements mWHERE dma.DeviceId = @DeviceID AND dma.AssociationStart = @Start AND dma.AssociationEnd = @End AND m.Timestamp BETWEEN @Start AND COALESCE(@End, SYSDATETIMEOFFSET())However, the fact that dma.AssociationEnd = @End succeeds already implies that neither dma.AssociationEnd nor @End is null. So the COALESCE (and the whole CASE in the original question) is a waste of time.(Of course, this only makes sense within a larger SELECT that has dma.) There is no direct concept of iteration ("next") with strings, in Scheme. That only applies to lists. So instead you have to iterate with indices:(define (string&lt;? lhs rhs) (let* ((lhslen (string-length lhs)) (rhslen (string-length rhs)) (minlen (min lhslen rhslen))) (let loop ((i 0)) (if (= i minlen) (&lt; lhslen rhslen) (let ((lhschar (string-ref lhs i)) (rhschar (string-ref rhs i))) (cond ((char&lt;? lhschar rhschar) #t) ((char&lt;? rhschar lhschar) #f) (else (loop (+ i 1))))))))) Good encapsulation says that you should expose as little implementation detail as possible. In your case, that means favouring your last option and not exposing B, C, nor D. That way, any changes to B, C, and D can be insulated from A's users. In addition to what littleadv's post says, your buffers are one character too short (it didn't leave any space for the null-terminator). Thus, your strcpy causes a buffer overflow. The X x2 = ... invokes the copy constructor (even if the compiler optimises it out later). Thus, it must still be accessible. You're so very close.vi "$(find . -name '*.txt' -exec ls -t {} + | head -1)" Condition variables are for synchronising on a condition that you are expecting to change. Locking ensures that:The change can be reliably observed on the waiting threadsThe item under change isn't somehow changed by another thread at the same time one of the now-woken-up threads is observing itA condition system that doesn't use mutexes would be much more brittle. On your PHP side, use single-quotes around the key so that the $ character is not treated as a variable reference. i.e.,hash_hmac("sha1", "helloworld", 'PRIE7$oG2uS-Yf17kEnUEpi5hvW/#AFo')Otherwise, the key you really get is PRIE7-Yf17kEnUEpi5hvW/#AFo (assuming the variable $oG2uS is not defined). Not that I know of. But if you match \s+\w="\d", then you can call find multiple times and process each match on its own. You use any of eq?, eqv?, or equal?.All three can be used with any objects without error (unlike =, which can only be used with numbers). However, the result will differ depending on which types you pass in. But if you know you're comparing symbols, all of them will have the same result.If you have done any Java programming, eqv? is like ==, and equal? is like .equals(). In simple terms, eqv? does an identity comparison, and equal? does a value comparison.(And eq? does a straight-up pointer comparison. For some implementations, it may be faster than eqv?, with the understanding that it sometimes returns false for equal numbers or characters. For other implementations, it's exactly identical to eqv?. Most of the time, for robustness, you should stick to using eqv? for doing identity comparisons, and forget that eq? exists.) Scheme's rationals have bignums backing them. Most languages don't have built-in bignums.In my opinion, it's pointless to have built-in rationals without built-in bignums, because without bignums, you start to lose precision after a certain point, and you may as well be upfront about the lossiness by using floating-point. Of course it's not the only way. But you may have to use pointers:void pick_and_handle() { unique_ptr&lt;handler&gt; http_handler; if (connection-&gt;http_header.uri_str != "/") http_handler.reset(new http_photoserver(connection)); else http_handler.reset(new http_status(connection)); http_handler-&gt;handle();}(Instead of unique_ptr, you can use boost::scoped_ptr, shared_ptr, and auto_ptr also. But in this case, unique_ptr and boost::scoped_ptr are most appropriate.) You are passing in string literals, and your function expects Strings. Does your String class have a (non-explicit) constructor that can be called with a char const*? If not, there's your problem. I believe in using standard library facilities. Thus, my solution uses std::set. :-)int largest_num_smaller_than(std::set&lt;int&gt; const&amp; set, int num){ std::set&lt;int&gt;::const_iterator lb(set.lower_bound(num)); return lb == set.begin() ? -1 : *--lb;} To expand on my comment on Ernest's correct answer, here's how I might implement the remove-and-put solution:for (String key : new ArrayList&lt;String&gt;(map.keySet())) { String upper = key.toUpperCase(); for (String value : map.remove(key)) map.add(upper, value);} Yes, Hash#keys returns the hash's keys as a new array, i.e., the hash and the array returned by Hash#keys are completely independent of each other:a = {}b = a.keysc = a.keysb &lt;&lt; :fooa # still {}b # [:foo]c # still []a[:bar] = :baza # {:bar =&gt; :baz}b # still [:foo]c # still [] An auto is a type inference based on the value you're initialising it to. A parameter isn't initialised to anything at the place it appears in the code. :foo is a symbol named "foo". Symbols have the distinct feature that any two symbols named the same will be identical:"foo".equal? "foo" # false:foo.equal? :foo # trueThis makes comparing two symbols really fast (since only a pointer comparison is involved, as opposed to comparing all the characters like you would in a string), plus you won't have a zillion copies of the same symbol floating about.Also, unlike strings, symbols are immutable. In this case, x[0] is define, x[1] is the variable name, and x[2] is the expression. So, in Python, _, var, exp = x is a "destructuring assignment", which destructures the array x into its constituent elements, and assigns them to the variables on the left-hand side. Simply doing grep "var/corefiles" $VFSTAB_LOC (without the for or echo) will do exactly what you say you're wanting to do. Use this:Pattern.compile("((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}((:[0-9A-Fa-f]{1,4}){1,2}|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)|(([0-9A-Fa-f]{1,4}:){3}|(((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|((:[0-9A-Fa-f]{1,4}){1,7}|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:)))")Summary of changes:All backslashes are doubled.There is a typo of [1-9} in your pattern. That is fixed.Your pattern is also missing a final closing parenthesis. The || and &amp;&amp; operators are short-circuiting.true || willNeverExecute();false &amp;&amp; willNeverExecute(); printf("%.2f", 2.3678); /* prints 2.37 */ You need to make your AcceptLoop(void*) a static function.Example:class ServerManager { // ... static void* AcceptLoop(void*); void* AcceptLoop(); // Implement this yourself};void* ServerManager::AcceptLoop(void* delegate){ return static_cast&lt;ServerManager*&gt;(delegate)-&gt;AcceptLoop();} Firefox uses a number of GUI toolkits, including the native Windows one, as well as GTK+ for X platforms. Sadly, there is no official support for Qt. All that does is to require that the elements, of type T, be comparable with other objects of the same type (Comparable&lt;T&gt;). The reason that that's used instead of Comparable&lt;?&gt; is that the latter simply says comparable with some type.But since the priority queue holds objects of type T only, and thus compares other objects of type T only, it's fair to require that T be comparable with other objects of the same type. This way works, but isn't 100% reliable:${0%/*}The way that works is that it reads $0 (the program name), and strips off everything from the final slash onwards. It's not reliable because if your script is invoked via a symlink, you will get the directory containing the symlink, not the directory containing the real script.Also, it's possible to pass in a "fake" value for $0, for example by using exec -a. So even if you aren't using symlinks, it's still not a 100% solution. In fact, such a solution doesn't exist. Sure. You can do this:for (Object thing : unitMap.values()) { // use "thing" here}If you need the keys too, you can either get just the keys:for (String key : unitMap.keySet()) { // use "key" here}or both the keys and values together:for (Map.Entry&lt;String, Object&gt; entry : unitMap.entrySet()) { // use "entry.getKey()" and "entry.getValue()"}In all the above cases, each entry in the map is traversed one by one. So at the end of the loop, you'll have processed all the entries in the map. One way you can decorate an input/output stream is to apply compression/decompression to it. See the classes in java.util.zip, for example. Such a decorated stream can be used exactly the same way as a "regular" input/output stream, with compression/decompression performed totally transparently. It's done the same way in Java as any other language: you bind the socket to the address you want to connect from, before you connect.Socket s = new Socket();/* * Change the 192.168.0.1 to whatever IP address you want the connection * to come from. If your IP address is stored in an InetAddress object, * you can use that too, instead of a string. */SocketAddress from = new InetSocketAddress("192.168.0.1", 0);SocketAddress to = new InetSocketAddress("192.168.0.2", 80);s.bind(from);s.connect(to); Hashes in Perl only ever have strings as keys. So your $int_hash's keys are all coerced into strings anyway, and so any difference in run time between the two versions should be negligible. Java uses erasure-based generics (i.e., the type parameters are erased at runtime&mdash;for example, List&lt;Integer&gt; and List&lt;String&gt; are treated as the same type at runtime). Since reflection is inherently a runtime feature, the type parameters are not used or involved at all.In other words, you can only instantiate the raw type (SomeClass, not SomeClass&lt;T&gt;) when you're using reflection. You will then have to manually cast the type to the generic version (and generate an unchecked warning). You cannot satisfy both "error code propagation" and "single return only" at once, at least not cleanly. Choose one and live with it.Actually, I take that back. You can have both, but you have to use goto. That is how the Linux kernel handles its error returns. The first version is wrong, because it returns the new value. The postincrement operator is supposed to return the old value. In Java, string literals (bare "ABC" instead of new String("ABC")) are interned. That is, there is only one copy stored in the JVM, and that is always the copy that's used. That's why they compare equal when using ==.The following comparisons are also always true:str1.intern() == str2.intern()str1.intern() == str3str2.intern() == str3str1.intern() == str4str2.intern() == str4 Yes. Use ExecuteNonQuery's return value. :-)Quoting ExecuteNonQuery's documentation: For UPDATE, INSERT, and DELETE statements, the return value is the number of rows affected by the command. var i;for (i = 1; i &lt; 5; ++i) { alert(obj['resposta' + i]);} You can have more than one @author tag. So, if you've made extensive changes to a class, just add a new @author tag with your own name in it. There's no need to list the changes you've done---the revision history should show that well enough. Yes, you can copy the data:char* pdata = new char[str_len];memcpy(pdata, buf, str_len);pushWork(pdata);At the pushWork end, it has to take care of freeing the data when it's done:delete[] pdata;You will also want to consider encapsulating this all into a std::vector so you don't have to worry about exception safety:std::vector&lt;char&gt; data(buf, buf + str_len);pushWork(data);In this case, pushWork needs to be modified to take a std::vector by value, but the upside is that it won't have to worry about deleting the data when done, and will be fully exception-safe. No, there isn't. But you can create an exception called, say, ExitError:public class ExitError extends Error { private final int code; public ExitError(int code) { this.code = code; } public int getCode() { return code; }}Now, in your application's script runner, you can do this:public int runScript() { try { // Invoke script via Rhino } catch (ExitError exc) { return exc.getCode(); }}And in the command-line version:public static void main(String[] args) { try { // Invoke script via Rhino } catch (ExitError exc) { System.exit(exc.getCode()); }}Also, in your JS code, write a wrapper function:function exit(code) { throw new ExitError(code);} Not so simple. :-)The first one creates a pointer to the given string literal, which is allowed to be placed in read-only memory.The second one creates an array (on the stack, usually, and thus read-write) that is initialised to the contents of the given string literal. You are misusing the wait/notify mechanism. :-) That's the real problem.In Java, wait/notify is used to implement condition variables, which allows a thread to wait for a "condition" to be fulfilled. Another thread can also notify any waiting threads that said condition "may" be fulfilled, and to recheck the condition.Here's a simple example:public class Exchanger&lt;T&gt; { private T item; public synchronized T poll() { while (item == null) wait(); T result = item; item = null; notifyAll(); return result; } public synchronized void offer(T value) { if (value == null) throw new NullPointerException(); while (item != null) wait(); item = value; notifyAll(); }}There are two conditions here (wrapped up under one condition variable, which normally isn't very kosher, but):The item slot is nullThe item slot isn't nullBasically, whenever poll or offer is called, it blocks until another thread does an offer or poll, respectively. To test for when to block, it does the relevant checks within the while loop. rev is part of the util-linux package, at least on my Ubuntu system. If MinGW has a util-linux package, you should install that. Okay, do this:void threadMethod(void* ptr) { static_cast&lt;Test*&gt;(ptr)-&gt;testMethod();}ThreadPtr threadPtr = &amp;threadMethod;That way, you're dealing with a real function, not a PMF. Read my post here, especially the post I linked to about password hashing.You should ideally use bcrypt or scrypt rather than doing your own password hashing.But if you must, you should run for a few thousand iterations at the minimum, preferably more.Yes, you can use MessageDigest for SHA-512. Each time you call digest, the state of the object automatically resets, which is really handy---you can start updating for the next iteration straight away.But I still think you should use bcrypt or scrypt instead. For your own good, and the good of your users. :-) Most computers use binary floating-point. Binary floating-point cannot represent 0.1 exactly (in binary, it's a recurring fraction). Thus, it also cannot represent 0.9 exactly either. lower_bound is almost like doing a usual binary search, except:If the element isn't found, you return your current place in the search, rather than returning some null value.If the element is found, you search leftward until you find a non-matching element. Then you return a pointer/iterator to the first matching element.Yes, it's really that simple. :-) Bags are really useful for tracking instance counts. For example, if you want to keep a record of which hosts you're servicing web requests for, you can add their IP to the bag when you start servicing the request, and remove it when done.Using a bag will allow you to tell at a glance which IPs you're currently servicing. It will also let you quickly query whether you're servicing a given IP address.If you use a set for this rather than a bag, then having multiple concurrent requests from the same IP address will mess up your record-keeping. This seems to work:#!/usr/bin/perl -ns/[^\001]//g;$count += length;END {print "$count\n"}Or, for a count of each line:#!/usr/bin/perl -ns/[^\001]//g;print length, "\n"; Yes, you should do the covariant overrides. This is not "a waste", since it constrains the return type of parent for all subclasses of ColorBinaryTree. You can't set the innerHTML to a DOM object---it holds a string only! Instead, use subSectionHeading.appendChild(link). No, there is no way to obtain that information, because the file system on a POSIX system does not have a creation time field.If your filesystem has extended attributes (xattr), it may store the file creation time. But then you would have to grab that using the xattr interface, not via stat.And alas, Googling for "perl xattr" doesn't yield anything useful. Only by running gdb as root. (In other words, no.)For security reasons, normal users are not allowed to trace processes belonging to other users, especially root. If your MyServerThread class stashes the data into a field, you can access that field from multiple instances of MyServerThread. You can use a pointer:unique_ptr&lt;mem_array&gt; myData;switch (x) {case 0: myData.reset(new mem_array(1, 1, "up")); break;case 1: myData.reset(new mem_array(0, 0, "down"));; break;} Having distinct delimiters allows nesting. Ruby's block parameter list does not support nesting, so using the same delimiter is okay. That has nothing to do with Double.parseDouble, and everything to do with Double.toString.Try this:System.out.printf("%.1f", Double.parseDouble("99999999999999") + 1); You use require to load a file, not include. :-)First, you have to require the file containing the module you want to include. Then you can include the module.If you're using Rails, it has some magic to automagically require the right file first. But otherwise, you have to do it yourself. Lexical variables are never part of an environment from the perspective of eval. So, there is no way for eval to touch the lexical variables x and y, in your example.Update: As of Guile 2.0.5, you can use local-eval, which will indeed allow your eval expression to use local (lexical) variables. But like Eli says, most Scheme implementations don't support this. It's hard to tell why, since it does appear to be unnecessary, but probably it's an optimisation to reduce the number of free variables that are referenced. In this case, p, v, and n become lexical variables of f, and no longer require free variable references.However, since the corresponding free variables are actually lexical variables of vector-map and not further modified, it shouldn't be hard for the compiler to automatically do this kind of optimisation internally. Now, if Ikarus doesn't have a compiler, then that might explain the manual optimisation. For JList, you don't have to use DefaultListModel, just some implementation of the ListModel interface. And the latter is very achievable using a Deque. For your operator* and operator+, you have to return the Vector by value, not by reference. What you have there is returning a dangling reference, and that is undefined behaviour. For something faster than your approach, you should build a primes table using Sieve of Eratosthenes or the like (generate primes at least as far as the number you're testing). Then just look your number up using binary searching. If you keep the table around, you can incrementally build it up if you later need to look up a higher number.Gogo dynamic programming. :-) You forgot one of the most important reasons: so that security controls (e.g., root vs non-root access, file permissions, application memory space isolation, etc.) can be enforced.If user code had the same access as kernel code, user code could bypass all the security-related bookkeeping data in the kernel. e.g., a normal user could then overwrite the current uid field to 0, automatically making them root. You need to use code.equals("e") || code.equals("E") (or just code.equalsIgnoreCase("e")). This is because == does identity comparison ("are x and y the same object?"), whereas equals does value comparison ("do x and y have the same value?"). That's because that's how polymorphism works in Java: it always uses the most-derived version of the method, which overrides other versions. The only way to get the base-class version is to use super.setType within the most-derived override. In Java, expressions are always evaluated left-to-right. So the result of the first readDouble call will become the first argument to the Object constructor (but please don't name your class Object! that collides with java.lang.Object), and so on. Try this:.box h2 a { color: red;} Just use System.getenv:String dbSystem = System.getenv("DB_SYSTEM");If you call it with no arguments, it returns all the environment variables:Map&lt;String, String&gt; env = System.getenv();String dbSystem = env.get("DB_SYSTEM"); Implementations are allowed to implement internal defines using one of two possible semantics: letrec and letrec*.SCM has obviously chosen to use letrec semantics. That means that, given a bunch of internal defines, none of them can immediately refer to the value of another internal define in that same bunch: the same restriction that applies to letrec.Some implementations, like Racket, use letrec* semantics. That means that any variable defined in an earlier internal define can be used directly by later internal defines. (In other words, your code will work fine in any letrec*-based implementation.)Since you're using a letrec-based implementation, do this:(let ((returned (get-fields))) (close-input-port port) returned) For non-greedy matching, append a ? after the pattern. e.g., .*? matches the fewest number of characters possible. You should use iterator instead of const_iterator, if your intent is to call clear. const_iterator is for cases where you are calling only const member functions.Using mutable is not appropriate for this situation. Only mark member variables mutable if they are not part of the object's visible state, e.g., cached data. You can still perform memory synchronisation without synchronized if you have volatile, atomic variables, or other concurrent containers that provide happens-before semantics. However, if you do none of those things, then nothing is guaranteed with regard to memory visibility.In your particular case, if you want to call add() on a container in one thread and have it be visible in another without explicit locking, then this will only work if the container is a concurrent one (e.g., one of the ones in the java.util.concurrent package), or a synchronised one (e.g., Collections.synchronizedList). Inner classes can't have static methods, so you can't have main there. However, static nested classes can indeed have main.Also, as aix's answer says, you can also have multiple package-private top-level classes in the same source file. It's not very thread-safe. :-( (Based on the OpenJDK 6 version of the code.)Things they did right:The add and remove methods are marked synchronized, so a call to one won't happen at the same time as a call to the otherThe listener list arrays are never modified; add and remove always assign a new array to listenerListThings they did wrong (unfortunately):The listenerList field is not volatileThe getListenerList() method is not synchronizedThat means, if you call add or remove in one thread, and then call getListenerList in another thread, the changes may not be observed, and you may still get back the old version of the listener list. Probably the same way that Java does it (Java 5 supports covariant returns at the language level, but the JVM doesn't support it): by adding synthetic methods. Here's how Java does it: say you have a class like this:class Foo implements Cloneable { @Override public Foo clone() { // ... }}Behind the scenes, two clone methods get generated: public Foo clone() (which contains the real code), and public Object clone() (which simply returns the result of the former). The latter method (which is synthesised) is how the clone method gets to be overridden at the JVM level. A double has enough precision for storing that. However, when displaying to users, use a format string like %.6f so that you don't print garbage digits out. C++ is hard when you come from Java and C# because, being unmanaged, it has a totally different execution model compared to managed languages.For example, rather than relying on a garbage collector to pick up unused objects for you, you need to use smart pointers so that they keep track of when to delete objects. Also, the notion of object deletion (and more generally, that objects have specific, finite lifetimes, unlike most managed languages) means that you have to know when an object has been freed or invalidated and cannot be touched again.One example of this is with STL containers. You access these containers using iterators (think pointers on steroids), but there are very picky rules about when the iterators are invalidated. If you use a vector, for example, any time the vector has to be expanded, all existing iterators to it are invalidated and cannot be used any more. Seasoned C++ programmers know these rules like the backs of their hands, but it's a steep learning curve for a newcomer.In other words, you have a lot of learning ahead of you. If you want to get into unmanaged programming, it's learning worth having, but the decision is yours. :-) You should quote the argument to -z!if [ -z "$(grep "&gt;Success&lt;" $OUTFILE)" ]Of course, to test whether &gt;Success&lt; is found, there's an even easier way:if grep -q "&gt;Success&lt;" $OUTFILE You can't use rotate with const_iterators, since rotate changes the elements of the range specified. Instead, you have to use iterators. I'm sure getting COL2 is as simple as using $row-&gt;{COL2} instead of $row-&gt;{COL1} (as you had in your code). So, make your get_val function return two values:return @$row{'COL1', 'COL2'};and in the calling function:my ($val, $val2) = get_val(); Well, in the final case, you are creating a new MultiplyBy object with 3 as the constructor argument. This object is then passed into std::transform, that it then calls operator() on.If it helps you understand better, this is identical:int array[] = {1, 2, 3, 4, 5};MultiplyBy times3(3);std::transform(array, array + 5, array, times3); You can just use /,\s*/ (which is much simpler than what you've got!):'Toys, Cars, Some Other Topic'.split /,\s*/=&gt; ["Toys", "Cars", "Some Other Topic"] This is what I have:boolspin_lock(int64_t* lock, int64_t thread_id, int tries){ register int32_t pic_hack asm("ebx") = thread_id &amp; 0xffffffff;retry: if (tries-- &gt; 0) { asm goto ("lock cmpxchg8b %0; jnz %l[retry]" : : "m" (*lock), "A" ((int64_t) 0), "c" ((int32_t) (thread_id &gt;&gt; 32)), "r" (pic_hack) : : retry); return true; } return false;}It uses the asm goto feature, new with gcc 4.5, that allows jumps from inline assembly into C labels. (Oh, I see your comment about having to support old versions of gcc. Oh well. I tried. :-P) Yes, you can.private static &lt;T&gt; List&lt;T&gt; pushBack(List&lt;T&gt; list, Class&lt;T&gt; typeKey) throws Exception { list.add(typeKey.getConstructor().newInstance()); return list;}Usage example:List&lt;String&gt; strings = new ArrayList&lt;String&gt;();pushBack(strings, String.class); function mandatorySteps() { return doStep1() &amp;&amp; doStep2() &amp;&amp; ...;}function optionalSteps() { doStep15(); doStep16(); ...} If you are creating thousands of threads, you're doing it wrong.Instead, consider using the Executor framework. (Start with the Executors and ThreadPoolExecutor classes.) They allow you to queue thousands of tasks while having a sane number of threads handling them.I guess this approach is what you meant by "library to replace the classical threads". I highly recommend you look into executors.One caveat: Executors, by default, use non-daemon threads. Therefore, you must shut down your executor when you're done with it. You can do this at program exit, if there is a normal way to exit your program that doesn't simply involve waiting for all threads to finish. :-) Yes, NIO provides a SocketChannel class (call the getChannel method on your Socket), which allows you to call configureBlocking to use non-blocking mode. You should then do all your I/O through the channel, and not through the Socket object. No. Order of precedence simply decides whether you get this:A &amp;&amp; B(with A being x-- == 9 and B being y++ == 11) orA == B == C(with A being x--, B being 9 &amp;&amp; y++, and C being 11).Obviously, we're dealing with the first case. Short circuiting fully applies; if A is true, then B is not evaluated. I think you have the notion of methods and instance_methods mixed up. If you were to replace all instances of methods with instance_methods, you will see the results you expect.instance_methods is used to enumerate which methods a class's instances have. methods is used to enumerate what methods the object has. (Class objects are objects too, and have their own methods like new that are not instance methods.For example, String#slice is an instance method; you can call slice on string instances. On the other hand, String.new is a method on String itself; you don't call new on string instances, but you can call String.new (i.e., on the String class object itself) to create a new string.) On Sun's JDK, you can access the sun.java.command property:String args = System.getProperty("sun.java.command");However, you have to split the arguments yourself, and it's also not very portable to other JVMs. The PropObject::* is a pointer-to-member (data member, in this case). It's basically a pointer to a (non-static) member (which are Student::age and Student::grade in the case of your code).To use it, you have to specify the this object that the function would use. That's done by using either the .* or -&gt;* operator; in this case, the PropType&amp; t = po.*Prop; line handles that, where po is used as the this object for the members. Put this line in your crontab:TZ=Asia/Kolkata You should not worry about those lines. It's a way to make your script runnable with both Perl and the shell, making it super-portable. You can use JavaBeans introspection for this. Read up on the java.beans.Introspector class:public static Map&lt;String, Object&gt; introspect(Object obj) throws Exception { Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); BeanInfo info = Introspector.getBeanInfo(obj.getClass()); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { Method reader = pd.getReadMethod(); if (reader != null) result.put(pd.getName(), reader.invoke(obj)); } return result;}Big caveat: My code deals with getter methods only; it will not find naked fields. For fields, see highlycaffeinated's answer. :-) (You will probably want to combine the two approaches.) "Thousands" is not going to be a problem. Just do it.When you get into millions, then you might have to reconsider. You need to implement the "rule of three". That means that any time you have a constructor that creates resources and a destructor that frees them, you also need to create a copy constructor and an assignment operator that copies these resources properly too.Right now, you don't have a copy constructor or an assignment operator, so those items are not getting copied. In the specific case of Lisp:Lisp has macros! You can transform the language in any way you please using Lisp macros.You can also create reader macros to change the way source expressions are parsed in Lisp.For more extensive changes to the source format, you can even make your own reader. See David A. Wheeler's readable S-expressions proposal for an example. Which toolkit are you using? I'm going to assume you're using Swing or AWT.In Swing and AWT, there is a thing called a layout manager that specifies how components are laid out. In this case, BoxLayout sounds perfect for what you're seeking to do. Mark Elliot's idea is correct. I don't like the whole Map&lt;?, List&lt;?&gt;&gt; idea though; I've been far too spoilt on Guava. So here's a Guava version of the same idea:SortedSetMultimap&lt;String, ?&gt; sorted = Multimaps.invertFrom( Multimaps.forMap(map), TreeMultimap.create());for (Map.Entry&lt;String, ?&gt; entry : sorted.entries()) { // ...}This is, like, a third of the size of Mark's code. :-) Real web sites use real web frameworks, which have a concept called a "layout" (at least that's what they're called in Rails; as mentioned in Uwe's answer, they're called master pages in ASP.NET). All the common "templatey" stuff goes into a layout. You could create a custom class for this:class RunningTime attr_reader :time def initialize time @time = time end def disqualified? @time == 'disqualified' end def &lt;=&gt; rhs case [disqualified?, rhs.disqualified?] when [false, true] -1 when [true, true] 0 when [true, false] 1 else time &lt;=&gt; rhs.time end endendrunners.sort_by {|runner| RunningTime.new(runner.time)} Using $name =~ $regex won't change your $name. You have to use the s/// operator to effect any change.e.g.,$name =~ s/$pattern/$replacement/;If you are specifying both the pattern and replacement in the same argument, e.g., in the form of s/foo/bar/, you will have to split them first:my (undef, $pattern, $replacement) = split '/', $regex;$name =~ s/$pattern/$replacement/;Original answer:Use qr//:$name =~ qr/$regex/;You can also just use $name =~ /$regex/, but the qr version is more general, in that you can store the regex object for later use:$compiled = qr/$regex/;$name =~ $compiled;$name =~ s/$compiled/foobar/;etc. I'm actually extremely surprised you didn't use pack for your Perl version!$ascii = pack 'H*', $hex_;Anyway, the Java port of your Perl code, if you want to code it manually (as opposed to using something like Apache Commons Codec) is:StringBuilder sb = new StringBuilder();for (int i = 0; i + 1 &lt; hex.length(); i += 2) sb.append((char) Integer.parseInt(hex.substring(i, i + 2)));String ascii = sb.toString(); I actually think you've answered your own question: it returns the valid indices of the array, no matter what value you've set for $[. So from a generality point of view (especially for library usage), it's more preferred.The version of Perl I have (5.10.1) doesn't support using keys with arrays, so it can't be for historic reasons. astore_1 is the same as astore 1, and astore_2 is the same as astore 2, except that astore_1 and astore_2 are one byte each, whereas astore is a two-byte instruction. It may help you to think of the obj.method(arg1, arg2) invocation syntax as purely syntactic sugar for calling method(obj, arg1, arg2) (except that method is looked up via obj's type, and isn't global).If you view it that way, obj is the first argument to the function, which traditionally is named self in the parameter list. (You can, in fact, name it something else, and your code will work correctly, but other Python coders will frown at you.) I think your dir setting is wrong. Here's the one we use at work (and it works for us):&lt;xjc schema="${xsd.location}/eviction.xsd" destdir="${src}" package="com.onsitemanager.eviction.schema"&gt; &lt;produces dir="${src}/com/onsitemanager/eviction/schema" includes="*.java"/&gt;&lt;/xjc&gt;(Don't worry too hard about what the values of ${xsd.location} and ${src} are, as long as they're sensible for your setup with regard to where you store your .xsd files and source files, respectively.)Of note is that dir is the directory where the .java files are being output to, and includes is simply *.java. sed -n 's/.*time=\(.*\)ms/\1/p' &lt; logfileThis sets up a regular expression that captures everything between the time= and ms into the first capture group (which is referred to on the right-hand-side as \1) and prints it. EC2 has high-memory instances of up to 68.4 GB each, and they charge by the hour. Granted, that is not 100GB of memory, but, if you stack a few of them up together.... Let's step through an example; maybe that will help. :-) For simplicity, I'm just going to use list as the collector/continuation, which will just return a list with the arguments to the continuation.(multirember&amp;co 'foo '(foo bar) list)At the start,a = 'foolat = '(foo bar)col = listAt the first iteration, the (eq? (car lat) a) condition matches, since lat is not empty, and the first element of lat is 'foo. This sets up the next recursion to multirember&amp;co thusly:a = 'foolat = '(bar)col = (lambda (newlat seen) (list newlat (cons 'foo seen))At the next iteration, the else matches: since lat is not empty, and the first element of lat is 'bar (and not 'foo). Thus, for the next recursion, we then have:a = 'foolat = '()col = (lambda (newlat seen) ((lambda (newlat seen) (list newlat (cons 'foo seen))) (cons 'bar newlat) seen))For ease of human reading (and avoid confusion), we can rename the parameters (due to lexical scoping), without any change to the program's semantics:col = (lambda (newlat1 seen1) ((lambda (newlat2 seen2) (list newlat2 (cons 'foo seen2))) (cons 'bar newlat1) seen1))Finally, the (null? lat) clause matches, since lat is now empty. So we call(col '() '())which expands to:((lambda (newlat1 seen1) ((lambda (newlat2 seen2) (list newlat2 (cons 'foo seen2))) (cons 'bar newlat1) seen1)) '() '())which (when substituting newlat1 = '() and seen1 = '()) becomes((lambda (newlat2 seen2) (list newlat2 (cons 'foo seen2))) (cons 'bar '()) '())or (evaluating (cons 'bar '()))((lambda (newlat2 seen2) (list newlat2 (cons 'foo seen2))) '(bar) '())Now, substituting the values newlat2 = '(bar) and seen2 = '(), we get(list '(bar) (cons 'foo '()))or, in other words,(list '(bar) '(foo))to give our final result of'((bar) (foo)) When overriding, method parameters are not covariant (that is, subclasses have to accept a type that the superclass also accepts, not anything narrower).This is because people can use your PersonServiceImpl via the PersonService interface, which will accept an argument of type BaseCommand&lt;Person&gt; that is not necessarily a PersonCommand (imagine if you created a second class that extended BaseCommand&lt;Person&gt;).If you make your method take a parameter of type BaseCommand&lt;Person&gt;, your code should compile correctly. Arrays can't be copied in that way. The usual way to copy arrays is by using memcpy. You can use mprotect with PROT_NONE ("Page cannot be accessed"). Then any access to the given page will cause a fault. That operation is called apply.(apply + (list 1 2 3)) ; =&gt; 6apply "expands" the last argument; any previous arguments are passed as is. So these are all the same:(apply + 1 2 3 (list 4 5 6))(apply + (list 1 2 3 4 5 6))(+ 1 2 3 4 5 6) I also have a non-BigInteger-based version (since having to reach out for BigInteger did bug me for a while); I've retained my main function for your ease of testing:public class UlongToString { private static final String MIN_VALUE = "" + Long.MIN_VALUE; public static String ulongToString(long value) { long pos = value &amp; Long.MAX_VALUE; if (value == pos) return String.valueOf(pos); char[] chars = MIN_VALUE.toCharArray(); chars[0] = '0'; for (int i = chars.length - 1; i != 0 &amp;&amp; pos != 0; --i) { if ((chars[i] += pos % 10) &gt; '9') { chars[i] -= 10; ++chars[i - 1]; } pos /= 10; } int strip = '1' - chars[0]; return new String(chars, strip, chars.length - strip); } public static void main(String... args) { for (String arg : args) { System.out.println(ulongToString(Long.parseLong(arg))); } }} Yes, if you don't want the memory allocated by the new[] to leak, you should delete[] it when you're done using that memory.To avoid having to keep track of that memory, I recommend you use std::string or std::vector instead. That's by design. You're supposed to encode the getName.php, name, and flowers separately. You could also add a third overload to explicitly capture the string literal case:void func(char const* cstr) { return func(std::string(cstr));} You didn't post the code to updatePos. But at a minimum, you need to make that method, as well as keyPressed (and anything else that uses x and/or y) synchronized.Alternatively you can make both x and y volatile, but then x and y could get updated out of lockstep.But without any memory synchronisation, changes from one thread are not guaranteed to be observable from another thread. Sure. Just run git archive from the directory that contains the local repo, and don't specify --remote. Testing for "positive zero" is incorrect. If you want the number to be 0.000 to three dp, just check that the number is within (-0.0005, 0.0005). e.g.,expect(Math.sin(-Math.PI) * 300).between(-0.0005, 0.0005);(You may need to add a between method to your expect, if it doesn't already provide it under a different name.) strncat suffers from the Schlemiel the Painter problem. The way you're using snprintf does not (though it's possible to use strncat that way too, and sidestep the problem that way). Sure. :-)return s.substring(5); You should not access a, b, and c after the destructor is called, even if it's an explicit destructor call. You never know what your compiler puts in your destructor that might make those values invalid.However, the memory is not actually freed in the case of an explicit destructor call. This is by design; it allows an object constructed using placement new to be cleaned up.Example:char buf[sizeof (Fool)];Fool* fool = new (buf) Fool; // fool points to buf// ...fool-&gt;~Fool(); You can add a cityId field in your enum:public enum Test { MOSCOW(1001), NEWYORK(1002), SOCHI(1234); private final int cityId; private Test(int cityId) { this.cityId = cityId; } public int getCityId() { return cityId; } public static Test valueOf(int cityId) { /* * Using linear search because there's only a small handful * of enum constants. If there's a huge amount (say, &gt;20), * a map lookup is better. */ for (Test value : values()) { if (value.cityId == cityId) return value; } throw new IllegalArgumentException("Unknown city ID: " + cityId); }}Then you can indeed switch on the enum value:switch (Test.valueOf(cityId)) {case MOSCOW: // ...} You can only get a HashMap out of {}, not [] (you should be able to get an ArrayList out of it though). The only clean way is to use the virtual function approach.If the Parent class has at least one virtual function (not necessarily DoSomething), there's also a yucky way to do it:void DoSomething() { if (Child1* child = dynamic_cast&lt;Child1*&gt;(this)) { child-&gt;childMember = 0; } else if (Child2* child = dynamic_cast&lt;Child2*&gt;(this)) { child-&gt;childMember = 0; } // and so on, and so forth}(If Parent has no virtual functions, then the dynamic_cast won't work. Though, any class designed to be inherited from should have at least one virtual function, even if it's just the destructor.) I have no knowledge of abstract interpretation, so I'll take the functional programming approach to folding. :-)In functional programming, a fold is an operation applied to a list to do something with each element, updating a value each iteration. For example, you can implement map this way (in Scheme):(define (map1 func lst) (fold-right (lambda (elem result) (cons (func elem) result)) '() lst))What that does is that it starts with an empty list (let's call that the result), and then for each element of the list, from the right-hand-side moving leftward, you call func on the element and cons its result onto the result list.The key here, as far as termination goes, is that with a fold, the loop is guaranteed to terminate as long as the list is finite, since you're iterating to the next element of the list each time, and if the list is finite, then eventually there will be no next element.Contrast this with a more C-style for loop, that doesn't operate on a list, but instead have the form for (init; test; update). The test is not guaranteed to ever return false, and so the loop is not guaranteed to complete. What that means is that you cannot overload an operator when all the operands are non-class/enum types. i.e., you cannot override the behaviour of % when both sides are float (or int, or any other primitive type). in uses the method __contains__. Each container type implements it differently. For a list, it uses linear search. For a dict, it uses a hash lookup. I'd do this:stringstream convert;convert &lt;&lt; x;string y(convert.str());string z(y.rbegin(), y.rend());return z;No need to write a manual loop! The Event Dispatch Thread is fixed. It doesn't get reassigned just because you created a Swing object on another thread (which you should never do anyway). Both Racket (with readline support loaded; see below) and Chez Scheme will do this. :-) So will Guile, but it will fold multi-line forms into a single line (unlike Racket/Chez).To enable bracket matching for Racket, add this line to your ~/.racketrc:(#%require readline/rep)and this line to your ~/.inputrc:set blink-matching-paren on You cannot. Java has erasure-based generics, which means that the type parameters are not available at runtime.If your collection is not empty, you can do an instanceof on the first element or something, of course. Assuming that, when you say "easy to get and add", the "add" refers to adding to the end of the collection only, then ArrayList is indeed a good option.If you want to add to the front as well, then ArrayDeque is better. And if you want to be able to add to an arbitrary location, then neither is a very good choice. For good encapsulation, you should keep your vector private. Your ascending and descending functions (or rather, pointers thereto) are passed as the compare argument to the selectionSort function. [A-Za-z\d][-A-Za-z\d]{3,498}[A-Za-z\d]If you are willing to treat _ as a letter also, it's even simpler:\w[-\w]{3,498}\w As Marc B alluded to, Java will promote b to a long before actually doing the % operation. This promotion applies to all the arithmetic operations, even &lt;&lt; and &gt;&gt; I believe.In other words, if you have a binary operation and the two arguments don't have the same type, the smaller one will be promoted so that both sides will have the same type. Class objects are indeed objects.Class methods are actually methods defined in the class's eigenclass (singleton class). That is why those methods are not available to actual instances of said classes.Here's a way to help you see this: first, add a singleton_class method if you don't already have it:module Kernel def singleton_class class &lt;&lt; self self end endendNow, try the following:String.instance_methodsString.singleton_class.instance_methodsClass.instance_methodsClass.singleton_class.instance_methodsc = Class.newc.instance_methodsc.singleton_class.instance_methodsThis will help you gain an appreciation for what methods are available to instances of a class, versus what methods are methods on the class (i.e., instances of the class's singleton class).(You can pass a false argument to each of those instance_methods calls to see which methods are defined for that class, and not any superclasses.) There is no such number as 0.285 in double. Here are the two numbers I see when testing in JRuby:irb(main):002:0&gt; java.math.BigDecimal.new(0.285).to_s=&gt; "0.284999999999999975575093458246556110680103302001953125"irb(main):003:0&gt; java.math.BigDecimal.new(2.85 * 0.1).to_s=&gt; "0.28500000000000003108624468950438313186168670654296875"Obviously, it seems JRuby has the same behaviour as your JS. :-) It's (cons 0 c), not (cons (0 c)). :-) Even so, cons is the wrong approach here. :-)Here's how I'd translate it:(define (mult a b) (if (zero? b) 0 (let ((c (mult a (quotient b 2)))) (if (even? b) (* 2 c) (+ a (* 2 c))))))A less-literal translation can make the code slightly more readable:(define (mult a b) (if (zero? b) 0 (let ((c (mult a (quotient b 2)))) (if (even? b) (+ c c) (+ a c c)))))ETA: Binary digit edition! (Where, say, 4 is represented as '(0 0 1).)(define (mult a b) (if (null? b) '() (let ((c (mult a (cdr b)))) (if (zero? (car b)) (cons 0 c) (add a (cons 0 c))))))(where you have to implement add to do binary-digit addition.) If you don't care about the port number, and don't mind that it changes every time your program is run, simply don't bind the port before you listen on it (or bind with port 0, if you want to bind a specific IP address). In both cases, you're telling the OS to pick a free port for you.After you begin listening, use getsockname to find out which port was picked. You can write it to a file, display on it on the screen, have a child inherit it via fork, etc. You can do it brute-force. ;-) Ruby example:require 'set'set = Set.new(0..n).each do |x| set &lt;&lt; (x &amp; n)end(where set is a set datatype, i.e., removes duplicates.) Try using this instead:perl -ne '/\d+/ &amp;&amp; print "$&amp;\n"' String literals are really of type char const*. However, for compatibility with older C code that's not const-correct, C++ allows them to be assigned to a char*. That does not mean you are really allowed to modify them. You need to use $decoded_json-&gt;{"foo"}---note the curly brackets, not the square ones. Also note the arrow -&gt;---decode_json returns a reference.I will readily admit that the documentation in this case is no help for someone who doesn't already know Perl, for example, to the level of knowing what $perl_hash_or_arrayref means. (A seasoned Perl programmer knows instantly it means you have to use -&gt;.) You need to say new Dog(), not just new Dog.Alas, Java is not C++; you don't get to omit the brackets just because you're using the default constructor. printf '\xa1' | dd conv=notrunc of=somefile bs=1 seek=$((0xdeadbeef)) The superclass doesn't have a default constructor. So you need to pass the appropriate constructor arguments to the superclass:super(id);(Put this as the top line in both the Manager and Engineer constructors.) You should also remove the this.emp_id = id line, in both cases.In general, if your constructor doesn't start with a super(...) or this(...) statement (and you can only have one of these, not both), then it defaults to using super() (with no arguments). The other answers in this thread all seem too complicated (I read through them all), so here's my take on it:(define (all-equal? lst) (define item (car lst)) (let next ((lst (cdr lst))) (cond ((null? lst) #t) ((equal? item (car lst)) (next (cdr lst))) (else #f))))(It does not work with an empty list, by design. It's easy to add a (if (null? lst) #t ...) if necessary.) I have a version that uses only "first-principles" operations and is efficient (does not require more than one pass through any of the lists, unlike append-based solutions). :-)It does this by defining two simple building blocks (fold and reverse), and then defining flatten (and its helper, reverse-flatten-into) atop those (and notice how each function is just one or two lines long):;; Similar to SRFI 1's fold(define (fold1 kons knil lst) (if (null? lst) knil (fold1 kons (kons (car lst) knil) (cdr lst))));; Same as R5RS's reverse(define (reverse lst) (fold1 cons '() lst));; Helper function(define (reverse-flatten-into x lst) (if (pair? x) (fold1 reverse-flatten-into lst x) (cons x lst)))(define (flatten . lst) (reverse (reverse-flatten-into lst '())))The only external functions used are: cons, car, cdr, null?, and pair?.The key insight from this function is that fold is a very powerful operation, and should be part of any Schemer's toolkit. And, as seen in the code above, it's so simple to build from first principles! First build your hash thusly:hash = { :key1 =&gt; value1, :key2 =&gt; condition ? value2 : :delete_me, :key3 =&gt; value3}Then do this after building your hash:hash.delete_if {|_, v| v == :delete_me}Unless your hash is frozen or otherwise immutable, this would effectively only keep values that are present. Any OpenID system worth a salt lets you type in your own URL. So even if Facebook isn't offered in the provider listing on some site, you just need to type in the Facebook OpenID endpoint URL, and you'll be able to authenticate using Facebook. You can't! The empty list is a singleton, immutable object. It has no slots (car or cdr) that you can change. But you can do this:(set! mlst-my (mappend! mlst-my (list-&gt;mlist (list 100))))That is, you set! your variable to mappend!'s return value.To understand all that, understand how singly linked lists work. It comprises cons cells (or dotted pairs), which each have two slots (traditionally named car and cdr). The car slot points to the value, and the cdr points to the next cons/pair.So, a list like (1 2 3) has three conses:#0=(1 . #1#)#1=(2 . #2#)#2=(3 . ())The way append! works is to find the last cons (the one whose cdr is pointing to ()), and change its cdr to point to the list you're appending.If your list is empty, though, it has no conses, and therefore it has nothing to change. Empty lists are always immutable. You can use procedure-arity.(procedure-arity expt) ; =&gt; 2Note that when using procedure-arity with variadic functions or case-lambda or the like, the results are more complicated:(procedure-arity apply) ; =&gt; (arity-at-least 2)(procedure-arity (case-lambda ((x) x) ((x y z) z) ((a b c d e f . g) g))) ; =&gt; `(1 3 ,(arity-at-least 6)) /Zc:wchar_t- does the opposite of what /Zc:wchar_t does: it causes wchar_t to be treated as the same type as unsigned short, for compatibility with VC6./Zc:wchar_t- causes your code to be non-conformant with standard C++, so don't use it unless you must. A float has much less precision than a double; you lose about half the digits. So at best you'd be seeing the 622.0799 portion (rounded up to 622.0800). The difference you see is probably caused by the rounding mode in use.Here are the actual numbers:As double: 622.0799999586118929073563776910305023193359375As float: 622.08001708984375 (internal representation: 1142654239)Immediately-preceding float: 622.0799560546875 (internal representation: 1142654238)The internal representations are values generated using Java's Float.floatToIntBits. You can also use Float.intBitsToFloat to get back a floating-point number. If you're using nth to traverse a list, you're doing it wrong. In this case, you might want to write a summing function:(defun sum (items) (reduce #'+ items)) The command-line arguments are available under bsh.args, not args. So if you change all instances of args in your code with bsh.args, you should be good to go. Reference: Special Variables and Values.This worked for me:for (arg : bsh.args) print(arg);Example:$ bsh foo.bsh 1 2 3123 Your area-cylinder is wrong. It should take the circumference and multiply by the height. Thus:(define (area-cylinder radius height) (* 2 pi radius height))Your area-circle is also wrong. It should be thus:(define (area-circle radius) (* pi radius radius))So the area-pipe function should be:(define (area-pipe2 inner-radius height thickness) (+ (area-cylinder inner-radius height) (area-cylinder (+ inner-radius thickness) height) (* 2 (- (area-circle (+ inner-radius thickness)) (area-circle inner-radius))))) You need to make your operator double a const function:operator double() const;andComplex::operator double() const { return _num;} Well, sure. In XSD file, define a type first:&lt;xs:complexType name="response"&gt; &lt;!-- define type here --&gt;&lt;/xs:complexType&gt;Now define your elements using it:&lt;xs:element name="response1" type="response"/&gt;&lt;xs:element name="response2" type="response"/&gt;&lt;!-- and so on and so forth --&gt; You don't need to link with a debug version of the library in order to use it, which is why pkg-config doesn't offer such an option. All you need to do is set up your LD_LIBRARY_PATH appropriately when you run the program, and the debug library will get used at runtime. There's several problems with your frame-add-subframe function:Why are you using funcall in this instance? You should be able to directly call frame-add-slot: (frame-add-slot subframe 'ako)If the funcall usage is merited, then you'd use it like this: (funcall #'frame-add-slot subframe 'ako)I presume that instead of specifying 'ako hardcoded, you meant to use res somehow? That variable is unused. If you use writeSubsTo(Feed&lt;? super Sub&gt; f), then you can pass in a Feed&lt;Super&gt;. Then you can do away with your filler classes altogether. Yay for contravariance! :-P(There's also a covariant version, ? extends X, for cases where you're getting values out rather than putting values in.) The assignment operator is used if you do this:MyType my1, my2;my1 = my2; // same as: my1.operator=(my2); Try using std::deque&lt;Ogre::Vector3&gt; instead of deque&lt;Ogre::Vector3&gt; (which is Ogre::deque&lt;Ogre::Vector3&gt; in this case).Or you can use Ogre::deque&lt;Ogre::Vector3&gt;::type. The docs seem to say that is the same as the std::deque above. List&lt;Integer&gt; template = Arrays.asList(1, 3, 5, 7, 9);Set&lt;List&lt;Integer&gt;&gt; seen = new HashSet&lt;List&lt;Integer&gt;&gt;();for (int i = 0; i &lt; 10; ++i) { List&lt;Integer&gt; items = new ArrayList&lt;Integer&gt;(template); do { Collections.shuffle(items); } while (!seen.add(items)); System.out.println(items);}:-) The first and third ways are the same: they evaluate an array in scalar context. I would consider this to be the standard way to get an array's size.The second way actually returns the last index of the array, which is not (usually) the same as the array size. Okay, how about ImmutableList (from Guava)? Each thread can subsequently copy it into its own thread-local mutable list, if it wants to.If it really has to be mutable, a CopyOnWriteArrayList works too. :-) Sure, use an enum for your directions, then use an EnumMap for your map type.public enum Direction { NORTH, EAST, SOUTH, WEST;}Map&lt;Direction, Place&gt; map = new EnumMap&lt;Direction, Place&gt;(Direction.class);This guarantees that the key must be of type Direction. And it's watertight---because of the type key passed to the EnumMap constructor, even if you're using generics-blind code, the type restriction will still get enforced (at runtime). It's the domain name spelt out in reverse.For example, one of my domains is hedgee.com. So, I use com.hedgee as the base name of all my packages. The JDK and JRE are never distributed as zips, but always as an installer. This is because there is executable code (unpack200 in particular) that has to be run as part of the installation. In C++0x, you can do this:TestObject() :TestObject{5, 12, 7} {}See Delegating Constructors for more details. (Curly braces not look familiar to you? They're for preventing narrowing.)If you don't have C++0x available yet, then in your case, you can use default arguments as mentioned in other answers here. The edge argument comes from the items in (cdr node). Your inner lambda will be called once for each element in (cdr node).Try this for example:(mapc #'princ '(1 2 3 4 5))Or, with a literal lambda:(mapc #'(lambda (x) (princ x) (terpri)) '(1 2 3 4 5)) Simple!#!/usr/bin/perl -ps/.*?,//; Your approach (about wrapping with a custom checked exception) is fine. But unless malformed input is expected and should be handled by callers (which is your case, but not necessarily in general for other readers here), using an unchecked exception is better. Yes, of course you can link both a static library and a dynamic library. Linking to a static library is essentially the same as grabbing the required object files from the archive and including them in the linking process.If the static library and the dynamic library you're linking is for the same library, then the dynamic link is redundant. It's still allowed to be done, but it'd be pointless (and just introduces an unnecessary runtime dependency for your executable, at least on Unix). You also have to specify Locale.US with your SimpleDateFormat.SimpleDateFormat sdf = new SimpleDateFormat(dateFormat, Locale.US); Yes, you can use:v1 &lt;- 1:5 To add to Nathan's excellent suggestion, there's also Land of Lisp. :-) It's a special feature of Racket's reader. (See John's answer.)For other implementations, you can instead use the readable S-expressions reader to be able to read infix expressions. It uses curly braces. e.g., {3 + 4} is read in as (+ 3 4). Even more special (than Racket's infix reader), you can use {3 + 4 + 5} or {3 + 4 + 5 + 6}; they will read as (+ 3 4 5) and (+ 3 4 5 6) respectively. An empty list is not a number, so the type definition you have will not accept it.You can use (lambda (x) (or (number? x) (null? x))) instead of number? to accept either a number or an empty list, but I have no idea why you would want to do that. Quick answer (:-P): You have to add brackets so that it's getIsMale() and getAge(). All functions must be called with brackets, in Java.Style comment: Boolean getters should normally be named isXXX, not getXXX, so your male getter should be named isMale, not getIsMale. I don't know Common Lisp that well, so here's a Scheme implementation of the code pasted by Ben:(define (difference big small) (fold delete big small))(define (delete x lst) (delete-by equal? x lst))(define (delete-by equal? x lst) (if (null? lst) '() (receive (y ys) (car+cdr lst) (if (equal? x y) ys (cons y (delete-by equal? x ys))))))where fold and car+cdr come from SRFI 1, and receive comes from SRFI 8.If we will allow ourselves the use of SRFI 26's cut form, then we have a solution that looks even closer to the Haskell version (since the latter uses currying in at least two places):(define difference (cut fold delete &lt;...&gt;))(define delete (cut delete-by equal? &lt;...&gt;)); Unchanged from the above version(define (delete-by equal? x lst) (if (null? lst) '() (receive (y ys) (car+cdr lst) (if (equal? x y) ys (cons y (delete-by equal? x ys)))))) Yes, that is true, because string literals are all interned. Read the documentation for String.intern() for more details.As a consequence, these are all the same object (and will compare equal with ==):s1s3s1.intern()s2.intern()s3.intern() They get created in the call to fork. Here: if (!fork()) { // this is the child process close(sockfd); // child doesn't need the listenerfork returns in both the parent process (with the child's process ID as the return value) as well as in the child process (with 0 as the return value). Yes. Use this as A's new method:sub new { my ($cls, @args) = @_; # ... my $obj = ...; # populate this bless $obj, $cls;}The key is that when using B-&gt;new, the first argument is B (which I bound to $cls in my example). So if you call bless using $cls, the object will be blessed with the correct package. It sounds like you need to launch your JVM with a larger memory limit. Try something like (if you're using Bourne shell):export ANT_OPTS=-Xmx1gantor, if you use cmd under Windows:set ANT_OPTS=-Xmx1gantAbove, the 1g means 1 GB. You can tweak that to whatever you like; for example, if you want to use 1.5 GB, you can use -Xmx1536m. You're so close! Just use the initialiser list syntax:Tree::Tree() : apples(0) { // ...}Tree::Tree(int fruit_num) : apples(fruit_num) { // ...} If dx is 0x0680, then dh is 0x06 and dl is 0x80.0x80 is interpreted as 128 in unsigned mode, and -128 in signed mode.Thus, you have to use jg, since 6 > -128, but 6 &lt; 128. jg does signed comparison; ja does unsigned comparison. Sure:aField.set(this, aValue);To do type checking first:if (!aField.getType().isInstance(aValue)) throw new IllegalArgumentException();but since calling set with a value of the wrong type will generate an IllegalArgumentException anyway, that sort of check isn't very useful. When a window has focus and you type, that window receives keypress messages. When another window steals focus, the latter window starts receiving those messages instead. If that new window rejects or ignores those messages, that's when the keystrokes "disappear". If you are running on Unix, the shared library has to be named libxyz.so, not xyz.so. public &lt;T extends AbstractBase&gt; T getById(long id, Class&lt;T&gt; typeKey) { if (ClassA.class.isAssignableFrom(typeKey)) { // ... } else if (ClassB.class.isAssignableFrom(typeKey)) { // ... } else { // ... }}or if you want exact match on classes (rather than be of a potential subclass type):public &lt;T extends AbstractBase&gt; T getById(long id, Class&lt;T&gt; typeKey) { if (typeKey == ClassA.class) { // ... } else if (typeKey == ClassB.class) { // ... } else { // ... }} From what I understand of what your in function is supposed to do, you can define it this way:(define in fold) ; after loading SRFI 1:-P(More seriously, you can look at my implementation of fold for some ideas, but you should submit your own version for homework.) Assuming the cs240utils.lib is meant to be a static library, you don't use g++ to create it. Instead, you use ar (or lib, if using the MSVC toolchain) to assemble all the files into the library. I'm going to be a devil's advocate and tell you about Steve Yegge's adventures developing a Java-based RPG, named Wyvern (sadly now defunct). His view, as I understood it, was that Java made the code too complex to maintain; it got to half a million lines long, at one stage.Sure, you might say your game won't get that big. But don't underestimate the power of scope creep. :-)Nevertheless, some successful games are indeed written in Java. mikera's answer is one example, as are games like Runescape or Minecraft. But still, if your game has the potential to get big, Java probably still isn't (in my opinion, and it seems Steve Yegge's also) your best choice. There is no difference between const Class&amp; and Class const&amp;; likewise, there is no difference between const Class* and Class const*. Both denote a reference/pointer to a constant Class instance.However, Class* const is a totally different beast. That is a const pointer to a non-const Class instance. As of Guava 10, MapMaker.softKeys is deprecated, and the corresponding method doesn't exist in CacheBuilder.Why was this change made? What do I need to do with existing code that use it? I wrote the question because, initially, I did genuinely wonder why (as I had existing code that used softKeys). However, the reason was obvious on reflection and I decided to post it here, in case someone else also uses softKeys and was wondering the same thing.In short, the reason was that softKeys never made any sense in the first place. Thus, its initial inclusion was in itself a mistake, one which the Guava developers are rectifying via deprecation.In general, you use soft references if you want the object to stick around for a little after all the strong references are gone; in contrast, with weak references, the object usually gets collected soon once there are no strong or soft references left. This is useful for cached values that you want to hold on to temporarily, so that a lookup using the corresponding key will "revive" a strong reference for the value.However, this behaviour doesn't make any sense for keys:Since softKeys and weakKeys maps use an identity-based lookup, the only way to get at an entry of interest is to posess a strong reference to its key.† Thus, once there are no strong key references left, the entry is effectively dead (with no possibility of revival).The only practical difference between softKeys and weakKeys is how long an entry remains in the map after all the strong references to its key are gone. Since such entries are dead anyway, using softKeys instead of weakKeys only delays the entry's eviction, for no good reason.Thus, most times when coming across code that uses softKeys, a much more suitable replacement is weakKeys.† I am not considering the case of fetching the entry via iteration, or anything other than key-based lookup, since maps are primarily about key-based operations. Suppose you have three numbers:int randomNumber1 = 3;int randomNumber2 = 4;int randomNumber3 = 5;int randomNumbers = randomNumber1 + randomNumber2 + randomNumber3;Do you expect randomNumbers to be 345? Or do you expect it to be 12?Now try this:String randomNumbers = "" + randomNumber1 + randomNumber2 + randomNumber3;What do you get this time? divide has an overload that takes a rounding mode. You need to choose one. I believe "half even" is the most commonly used one for monetary calculations. C# is not designed for that sort of thing at the language level. You will have to use reflection to achieve that, and only for fields, not local variables (which cannot be accessed via reflection). Using exceptions allows the caller to decide how to handle an error. If you called exit directly within the function, then the program would exit without the caller being able to decide how to handle the error. Also, with exit, stack objects would not be unwound. :-( &amp;&amp; (and ||) establish sequence points. So the expression on the left-hand side will get evaluated before the right-hand side. Also, yes, if the left-hand side is false/true (for &amp;&amp;/||), the right-hand side is not evaluated. Here's a solution that uses SRFI 1:(define (for-n start stop fn) (map fn (iota (- stop start) start)))If this is for homework, then it's up to you to define iota, and perhaps map also. :-DAnother solution using a different strategy (also uses SRFI 1):(define (for-n start stop fn) (unfold-right (lambda (x) (&lt; x start)) fn sub1 (sub1 stop)))where sub1 == (lambda (x) (- x 1)). Of course, you have to implement unfold-right yourself, in this case.Hopefully from the above two example solutions, you have enough ideas to build your own from-scratch solution. :-) I did a quick grep of the Guava source and documentation, and neither seem to have any mention of versions. I was wondering if there was a way Guava's version information can be obtained at runtime.This version information doesn't have to be accessible via any getter, if no such thing actually exists; if it's stashed in a field somewhere that doesn't get GC'd while Guava is loaded, that would be sufficient.Is this version information available anywhere at runtime?I have a very specific use for this. A big part of my work is analysing Java heap dumps to identify and fix places in the code that cause exorbitant memory usage. For this task, I use fasthat, a heavily-modified version of jhat with special features useful to my work.One of those features is to display the contents of containers. I've already implemented this for the likes of ArrayList, HashMap, ConcurrentHashMap, etc. (I implement type printers on demand, based on what I encounter in our heap dumps.) Currently, I'm implementing a type printer for Guava's CustomConcurrentHashMap.Since the layout of structures can change between versions, my code tweaks its unpacking behaviour based on what version is in use. For example, at work, we used to use JRuby 1.2, but recently switched to JRuby 1.6, so I have type printers for both of those versions, and it selects the version based on the version information it finds in the heap dump.So, that's the point of the second paragraph of the question: if the version information is anywhere in the heap dump, that's all I need.And before anyone asks: heap dump data is not "live", so you cannot simply call toString or the like. You really have to walk the data structures to extract the bits out, and you really do have to use implementation details to the nth degree. ;-) For Racket:Use add1 instead of 1+Use sub1 instead of -1+ or 1-The trouble is, none of those names are standard, so you can't reliably use them across all Scheme implementations. :-) Run this:sudo chmod 755 /usr/localThis error message comes up because your /usr/local is world-writeable, which is a Bad Thing---it enables other users to place trojan horses on your system. str = 'the fifth letter is e'thing = 'e'str.sub! /\s+#{thing}\s+/, '' (lambda (x) (x x)) takes a function object, then invokes that object using one argument, the function object itself.This is then called with another function, which takes that function object under the parameter name fact-gen. It returns a lambda that takes the actual argument, n. This is how the ((fact-gen fact-gen) (sub1 n)) works.You should read the sample chapter (Chapter 9) from The Little Schemer if you can follow it. It discusses how to build functions of this type, and ultimately extracting this pattern out into the Y combinator (which can be used to provide recursion in general). You can do this:public static &lt;T extends Enum&lt;T&gt; &amp; XYZ&gt; void getEnumeration(Class&lt;T&gt; myEnum) { // ...}Here's an actual example I wrote to test out my concept:public class EnumTest { public enum Runnables implements Runnable { HELLO { @Override public void run() { System.out.print("Hello, "); } }, WORLD { @Override public void run() { System.out.println("world!"); } }; } public static &lt;T extends Enum&lt;T&gt; &amp; Runnable&gt; void getEnumeration(Class&lt;T&gt; myEnum) { for (Runnable runnable : myEnum.getEnumConstants()) runnable.run(); } public static void main(String[] args) { getEnumeration(Runnables.class); }} No. sizeof is an operator, and works on types, not the actual value (which is not evaluated).To remind you that it's an operator, I suggest you get in the habit of omitting the brackets where practical.int* ptr = 0;size_t size = sizeof *ptr;size = sizeof (int); /* brackets still required when naming a type */ Java works with UTF-16. So, if your input stream has astral characters, they will appear as a surrogate pair, i.e., as two chars. The first character is the high surrogate, and the second character is the low surrogate. If E is guaranteed to implement Comparable&lt;E&gt;, you can do this:if (comparator == null) { comparator = new Comparator&lt;E&gt;() { @Override public int compare(E lhs, E rhs) { return lhs.compareTo(rhs); } };} The idea is fine. I'd write it like so, though:def add_http uri uri =~ %r(https?://) ? uri : "http://#{uri}"endMuch simpler, and no leaning toothpicks! :-D It cannot be done in syntax-rules. End of story.Injecting an arbitrary identifier (x, in your case) into the output expression requires breaking hygiene, and syntax-rules does not provide any means to break hygiene. You will need to use a lower-level macro system to do this. MIT Scheme uses explicit renaming (see Matthias Benkard's answer), but for other Scheme implementations that use syntax-case, you can do it thus:(define-syntax funcify (lambda (stx) (syntax-case stx () ((_ body) (with-syntax ((x (datum-&gt;syntax stx 'x))) #'(lambda (x) body))))))The key is the (datum-&gt;syntax stx 'x) bit, which injects the symbol x as if it were in the syntactic context of the funcify invocation.By the way, your solv must also be a macro, not a procedure, but at least it can be a syntax-rules macro:(define-syntax solv (syntax-rules () ((_ lhs rhs) (solve (funcify lhs) (funcify rhs))))) Sure, just use apply:(apply + '(1 2 3 4 5 6)) ; same as (+ 1 2 3 4 5 6)(apply + 1 2 3 '(4 5 6)) ; ditto(apply + 1 2 3 4 5 '(6)) ; ditto(apply + 1 2 3 4 5 6 '()) ; ditto If you have SRFI 13 loaded, you can use string-join like so:(define b (string-join (map number-&gt;string temp-list))) SRFI 23 provides error. For error conditions, doing that is much better than calling exit, because it makes it possible for other code to catch the error and do error-handling. (Some implementations implement exit as an exception anyway, but that doesn't take away from my point that using error is more appropriate.)SRFI 34 provides a more complete exception facility, and can be even more appropriate than error. To have a message body part be inline instead of an attachment, do this:messageBodyPart.setDisposition(Part.INLINE); The standard idiom in Scheme for creating a list piecemeal is to prepend elements to the front, using cons, and not trying to set-cdr! the last cons cell in the list. At the end, when your list is done, you can then use reverse to get the elements in the correct order. This way, no list mutation is necessary per se.So if you're trying to create the list (1 2 3) piecemeal:Start off with the empty list, (), and cons 1 to it. This gives you (1).Then cons 2 to the list: (2 1)Then cons 3 to the list: (3 2 1)Finally, when you're done building the list, reverse it: (1 2 3)You may ask why this is "better". That's because accessing the last pair to set-cdr! is an O(n) operation; with linked lists, elements are not random-access, but are linear on the element position being accessed. Whereas, cons is always O(1).reverse is an O(n) operation, but as long as you're doing it only at the end (when you are ready to build the list in the correct order), rather than calling it all the time, that won't detrimentally affect performance. No. The trouble with the "current lambda" approach is that Scheme has many hidden lambdas. For example:All the let forms (including let*, letrec, and named let)do (which expands to a named let)delay, lazy, receive, etc.To require the programmer to know what the innermost lambda is would break encapsulation, in that you'd have to know where all the hidden lambdas are, and macro writers can no longer use lambdas as a way to create a new scope.All-round lose, if you ask me. Racket's documentation has an excellent tutorial on using macros.I would definitely recommend Scheme macros over CL macros if you haven't deal with any sort of Lisp macros before. That's because Scheme macros use pattern matching, and it's much easier to read.Example (using Racket's define-syntax-rule):(define-syntax-rule (let ((var val) ...) expr ...) ((lambda (var ...) expr ...) val ...))This is a very simple macro that defines let in terms of creating a corresponding lambda, then applying it. It's easy to read, and easy to reason about what it does.Slightly more complicated macro:(define-syntax let* (syntax-rules () ((let* () expr ...) (let () expr ...)) ((let* ((var val) next ...) expr ...) (let ((var val)) (let* (next ...) expr ...)))))This defines let* in terms of nested lets, so that the bindings are done sequentially. It includes a base case (with no bindings), as well as a recursive case. Here's how I'd do it in Racket:(require srfi/1 srfi/26)(define (digits-&gt;list num (base 10)) (unfold-right zero? (cut remainder &lt;&gt; base) (cut quotient &lt;&gt; base) num))This is the sort of problem unfold was designed for. :-D Easy!Set up your sudoers to not require a password for ipfw:user = NOPASSWD: /usr/sbin/ipfwUse sudo as usual. Any type? You could consider using Boost.Any. Then your type would be:std::map&lt;std::string, std::vector&lt;boost::any&gt; &gt; My answer has two parts: first, I'll implement a map-shortest, then I'll tweak that to implement map-longest since that's (barely) more involved. Both solutions require SRFI 1; the map-shortest solution uses unfold and any, and the map-longest solution uses unfold and every. (By the way, SRFI 1 also provides a map that works the same as map-shortest.)First, map-shortest:(define (map-shortest func . lists) (unfold (lambda (lists) (any null? lists)) (lambda (lists) (apply func (map car lists))) (lambda (lists) (map cdr lists)) lists))This is straightforward:It checks if any of the lists are empty. If so, stop.Otherwise, the car of each list is used as arguments to call the function with.Then, cdr through each list for the next iteration.Now, map-longest is a variation of that, except that you have to deal with the fact that some lists may already be empty:(define (map-longest func filler . lists) (define (car-or-filler x) (if (pair? x) (car x) filler)) (define (cdr-or-null x) (if (pair? x) (cdr x) '())) (unfold (lambda (lists) (every null? lists)) (lambda (lists) (apply func (map car-or-filler lists))) (lambda (lists) (map cdr-or-null lists)) lists))So, this is quite similar to map-shortest, with three differences:The termination condition is every, not any: we stop when every list is empty.Instead of car, we use car-or-filler, which gets the car if the list isn't empty, or the filler otherwise.Instead of cdr, we use cdr-or-null, which gets the cdr if the list isn't empty, or the empty list otherwise. (At this point, I can hear Common Lispers laughing: in Common Lisp, (cdr '()) returns '(); not so in Scheme.)Simple enough, hopefully? :-) In full Scheme, this is allowed. However, you are probably using one of the teaching variants of Scheme (such as Intermediate Student or Advanced Student) that Racket provides, which disallows functions with more than one expression.I'd say you can work around it by using begin, but Intermediate Student doesn't provide begin either (Advanced Student appears to, which helps). If you're using Intermediate Student, I guess you're just not meant to use multiple expressions, and that's that. :-) (define (func x y k) (some-procedure (lambda (ret) (if ret (- x 1 (lambda (ret) (func ret y k))) (k #f))))You are lacking a base case, which is why the only explicit call to the continuation is (k #f). If you have a base case, then you'd pass the base case return value to the continuation, also. For example:(define (func x y k) (zero? x (lambda (ret) (if ret (k y) (some-procedure (lambda (ret) (if ret (- x 1 (lambda (ret) (func ret y k))) (k #f)))))))) Here's my implementation. It's just to give you an idea how to approach this problem; I wrote it in a way that probably wouldn't pass for a homework submission (not that I'm presuming that's your intent at all). :-)(define (cached-assoc xs n) (define cache (make-vector n #f)) (define index 0) (define (fetch-cache k i) (if (or (negative? i) (&lt; i (- index n))) #f (let ((cur (vector-ref cache (modulo i n)))) (if (equal? (car cur) k) cur (fetch-cache k (sub1 i)))))) (define (update-cache val) (vector-set! cache (modulo index n) val) (set! index (add1 index)) val) (lambda (k) (cond ((fetch-cache k (sub1 index))) ((assoc k xs) =&gt; update-cache) (else #f)))) If you are using R6RS hashtables, you can use the hashtable-keys and hashtable-entries functions.If you're using Guile's native hashtables, you can use hash-map-&gt;list, hash-for-each, hash-for-each-handle, or hash-fold.So for your example, using Guile's hash-for-each, you'd do:(use-modules (ice-9 hash-table))(define my-hash (make-hash-table))(hash-set! my-hash "one" 1)(hash-set! my-hash "two" 2)(hash-set! my-hash "three" 3)(hash-for-each (lambda (key value) (format #t "~a =&gt; ~a~%" key value)) my-hash) (current-input-port my-port)Don't do this at the racket REPL! This will cause all subsequent REPL input to come from that source. (It's okay to run inside DrRacket, however, even in the DrRacket REPL.) You should be able to just use '\u2602' and have that do the Right Thing. When a datum is quoted, nothing within is evaluated. For example:fooevaluates to the value bound to the identifier foo, whereas'fooor(quote foo)evaluates to the symbol foo.Likewise,(+ 1 2 3)evaluates to 6, whereas'(+ 1 2 3)or(quote (+ 1 2 3))evaluate to a list with four elements: the symbol +, and the numbers 1, 2, and 3. In particular, the + is not evaluated.Similarly, your name and mode, both being within the quoted datum, are not treated as identifiers, but as symbols. They are not evaluated. From the stack trace, it looks like you have a very deep widget nesting structure! That is the cause of the stack overflow, not so much the getChars. If you can, consider simplifying your widget tree, so widgets aren't so deeply nested. To expand on Basile's answer:(1 2)is a proper list of length two. That is, it contains two cons cells:#1=(1 . #2#)#2=(2 . ())On the other hand,(1 . 2)is an improper list of length one. That is, it contains one cons cell:#1=(1 . 2)A non-empty proper list is a list where the last cons cell's cdr that contains the empty list, (). A non-empty improper list is a list where the last cons cell's cdr contains anything else. Yes.You must actually call matches() or find() on the matcher first.Your regex must actually contain capturing groupsExample:Pattern p = Pattern.compile("[A-Z](\\d*),(\\d*)");matcher m = p.matcher("H3,4");if (m.matches()) { // use m.group(1), m.group(2) here} By default, Racket does not provide mutable pairs, and thus no mutable lists either. That means that the values of pairs and lists are unchangeable.However, you can (require racket/mpair), which, as the name implies, provides mutable pairs. You then use mcons, mcar, mcdr, mlist, etc. instead of cons, car, cdr, list. Sure, just use apply:(defun wraptest (&amp;rest arguments) (apply #'test arguments))This technically doesn't "break out of list"; it simply uses a list's elements as arguments to a function call.(Disclaimer: I'm a Schemer, not a Common Lisper, and there may be a more-idiomatic way to achieve the same result in CL.) Non-rigorous (sorry if this is for homework ;-)) but practical answer: all mutations (i.e., both functions in your case) must be synchronised in order to have predictable results. If you want to be able to change the field value, make the field volatile if you want changes to the field to be visible to other threads without having to use other happens-before mechanisms. (Reading and writing a volatile field are happens-before events.)Of course, if you always use other happens-before systems (e.g., synchronized, mutex locks, BlockingQueue, Exchanger, setting the field value before creating the thread you're sending it to, etc.), then volatile isn't necessary. But that is more fragile, because if you later change code such that no happens-before happens any more, then you've created a bug. You should use the Racket Simply Scheme module. The file you have linked to is not compatible with Racket.More specifically, in Racket, you're not allowed to use set! to overwrite existing function bindings, which is what that file does. (Technically, it can potentially break other Scheme implementations also, so this isn't a "Racket quirk" or anything.) In Lisp, each set of brackets is significant. You cannot add extra brackets willy-nilly. In particular, if you see double opening brackets outside of a let form's variable bindings, you are probably doing something wrong.In the first branch of your if, you probably need to use progn.In the second branch of your if, the (+ n 1) is in the wrong place. Instead, change the (char line n) to (char line (+ n 1)).Thus:(if (or ...) (progn (vector-push-extend temp-word *word-array-2*) (return-from add-word-2 n)) (vector-push-extend (char line (+ n 1)) temp-word))Having said this, I have no idea what your function is trying to do, so the above is just a best guess. ;-) To expand on the "mutability makes parallelism hard" concept, when you have multiple cores going, you have to use synchronisation if you want to modify something from one core and have it be seen consistently by all the other cores.Getting synchronisation right is hard. If you over-synchronise, you have deadlocks, slow (serial rather than parallel) performance, etc. If you under-synchronise, you have partially-observed changes (where another core sees only a portion of the changes you made from a different core), leaving your objects observed in an invalid "halfway changed" state.It is for that reason that many functional programming languages encourage a message-queue concept instead of a shared state concept. In that case, the only shared state is the message queue, and managing synchronisation in a message queue is a solved problem. Standard Lisp lists cannot be appended to in constant time.However, if you make your own list type, you can do it. Basically, you can use a record type (or just a cons cell)---let's call this the "header"---that holds pointers to the head and tail of the list, and update it each time someone adds to the list.However, be aware that if you do that, lists are no longer structurally inductive. i.e., a longer list isn't simply an extension of a shorter list, because of the extra "header" involved. Thus, you lose a great part of the simplicity of Lisp algorithms which involve recursing into the cdr of a list at each iteration.In other words, the lack of easy appending is a tradeoff to enable recursive algorithms to be written much more easily. Most functional programmers will agree that this is the right tradeoff, since appending in a pure-functional sense means that you have to copy every cell in all but the last list---so it's no longer O(1), anyway.ETA to reflect OP's editYou can create a queue, but with the opposite behaviour: you add elements to the back, and retrieve elements in the front. If you are willing to work with that, such a data structure is easy to implement in Scheme. (And yes, it's easy to append two such queues in constant time.)Racket also has a similar queue data structure, but it uses a record type instead of cons cells, because Racket cons cells are immutable. You can convert your queue to a list using queue-&gt;list (at O(n) complexity) for times when you need to fold. Vendor IDs are a scarce resource, just like OUIs (top 3 octets of MAC address) and IPv4 addresses are. They have to be allocated so others don't use IDs/addresses that collide with yours. The cost just raises the barrier to allocation, so everybody doesn't land-grab willy-nilly.It would be nice to have a "private" range, much like RFC1918 addresses (10/8, 172.16/12, and 192.168/16), that people who don't care about collisions can use. Comparisons between alists and hash tables (which Dictionary uses), since nobody seems to have touched on this yet:Alists:Are simple to implement (just a list of pairs)Have linear-time lookup (thus only useful for small lists)Hash tables:Take a little more effort to implement (in particular, you must implement a stable hash function for keys)Have amortised constant-time lookup Literal lists ('(foo bar baz), as opposed to (list 'foo 'bar 'baz)) are not allowed to be mutated. If you do, that "is an error" (i.e., the behaviour is undefined).In this case, what you are observing is that the literal '(he said:) is being reused over and over, with the understanding that it's not going to get mutated. Since you violated that understanding, you get the weird behaviour you saw.In contrast, when you use (list 'he 'said:), a new list is returned every time. In Scheme, functions are objects like numbers, strings, etc. So in this case, your example is equivalent to this:(define (equal-length x y) (= (string-length x) (string-length y)))(splitby '("a" "b" "cc" "ab" "abc" "a" "b") equal-length)The use of the function is to allow the splitting criterion to be customised. In this case, items are in the same group for as long as the given function returns a true value; otherwise a new group is created.To get started, write a group-equal function, that groups equal elements together:(define (group-equal lst) ...)where, for example,(group-equal '(1 2 2 3 3 3 4))returns((1) (2 2) (3 3 3) (4))If you successfully implement that, then it's identical to your splitby function, except that you use the given function (equal-length, for example) instead of equal? (as group-equal might use). See Integer Exponentiation. Hint: choose either of the bottom two functions. Sure, you can do this:(defun foo (fn) (mapcar fn '(1 2 3)))Examples:(foo #'(lambda (x) (* x 2)))(foo #'1+)(foo #'sqrt)(foo #'(lambda (x) (1+ (* x 3)))) tl;dr version: Add -Wl,--no-as-needed to the link command.After a series of experimentation and conversations with the OP, I've figured out what's going on.In the latest version of Ubuntu, ld uses --as-needed by default. What that does is to remove references to libraries that are not explicitly required.The way Hoard works is as an LD_PRELOAD library. i.e., you are not supposed to need to use functions in libhoard.so directly. Of course, you could link in libhoard directly if you wanted to...unless --as-needed is used, of course.After discovering this, the solution is simple. Just add -Wl,--no-as-needed to the gcc linking command. Here's my implementation (now fixed to use call-site's car and cdr, so you can redefine them and they will work correctly):(define-syntax (biteme stx) (define (id-&gt;string id) (symbol-&gt;string (syntax-&gt;datum id))) (define (decomp id) (define match (regexp-match #rx"^c([ad])(.*)r$" (id-&gt;string id))) (define func (case (string-ref (cadr match) 0) ((#\a) 'car) ((#\d) 'cdr))) (datum-&gt;syntax id (list func (string-&gt;symbol (format "c~ar" (caddr match)))))) (syntax-case stx () ((_ (c*r x)) (regexp-match #rx"^c[ad]+r$" (id-&gt;string #'c*r)) (with-syntax (((a d) (decomp #'c*r))) (syntax-case #'d (cr) (cr #'(a x)) (_ #'(a (biteme (d x)))))))))Examples:(biteme (car '(1 2 3 4 5 6 7))) ; =&gt; 1(biteme (cadr '(1 2 3 4 5 6 7))) ; =&gt; 2(biteme (cddddr '(1 2 3 4 5 6 7))) ; =&gt; (5 6 7)(biteme (caddddddr '(1 2 3 4 5 6 7))) ; =&gt; 7(let ((car cdr) (cdr car)) (biteme (cdaaaaar '(1 2 3 4 5 6 7)))) ; =&gt; 6 In the Preface of The Reasoned Schemer, they explain it thus: A relation, a function that returns a goal as its value, ends its name with a superscript 'o' (e.g., caro and nullo).So, it's a notation to denote a relation. Óscar López's answer is correct, but doesn't explain why normal pairs are immutable.In Racket (and its predecessor, PLT Scheme, since version 4), cons cells are immutable by default. Most Scheme programs never need to modify cons cells, and having them be immutable allows many optimisations. (For example, list? and length can both be constant-time.)For cases where mutability is needed, there's mpair (as mentioned), and more usefully, there's boxes. Macro "arguments" are not evaluated. So, when you pass in '(1 2 3), i.e., (quote (1 2 3)), that is exactly what the macro sees.P.S. You are much better off using hygienic macros in Scheme. Here's an example using syntax-case:(define-syntax mult2 (lambda (stx) (define (double x) #`(* 2 #,x)) (syntax-case stx () ((_ lst) #`(list #,@(map double (syntax-e #'lst)))))))(That's still not how such a macro is idiomatically written, but I tried to mirror your version as closely as possible.) With syntax-case and its guard support:(define-syntax translate (lambda (stx) (syntax-case stx () [(_ v) (identifier? #'v) #'(symbol-&gt;string 'v)] [(_ v) (number? (syntax-e #'v)) #'(number-&gt;string v)])))(I've used square brackets for easy comparison with Eli's answer, however, it's not my usual style. ;-))But if you're using syntax-case, then you can just as well do the conversion at the syntax level instead of producing code that does it at runtime:(define-syntax translate (lambda (stx) (syntax-case stx () [(_ v) (identifier? #'v) (datum-&gt;syntax stx (symbol-&gt;string (syntax-&gt;datum #'v)))] [(_ v) (number? (syntax-e #'v)) (datum-&gt;syntax stx (number-&gt;string (syntax-&gt;datum #'v)))])))The main thing here is that the macro code is now plain scheme, for example, you could abstract the common parts into a helper:(define-syntax translate (lambda (stx) (define (rewrap convert x) (datum-&gt;syntax stx (convert (syntax-&gt;datum x)))) (syntax-case stx () [(_ v) (identifier? #'v) (rewrap symbol-&gt;string #'v)] [(_ v) (number? (syntax-e #'v)) (rewrap number-&gt;string #'v)])))Along the same lines, if this macro is so simple, then there's no real need for syntax-case, other than pulling out the subexpression:(define-syntax translate (lambda (stx) (syntax-case stx () [(_ v) (let ([d (syntax-&gt;datum #'v)]) (datum-&gt;syntax stx ((cond [(number? d) number-&gt;string] [(symbol? d) symbol-&gt;string]) d)))])))Note, BTW, that there is no magic in syntax-case -- and in the case of this simple pattern, you could just pull out the value yourself:(define-syntax translate (lambda (stx) (let ([d (cadr (syntax-&gt;datum #'v))]) (datum-&gt;syntax stx ((cond [(number? d) number-&gt;string] [(symbol? d) symbol-&gt;string]) d)))))There is some boilerplate stuff that syntax-case does that this last version loses:If you use the macro in an unexpected way like (translate) then this version will throw an error about cadr instead of a more comprehensible syntax errorSimilarly, if you use (translate 1 2) then this version will just silently ignore the 2 instead of an error.And if it's used with something that is neither an identifier nor a number (eg, (translate (+ 1 2))) then this will depend on the unspecified value that cond returns rather than throwing a syntax error. Jon's answer is very good. You should try to implement it as much as you can. If you need to, you can also refer to my answer here (which doesn't follow Jon's approach since I wrote most of my answer before he posted his):(define (fun nums) (lambda (x) (let loop ((nums nums) (value x)) (if (null? nums) value (let ((num (car nums)) (rest (cdr nums))) (cond ((positive? num) (loop rest (+ value num))) ((negative? num) (loop rest (* value num))) ((zero? num) (loop rest (* value value)))))))))You should study it to see how it works, then write your own version using a completely different approach, like Jon's idea about using compose. :-)Edit: The function I wrote can be simplified further: using SRFI 1's fold, you can do this:(define (fun nums) (define (step num value) (cond ((positive? num) (+ value num)) ((negative? num) (* value num)) (else (* value value)))) (lambda (x) (fold step x nums))) You can implement a Y combinator using call/cc, as described here. (Many thanks to John Cowan for mentioning this neat post!) Quoting that post, here's Oleg's implementation: Corollary 1. Y combinator via call/cc -- Y combinator without an explicit self-application.(define (Y f) ((lambda (u) (u (lambda (x) (lambda (n) ((f (u x)) n))))) (call/cc (call/cc (lambda (x) x))))) Here, we used a fact that((lambda (u) (u p)) (call/cc call/cc)) and((lambda (u) (u p)) (lambda (x) (x x))) are observationally equivalent. In Scheme's read syntax, a standalone dot is special. '. won't get you a dot symbol; it's invalid syntax. (If it works in your implementation, then that's just a special quirk of your implementation.)Instead, you have to escape it. In most Scheme implementations, you can either use '|.| or '\..(car '(\. a)) ; returns the same thing as (string-&gt;symbol ".")(car '(|.| a)) ; likewise I think it's best if you take command0 and command1's values as a single string. e.g.,wrapper --command0 "/path0/benchmark0 ..." --command1 "/path1/benchmark1 ..."Yes, there's more work for you in that you have to wordexp your respective command strings (unless you're already just passing those strings straight to the shell ;-)), but it more cleanly separates out what's for the wrapper and what's for the invoked commands. call/cc calls the given function with the current continuation as its sole argument. Thus, k here is the current continuation. When you call it with a value, the call/cc will return with the value you gave. (Though, since you're not using call/cc's return value in your code above, and since R6RS allows zero-valued returns in that case, you can just call saved-cont with no arguments and still do what you expect.)Here, basically, every time you call (saved-cont), the code below the call/cc will run again. Thus, x will increment, and its new value will display. Scheme doesn't have a concept of a "keyword" (at least not the type you're talking about; some implementations like Racket and Guile have keywords for keyword arguments, like #:foo). Thus, from what I read from your question, anything that's read in as a symbol will be used as an identifier when evaluated. Thus, symbol? is sufficient.If you actually do want to test for Racket keywords, you can use keyword?. Such keywords do not pass the symbol? test.-&gt; (symbol? 'foo)#t-&gt; (keyword? 'foo)#f-&gt; (symbol? '#:foo)#f-&gt; (keyword? '#:foo)#t Another approach is tree sort, which is like insertion sort (@soegaard's solution) but with better time complexity. Here, you start with an empty tree as the initial value, and build the tree up at each fold iteration. By the way, there is a faster way to implement integer exponentiation. Rather than multiplying x over and over again, y times (which makes it O(y)), there is an approach that is O(log y) in time complexity:(define (integer-expt x y) (do ((x x (* x x)) (y y (quotient y 2)) (r 1 (if (odd? y) (* r x) r))) ((zero? y) r)))If you dislike do (as many Schemers I know do), here's a version that tail-recurses explicitly (you can also write it with named let too, of course):(define (integer-expt x y) (define (inner x y r) (if (zero? y) r (inner (* x x) (quotient y 2) (if (odd? y) (* r x) r)))) (inner x y 1))(Any decent Scheme implementation should macro-expand both versions to exactly the same code, by the way. Also, just like Óscar's solution, I use an accumulator, only here I call it r (for "result").) SRFI 89 was written by Gambit's author, so it's only fair to assume that Gambit's define* does what that document says. :-)In other words, it's syntactic sugar over lambda* (as described in SRFI 89) rather than lambda. For the specifics of your question (rather than general techniques), here's how I might go about it:(int -&gt; ((int -&gt; (bool -&gt; int)) -&gt; (bool -&gt; int))) can be simplified to (A -&gt; ((A -&gt; B) -&gt; B)) where A = int and B = (bool -&gt; int). This simplified version is easy to construct:(lambda (a) (lambda (f) (f a)))It's easy to see why this works: a has type A, and f has type (A -&gt; B), so calling (f a) will result in B. To put concrete types to those variables, a has type int, f has type (int -&gt; (bool -&gt; int)), and the result is, of course, (bool -&gt; int).So, now you need to find a suitable function that has type (int -&gt; (bool -&gt; int)) to slot into the f parameter. This is pretty simple to make an example of:(lambda (n) (lambda (negate?) ((if negate? - +) n)))And here's how you might use those functions:&gt; (define (foo a) (lambda (f) (f a)))&gt; (define (bar n) (lambda (negate?) ((if negate? - +) n)))&gt; (define baz ((foo 42) bar))&gt; (baz #t)-42&gt; (baz #f)42 Ouch:Using this style of while loop encourages excessive use of imperative programming.Using define-macro creates unhygienic macros, which is a nightmare in Scheme.While I don't encourage writing an imperative-style loop macro, for your reference, here's a non-define-macro version of the same macro:(define-syntax-rule (my-while condition body ...) (let loop () (when condition body ... (loop))))It uses syntax-rules, which creates hygienic macros, and is much, much easier to read than what you have.Now, for the actual answer for your question, first, let's write your original macro out in a more readable way:(define-macro my-while (lambda (condition body) `(local ((define (while-loop) (if ,condition (,body (while-loop)) (void)))) (while-loop))))Once you write it out this way, you can see where the real problem is: in the (,body (while-loop)) line, which should instead have been (begin ,body (while-loop)). I believe that in Scheme, portability is a fool's errand, since Scheme implementations are more different than they are similar, and there is no single implementation that other implementations try to emulate (unlike Python and Ruby, for example).Thus, portability in Scheme is analogous to using software rendering for writing games "because it's in the common subset between OpenGL and DirectX". In other words, it's a lowest common denominator—it can be done, but you lose access to many features that the implementation offers.For this reason, while SRFIs generally have a portable reference implementation (where practical), some of them are accompanied by notes that a quality Scheme implementation should tailor the library to use implementation-specific features in order to function optimally.A prime example is case-lambda (SRFI 16); it can be implemented portably, and the reference implementation demonstrates it, but it's definitely less optimal compared to a built-in case-lambda, since you're having to implement function dispatch in "user" code.Another example is stream-constant from SRFI 41. The reference implementation uses an O(n) simulation of circular lists for portability, but any decent implementation should adapt that function to use real circular lists so that it's O(1).†The list goes on. Many useful things in Scheme are not portable—SRFIs help make more features portable, but there's no way that SRFIs can cover everything. If you want to get useful work done efficiently, chances are pretty good you will have to use non-portable features. The best you can do, I think, is to write a façade to encapsulate those features that aren't already covered by SRFIs.† There is actually now a way to implement stream-constant in an O(1) fashion without using circular lists at all. Portable and fast for the win! TL;DR: Use named let (if you are executing a recursive function immediately) or rec (if you are saving the recursive function for later execution).The usual way is with letrec, or something that uses a letrec behind the scenes, like named let or rec. Here's a version of (factorial 10) using letrec:(letrec ((factorial (lambda (x) (if (&lt; x 1) 1 (* (factorial (- x 1)) x))))) (factorial 10))And the same thing using named let:(let factorial ((x 10)) (if (&lt; x 1) 1 (* (factorial (- x 1)) x)))The key understanding here is that both versions are exactly the same. A named let is just a macro that expands to the letrec form. So because the named let version is shorter, that is usually the preferred way to write a recursive function.Now, you might ask, what if you want to return the recursive function object directly, rather than execute it? There, too, you can use letrec:(letrec ((factorial (lambda (x) (if (&lt; x 1) 1 (* (factorial (- x 1)) x))))) factorial)There, too, is a shorthand for this, although not using named let, but instead using rec:(rec (factorial x) (if (&lt; x 1) 1 (* (factorial (- x 1)) x)))The nice thing about using rec here is that you can assign the function object to a variable and execute it later.(define my-fact (rec (factorial x) (if (&lt; x 1) 1 (* (factorial (- x 1)) x))))(my-fact 10) ; =&gt; 3628800The more theoretical and "pure" way to create recursive functions is to use a Y combinator. :-) But most practical Scheme programs do not use this approach, so I won't discuss it further. Special forms are not functions: functions take values as arguments, whereas special forms take forms. For example, look at your example of if:(if 1 2 3)Okay, that's easy, since 2 and 3 are already values. But what about this?(define (modadd a b n) (if (zero? n) #f (modulo (+ a b) n)))In this case, the if is actually receiving the #f and (modulo (+ a b) n) as forms, not as values. And this is important! (modulo x n) will fail if n is 0: that is why it's left unevaluated until we know that n is not 0.The trouble with being able to pass special forms as first-class objects is that higher-order functions cannot call those objects using predictable semantics: is it a function object, so that you're passing in values, or is it a special form, so that you're passing in forms? This gets to be a huge mess.Yes, you can write a wrapper function, like my modadd, that encapsulates if. However, there is no way you can just reimplement if as a function, while still preserving the only-evaluate-one-of-the-branches behaviour. Consider the following code:(call-with-values (lambda () (call/cc (lambda (k) (k k k)))) (lambda (x y) (procedure-arity y)))It's pretty obvious here that the continuation at the point of the call/cc call is the lambda on the right-hand side, so its arity should be 2. However, the return value of the above (in Racket) is (arity-at-least 0) instead.Indeed, running similar code in Guile (substituting procedure-minimum-arity for procedure-arity) shows that the continuation also supposedly allows any number of arguments, even though it's pretty clearly not the case.So, why is that? As far as I understand (correct me if my understanding is wrong), the arity of a continuation is pretty straightforward: it's 1 except in the context of call-with-values, in which case it's whatever the arity of the right-hand-side lambda is. (Which, granted, can be complicated if it's a case-lambda or the like, but no more complicated than if you were calling (procedure-arity (case-lambda ...)) directly.) You are correct that there are parallels between the define and letrec versions of your code. However, the devil is in the details. In R5RS, internal define has letrec semantics. In R6RS, internal define has letrec* semantics.What's the difference? Your code has actually just highlighted this difference. As Zhehao's answer mentions, your definition of total and count inside the same letrec as the length and sum is incorrect: length and sum are not guaranteed to be bound by the time you're evaluating the values of (length elems) and (sum elems), since the binding of those variables is not guaranteed to be left-to-right.letrec* is similar to letrec, but with a left-to-right guarantee. So if you changed your letrec to letrec*, it'd be okay.Now, back to my initial comment: because R5RS's internal define uses letrec semantics, even your define version of the code would be incorrect under an R5RS implementation, but it would be okay under an R6RS implementation, which has letrec* semantics. No, there are no standard operators for these. But identical-head is not hard to write:(defun identical-head (l1 l2) (and l1 l2 (equal (car l1) (car l2)) (cons (car l1) (identical-head (cdr l1) (cdr l2)))))I don't know of an easier way to write identical-tail except reversing the input lists, calling identical-head, and then reversing the result, since lists only allow forward traversal, not backward.(defun identical-tail (l1 l2) (reverse (identical-head (reverse l1) (reverse l2))))Here's how I'd write identical-tail-head:(defun identical-tail-head (l1 l2) (labels ((starts-with-p (list prefix) (cond ((null prefix) t) ((null list) nil) ((equal (car list) (car prefix)) (starts-with-p (cdr list) (cdr prefix)))))) (cond ((null l1) nil) ((starts-with-p l2 l1) l1) (t (identical-tail-head (cdr l1) l2)))))It's not a very efficient way to do it, since it's O(n²), but (again) given that lists are forward-traversal-only, I haven't come up with a better way. You can't use up-from standalone like that. It only works inside of a loop form:&gt; (loop ((for x (up-from 0 (to 20) (by 2)))) (display x) (newline))024681012141618 In Scheme implementations with a Tiny-CLOS-like object system, you can just use class-of. Here's a sample session in Racket, using Swindle:$ racket -I swindleWelcome to Racket v5.2.1.-&gt; (class-of 42)#&lt;primitive-class:exact-integer&gt;-&gt; (class-of #t)#&lt;primitive-class:boolean&gt;-&gt; (class-of 'foo)#&lt;primitive-class:symbol&gt;-&gt; (class-of "bar")#&lt;primitive-class:immutable-string&gt;And similarly with Guile using GOOPS:scheme@(guile-user)&gt; ,use (oop goops)scheme@(guile-user)&gt; (class-of 42)$1 = #&lt;&lt;class&gt; &lt;integer&gt; 14d6a50&gt;scheme@(guile-user)&gt; (class-of #t)$2 = #&lt;&lt;class&gt; &lt;boolean&gt; 14c0000&gt;scheme@(guile-user)&gt; (class-of 'foo)$3 = #&lt;&lt;class&gt; &lt;symbol&gt; 14d3a50&gt;scheme@(guile-user)&gt; (class-of "bar")$4 = #&lt;&lt;class&gt; &lt;string&gt; 14d3b40&gt; Yes. The obvious solution involves calling map twice and then consing together the two results. You'll be looking forward to Java 8, then! It will have Project Lambda included, which has a much, much nicer syntax for closure-like anonymous classes.† Example:Iterable&lt;String&gt; strs = ...Iterable&lt;String&gt; downCased = strs.map(s -&gt; s.toLowerCase());Any interface with one method (or abstract class with one abstract method) can use this syntax, including Guava's Function and Predicate (though Java 8 has its own Mapper and Predicate interfaces, so these are usable out of the box). In this case Iterable.map is a new extension method that takes a new interface type called Mapper.If you'd like more examples of Java 8 lambdas, just ask!† All the usual restrictions of anonymous classes still apply, including that local free variables must be "effectively final". This means you don't have to explicitly tag the variable as final, but you're still not allowed to alter the value. A, B -> A(number -> A) -> A(A -> B), A -> BA, A, (A, A -> boolean) -> A(the last assumes that x and y are the same types) As seen in the base case in the code, your collector/continuation must take 3 arguments. It seems you passed in a function which doesn't.It's good you worked through multirember&amp;co: I wrote an answer about it, which you may wish to review.Anyway, a general approach in testing these collector/continuations is to start by using list as your continuation, since list is variadic and simply returns the items given as a list. Here's an example:&gt; (multiinsertLR&amp;co 'foo 'bar 'baz '(foo bar baz qux quux) list)'((foo foo bar baz foo qux quux) 1 1)Oh, I see two foos! Which one was inserted, and which one was in the original list?&gt; (multiinsertLR&amp;co 'foo 'bar 'baz '(goo bar baz qux quux) list)'((goo foo bar baz foo qux quux) 1 1)Ah, so we're on to something! Any time the list contains a bar, foo is inserted before it; and any time the list contains a baz, foo is inserted after it. But the numbers?&gt; (multiinsertLR&amp;co 'foo 'bar 'baz '(baz goo bar baz qux bar quux baz) list)'((baz foo goo foo bar baz foo qux foo bar quux baz foo) 2 3)Those numbers look like counters! Each "left" insertion increments the first counter, and each "right" insertion increments the second counter.In looking at the code, if you look at each of the branches of the cond, you will see what happens in a left-match case, a right-match case, and a not-match case (and of course, an end-of-list case, which sets up the base/initial value). Notice how the insertion (and counter increment) happens in each case. Since you already get multirember&amp;co, this should be fairly easy from here on. All the best! I dislike all of the string-based solutions.The best way to do it, in my view, is to look at each digit by dividing (and modding) by 10 at each stage, then comparing. Example:(define (count-digit num digit) (let loop ((num num) (count 0)) (if (zero? num) count (loop (quotient num 10) (+ count (if (= digit (remainder num 10)) 1 0)))))) If your Scheme implementation supports SRFI 60, you can simply use:(logand n 1)(bitwise-and is a synonym that some Scheme implementations prefer, so if you don't have logand, check for bitwise-and too.)Otherwise, if you are willing to assume you're on a two's-complement system (all mainstream platforms are), you can also use odd? or even?:(if (odd? n) 1 0) [All the code snippets here require SRFI 1 to be loaded first.]What you seem to be wanting is to zip the lists:&gt; (zip '(1 2 3) '(4 5))((1 4) (2 5))However, as you can see, this stops when it gets to the end of the shortest list. Maybe you can write a custom zip that will stop after all elements are exhausted:(define (my-zip l1 l2) (cond ((and (null? l1) (null? l2)) '()) ((null? l1) (cons (car l2) (my-zip l1 (cdr l2)))) ((null? l2) (cons (car l1) (my-zip (cdr l1) l2))) (else (cons* (car l1) (car l2) (my-zip (cdr l1) (cdr l2))))))Let's try it out!&gt; (my-zip '(1 2 3) '(4 5))(1 4 2 5 3)&gt; (my-zip '(1 2 3) '(4 5 6 7))(1 4 2 5 3 6 7) Andrew has the right idea, but with Perl-style regex syntaxes (which includes Java's built-in regex engine), you can do even better:str.replaceAll("\\[.*?\\]", "");(i.e., use the matching expression \[.*?\]. The ? specifies minimal match: so it will finish matching upon the first ] found.) Having an if within a cond condition is usually a sign of doing something wrong. I think you meant to say this:(define prefix (lambda (pf ls) (cond [(null? pf) #t] [(null? ls) #f] [(equal? (car pf) (car ls)) (prefix (cdr pf) (cdr ls))] [else #f]))) What you have is fine, except that if you want 100000 to return 0, then change the &lt; to &lt;=. :-) Here's one way to do it, by making the regex case-sensitive by default and marking the insensitive section:&gt; pattern = /(?i:hello, my name is) Bartholomew/=&gt; /(?i:hello, my name is) Bartholomew/&gt; pattern =~ 'Hello, my Name is Bartholomew'=&gt; 0&gt; pattern =~ 'Hello, my Name is bartholomew'=&gt; nilThe other way to do it is to make the regex case-insensitive by default, and marking the sensitive section:&gt; pattern = /hello, my name is (?-i:Bartholomew)/i=&gt; /hello, my name is (?-i:Bartholomew)/i&gt; pattern =~ 'Hello, my Name is Bartholomew'=&gt; 0&gt; pattern =~ 'Hello, my Name is bartholomew'=&gt; nil You're missing an opening parenthesis before the lambda, and the let form is missing a body. Also, you can't use let for defining recursive functions; you need to use letrec (for Scheme) or labels (for Common Lisp). Perhaps you meant this (Scheme):(letrec ((exp (lambda (x y) (if (= y 1) x (* (exp x (- y 1)) x))))) exp) You should add (require (only-in srfi/1 fold-right)) to the top of your code. The continuation in this case is the "thing" that receives the return value of the call/cc invocation. Thus:(display (call/cc (lambda (k) (k 12)))has the same result as(display 12)Continuations in Scheme "look and feel" like procedures, but they do not actually behave like procedures. One thing that can help you understand continuations better is CPS transformations.In CPS transformation, instead of a function returning a value, instead it takes a continuation parameter, and invokes the continuation with the result. So, a CPS-transformed sqrt function would be invoked with (sqrt 64 k) and rather than returning 8, it just invokes (k 8) in tail position.Because continuations (in a CPS-transformed function) are tail-called, the function doesn't have to worry about the continuation returning, and in fact, in most cases, they are not expected to return.With this in mind, here's a simple example of a function:(define (hypot x y) (sqrt (+ (* x x) (* y y))))and its CPS-transformed version:(define (hypot x y k) (* x x (lambda (x2) (* y y (lambda (y2) (+ x2 y2 (lambda (sum) (sqrt sum k))))))))(assuming that *, +, and sqrt have all been CPS-transformed also, to accept a continuation argument).So now, the interesting part: a CPS-transformed call/cc has the following definition:(define (call/cc fn k) (fn k k))With CPS transformation, call/cc is easy to understand and easy to implement. Without CPS transformation, call/cc is likely to require a highly magical implementation (e.g., via stack copying, etc.). Skeleton solution:(define (zip l1 l2) (cond ((null? l1) l2) ((null? l2) l1) (else (cons ??? (cons ??? (zip ??? ???))))))Fill in the ??? yourself. :-) What you have is on the wrong track, sorry. (Think about what the result should be if given an empty input.) Similar to my answer to your last question, here's a skeleton solution:(define (unzip l) (if (null? l) ??? (let ([next (unzip ???)]) (list (cons ??? ???) ???))))Fill in the ???s appropriately. (Yes, my solution is tested and works for both odd and even inputs.) First, note that the let is macro-expanded to the following:((lambda (a) (a 4)) (lambda (x) (+ 1 x)))So, now, let's CPS-transform the above, and we get:((lambda (a k) (a 4 k)) (lambda (x k) (+ 1 x k)) k)where the k on the final line is the continuation your original let uses.If all those ks look too confusing, here's the same code:((lambda (a k1) (a 4 k1)) (lambda (x k2) (+ 1 x k2)) k0)where the k0 is the original continuation.In both cases, I assume that + is also similarly CPS-transformed to take a continuation to pass the result of the addition to.... Think about how you would implement append (or, more generally, think about how you would implement a right-fold). Now, if you append a list to a singleton list containing your element-to-add, you've basically appended your element.(Obviously, this is O(n), so don't add elements individually this way.)Here's a solution using a right-fold:(define (append-element lst elem) (foldr cons (list elem) lst))and a solution using append:(define (append-element lst elem) (append lst (list elem)))So if you can implement either foldr or append yourself, using the operations you've listed (it's easy! try it), you're good to go.P.S. In fact, you can implement append using a right-fold:(define (append lst1 lst2) (foldr cons lst2 lst1))but that still leaves you to implement foldr yourself. ;-) (Hint: it's easy. Look at my implementation of left-fold for starting ideas.) The idea here is not to use a global variable, but instead to keep the count "in the stack".Here's a Scheme solution. I'm sure you'll be able to convert this to whatever Lisp dialect you're using:(define (count-a lst) (cond ((null? lst) 0) ((eq? (car lst) 'a) (+ (count-a (cdr lst)) 1)) (else (count-a (cdr lst)))))If that's not DRY enough for you, here's a more condensed version:(define (count-a lst) (if (null? lst) 0 (+ (count-a (cdr lst)) (if (eq? (car lst) 'a) 1 0)))) In Java, you have to have boolean values on both sides of ||. And, neither one % 6 nor one % 17 are boolean. However, one % 6 != 0 and one % 17 != 0 are. It seems you're very close. Try this (untested):(define (size tree) (if (null? tree) 0 (+ 1 (size (left tree)) (size (right tree)))))Though, personally, I would much rather prefer to use #f as the null value, rather than '(). In that case, use not instead of null? in the first line. You can use closures to store anything you want.Here's the solution I wrote, with a few details removed to give you some space to think. :-)(define (copy-first-to-end lst) (define top ???) (define (inner lst) (if (null? lst) ??? (cons ??? (inner ???)))) (inner ???))In this case, inner is a closure that, among other things, has access to the top variable (which you will use to stash your value of interest). The point of a higher-order function is to reduce the boilerplate in your code, and to decrease coupling between the looping (technically it's a recursion, but its purpose is looping, so I will refer to it as such) and the actual logic. Here's an example (re grabbing all the odd numbers): a manual loop would look like this:(define (filter-odd lst) (cond ((null? lst) '()) ((odd? (car lst)) (cons (car lst) (filter-odd (cdr lst)))) (else (filter-odd (cdr lst)))))But notice that you've got the looping and the filtering in one function. This makes it harder to figure out what the function is doing, since these two unrelated operations are coupled together. With higher-level functions, you can do differently:(define (filter pred lst) (cond ((null? lst) '()) ((pred (car lst)) (cons (car lst) (filter pred (cdr lst)))) (else (filter pred (cdr lst)))))(define (filter-odd lst) (filter odd? lst))Notice now, how odd? is separated from the looping logic, which has now been separated into filter? filter now takes a function object which decides whether the item is to be kept or not, and callers of filter can slot in any function of their choice.That is what is meant by a higher-order function: it's a function that takes a function object as a parameter, to customise its operation.As mentioned in the original edit of your question, map is another higher-order function, but instead of filtering items from a list, it returns a transformation of every item in the original list, where the specific transformation is given by map's caller via a parameter.To answer your actual question about flattening, etc., (map filter-odd '((1 3 (9 5 7)))) will return a list with a single item, the result of calling (filter-odd '(1 3 (9 5 7))). So no, map will not recurse into sublists for you (and neither will filter).But you can flatten the input first (since you're flattening the output anyway), then call filter-odd on that directly. I hope that will give you the result you expect.(I renamed your odd to filter-odd, since that is less likely to be confused with odd? (the predicate).)Bonus materialBy the way, both filter and map are specialisations of a much more general higher-order function, called a fold (or more specifically, a right-fold). Folds can express things that cannot be accommodated by either filter or map, but that somehow involve traversing all the items in a list. Here's an example of a length function, expressed as a fold:(define (foldl func init lst) (if (null? lst) init (foldl func (func (car lst) init) (cdr lst))))(define (length lst) (foldl (lambda (elem count) (+ count 1)) 0 lst))The benefit here is that the length function does not have to worry about traversing the list: that is handled by the fold. It only needs to worry about what to do at each iteration (which, here, is simply adding 1 to count, which starts out as 0).In this case, the length is the same whether we traverse from the left or the right, and in Scheme, traversing from the left is more space-efficient, so we prefer that. But for implementing map and filter, a right-fold is necessary (otherwise the elements come out reversed---try substituting the foldr with foldl in the below functions and you'll see):(define (foldr func init lst) (if (null? lst) init (func (car lst) (foldr func init (cdr lst)))))(define (map func lst) (foldr (lambda (elem result) (cons (func elem) result)) '() lst))(define (filter pred lst) (foldr (lambda (elem result) (if (pred elem) (cons elem result) result)) '() lst)) One way to do it is to define a custom input operator (operator&gt;&gt;) for your Point class, then use istream_iterator to read the elements. Here's a sample program to demonstrate the concept:#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;vector&gt;struct Point { int x, y;};template &lt;typename T&gt;std::basic_istream&lt;T&gt;&amp; operator&gt;&gt;(std::basic_istream&lt;T&gt;&amp; is, Point&amp; p) { return is &gt;&gt; p.x &gt;&gt; p.y;}int main() { std::vector&lt;Point&gt; points(std::istream_iterator&lt;Point&gt;(std::cin), std::istream_iterator&lt;Point&gt;()); for (std::vector&lt;Point&gt;::const_iterator cur(points.begin()), end(points.end()); cur != end; ++cur) { std::cout &lt;&lt; "(" &lt;&lt; cur-&gt;x &lt;&lt; ", " &lt;&lt; cur-&gt;y &lt;&lt; ")\n"; }}This program takes the input, in the format you specified in your question, from cin, then outputs the points on cout in (x, y) format. You usually need an existing Java compiler (and runtime) to bootstrap. However, there are other Java compilers available, like Jikes, that are written in C++. Whether you can use Jikes to bootstrap OpenJDK is a different story, but in theory, it should be possible. You can also use to_i, which would communicate your intent even better, unless you expect to be dealing with fractional cents (in which case, to_i seems to truncate towards zero). Instead of jobName and jobDuration, you need to say this.name and this.duration, since that's what those fields are named. The standard way to do looping in Scheme is to use tail recursion. In fact, let's say you have this loop:(do ((a 0 b) (b 1 (+ a b)) (i 0 (+ i 1))) ((&gt;= i 10) a) (eprintf "(fib ~a) = ~a~%" i a))This actually get macro-expanded into something like the following:(let loop ((a 0) (b 1) (i 0)) (cond ((&gt;= i 10) a) (else (eprintf "(fib ~a) = ~a~%" i a) (loop b (+ a b) (+ i 1)))))Which, further, gets macro-expanded into this (I won't macro-expand the cond, since that's irrelevant to my point):(letrec ((loop (lambda (a b i) (cond ((&gt;= i 10) a) (else (eprintf "(fib ~a) = ~a~%" i a) (loop b (+ a b) (+ i 1))))))) (loop 0 1 0))You should be seeing the letrec here and thinking, "aha! I see recursion!". Indeed you do (specifically in this case, tail recursion, though letrec can be used for non-tail recursions too).Any iterative loop in Scheme can be rewritten as that (the named let version is how loops are idiomatically written in Scheme, but if your assignment won't let you use named let, expand one step further and use the letrec). The macro-expansions I've described above are straightforward and mechanical, and you should be able to see how one gets translated to the other.Since your question asked how about variadic functions, you can write a variadic function this way:(define (sum x . xs) (if (null? xs) x (apply sum (+ x (car xs)) (cdr xs))))(This is, BTW, a horribly inefficient way to write a sum function; I am just using it to demonstrate how you would send (using apply) and receive (using an improper lambda list) arbitrary numbers of arguments.)UpdateOkay, so here is some general advice: you will need two loops:an outer loop, that goes through the range levels (that's your variadic stuff)an inner loop, that loops through the numbers in each range levelIn each of these loops, think carefully about:what the starting condition iswhat the ending condition iswhat you want to do at each iterationwhether there is any state you need to keep between iterationsIn particular, think carefully about the last point, as that is how you will nest your loops, given an arbitrary number of nesting levels. (In my sample solution below, that's what the cur variable is.)After you have decided on all these things, you can then frame the general structure of your solution. I will post the basic structure of my solution below, but you should have a good think about how you want to go about solving the problem, before you look at my code, because it will give you a good grasp of what differences there are between your solution approach and mine, and it will help you understand my code better.Also, don't be afraid to write it using an imperative-style loop first (like do), then transforming it to the equivalent named let when it's all working. Just reread the first section to see how to do that transformation.All that said, here is my solution (with the specifics stripped out):(define (n-loop proc . ranges) (let outer ((cur ???) (ranges ranges)) (cond ((null? ranges) ???) (else (do ((i (caar ranges) (+ i 1))) ((&gt;= i (cadar ranges))) (outer ??? ???))))))Remember, once you get this working, you will still need to transform the do loop into one based on named let. (Or, you may have to go even further and transform both the outer and inner loops into their letrec forms.) Scheme uses lexical scoping, not dynamic scoping. So the x the undefinedTest sees is the x that is lexically visible from that function, which in this case, as you've already noted, is the top-level scope. &gt; (list '(6 * 3) '+ '(5 - 2))((6 * 3) + (5 - 2)Yes, it's as simple as using the list function. I'm not a fan of manual looping, so here's a solution based on unfold (load SRFI 1 and SRFI 26 first):(define (digits n) (unfold-right zero? (cut modulo &lt;&gt; 10) (cut quotient &lt;&gt; 10) n))This returns an empty list for 0, though. If you want it to return (0) instead, we add a special case:(define (digits n) (case n ((0) '(0)) (else (unfold-right zero? (cut modulo &lt;&gt; 10) (cut quotient &lt;&gt; 10) n))))Of course, you can generalise this for other bases. Here, I implement this using optional arguments, so if you don't specify the base, it defaults to 10:(define (digits n (base 10)) (case n ((0) '(0)) (else (unfold-right zero? (cut modulo &lt;&gt; base) (cut quotient &lt;&gt; base) n))))Different Scheme implementations use different syntaxes for optional arguments; the above uses Racket-style (and/or SRFI 89-style) syntax. Indeed, it's as you say: internal defines are not supported by the Advanced language. For working with the SICP exercises, I've been told it's best to use the neil/sicp package: instructions for using this are detailed here.However, even the standard Racket language (#lang racket) will support internal defines without problems. You can use SRFI 1 function circular-list (alongside Racket's built-in take) to do this:(require srfi/1)(define (take-circular lst n) (take (apply circular-list lst) n))If you want to avoid using SRFI 1, another method works like this:(define (take-circular lst n) (let ((size (length lst))) (if (&gt; n size) (append lst (take-circular lst (- n size))) (take lst n)))) A Scanner is probably not the right tool for reading S-expressions. S-expression readers usually use a recursive-descent parser to do the job, using a readtable to handle the various datum types. This page describes how Racket does it, for example. Here's my solution. It's based on a tortoise-and-hare algorithm (which is used in any kind of list traversal where you need to detect circular lists), so it doesn't do any more work than a sane list traversal has to do anyway. :-)(define (middle-elements lst) (if (null? lst) '() (let loop ((tortoise lst) (hare (cdr lst))) (cond ((eq? tortoise hare) #f) ((null? hare) (list (car tortoise))) ((null? (cdr hare)) (list (car tortoise) (cadr tortoise))) (else (loop (cdr tortoise) (cddr hare)))))))It covers the following cases:If given an empty list, returns an empty list.If given a list with an odd number of elements, returns a singleton list with the middle element.If given a list with an even number of elements, returns a list with the two middle elements.If given a circular list, returns #f.If given an improper list (including a non-list), summons nasal demons. This might help you:(define (-&gt;string x) (call-with-output-string (lambda (out) (display x out))))This writes out any object to a string port and returns its string value.&gt; (-&gt;string #t)"#t"&gt; (-&gt;string #f)"#f" You have two options for getting the list '(* * *):&gt; (define a '(* * * (- - - (* * *))))&gt; (fourth (fourth a))'(* * *)&gt; (take a 3)'(* * *)What's the difference? Consider this instead (same structure as your list, but different contents):&gt; (define a '(1 2 3 (4 5 6 (7 8 9))))&gt; (fourth (fourth a))'(7 8 9)&gt; (take a 3)'(1 2 3)If you want your first approach to work, then the input would have to look like this instead:&gt; (define a '((* * *) (- - -) (* * *)))&gt; (first a)'(* * *)&gt; (third a)'(* * *) This seems like a crazy macro to want to write, especially when SRFI 26 is so much more intuitive to use. Instead of (wrap list (0 'blah) (2 'bloo) (4 'blee)), you can just use:(cut list 'blah &lt;&gt; 'bloo &lt;&gt; 'blee &lt;...&gt;)That is surely much easier to read.If you really must write such a macro, here's one way to go about it, by transforming usages of wrap into equivalent usages of cut:(require (for-syntax syntax/parse) srfi/26)(define-syntax (wrap stx) (syntax-parse stx ((_ func:expr (idx:nat expr:expr) ...) (let* ((alist (map cons (syntax-&gt;datum #'(idx ...)) (syntax-e #'(expr ...)))) (upper (add1 (apply max -1 (map car alist)))) (listfunc (lambda (i) (cond ((assv i alist) =&gt; cdr) (else #'&lt;&gt;))))) (with-syntax (((args ...) (build-list upper listfunc))) #'(cut func args ... &lt;...&gt;))))))The key to answering your question, about how to get the integers given the syntax objects, is by using syntax-&gt;datum (for deep syntax-stripping) or syntax-e (for shallow syntax-stripping).(P.S. (To Racket experts reading this.) I'm very new to syntax-parse, so I'm sure syntax-parse experts can find better ways to write the above. I originally wrote the macro as a syntax-case macro, then slapped on syntax-parse syntax classes. That's it.) (define (monotonically-increasing? lst) (apply &lt; lst))Or, if you want monotonically-non-decreasing:(define (monotonically-non-decreasing? lst) (apply &lt;= lst))Yes, it's really as simple as that. Totally O(n), and no manual recursion required.Bonus: For good measure:(define (sum lst) (apply + lst)):-P You can invoke function objects directly, without using apply:(define (proc4 f g) (lambda (x y) (if (&gt; (f x y) (g x y)) f g))) No, it is not dynamic scoping. Note that your define here is an internal definition, accessible only to the code inside the let. In specific, f is not defined at the module level. So nothing has leaked out.Internal definitions are internally implemented as letrec (R5RS) or letrec* (R6RS). So, it's treated the same (if using R6RS semantics) as:(let ((x 1)) (letrec* ((f (lambda (y) (+ x y)))) (set! x 2) (f 3))) A nullary (zero arguments) lambda used in this way is called a thunk.Thunks are used in Scheme to defer the execution of some piece of code. Suppose, for example, that we're talking about (display #f) instead of (cont #f). If you wrote (display #f) directly, then when the code execution reached that point, it'd display #f straight away, whereas if you wrapped it in a thunk ((lambda () (display #f))), it wouldn't display the #f until you invoked the thunk.Back to your code, a (cont #f) in the code would cause an immediate jump at the point where the continuation is invoked. Wrapping it in a thunk delays the invocation of the continuation until you invoke the thunk. Óscar López's answer is correct. Here is a version of the same code, using a named let, that is (in my opinion, at least) easier to read:(define (add-until lst num) (let loop ((lst lst) (acc 0)) (if (or ??? (= ??? ???)) acc (loop ??? (+ ??? ???))))) You are very, very close to the solution! Well, sort of. But here's a start. Look at the original code, around where you were modifying it:(let* ((location (make-source-location "*stdin*" (port-line (current-input-port)) (port-column (current-input-port)) -1 -1)) (c (read-char))) ...)Here, you changed all your (current-input-port) to your string port (BTW, don't call open-input-string more than once, since you create a new string port each time, each with independent cursors), but it's not the only place that actually uses (current-input-port).Do you see it? It's actually in the (read-char) call! That function actually takes a port argument, defaulting to (current-input-port).In fact, if you look above and search for instances of (read-char) and (peek-char), you'll notice that the use of (current-input-port) is pretty much baked into the whole make-lexer function. So you will need to change that.I would suggest that you specify an input port to the make-lexer function:(define* (make-lexer errorp #:optional (input (current-input-port))) ...then change all instances of (read-char) and (peek-char) to use the input port. Also don't forget to change your make-source-location call too:(let* ((location (make-source-location "*stdin*" (port-line input) (port-column input) -1 -1)) (c (read-char input))) ...)Now, you can use (make-lexer errorp (open-input-string program)) and it should work. (I have not tested it.) You had:std::priority_queue&lt;uint32_t*, std::vector&lt;uint32_t*&gt;, edgeComparator&gt; q();But instead, you should use:std::priority_queue&lt;uint32_t*, std::vector&lt;uint32_t*&gt;, edgeComparator&gt; q;The first version declares a function named q, that takes no arguments, and returns a value of type std::priority_queue&lt;...&gt;.The second version declares a variable named q, of type std::priority_queue&lt;...&gt;, which is default-initialised. Are you using Racket? If so, you can use append-map:(define (double-duplicate lst) (append-map (lambda (x) (list x x)) lst))append-map is analogous to the likes of Scala's flatmap.It's not hard to write your own version of append-map if you need to:(define (append-map func lst) (fold-right (lambda (e r) (append (func e) r)) '() lst)) @Overridepublic String toString() { return /* fill this in */;} I think your course had this in mind:(defun my-remove-if (pred lst) (apply #'append (mapcar (lambda (x) (and (not (funcall pred x)) (list x))) lst)))It does use apply and append and mapcar, like you said. Example usage:(my-remove-if #'numberp '(32 a t 4 3 e))=&gt; (a t e)More idiomatic solution suggested by Rörd:(defun my-remove-if (pred lst) (mapcan (lambda (x) (and (not (funcall pred x)) (list x))) lst)) Use this instead:using namespace System::Windows::Media::Imaging;Clearly, the line above that should have hinted that in C++/CLI, you use :: rather than .. Email attachments use MIME.Unfortunately, there doesn't seem to be a built-in module that will do MIME encoding. (There is one, net/mime, for doing MIME decoding.)I've searched PLaneT too, and there, the closest library for that is bzlib/mime, but there's no documentation for it, so I can't tell you if it will do the job or not. Let's look at the example of (compare? '(1 x 2 x 3 x 4)).You want to ensure that (compare? '(2 x 3 x 4)) is true, and that the 1 x before that also matches.That then means that you want to ensure that (compare? '(3 x 4)) is true (which it is, by definition), and that the 2 x before that also matches.Notice how we are working with smaller and smaller lists each time. We can do that because lists have structural induction. Because of structural induction, you don't actually have to know the length of the list. The algorithm just works on smaller and smaller sublists until it hits a base case.Sample skeletal solution (fill in the &lt;???&gt; with suitable code):(define (compare? lst) (if (or (null? lst) (null? (cdr lst))) #t (let ((item (cadr lst)) (next (compare? (cddr lst)))) (case next ((#f) &lt;???&gt;) ((#t) &lt;???&gt;) (else (and &lt;???&gt; &lt;???&gt;))))))(Technically the #f clause is not necessary, but, it may make it clearer to you what the solution approach should be.)This solution will only work correctly if the matched slots in the list are not #t or #f. Since you're using symbols in your example, it will work correctly. The kind of table you're describing is sometimes called a join table. You would create a primary key across the columns you're joining, both for uniqueness and because it's more likely to be indexed for better performance. The main difference is this:flatten1 works by storing the output elements (first from the cdr side, then from the car side) into an accumulator. This works because lists are built from right to left, so working on the cdr side first is correct.flatten2 works by recursively flattening the car and cdr sides, then appending them together.flatten1 is faster, especially if the tree is heavy on the car side: the use of an accumulator means that there is no extra list copying, no matter what. Whereas, the append call in flatten2 causes the left-hand side of the append to be copied, which means lots of extra list copying if the tree is heavy on the car side.So in summary, I would consider flatten2 a beginner's implementation of flatten, and flatten1 a more polished, professional version. See also my implementation of flatten, which works using the same principles as flatten1, but using a left-fold instead of the right-fold that flatten1 uses.(A left-fold solution uses less stack space but potentially more heap space. A right-fold solution uses more stack and usually less heap, though a quick read of flatten1 suggests in this case that the heap usage is about the same as my implementation.) You are very close. You simply need to add #:match-select cadr to your regexp-match call:(regexp-match* #rx"{(.*?)}" text #:match-select cadr)By default, #:match-select has value of car, which returns the whole matched string. cadr selects the first group, caddr selects the second group, etc. See the regexp-match* documentation for more details. Óscar López's answer is correct. Here are two more implementations (again with the fill-in-the-blanks).The first one is a left-fold solution (contrast with Óscar's solution, which is a right-fold one):(define (length lst) (let loop ((lst lst) (count 0)) (if &lt;???&gt; ; if the list is empty &lt;???&gt; ; return the count (loop &lt;???&gt; &lt;???&gt;)))) ; otherwise bump the count and continue down the listThis has the advantage of being tail-recursive, whereas the right-fold version isn't.The second one is a tortoise-and-hare solution, which allows cyclic lists to be detected (the earlier solutions would run forever if given a cyclic list):(define (length lst) (if (null? lst) 0 (let loop ((tortoise lst) (hare (cdr lst)) (count 1)) (cond ((eq? tortoise hare) #f) ; found a cycle ((null? hare) &lt;???&gt;) ; reached end of list ((null? (cdr hare)) &lt;???&gt;) ; reached end of list too (else (loop &lt;???&gt; &lt;???&gt; (+ count 2))))))) ; bump the count and keep looking What you have there is an association list (alist). Alist entries are, indeed, often simple conses rather than lists (though that is a matter of preference: some people use lists for alist entries too), so what you have is fine. Though, I usually prefer to use literal syntax:'(("Favorite color?" . "red") ("Favorite number?" . "123") ("Favorite fruit?" . "avocado"))Alists usually use a symbol as the key, because symbols are interned, and so symbol alists can be looked up using assq instead of assoc. Here's how it might look:'((color . "red") (number . "123") (fruit . "avocado")) Use send/apply to apply multiple arguments to send:(send/apply my-list-box set (map ...))The (apply send my-list-box set (map ...)) (that you were trying to use) is only invalid because send is a syntax (macro), not because there are multiple preceding arguments. For example, this works:(apply + 1 2 3 '(4 5 6)) Same way as you would evaluate it, but instead of outputting the result, you simply output the expression that would be used.Here's my implementation, tested on Racket:(define (decompose expr) (define (expand x) (if (list? x) (decompose x) x)) (define oper (car expr)) (let next ((args (map expand (cdr expr)))) (if (&lt;= (length args) 2) (cons oper args) (list oper (car args) (next (cdr args)))))) You are correct in that there are macros involved: in particular, quasiquote is a macro, and unquote and unquote-splicing are literals. None of those are procedures, so normal evaluation rules do not apply.Thus, it's possible to give (quasiquote (foo bar baz unquote x)) the special treatment it needs, despite unquote not being the first syntax element. Here's my (Racket-specific) solution, which doesn't involve lots of (or, for that matter, any) modulo calls, and is completely general (so that you don't need to construct the (3 2 1 3 1 2 3) list that the OP has):(define (sum-of-multiples a b limit) (define (sum-of-multiple x) (for/fold ((sum 0)) ((i (in-range 0 limit x))) (+ sum i))) (- (+ (sum-of-multiple a) (sum-of-multiple b)) (sum-of-multiple (lcm a b))))Test run:&gt; (sum-of-multiples 3 5 1000)233168 SRFI 1's reference implementation is linked to in the "References &amp; Links" section of the document: http://srfi.schemers.org/srfi-1/srfi-1-reference.scmEach SRFI will have its own reference implementation, usually written by the author of the SRFI. Some will work across many Scheme implementations, but there are occasionally reference implementations that only work for one or two Scheme implementations, that you may have to port. I'd advise the following recipe:How do you solve this when you're dealing with a flat list, with no sublists?Now, handle sublists using the same approach. Initially, you may want to assume sublists are flat, but eventually you'll need to deal with sublists of sublists.You need to think about how to solve each step separately. Why use Java, when sed is perfectly good for this?1,/^10:/d/^20:/qThis removes all lines between the first line and the line starting with 10:, prints lines after it, and quits when it sees a line starting with 20:.Or, if you want to remove all the lines that have a number followed by a colon, you can use this:/^[[:digit:]]\{1,\}:$/dThis removes all lines that contain 1 or more digits, then a colon, and nothing else. In contrast to the other answers, I tend to use Ctrl-Right for this: after you get(println|) (square 5)(where | is where the cursor is), I simply press Ctrl-Right to get the correct result. This is straightforward:(define (f n) (* (+ (* n n) 300) (/ 13 n))) Since Anton mentioned about an idiomatic solution, here is my idiomatic solution in Racket (I believe the use of higher-order functions, like map, filter-not, and arguably const is more idiomatic than manually looping and filtering). :-)(define (set-list lst val) (map (const val) (filter-not list? lst)))(Racket does provide filter-map but it applies the filter and map in the opposite order from what we want to do.) Try this:(define (last lst) (accumulate (lambda (x y) (if (null? y) (cons x y) y)) '() lst)) You can always turn calls into jumps if you are able to hold call frame information somewhere else. That is what "stack externalising" refers to.For your interpreter, your call frame data needs to hold the non-tail call's continuation (which may itself hold further references, such as to any variables it needs access to). You will need one call frame per active non-tail call.All this does, of course, is trade stack space for heap space. In the end, you don't really save any memory this way. :-) cons-stream needs to be a macro in order for your sample code to work correctly. Otherwise the invocation of cons-stream will evaluate all its arguments eagerly.Try this (not tested):(define-syntax cons-stream (syntax-rules () ((cons-stream a b) (cons a (memo-func (lambda () b))))))P.S. Your delay needs to be a macro also, for similar reasons. Then after you fix delay, you can make your cons-stream use delay directly. SRFI 41's reference implementation has two variants, one for R5RS and one for R6RS. MIT Scheme is boycotting R6RS, so you should use the R5RS version.I haven't used MIT Scheme, so I can't say further beyond that. From what I see on their home page, MIT Scheme also appears not to have a module system, so you probably need to just save that file to your project directory and load it in, the old-fashioned way. A simplified version of member is easy to implement using fold, of course:(define (member x lst) (fold (lambda (e r) (or r (equal? e x))) #f lst))Now, with that, the rest is trivial:(define (difference a b) (filter (lambda (x) (not (member x b))) a))If you want to amalgamate all that into one function (using your neq?), you can do:(define (difference a b) (filter (lambda (x) (fold (lambda (e r) (and r (neq? e x))) #t b)) a)) In order for eof-object? to return true, you must actually send an end-of-file if you're reading from the console. In Unix, press CtrlD; in Windows, press CtrlZ then Enter. No, you don't need streams to make a circular list.There are two approaches to creating circular lists, the standard Scheme approach, and the Racket approach (since Racket's conses are immutable). I will look at examples using SRFI 1's circular-list function. Here's the reference implementation:(define (circular-list val1 . vals) (let ((ans (cons val1 vals))) (set-cdr! (last-pair ans) ans) ans))What that does is to find the last pair in the list of given values, and set-cdr!s it back to the beginning of that list. Pretty straightforward, right?In Racket, conses are immutable, so set-cdr! does not exist. So instead, Racket does it this way:(define (circular-list val1 . vals) (let ([ph (make-placeholder #f)]) (placeholder-set! ph (cons val1 (let loop ([vals vals]) (if (null? vals) ph (cons (car vals) (loop (cdr vals))))))) (make-reader-graph ph)))This uses Racket's make-reader-graph function to handle the cycles. Very nifty. :-) The simplest answer is not to do this using Java code, but to use tee; trying to reimplement tee in Java is just reinventing a square wheel. Just do this:java -jar yourapp.jar | tee -a output.logOn Windows? Install MinGW and/or Cygwin. :-) In a smart compiler, case 1 and case 2 are equivalent. Even without a smart compiler, so that the lambdas are created afresh each time, case 2 may create an infinite number of lambdas, but they are instantly garbage-collectable. So the result is the same: constant stack and heap usage.In case 3, each new lambda contains a free reference to the previous lambda, so none of the lambdas being created are garbage-collectable. You still have constant stack usage, but the heap usage will balloon. (A really smart compiler can figure out that the lambda is actually unused, and eliminate that entirely, but my general point about free references holds.)A compiler can also replace (lambda () (b)) with b directly if it can prove that b is already a nullary(-only) procedure, and/or if it can prove that the resultant lambda will only be called in a nullary fashion (otherwise, it has to add type and arity checkers). Again, for that to apply to your example, it would take a pretty smart compiler. Did you try using an absolute path for RAILS_ROOT? LikeRAILS_ROOT = '/Users/chris/acme' Easy! Don't use snapshots. Access higher-level scopes directly. Scheme solution:(define (lol lst) (let outer ((lhs lst)) (if (null? lhs) '() (let inner ((rhs (cdr lhs))) (if (null? rhs) (outer (cdr lhs)) (cons (list (car lhs) (car rhs)) (inner (cdr rhs))))))))And a Common Lisp translation of same:(defun lol (list) (labels ((outer (lhs) (and lhs (labels ((inner (rhs) (if rhs (cons (list (car lhs) (car rhs)) (inner (cdr rhs))) (outer (cdr lhs))))) (inner (cdr lhs)))))) (outer list)))Sorry, I'm not a Common Lisper, so I hope this isn't too ugly. :-) Leppie (who told me to "go play with your mutation in the traffic ;p" in response to my set-car!/set-cdr! comment above ;-)) wanted me to write a fold-based solution, so here it is!(define (fun lst) (fold-right (lambda (e r) (case e ((cat) (cons* e e r)) (else (cons e r)))) '() lst)) If the set of possible keys is well-defined, use symbols. Otherwise, use strings.The main difference between strings and symbols is that symbols are (by default) interned. With strings, you can have multiple strings that have the same contents, but are different objects (they do not compare as eq?). With symbols, two symbols that have the same contents are guaranteed to be the same object.The advantage of this is that you can do symbol comparisons using eq?, whereas for strings you have to use string=? or equal?.However, in order for this magic to happen, behind the scenes, Scheme implementations maintain an intern pool, which is basically like a string-to-symbol hash table. If you call string-&gt;symbol and the string is not already in the intern table, it will add the string (and its corresponding symbol) to the table, so if your set of possible keys is not well-defined, you can junk up the intern table pretty quickly.Edit: When you say "keys", did you mean keyboard characters? That is definitely a well-defined set, so you can use symbols. Assuming a depth-first left-to-right traversal, you cannot use tail recursion for the left-hand branch, but you can use it for the right-hand branch.Example Scheme code (assuming that your tree has three accessor functions, value, left, and right):(define (collect-in-order tree) (define (collect node result) (if node (collect (right node) (cons (value node) (collect (left node) result))) result)) (reverse (collect tree '())))The (collect (right node) ...) is in tail position, so that is a tail call.You can also do a right-to-left traversal, in which case it's the leftward descents that are tail-recursive:(define (collect-in-order tree) (let collect ((node tree) (result '())) (if node (collect (left node) (cons (value node) (collect (right node) result))) result))) You can use regular expressions for that:String formattedDate = plainDate.replaceFirst( "(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})", "$1-$2-$3 $4:$5:$6");Though, I like assylias's SimpleDateFormat answer better. :-) Ensure you have this line in your ~/.racket/racket-prefs.rktd:(plt:human-language english)(Tested against version 5.2.1.) You have too many brackets. If you took out the extra brackets around the internal defines, things should work a lot better. Scheme does not have goto, so all looping is, ultimately, done using tail recursion. Without a proper tail recursion guarantee, there is no reliable way to provide looping in Scheme.Update: I want to explain what I mean by "ultimately uses tail recursion". Let's look at the do macro, since @newacct mentioned it. For example:(do ((i 1 (+ i 1))) ((&gt; i 10)) (display i) (newline))As I mentioned, Scheme does not have goto, so it must get its looping from somewhere. It actually macro-expands to (something like) this:(let loop ((i 1)) (unless (&gt; i 10) (display i) (newline) (loop (+ i 1))))Notice that loop here is not a keyword or builtin function. It's a named function that's created by the named let†, and which is being invoked (via tail recursion) at the bottom of the unless form.Really, all standard looping forms in Scheme use tail recursion. There's no getting away from it.† Here's what the named let (loosely speaking‡) macro-expands to:(letrec ((loop (lambda (i) (unless (&gt; i 10) (display i) (newline) (loop (+ i 1)))))) (loop 1))‡ Strictly speaking, it macro-expands to:((letrec ((loop (lambda (i) (unless (&gt; i 10) (display i) (newline) (loop (+ i 1)))))) loop) 1) Think about what you want your base case to be. Do you want just elem, or do you want a list with the single item elem? There is a difference. If the want the latter, you will need to fix your base case in the code.In other words, do you want (appendElem '() 42) to return 42, or (42)? Think carefully about the answer to that question, then think about what the consequence of each choice is.By the way, while you can implement appendElem as a toy, you'll soon realise that that function has O(n) runtime. So do not build lists using this approach! The standard way to build a list is to cons items to it, then reverse the final resulting list. Okay, from what I can read of the source code, here's how the various handlers get called (this is all unofficial, based purely on source code inspection):Read handler: (lambda (bv off len)): takes a bytevector (which your handler will put the read data into), an offset (fixnum), and a length (fixnum). You should read in up to len bytes, placing those bytes into bv starting at off. Return the number of bytes actually read in (as a fixnum).Write handler: (lambda (bv off len)): takes a bytevector (which contains the data to write), an offset (fixnum), and a length (fixnum). Grab up to len bytes from bv, starting at off, and write them out. Return the number of bytes actually written (as a fixnum).Get position handler: (lambda (pos)) (called in text mode only): Allows you to store some data for pos so that a future call to the set position handler with the same pos value will reset the position back to the current position. Return value ignored.Set position handler: (lambda (pos)): Move the current position to the value of pos. Return value ignored.Close handler: (lambda ()): Close the port. Return value ignored. To answer another question you had, about compiling and running "bytecode":To compile an expression, use compile. This returns a code object.There is no publicly-exported approach to run this code object. Internally, the code uses run-vmi, but you can't access this from outside code.Internally, the only place where compiled code is loaded and used is in its auto-compile-cache system.Have a look at heap/boot/eval.scm for details. (Again, this is not an official response, but based purely on personal experimentation and source code inspection.) Currently, BMP files can only be loaded, not saved. See racket/draw/private/bitmap.rkt for more details.Yes, that does make the documentation for save-file erroneous. I really haven't spotted anything in the source code that would suggest that save-file would actually support bmp. The usual way to stop recursing is, well, to stop recursing. i.e., don't call the recursive function any longer. :-)If that is too hard to do, the other way to break out of something is to capture a continuation at the top level (before you start recursing), then invoke the continuation when you need to "escape". Your instructor may not like this approach, though. ;-) First, think about how to copy a list. This won't involve the num parameter.Then, use the same num-decrementing approach you have in search to replace (instead of copy) the list element if num is 0. You can do it if you import SRFI 61 first:(require srfi/61)(define (find-in-vector vec v) (define vlen (vector-length vec)) (let loop ((pos 0)) (cond ((= pos vlen) #f) ((vector-ref vec pos) (lambda (el) (and (pair? el) (equal? v (car el)))) =&gt; values) (else (loop (add1 pos))))))The important thing that SRFI 61 provides is that it allows for the (&lt;generator&gt; &lt;guard&gt; =&gt; &lt;receiver&gt;) clause. Here, the generator is the thing that creates a common value to be used by both the guard and the receiver. Our receiver in this case is simply values, which returns the value it's given without any processing.Update: Currently srfi/61 does not work correctly for programs that use #lang racket or the like (srfi/61 is using different bindings for =&gt; and else from what racket/private/cond provides). This has been recently fixed and should appear in a future Racket release. You forgot to decrement i after removing the item. This will skip the next item, since all subsequent items will have been renumbered down by 1. It's invalid: 5+5 resolves to 10, and you cannot have two case clauses with the same constant. It worked just fine for me. Did you accidentally chop out the #lang racket line at the top? If so, put it back and you should be good to go. (require srfi/26)(define (odd-list lists) (map (cut filter odd? &lt;&gt;) lists))Enjoy. :-) Do you know how to use the tortoise-and-hare algorithm? If so, after your algorithm completes, your tortoise will be at the middle of the list.If you're really stuck, I have a working implementation. Or, here's some pseudocode-like thing:(define (median lst) (if (null? lst) #f ;; oops, empty list (let loop ((tortoise &lt;???&gt;) (hare &lt;???&gt;)) (cond ((eq? tortoise hare) #f) ;; oops, circular list ((null? hare) &lt;???&gt;) ;; median value here ((null? (cdr hare)) &lt;???&gt;) ;; average of middle two elements (else (loop &lt;???&gt; &lt;???&gt;)))))) ;; keep going Try this on your chosen Scheme implementation (you may need to load in SRFI 6 before string ports will work):(call-with-input-string "(123\"abc\")" read)On both Racket and Guile, this reads in as (123 "abc"), which is exactly as I expect. From a quick glance at R5RS's "Lexical structure" section, I believe that implementations that return something different, like (|123"abc"|), are probably non-conformant. You can use sequence-ormap for this:(define (member? item seq) (sequence-ormap (lambda (x) (equal? item x)) seq))To test:&gt; (member? 7 17)#t&gt; (member? #\e "Hello")#t Firstly, you should learn to use quasiquotation, so your macro is easier to read. Like this:(define-macro (my-when test . branch) `(if ,test (begin ,@branch)))More seriously, though, this is pretty easy to write using syntax-rules, and you really should vastly prefer it over define-macro.(define-syntax-rule (my-when test branch ...) (if test (begin branch ...)))Oh, you haven't seen define-syntax-rule before? It's a simple macro you can use for writing a one-clause define-syntax macro, and it's defined so:(define-syntax define-syntax-rule (syntax-rules () ((define-syntax-rule (name . pattern) template) (define-syntax name (syntax-rules () ((name . pattern) template))))))Notice how, using define-syntax-rule, simple macros become really, really easy to write. Here's another example:(define-syntax-rule (let ((name value) ...) expr ...) ((lambda (name ...) expr ...) value ...)) No, your added parentheses are in the wrong place. cond clauses are of the form (test result ...), so the first expression in the parentheses should be your test, followed by the result.(define (con-func f a flag) (cond ((= flag 0) (lambda (x) (f (+ x a)))) ((= flag 1) (lambda (x) (f (- x a)))) ((= flag 2) (lambda (x) (f (* x a)))) ((= flag 3) (lambda (x) (f (/ x a)))) (else f)))Of course, in this case, since you're testing the same value against a bunch of constants, you can simplify to using a case:(define (con-func f a flag) (case flag ((0) (lambda (x) (f (+ x a)))) ((1) (lambda (x) (f (- x a)))) ((2) (lambda (x) (f (* x a)))) ((3) (lambda (x) (f (/ x a)))) (else f))) The standard way to sum numbers in Racket, to my knowledge, is to use for/fold rather than apply, if your range is huge:(for/fold ((n 0)) ((i (in-range 100000000))) (+ n i))This takes half a second to run on my computer. Sure, just use apply:(define a +)(define b '(1 2))(apply a b) ; =&gt; 3(apply + b) ; =&gt; 3 In any Lisp system, reading and evaluating are separate steps. To the reader, everything is literal data; it's the evaluator that decides what to evaluate and what (by virtue of quote and quasiquote) to treat as literal data.The reader reads the following expressions exactly the same way:(+ 1 2 3)(+ . (1 2 3))(+ . (1 . (2 3)))(+ . (1 . (2 . (3))))(+ . (1 . (2 . (3 . ()))))This is because, at the basic level, non-empty lists are made up of a bunch of cons cells, which happen to have a cdr that points to another list (empty or not).Furthermore, there are legitimate Scheme expressions that do use improper lists. Rest arguments for lambdas are a prime example of this:(define (list . items) items) You can use not for that.(cond ((not (eq? (car l) (cadr (order l)))) (cons (count (car (order l)) (order l)) (count-inorder-occurrences (cdr (order l)))) ...) Hint: the car of a cons cell can be a cons cell too.More particularly, the list you have is written in long form as:(a . (b . ((x . (y . ((m . ()) . ()))) . ()))) You can use let:(let ((x 1) (y 2)) (+ x y)) Easy answer:$ factor 600851475143600851475143: 71 839 1471 6857More serious answer: Your prime? function is indeed broken; I'm not even certain what it's trying to do. (Also, your (= n 2) test is too late to be useful: the (even? n) test has trumped it.)My suggestion: Implement the Sieve of Eratosthenes. Here's my implementation. You should use loop and recur for updating your loop variables:(defn -main [] (loop [next-tick (System/currentTimeMillis)] (let [next-next (loop [next-tick next-tick loops 0] (if (and (&gt; (System/currentTimeMillis) next-tick) (&lt; loops max-frameskip)) (do (update) (recur (+ next-tick skip-ticks) (+ loops 1))) next-tick))] (display (/ (+ (System/currentTimeMillis) skip-ticks (- next-next)) skip-ticks)) (recur next-next)))) Simple.For each i, from 0 to floor(length / 2), compare the character at index i and at index length - i - 1.If mismatch, return false.Otherwise, if the loop runs out, return true.Skeletal code:(define (palindrome? str) (define len (string-length str)) (define halfway &lt;???&gt;) (let loop ((i 0)) (cond ((&gt;= i halfway) #t) ((char=? &lt;???&gt; &lt;???&gt;) (loop (+ i 1))) (else #f)))) You can still use cons to do it.(cons 'x '(a b c d)) ; =&gt; (x a b c d) There is a basic strategy for solving this kind of problem:First, solve it for a flat list. i.e., write the function so that it works if the input list has no sublists.Then, add a condition so that if the element you're inspecting is a list, then recurse into your function with that list.Here's some skeletal code:(define (replace lst from to) (cond ((null? lst) '()) ;; end of input ((list? (car lst)) &lt;???&gt;) ;; encountered a sublist ((equal? (car lst) from) &lt;???&gt;) ;; found the element we're replacing (else &lt;???&gt;))) ;; everything elseNotice that the second cond clause, (list? (car lst)), is the only thing that's new in your sublist-capable version. b ... allows zero or more expressions, whereas for b1 b2 ..., b1 is required to be an expression, while b2 ... is zero or more expressions. Since you don't want people writing a bodyless let, the b1 b2 ... form enforces at least one body expression.Do you know regular expressions? Think of b ... as analogous to .*, whereas b1 b2 ... is more like ..*. let* is simply nested let instances. For example,(let* ((x v1) (y v2) (z v3)) e)is the same as(let ((x v1)) (let ((y v2)) (let ((z v3)) e)))Does that help with your understanding of let*? :-)Update: The OP is asking (in comments to Óscar's post) how let* is different from let. Here is an example: first, let's use let*:(let ((x 42)) (let* ((x 10) (y (+ x 13))) y))This returns 23 (10 + 13). The value of the inner x is used, and the value of the outer x is shadowed.Now, let's look at what happens if we used let instead of let*:(let ((x 42)) (let ((x 10) (y (+ x 13))) y))This returns 55 (42 + 13). The value of the inner x is not used in computing the value of y; it only takes effect inside the body of the let. This line looks really suspicious:(append nset (append ((car(car(wset))) (+ (cadr(car(wset))) 1)) (cdr wset))))First, append is non-destructive. It doesn't change the value or contents of nset, it simply returns a new list with the things appended. You don't seem to do anything with the return value of append, which means that it's a no-op.Second, ((car(car(wset))) suggests to me that you're thinking of other languages' syntaxes, and that you probably meant (car (car wset)) instead. (Parentheses are significant in Scheme. You cannot have more or fewer than required.) Ditto with your (cadr(car(wset))), which I think you meant (cadr (car wset)). The test must return a true value before the associated expressions are evaluated. This is guaranteed by the Scheme standards; see section 4.2.1 of R5RS, for example. I think you might, instead of tagging procedures per se, want to look at Racket's object system, which has a concept of interfaces. It sounds quite similar to what you're after. You need to use a runtime that actually supports reading from standard input. Most web-based runtimes probably won't support that (though Ideone seems to let you specify standard input contents ahead of time (not interactively), see example).You should install Racket. The DrRacket program will actually give you a nice prompt whenever read is called. You have too many parentheses around the map. Remove the extra so that there's only one parenthesis before map, and you should be good to go.Your cond also needs to return the character corresponding to the number, not the number itself. Also, consider using a case instead of the cond you have.All up, here's how it would look:(define (leet-speak str) (list-&gt;string (map (lambda (x) (case x [(#\l) #\1] [(#\s) #\5] [(#\o) #\0] [(#\e) #\3] [else x])) (string-&gt;list str)))) Scheme uses S-expressions, so instead of car(x), you should use (car x). In your case, that means (car (cdr x)), not car(cdr(x)). Scheme has eager evaluation. This means that, unless you're using a special form (like if) or a macro (like cond or case) that delegates to such a special form, all subexpressions are evaluated first.That means for your expression(modified-if (= n 0) 1 (* n (factorial (- n 1))))the (* n (factorial (- n 1))) is evaluated first, before modified-if is run. (It may be run before or after (= n 0), but it doesn't matter either way, the recursive call still happens regardless.) And since this is a recursive call, that means that your program will infinitely recurse, and you will eventually run out of stack.Here's a simple example: consider this:(if #t (display "Yay!") (error "Oh noes!"))Because if is a special form, and it only evaluates the necessary branch, in this case it will only evaluate (display "Yay!") and not evaluate (error "Oh noes!"). But if you switch to using your modified-if, both expressions will be evaluated, and your program will raise an error. You don't iterate over the symbol. Instead, convert the symbol to a string (symbol-&gt;string) and get its length (string-length). To answer your first question, you have a recursive macro expansion that never stops recursing. The presence of the if doesn't stop the recursive macro expansion, since macro expansion happens at compile-time and your if happens at run-time.To answer your second question, you can't use flet to specify recursive functions, you have to use labels instead. gg is a lambda with two arguments, ff and x.ff is used in the expression (ff x x x) inside the lambda, so ff should be callable.The expression (ff x x x) has three arguments, so ff should be a function taking three arguments. An empty list is simply the nil symbol (and symbols, by definition, are not conses). car and cdr are defined to return nil if given nil.As for list-mutation functions, they return a value that you are supposed to reassign to your variable. For example, look at the specification for the nreverse function: it may modify the given list, or not, and you are supposed to use the return value, and not rely on it to be modified in-place.Even nconc, the quintessential destructive-append function, works that way: its return value is the appended list that you're supposed to use. It is specified to modify the given lists (except the last one) in-place, but if you give it nil as the first argument, it can't very well modify that, so you still have to use the return value. Here is an implementation based on Stephen Chang's comment (I swapped the argument order a little and renamed the function too):(define (insert-at lst pos x) (define-values (before after) (split-at lst pos)) (append before (cons x after))) In Sharpsign Equal-Sign notation, it's written as #0=(1 2 3 . #0#).Here's a function which creates such a list from the given arguments:(defun circular (first &amp;rest rest) (let ((items (cons first rest))) (setf (cdr (last items)) items)))Then, calling (circular 1 2 3) will return the circular list you wanted. Just use car and cdr to iterate through the elements ad infinitum.And if you really want an iterator function that takes no arguments and returns the next item for each call, here's how you might do it:(defun make-iter (list) (lambda () (pop list))) This is described in the manual (first hit on Google for "emacs add-hook"):(add-hook 'prog-mode-hook (lambda () (foo "foobarbaz"))) Are your listeners running on separate threads to the sender? If so, set up BlockingQueues (one for each listener), then have your sender offer items to each of the queues. Each listener then retrieves items from their respective queue. Usually when we talk about sorting, we refer to ordering the items by some characteristic of the item contents, not the item position in the list. I would call your situation permuting, but perhaps some people might dispute that usage, too. :-)Here's how you might approach the problem:Split the list in the middle (you can do this using tortoise-and-hare if you only want to traverse the list once); call those lists head and tail, if you want.Reverse the tail list, and interleave it with the head list.Another approach:Reverse the original list pairs (let's call it rev).Interleave the original list with rev, keeping track of the element traversed each time. When they meet in the middle, stop.Here's a demonstration of the second approach (requires SRFI 1 to be loaded):(define (zippy lst) (if (null? lst) '() (let recur ((lst lst) (rev (pair-fold cons '() lst))) (cond ((eq? lst (car rev)) (list (car lst))) ((eq? (cdr lst) (car rev)) (list (car lst) (caar rev))) (else (cons* (car lst) (caar rev) (recur (cdr lst) (cdr rev)))))))) You need to use for-each instead of map, in your case. for-each is non-collecting, unlike map.Also, for-each is guaranteed to pass the list items from left to right to your function. map makes no such guarantee, and is allowed to pass the list items in any order. (Although, in the specific case of Racket, map does use a left-to-right order. But you cannot depend on this in other Scheme implementations; some use a right-to-left order, and theoretically, other orderings are possible.) (define x (cons 3 '()))(write x)Alternatively, you can define null first:(define null '())(define x (cons 3 null))(write x) So, you don't mind slow and just want a selection-based approach, eh? Here we go....First, we define a select1 function that gets the minimum (or maximum) element, followed by all the other elements. For linked lists, this is probably the simplest approach, easier than trying to implement (say) quickselect.(define (select1 lst cmp?) (let loop ((seen '()) (rest lst) (ext #f) (extseen '())) (cond ((null? rest) (cons (car ext) (append-reverse (cdr extseen) (cdr ext)))) ((or (not ext) (cmp? (car rest) (car ext))) (let ((newseen (cons (car rest) seen))) (loop newseen (cdr rest) rest newseen))) (else (loop (cons (car rest) seen) (cdr rest) ext extseen)))))Now actually do the interweaving:(define (zippy lst) (let recur ((lst lst) (left? #t)) (if (null? lst) '() (let ((selected (select1 lst (if left? &lt; &gt;)))) (cons (car selected) (recur (cdr selected) (not left?)))))))This approach is O(n²), whereas the sort-and-interleave approach recommended by everybody else here is O(n log n). You are invoking CallBooleanMethod on the wrong object---the class object doesn't have an IsConnected method! It should be:(*env)-&gt;CallBooleanMethod(env, obj, mid); By using String.format:public static String replaceNeedlesWithValues(String subject, String needle, String[] values) { return String.format(subject.replace("%", "%%") .replace(needle, "%s"), values);}:-)Of course, you'll probably just want to work with String.format directly:String.format("The %s %s was %s his %s", "brown", "dog", "eating", "food");// =&gt; "The brown dog was eating his food" You can't do this using syntax-rules, but you can do it using syntax-case, by using a guard that uses free-identifier=?. Here's an example:(define-syntax (remove-id stx) (syntax-case stx () ((_ head ()) #''()) ((_ head (next tail ...)) (free-identifier=? #'head #'next) #'(remove-id head (tail ...))) ((_ head (next tail ...)) #'(cons 'next (remove-id head (tail ...))))))&gt; (remove-id foo (foo bar baz qux foo bar)); =&gt; (bar baz qux bar)But of course, if you're going to use syntax-case, there's a much simpler way to implement your quote-unique (this implementation uses Racket's custom hashtables):(require (for-syntax racket/dict))(define-syntax (quote-unique stx) (define (id-dict ids) (foldl (lambda (id d) (dict-set d id #t)) (make-immutable-custom-hash free-identifier=? (compose eq-hash-code syntax-e)) (syntax-e ids))) (syntax-case stx () ((_ ids ...) (with-syntax ((unique (dict-keys (id-dict #'(ids ...))))) #''unique)))) I don't know Common Lisp well enough to answer with how to do this in Common Lisp, so I'm using Scheme for my example below. Suppose you're writing a function to return the factorial of a number. Here's a "modify local variables" approach to that function (you'll have to define your own while macro, but it's not hard):(define (factorial n) (define result 1) (while (&gt; n 0) (set! result (* result n)) (set! n (- n 1))) result)Here's a "rebind local variables" approach to that function:(define (factorial n) (let loop ((n n) (result 1)) (if (zero? n) result (loop (- n 1) (* result n)))))In this case, loop is called with new values to rebind with each time. The same function can be written using the do macro (which, by the way, also uses rebinding, not modifying, at least in Scheme):(define (factorial n) (do ((n n (- n 1)) (result 1 (* result n))) ((zero? n) result))) You can use match-let-values or match-define-values for this (depending on whether you want lexical or top-level variables):&gt; (match-let-values (((_ _ a _) (values 1 2 3 4))) a); =&gt; 3&gt; (match-define-values (_ a _ _) (values 1 2 3 4))&gt; a; =&gt; 2 In the current JSR 335 draft, it's mentioned in the change log entry for 0.6.0 that it "eliminated support for unbound inner class constructor references".To illustrate, suppose you have an outer class named A and an inner class named B, and you want a function that takes an A and creates a new B instance:Function&lt;A, A.B&gt; foo = a -&gt; a.new B();Prior to 0.6.0, you can also use the constructor reference syntax to do the same thing (it's even documented in State of the Lambda):Function&lt;A, A.B&gt; foo = A.B::new;As mentioned above, that syntax is no longer supported in 0.6.0. I'm really curious to know why.I've looked through the archives for the lambda-spec-experts and lambda-dev mailing lists, and cannot find any information about it. JSR 335 (Lambda Expressions for the Java Programming Language) aims to support programming in a multicore environment by adding closures and related features to the Java language. JSR-335 was delivered into Java SE 8 (tag java8) and is now completed.(Excerpted from Project Lambda.) JSR 335: Lambda Expressions for the Java Programming Language Did the parameter names come from somewhere? According to ParaNamer's documentation, it uses several ways to obtain parameter names:Via a __PARANAMER_DATA field. Obviously, this only works if your class has such a field.Via debug information in your .class file. Obviously, this only works if your class was compiled with debugging information.Via a @Named annotation. Obviously, this only works if your method parameters contain such an annotation.If none of these apply to your class, then sorry, parameter names will not be available. Behind the scenes, the two do effectively the same thing, except that in option 1 you're passing in T's class object and in option 2 you're passing in T[]'s class object.I prefer option 1 because it's shorter and easier to read. Then again, it's the same as Array.newInstance with a cast added, so I'm not sure that your method adds a lot of value. :-) and is not a function, it's a macro, so you cannot pass it around like a function.The reason and is a macro, is to enable short-circuiting behaviour. You can make your own non-short-circuiting version:(define (my-and . items) (if (null? items) #t (let loop ((test (car items)) (rest (cdr items))) (cond ((null? rest) test) (test (loop (car rest) (cdr rest))) (else #f)))))and my-and can be used with apply.For comparison, here's what the macro (which does do short-circuiting) looks like:(define-syntax and (syntax-rules () ((and) #t) ((and test) test) ((and test rest ...) (if test (and rest ...) #f)))) Nothing built-in, but you can write your own:(define (map-apply funcs items) (map (lambda (item) (map (lambda (func) (apply func item)) funcs)) items))You'd have to pass in (list + *), not '(+ *), however. As noted in Richard Sitze's post, the main problem with the regex is that it should use + rather than *. Additionally, there are further improvements you can make to your regex:Instead of \\x{2192}, use \u2192. And because it's a single character, you don't need to put it into a character class ([...]), you can just use \u2192+ directly.Also, because | binds more loosely than .*\\s and \u2192+, you won't need the parentheses there either. So your final expression is simply ".*\\s|\u2192+". OMG's answer is technically correct, but you should get in the habit of inspecting objects for which methods they support:irb(main):001:0&gt; "Hello, world!".methods.sort=&gt; [:!, :!=, :!~, :%, :*, :+, :&lt;, :&lt;&lt;, :&lt;=, :&lt;=&gt;, :==, :===, :=~, :&gt;, :&gt;=, :[], :[]=, :__id__, :__send__, :ascii_only?, :between?, :bytes, :bytesize, :byteslice, :capitalize, :capitalize!, :casecmp, :center, :chars, :chomp, :chomp!, :chop, :chop!, :chr, :class, :clear, :clone, :codepoints, :concat, :count, :crypt, :define_singleton_method, :delete, :delete!, :display, :downcase, :downcase!, :dump, :dup, :each_byte, :each_char, :each_codepoint, :each_line, :empty?, :encode, :encode!, :encoding, :end_with?, :enum_for, :eql?, :equal?, :extend, :force_encoding, :freeze, :frozen?, :getbyte, :gsub, :gsub!, :hash, :hex, :include?, :index, :initialize_clone, :initialize_dup, :insert, :inspect, :instance_eval, :instance_exec, :instance_of?, :instance_variable_defined?, :instance_variable_get, :instance_variable_set, :instance_variables, :intern, :is_a?, :kind_of?, :length, :lines, :ljust, :lstrip, :lstrip!, :match, :method, :methods, :next, :next!, :nil?, :object_id, :oct, :ord, :partition, :prepend, :private_methods, :protected_methods, :public_method, :public_methods, :public_send, :replace, :respond_to?, :respond_to_missing?, :reverse, :reverse!, :rindex, :rjust, :rpartition, :rstrip, :rstrip!, :scan, :send, :setbyte, :singleton_class, :singleton_methods, :size, :slice, :slice!, :split, :squeeze, :squeeze!, :start_with?, :strip, :strip!, :sub, :sub!, :succ, :succ!, :sum, :swapcase, :swapcase!, :taint, :tainted?, :tap, :to_c, :to_enum, :to_f, :to_i, :to_r, :to_s, :to_str, :to_sym, :tr, :tr!, :tr_s, :tr_s!, :trust, :unpack, :untaint, :untrust, :untrusted?, :upcase, :upcase!, :upto, :valid_encoding?]That will help you explore which methods are available to you. Change your comparator to look for NEW first:function (a, b) { if ((a.word === 'NEW') != (b.word === 'NEW')) { return a.word === 'NEW' ? 1 : -1; } return a.word &gt; b.word ? 1 : a.word &lt; b.word ? -1 : 0;} It's not semantically correct to have (zip '(a b c) '(1)) => ((a 1) (b ()) (c ())) (unless you're specifically using () as a placeholder value); it's more sensible to have ((a 1) (b) (c)). Here's an implementation that achieves that:(define (zip-with-uneven . lists) (define (advance lst) (if (null? lst) lst (cdr lst))) (define (firsts lists) (let loop ((lists lists) (result '())) (cond ((null? lists) (reverse result)) ((null? (car lists)) (loop (cdr lists) result)) (else (loop (cdr lists) (cons (caar lists) result)))))) (let loop ((lists lists) (results '())) (if (andmap null? lists) (reverse results) (loop (map advance lists) (cons (firsts lists) results)))))andmap is from Racket. If you're not using Racket, you can use every from SRFI 1 instead.If you really want to use a placeholder, here's a (Racket-specific) version that supports placeholders. The default placeholder is (void), which I presume is never a valid value you'd want to put in your result list.(define (zip-with-uneven #:placeholder (ph (void)) . lists) (define (advance lst) (if (null? lst) lst (cdr lst))) (define (cons-with-placeholder a d) (if (void? a) d (cons a d))) (define (firsts lists) (let loop ((lists lists) (result '())) (cond ((null? lists) (reverse result)) ((null? (car lists)) (loop (cdr lists) (cons-with-placeholder ph result))) (else (loop (cdr lists) (cons (caar lists) result)))))) (let loop ((lists lists) (results '())) (if (andmap null? lists) (reverse results) (loop (map advance lists) (cons (firsts lists) results))))) No, profiling happens on method entry and exit, and not on every line of code. You will have to split off half the lines into separate methods if you want to see which half is the most work-intensive. Here's a possible regex you could use:name.replaceFirst("^\\d+\\.?\\s*-(?:.*?-)?\\s*", "")This takes out:digits at the frontoptionally followed by a dotoptionally spacesa hyphenif a further hyphen is found, then everything up to thatoptionally spaces Apart from the obvious answer of (lambda () 0), many Scheme implementations provide a const function that takes a value and returns a function that returns that value no matter what arguments (or lack thereof) are given. Here's a version that handles arbitrarily-nested lists: first, a nested-map that is like map but handles nested lists:(define (nested-map func tree) (if (list? tree) (map (lambda (x) (nested-map func x)) tree) (func tree)))Then, we create a mapper to use with it (using list-ref if the list is shorter than 16 elements, otherwise copying to a vector first for better scalability):(define (rearrange indices lst) (define mapper (if (&lt; (length lst) 16) (lambda (i) (list-ref lst (- i 1))) (let ((vec (list-&gt;vector lst))) (lambda (i) (vector-ref vec (- i 1)))))) (nested-map mapper indices))Notice how, after the mapper is defined, the function is simply a single call to nested-map. Easy! :-D You can't define top-level bindings outside of the top-level, in Scheme. (And inside of a let is definitely outside of the top-level---what you had, instead, was internal definitions, which are not exported to the top-level.) However, using define-values, you can still do what you need to do:(define-values (my-incf my-decf) (let ((x 0)) (values (lambda (y) (set! x (+ x y)) x) (lambda (y) (set! x (- x y)) x))))However, you can still use internal definitions, to make your code more readable:(define-values (my-incf my-decf) (let ((x 0)) (define (my-incf y) (set! x (+ x y)) x) (define (my-decf y) (set! x (- x y)) x) (values my-incf my-decf)))Best of both worlds. :-) In this case, the values sends the internal my-incf and my-decf definitions to the outer define-values, which is where the real top-level definition happens. This problem has two parts:You need to find a way to visit each element of the given form, recursing into sublists.You need a way to collect the unique elements being visited.Here's a solution to the first part:(define (recursive-fold visitor initial x) (let recur ((value initial) (x x)) (cond ((null? x) value) ((pair? x) (recur (recur value (car x)) (cdr x))) (else (visitor x value)))))I leave it for you to implement the second part. Well, the syntax for allowing my-map to take multiple lists is simply (define (my-map mapper lst1 . lsts) ...).But that's not what you're really asking, is it? The general implementation approach is as follows:See if any list is empty. If so, return empty list.Collect the first element of each list, and pass them as arguments to call the mapper with.Cons the result of that mapper call with a recursive call to my-map, using the rest of each list.Steps 2 and 3 will likely be implemented using the one-list version of map. Your first example with the "unbound variable" is due to your misspelling multiple-value-bind. Try fixing the spelling; you should see a different result.As to your second question, floor returns two values, the floor and the remainder. Remember that values is not the only function that returns multiple values!So, basically, the multiple-value-bind form looks like this:(multiple-value-bind (var-1 .. var-n) expr body)where expr is an expression that returns multiple values, which are bound to the variable names given in var-1 .. var-n; those variables are available for use in body. It is okay for expr to return more or fewer values than are given as variables; nil is used as the default value for any absent values, and any excess values are discarded. Which dialect of Lisp are you using? Here's a Scheme solution (using SRFI 1):(require srfi/1) ; assuming you're using Racket(define (reverse-first-n lst n) (call-with-values (lambda () (split-at lst n)) append-reverse!))I made the function really "reverse the first n elements" like your title says, and unlike your question description. So for example:&gt; (reverse-first-n '(3 1 4 5 2) 2)'(1 3 4 5 2)&gt; (reverse-first-n '(3 1 4 5 2) 3)'(4 1 3 5 2)As requested by the OP, here's a Common Lisp version. sds already posted a pretty decent version, so the version I'm writing is a more direct port of my Scheme solution (append-reverse! ⇒ nreconc; call-with-values ⇒ multiple-value-call; and I'm porting SRFI 1's split-at to CL):(defun split-at (list n) (if (zerop n) (values '() list) (multiple-value-bind (prefix suffix) (split-at (cdr list) (1- n)) (values (cons (car list) prefix) suffix))))(defun reverse-first-n (list n) (multiple-value-call #'nreconc (split-at list n)))(Why split-at? Its purpose is to provide both the take (subseq) and drop (nthcdr) with only one traversal of the input list.) To answer your question, Joel's article was indeed referring to recursion in that context.However, your code isn't actually pure-functional, because display and newline have side effects. So I'm going to go off on a tangent and give you some tangible examples of pure-functional recursive code.Consider a greatest common divisor function:(define (gcd x y) (if (zero? y) x (gcd y (modulo x y))))Here, each time where the remainder of dividing x by y is non-zero, it (tail-)recursively calls gcd again, where in this new call, the x and y values are different. (In particular, the y value gets smaller each iteration, eventually leading to a base case where x divides y exactly, even if y has to be 1 in order for that to happen.)Here's another case of pure-functional recursion (not tail recursion, this time, though it's possible to implement with tail recursion too), used to implement an algorithm for merging two sorted lists of numbers:(define (merge lhs rhs) (cond ((null? lhs) rhs) ((null? rhs) lhs) ((&lt; (car rhs) (car lhs)) (cons (car rhs) (merge lhs (cdr rhs)))) (else (cons (car lhs) (merge (cdr lhs) rhs)))))Again, whenever we're dealing with cases where both lhs and rhs are non-empty, we recurse into another call into merge, with one of the lists being shorter in each call, and we eventually get to a base case where one of the lists is empty.This merge function can be used to implement mergesort:(define (mergesort lst) (let ((len (length lst))) (if (&lt; len 2) lst (let-values (((lhs rhs) (split-at lst (quotient len 2)))) (merge (mergesort lhs) (mergesort rhs))))))This is the classic example of a divide-and-conquer algorithm. Each time the list has 2 or more elements, split the list into left and right halves, recurse into each half, then merge the sorted halves back together. It's type A. Why? Because of slicing.If, however, f() returned an A&amp;, and you used A&amp; a = f(); instead, then you have two options (both involving RTTI):You could use typeid(a) and either look at its name() or compare against the type_info objects for the various (sub)classes.You could use a dynamic_cast: for example, dynamic_cast&lt;D*&gt;(&amp;a) would return null if a is not of type D. Different CPUs have different instruction architectures (e.g., x86 vs ARM).Early Macs used the Motorola 68k architecture; later ones used PowerPC; and still later ones used x86. During each of these transitions, developers had to ship their executables as fat binaries, which would contain object code for both architectures.Current x86 CPUs have 32-bit and 64-bit modes.This is why you have 32-bit and 64-bit versions of Windows, Ubuntu, etc.Different operating systems provide different system calls, libraries, etc.Different OS versions can provide different system calls, libraries, etc. also (although OS vendors do aim to be backward compatible as much as possible).Even on the same operating system, the calling convention is not guaranteed to be the same between different compilers.Even on the same OS, different executable file formats may be in use. For example, on many Unix systems, a.out used to be the format used, but most eventually switched to ELF. During the transition period, libraries had to be provided in both formats. You have sin(x) working? Then it's easy. cos(x) = sin(x + pi/2) Chances are, /usr/local/include is not in your default include path. Try adding -I/usr/local/include to your compilation command. Do not treat arrays polymorphically. [1] [2] You will get undefined behaviour, as you've observed. Luckily for you, you're just seeing wrong results, but there's a code snippet on that page that demonstrates a crash. Let's assume that there's an intermediate superclass between Super and Derived (called, say, Intermediate).The reason the compiler generates Derived.someMethod is that you might recompile Intermediate to insert an implementation of someMethod, which would shadow the implementation from Super. Well, a direct translation of the idea is as follows:(define (set-contents . args) (send/apply output-list set (empty-list rows-length) (for/list ((i (length args))) (get-nth-item columns-as-list i))))But, since you're not actually using the arguments other than getting the argument count, that seems pretty fishy. What are you trying to do? Yes, Structure and Interpretation of Computer Programs, more commonly known as SICP. You should be able to use#lang htdp/bsl(or htdp/bsl+, htdp/isl, htdp/isl+, or htdp/asl) but it's "not in a complete shape, yet". As the documentation says, it's used for ? markers in your query string. For example, you might use this:SQLiteDatabase.delete("users", "user_name = ?", new String[] {"Talib"});The use of parameter markers is very important for avoiding SQL injection. For example,SQLiteDatabase.delete("users", "user_name = ?", new String[] {"' OR '' = '"});will not delete all rows of your table, but if you naively didSQLiteDatabase.delete("users", "user_name = '" + userName + "'");and userName was set to "' OR '' = '", that would indeed nuke your whole table. You forgot to initialise the days field with anything, so it remains null when you call the add method. Before the days.add(0, "Sunday"); line, add this:days = new ArrayList&lt;String&gt;();Also, take out the index numbers. Just use days.add("Sunday"); days.add("Monday");, and so on. IDEA has a tab called "Structure", which shows all the methods, fields, etc. of the currently-open class. You don't need a this., in this case. However, an inner class must always be constructed using an enclosing instance, so the this. simply makes this clear to the reader.If you're not inside of a non-static method of DataStructure (i.e., if this does not exist, or else isn't an instance of DataStructure), then you must actually specify an instance of DataStructure when creating an InnerEvenIterator:InnerEvenIterator iterator = dataStructure.new InnerEvenIterator(); You're setting your $PATH incorrectly. In looking at $PATH entries, no tilde expansion is done, so ~/tools/bin would actually search (effectively) ./~/tools/bin, not $HOME/tools/bin. If you want to be able to access Student methods from T instances within your DatabaseAccess class, you must constraint T's type to be subclasses of Student:public class DatabaseAccess&lt;T extends Student&gt; { // ...}By the way, if you make your Student class implement Comparable&lt;Student&gt; instead of the raw Comparable, your compareTo method would be easier to write. Add the export EDITOR=emacs line to the .profile file in your home directory, which will be sourced when starting login shells.Or, add that line to /etc/profile to make it apply for all users. The problem is that your script only accepts one argument after --cmd. That means that your command can only have one token in it.I suggest that you take all positional arguments as the command to run, and pass that to sudo using "$@". For that to work, you will need to avoid shifting off all the non-option arguments like you're currently doing.For example, you might do this:while [ "$#" -gt 0 ]; do case "$1" in --sudoUser) SUDO_USER="$2" shift 2;; --sudoPwd) SUDO_PWD="$2" shift 2;; *) break;; esacdonethen, for the rest of your script, replace all instances of $CMD_OR_SCRIPT with "$@" (the double-quotes are required). Also, do not specify --cmd when running your script. Thus, for your sample usage, you should use:./execSudoScript.sh --sudoUser root --sudoPwd pass ls /optAt the OP's request, here's an edited version of the whole script:#!/bin/sh# Initialize values of argumentsSUDO_USER=""SUDO_PWD=""while [ "$#" -gt 0 ]; do case "$1" in --sudoUser) SUDO_USER="$2" shift 2;; --sudoPwd) SUDO_PWD="$2" shift 2;; *) break;; esacdoneif [ -n "$SUDO_USER" ]; then if [ -n "$SUDO_PWD" ]; then echo "$SUDO_PWD" | sudo -k -S -u "$SUDO_USER" "$@" else sudo -u "$SUDO_USER" "$@" fielse if [ -n "$SUDO_PWD" ]; then echo "$SUDO_PWD" | sudo -k -S "$@" else sudo "$@" fifi Many filesystems are not efficient at handling directories with that many entries in them. There's very little you can do, codewise, to fix that. You need to try to move those files into multiple directories, to get better speed.Other possible reasons for slowness are that you're either using a data structure that takes O(n) for each entry (resulting in O(n²) total runtime), or you're running out of heap space (so that GC dominates runtime). I hesitate to call this a "common" usage, but enums are great for making some kinds of state machines. Neither | nor &amp; is for toggling bits. For that, you need to use ^. But 0x40 is indeed the correct value for flipping bit 6 ("7th" in your terms). According to this thread, using fclose instead of pclose means that the process at the other end of the pipe doesn't get reaped, so it stays zombied. The order is not required to be stable across runs. However, the field's hashCode() value is defined to be stable (it's documented to always be field.getDeclaringClass().getName().hashCode() ^ field.getName().hashCode()), so you may be able to use that as your ID, with the understanding that the hash code is not guaranteed to be unique.Alternatively, you may sort the results returned from getDeclaredFields() yourself, using whatever sorting criteria suits you. public static int ceil100(int num) { return (num + 99) / 100 * 100;}Granted, not efficient, but still. The answers posted by others work too:public static int ceil100(int num) { return num + 100 - num % 100;} The -lX11 -lXext must come after the viewer.c in the command line (and should probably be in the order -lXext -lX11). Also, ensure that the libx11-6-dev and libxext6-dev packages are installed.System libraries are usually in /lib and /usr/lib, and you do not need to use -L to specify those directories. Did you run ldconfig (as root) lately? There's a shared library cache that's updated by that program, and if you updated a file in /etc/ld.so.conf.d without running ldconfig, the cache data could be out of date. Instead of using FileReader, use an InputStreamReader with the correct text encoding. I think the strange characters are appearing because you're reading the file with the wrong encoding.By the way, don't use += with strings in a loop, like you have. Instead, use a StringBuilder:StringBuilder finalVersion = new StringBuilder();String currLine;while ((currLine = scan.readLine()) != null) { if (currLine.length() &gt; 3) { finalVersion.append(" ").append(currLine.substring(3)); } else { finalVersion.append(currLine); } finalVersion.append('\n');} The Unix command for clearing the terminal is clear.Alternatively, send the terminal codes for doing same (this varies by terminal, but this sequence works for most):cout &lt;&lt; "\033[H\033[2J";(I got the sequence by simply running clear | less on my system. Try it and see if you get the same result.) Just use "C%05d" as the format string. It does work correctly, when I tested with Bouncy Castle 1.49. However, you're comparing using the wrong method.If you need time-constant comparison, use MessageDigest.isEqual.If you don't need time-constant comparison, use Arrays.equals.To print out the contents of the byte arrays, use Arrays.toString:System.out.println(Arrays.toString(aSecret));System.out.println(Arrays.toString(bSecret));return MessageDigest.isEqual(aSecret, bSecret);Edit: The OP asked me to explain what "time-constant comparison" means, so here goes: a time-constant comparison takes the same amount of time to run, whether or not the two strings match. A non-time-constant comparison will usually take less time to run if the two strings have a mismatch, and the runtime depends on where the mismatch is: the comparison stops when the first mismatch is found.Whether you need a time-constant comparison or not depends on whether you have a timing oracle. That is, will the length of time the comparison took will give an attacker useful information?Here's an example of a timing oracle: suppose you're a web server sending a cookie to a browser. You don't want the user to tamper with the cookie, so you attach an HMAC of the cookie's contents:cookie_to_send = hmac(cookie) + ":" + cookieNow, when the browser sends the cookie back to you, you recompute the HMAC and see if it matches:mac, cookie = received_cookie.split(":")compare(mac, hmac(cookie))And if the comparison fails (the mac doesn't match the hmac(cookie)), then you reject the request.In that compare operation above, it is very, very important that this be a constant-time comparison. Otherwise, the attacker can look at how long your server took to reject the request, and use that to deduce what the expected HMAC value is. This is because one component of the comparison (the HMAC value in the cookie, before the first :) is controlled by the attacker, and the attacker can adjust its value byte-by-byte to see how long the rejection takes each time.In your case, your byte arrays (that you're comparing) are generated from generateSecret(), which suggests to me that it's not attacker-controlled. So, on the surface, it doesn't appear as if a time-constant comparison is necessary. But I'm not a security expert, so I don't know for sure. It's always safe (but can be slow, if the strings being compared are long) to use a time-constant comparison, so if at all unsure, that's what I suggest. No, but you can send the symbol instead:def overdue_tasks_valid validate_notification :overdue_tasksenddef created_overdue_tasks_valid validate_notification :created_overdue_tasksenddef validate_notification(method) notification = send method return if notification.valid? notification.errors.full_messages.each do |message| errors.add method, message endendThe secret sauce is, of course, Object#send. You are on the right track, and almost got it. You just need to use "$@" instead of $@.Here's a summary of what $* and $@ do, with and without quotes:$* and $@ paste in the positional arguments, then tokenise them (using $IFS) into separate strings."$*" pastes in the positional arguments as one string, with the first character of $IFS (usually a space) inserted between each."$@" pastes in the positional arguments, as a string for each argument.Examples:$ set foo bar "foo bar:baz"$ printf "%s\n" $*foobarfoobar:baz$ printf "%s\n" $@foobarfoobar:baz$ printf "%s\n" "$*"foo bar foo bar:baz$ printf "%s\n" "$@"foobarfoo bar:bazHere's what changes when you set $IFS:$ IFS=:$ printf "%s\n" $*foobarfoo barbaz$ printf "%s\n" $@foobarfoo barbaz$ printf "%s\n" "$*"foo:bar:foo bar:baz$ printf "%s\n" "$@"foobarfoo bar:baz You don't have to listen to both HTTP and HTTPS on the same port, in your specific case of writing a proxy server. Browsers connect to proxy servers via HTTP, whether for proxying HTTP or HTTPS requests. HTTPS requests use the CONNECT HTTP method to open a direct connection to the HTTPS server---that CONNECT request is still done in the unencrypted portion of the proxy traffic.Edit: Here's what I think your code should look like:http.createServer(function (request, response) { // Handle normal requests here}).on('connect', function (request, socket, head) { // Handle CONNECT requests here}).listen(3128); ConcurrentHashMap is designed to be non-blocking, although some contention is possible if multiple updates to the same hash segment happened simultaneously.Yes. The documentation explains how this works: Set the data at this location to the given value. The native types accepted by this method for the value correspond to the JSON types:  Boolean Long Double Map&lt;String, Object&gt; List&lt;Object&gt;  In addition, you can set instances of your own class into this location, provided they satisfy the following constraints:  The class must have a default constructor that takes no arguments The class must define public getters for the properties to be assigned. Properties without a public getter will be set to their default value when an instance is deserialized So, you must create getters for all the properties that you want saved. In your example, your firstProperty property will be written, though it won't be possible to read it back because you haven't defined a default constructor. In your case, you can't put them all into one CASE, since the results all go into different columns of the select.BTW, you should remove your ISNULL(region, '''') &lt;&gt; '''' condition, as it's redundant when paired with the LEN(region) &gt; 5 condition. (When region is null, then LEN(region) is also null, and NULL &gt; 5 is false.) Map&lt;Person, List&lt;Dog&gt;&gt; is not compatible with Map&lt;Person, List&lt;? extends Dog&gt;&gt;. In this case, the map's value type is expected to be List&lt;? extends Dog&gt;, not something that is convertible to same. But if you used Map&lt;Person, ? extends List&lt;? extends Dog&gt;&gt; for f's parameter, it will work.Here's a simple example involving more basic types:Map&lt;String, List&lt;?&gt;&gt; foo = new HashMap&lt;String, List&lt;Object&gt;&gt;(); // errorMap&lt;String, ? extends List&lt;?&gt;&gt; foo = new HashMap&lt;String, List&lt;Object&gt;&gt;(); // okThe OP asks why that behaviour occurs. The simple answer is that type parameters are invariant, not covariant. That is, given a type of Map&lt;String, List&lt;?&gt;&gt;, the map's value type must be exactly List&lt;?&gt;, not something similar to it. Why? Imagine if covariant types were allowed:Map&lt;String, List&lt;A&gt;&gt; foo = new HashMap&lt;&gt;();Map&lt;String, List&lt;?&gt;&gt; bar = foo; // Disallowed, but let's suppose it's allowedList&lt;B&gt; baz = new ArrayList&lt;&gt;();baz.add(new B());bar.put("baz", baz);foo.get("baz").get(0); // Oops, this is actually a B, not an AOops, the expectation for foo.get("baz").get(0) to be an A is violated.Now, suppose we do it the correct way:Map&lt;String, List&lt;A&gt;&gt; foo = new HashMap&lt;&gt;();Map&lt;String, ? extends List&lt;?&gt;&gt; bar = foo;List&lt;B&gt; baz = new ArrayList&lt;&gt;();baz.add(new B());bar.put("baz", baz); // DisallowedThere, the compiler caught the attempt to put an incompatible list into foo (via the alias bar). This is why the ? extends is required. Your major problem is that your recursive calls into fetch-exp swapped the order of the arguments. It should be (fetch-exp (sub1 n) (left-tree bt)) and (fetch-exp (sub1 n) (right-tree bt)). Alternatively, change the function's parameter order: (lambda (bt n) ...). It worked for me:$ g++-4.7 -O2 -Wall -std=c++11 -c mutextest.cc$ g++-4.6 -O2 -Wall -std=c++0x -c mutextest.cc$ g++-4.6 -O2 -Wall -std=gnu++0x -c mutextest.cc$ g++-4.4 -O2 -Wall -std=c++0x -c mutextest.cc$ g++-4.4 -O2 -Wall -std=gnu++0x -c mutextest.ccNone of these generated any error messages. You can use (integer-&gt;char 20351) to get that character, or you can use literal syntax, #\u4F7F. int bigwidth = 800;int bigheight = 500;int cropwidth = 70;int cropheight = 70;img.getSubimage((bigwidth - cropwidth) / 2, (bigheight - cropheight) / 2, cropwidth, cropheight); Don't use encryption just to hide how your client-server protocol works. If you want your server to be secure, make it secure even when the client is in full control of what goes on.As you've mentioned, it's easy to control the client: not just via decompilation, but also by running the client in a debugger (which can modify the contents of any object, modify control flow, etc.).My points, then, are:It's important to identify where the potential attack vectors are in your server, and address those. For example, if you want to be able to send a cookie to a client, which you want them to send back unaltered, you don't need encryption for that; just use HMAC.If you actually really want to encrypt traffic between client and server, don't use straight AES (especially because it sounds like you're using a fixed key, which is insecure). You want to use a protocol designed for wire encryption, like TLS (SSL). Yes, really use TLS (including acquiring a certificate from a certificate authority); don't take shortcuts.The nice thing about TLS is that there are no shared secrets (such as keys) that you have to embed into your jar. So there is nothing you have to worry about hiding. I suggest you set up a tcpdump session to see where the connection refused is coming from. In particular, see what the source IP and destination IP addresses are, for both the successful connections and the unsuccessful ones.There are two possibilities the above is designed to test for:You say you're not using proxy servers, but Java actually has a separate proxy configuration from the rest of the system, so it may be that your Java is configured to use a non-functional proxy server.Your Java system could be sending requests using a different source IP address to the one that your curl is using. Use this:web.add(new Node(0, "google", new int[] {1, 2})); These two expressions are equivalent:foo.map {|x| x.hex}foo.map &amp;:hex Easy, change the System.out.println to System.out.print. Done. :-DTo return a String instead, simply create a StringBuilder outside the loop, then append each line of the input to it.Sample code to demonstrate the latter (I just realised what the OP wants, which is spaces instead of newlines):StringBuilder result = new StringBuilder();while ((line = br.readLine()) != null) { if (result.length() != 0) result.append(' '); result.append(line);}return result.toString();Hiren Patel's style of reading each character works too:StringBuilder result = new StringBuilder();while ((c = br.read()) != -1) result.append(c == '\n' ? ' ' : (char) c);return result.toString(); convertBSTRToString probably allocates a new buffer that's sized exactly right to hold the BSTR you passed in. That means you cannot expand its size.In your code, you are trying to add currentDateTime()'s result into that buffer (in addition to its existing content). The data won't fit. Thus, bad things happen. For a top-level class, you can't use private, protected, or static.For a nested class, all of those modifiers are allowed. Using a foreach over a hash will get its keys and values sequentially, so don't do that.This worked for me:while (my ($k, $v) = each %read_data) { print "$k = $v\n";}(I vastly prefer getting hash entries rather than hash keys which then have to be looked up again.) Use E if you need to refer to the type later on. Use ? if you never have to refer to the type again. This works for me:$ a='{"name":"any"}'$ echo $a{"name":"any"}$ export b="$a"$ echo $b{"name":"any"}Why do you want to use eval to export a variable? Note, the variable name is interpolated too, so you can do this:$ foo=bar$ export $foo=baz$ echo $barbaz scp requires a remote host name to copy to (or from). In your sample command, you didn't specify which host you're copying to, so it assumed you're doing a local copy. Don't instantiate an org.apache.xerces.jaxp.DocumentBuilderFactoryImpl directly. Always use DocumentBuilderFactory.newInstance, which will use (among other things) the Services API to locate the actual DocumentBuilderFactory to instantiate. Use Console.readLine to read input from the console. You can get an instance of Console using System.console.Example:String s = System.console().readLine("Enter a port number: ");int port = Integer.parseInt(s);If System.console() returns null, that means that (from the JVM's perspective) you don't actually have a console. This may happen if your standard input has been redirected. Assuming 16 nodes:sub nodes { my ($num) = @_; grep {($num &gt;&gt; ($_ - 1)) &amp; 1} 1..16;} Your current approach doesn't actually count how many members are in a given type; it just keeps track of what the last member added is.To keep a count, consider using a hash-of-a-hash; use this for each $member_id you're adding:$cases{$type}{$member_id} = 1;The value for the hash assignment doesn't matter; it's just a way to use hash keys to maintain uniqueness.Then, to get the number of members for a given type, usescalar keys %{$cases{$type}} The term you're looking for is singleton.Both static methods and instance methods on a singleton are okay approaches, but note that the static methods approach cannot implement an interface, so if you need to implement an interface, use a singleton.For example:public enum HelloWorld implements Runnable { INSTANCE; @Override public void run() { System.out.println("Hello, world!"); }}// ...new Thread(HelloWorld.INSTANCE).start();If your hello-world code were in a static method, it wouldn't have been able to directly implement the Runnable interface. One way to do something similar to what you want, without having to use macros, is via SRFI 17:(require srfi/17)(define (bind-field field obj) (getter-with-setter (lambda () (dynamic-get-field field obj)) (lambda (val) (dynamic-set-field! field obj val))))Now, you can do this (I renamed your object from car to obj, since car is a built-in function and you don't want to shadow that):(define color (bind-field 'color obj))(set! (color) "green")(pretty-display (color)) Try this:SelectNodes("//*[matches(text(), '^[A-Z]')]");However, you may need to follow these steps before it will work. Sounds like this should do the trick (using this defintion of defmac):(defmac (operation expr where (binding ...)) #:keywords where (let* (binding ...) expr))It simply converts your operation form into the equivalent let*, so that your example would become:(let* ((x 1) (y (+ x 32))) (+ x y)) In the first version, txt[i] has been bound to a new variable, msg, which is a different location for each function being created.In the second version, i is the same location for each of the functions because i's scope is further up; there isn't a new i variable being created each time through the loop. C++ has a concept of pointers, where the variable holds only a "handle" to an actual object. The type of the actual object is not known at compile-time, only at runtime. Example:#include &lt;iostream&gt;#include &lt;memory&gt;class Greeter {public: virtual void greet() = 0;};class HelloWorld : public Greeter {public: void greet() {std::cout &lt;&lt; "Hello, world!\n";}};class GoodbyeWorld : public Greeter {public: void greet() {std::cout &lt;&lt; "Goodbye, world!\n";}};int main() { std::unique_ptr&lt;Greeter&gt; greeter(new HelloWorld); greeter-&gt;greet(); // prints "Hello, world!" greeter.reset(new GoodbyeWorld); greeter-&gt;greet(); // prints "Goodbye, world!"}See also: Vaughn Cato's answer, which uses references (which is another way to hold a handle to an object). gcc 4.7 does support C++11, if you run it with the -std=c++11 option. Have you tried that? Much shorter:int i = 3;i = 8 - i;i = 8 - i;And of course, for your 0/1 toggle, you should do this:int i = 0;i = 1 - i;i = 1 - i;And in general, for an a/b toggle, do this:int i = a;i = (a + b) - i;i = (a + b) - i;How does that work? Well, a + b - a is b, and a + b - b is a. :-D Not all methods from AbstractList are overridden. Remember that AbstractList subclasses AbstractCollection, which defines methods like containsAll or toString which are not overridden by either ArrayList nor LinkedList. You need to use s1.begin() and s1.end(), not occurrences.begin() and occurrences.end(), since occurrences is a type, and s1 is a variable of that type. string1, string2, and string3 are all string constants. i.e., they appear as constant pool entries in the .class file. In Java, string constants are interned.string4 is a new string, created by taking the string constant "he" and then appending "y". Therefore, it's not a string constant, and is not interned.That is why string3 != string4. You also need to add -lboost_system after where you had -lboost_thread. public static List&lt;Integer&gt; getOpenRange(int start, int end) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = start + 1; i &lt; end; ++i) result.add(i); return result;} Constructors are chained: each constructor you write must eventually invoke one of the superclass constructors. Example:public class MyException extends RuntimeException { public MyException(String message) { super(message); // invokes RuntimeException(String) constructor }}A super(...) or this(...) constructor invocation, if any, must appear as the first statement in your constructor. If neither of those is specified, super() is implicitly assumed, which will chain up to the superclass's default constructor. (And if the superclass has no default constructor, then the compilation will fail.) Java Native Access (JNA) is a way you can access C libraries from Java code. Its advantage over Java Native Interface (JNI) is that the library glue code is written in Java, not C, making it more maintainable.(I've used JNA a lot at work. If I get permission from work, I may be able to post the JNA stuff I've written, as examples for you to work with.) You should call shutdown first. Otherwise, you might be waiting for a very long time, since awaitTermination doesn't actually shut down your executor.If you wanted to wait for tasks to complete, rather than wait for the executor to shut down, then you should use invokeAll. In Java, bytes are signed, and in C#, bytes are unsigned. You can convert from signed to unsigned by adding 256 to the number, so that (in your example) -32 becomes 224 and -3 becomes 253.As Ichabod Clay says (in comments), you can also use the sbyte type so that you don't have to do that conversion. Personally I dislike signed bytes, so if this were for literal data, I'd just convert once and be done, but you have a choice. Yay. :-D Java doesn't have pairs; Java programmers tend to write their own class for that kind of thing. e.g.,class HLine { public final CvPoint point; public final double x; public final double y; public HLine(CvPoint point, double x, double y) { this.point = point; this.x = x; this.y = y; }}Then you can just create an ArrayList&lt;HLine&gt;. A .wav file is simply a RIFF file of type WAVE, with (at least) the fmt  and data chunks. The fmt  chunk contains information about the format of the data chunk, which contains the raw data.So if you want, you can extract just the data chunk for your usage. The RIFF format is really simple (read the Wikipedia page I linked). You should not have any trouble extracting the data chunk. I've written some sample to demonstrate the Comparator concept. It requires Guava:import java.util.Collections;import java.util.Comparator;import java.util.List;import com.google.common.collect.ComparisonChain;import com.google.common.primitives.Chars;public class Test { private enum Comparators implements Comparator&lt;Character&gt; { UPPER_DIGIT_LOWER { @Override int compare(char lhs, char rhs) { return ComparisonChain.start() .compareTrueFirst(Character.isUpperCase(lhs), Character.isUpperCase(rhs)) .compareTrueFirst(Character.isDigit(lhs), Character.isDigit(rhs)) .compareTrueFirst(Character.isLowerCase(lhs), Character.isLowerCase(rhs)) .compare(lhs, rhs) .result(); } }, LOWER_DIGIT_UPPER { @Override int compare(char lhs, char rhs) { return ComparisonChain.start() .compareTrueFirst(Character.isLowerCase(lhs), Character.isLowerCase(rhs)) .compareTrueFirst(Character.isDigit(lhs), Character.isDigit(rhs)) .compareTrueFirst(Character.isUpperCase(lhs), Character.isUpperCase(rhs)) .compare(lhs, rhs) .result(); } }; @Override public int compare(Character lhs, Character rhs) { return compare(lhs.charValue(), rhs.charValue()); } abstract int compare(char lhs, char rhs); } private static String sortChars(String str, Comparator&lt;Character&gt; cmp) { List&lt;Character&gt; chars = Chars.asList(str.toCharArray()); Collections.sort(chars, cmp); return new String(Chars.toArray(chars)); } public static void main(String[] args) { String name = "h498y948759hrh98A722hjDF94yugerTEr892ur48y"; System.out.println(sortChars(name, Comparators.UPPER_DIGIT_LOWER)); System.out.println(sortChars(name, Comparators.LOWER_DIGIT_UPPER)); }} You need to use %f (or %e or %g, depending on your preferred format) instead of %d for floating-point numbers. Indeed, using %d for non-integers is "undefined behaviour".printf("%f", c);Alternatively, if you're trying to round the floating-point to an integer, you must cast it first.printf("%d", (int) c); HashMap iteration order depends on how the object hashes are distributed among the buckets. When you add a new item, the number of buckets may be expanded, which will require the entries to be redistributed, which will reorder everything.Also, as a security measure, current implementations of HashMap have a randomised hashing mode ("alternative hashing") which is enabled after a certain threshold (jdk.map.althashing.threshold). This is to thwart a certain class of denial-of-service attacks which involve trying to find hash collisions. Oh look, this compares correctly!&gt; (= (* #e1.1 #e1.1) #e1.21)#t(Racket has this really nice feature that #e1.1 is actually read in as exactly 1.1. Other Scheme implementations do not necessarily work that way, and may actually read in #e1.1 as floating-point first and then convert to exact.)Anyway, to elaborate on everybody else's point, without an exactness specifier, Scheme treats a number literal with a dot in it as inexact† (that is, 1.1 and #i1.1 read in as the same thing). And with inexact numbers, you cannot really expect sane results when doing "exact" comparisons (such as =).† R7RS, section 6.2.5: "If the written representation of a number has no exactness preﬁx, the constant is inexact if it contains a decimal point or an exponent. Otherwise, it is exact." Yes, you can do this using open-output-pipe:(let ((p (open-output-pipe "wc"))) (display "The quick brown fox jumps over the lazy dog.\n" p) (close-pipe p))This is equivalent to echo "The quick brown fox jumps over the the lazy dog." | wc (including echo's implicit newline because I'm that particular, lol).There is, of course, an open-input-pipe analogue. Read the Pipes section of the Guile manual for more details. In the s/regexp/replacement/ syntax, the / can be replaced by any other character, such as ,, :, @, etc. This is very useful if your regexp itself contains / characters, such as your example of .*/.*\..Your command could be simplified a bit, though:find . -type f -name '*.*' | sed 's/.*\././' | sort -uHere, I simplified the regexp so that it no longer contains a / character. Since this is a Swing application, there is indeed no terminal (tty) present, even if you're using JTerminal (which looks like a terminal but doesn't actually take over your tty). You will instead need to set up an askpass program (as the error message says), which will prompt the user for a password.To set up an askpass program, you can either set the SUDO_ASKPASS environment variable, or else set it up in sudoers using Path askpass .... See the manual page for more details.Alternatively, if your password isn't very secret and you don't mind seeing it echoed on screen, run sudo with the -S option. printf writes using stdio, which does buffering (i.e., what's written doesn't get output straight away). You need to call fflush(stdout) first, before you send your syscall to read (since syscalls bypass stdio and knows nothing about buffers).Also, as Kerrek SB has noted, your asm does not have a clobber list and it's not volatile. That means that gcc is free to relocate your assembly code elsewhere in the function (since it's free to assume your assembly code has no side effects), which may have a different effect from what you expect. I recommend you use asm volatile. An apk file is just a jar file for Android. You can unpack it using unzip, jar, etc., which will extract any HTML files within (if any).If the app you're trying to work with isn't actually an HTML5 app, then there probably won't be any HTML files for you to play with. There is no automatic way to convert a native app to HTML5. You can dump out the structure of an object using the Data::Dumper module.use Data::Dumper;print Dumper($data); Heroku is a "platform as a service" that allows you to deploy web applications by simply pushing code to Heroku's repo. Heroku handles all the configuration and maintenance of the system for you. It's ideal for developers who just want to code, and not spend time having to set up and maintain servers. Here's a Perl script (let's call it match7th.pl) that will print out any lines where the 7th field matches the pattern given (e.g. 11A):#!/usr/bin/perl -wuse strict;my $pat = qr/$ARGV[0]/;while (&lt;STDIN&gt;) { my (undef, undef, undef, undef, undef, undef, $seventh) = split /_/; print if defined($seventh) &amp;&amp; $seventh =~ $pat;}Run it like this:find . -name '*.png' | perl match7th.pl 11A Arrays are not resizeable. So with method 1, you can create a new array with just the right size and return that. With method 2, if the incoming array is the wrong size, you're sunk.Java does not have pass-by-reference. So assigning something to someObject in method 2 won't do anything for the caller. You can only alter the elements of someObject. The host and user arguments must be specified as positional arguments, not as part of the options hash. Thus:Net::SSH.start(conn['host'], conn['user'], port: conn['port'], password: conn['password']) do |ssh| # ...endOr you can just pass through all the YAML key-value pairs directly:Net::SSH.start(conn.delete('host'), conn.delete('user'), conn) do |ssh| # ...end active_questions_for_standard_and_element may indeed return an array, but by applying [index-1] to it, you are getting an element from that array. Unless your array is meant to contain subarrays, you should not expect active_questions_for_standard_and_element(...)[index-1] to result in an array. Yes, the Racket web server does support virtual hosting. Read up more about dispatch-host. Sorry, I don't have example code either. Yes.First, check whether the node is an Element. If so, cast to it.Call Element.getAttribute. You will need to inspect the method's parameter types, then adjust the arguments accordingly. In C++, objects have definite lifetimes. Automatic variables' lifetimes end when they go out of scope, and dynamically-allocated objects' lifetimes end when they get deleted.In C#, most objects are dynamically allocated, and there is no delete. Therefore, objects don't have a defined point in time when they are "deleted". The closest thing you have, then, is using. I do think that the FooStatic approach you have is the best way to go about it, in terms of adhering to good OO practice. Essentially, your non-static Foo overrides work like function pointers into your static versions.(Emphasis on "work like": you can't actually use function pointers directly, since your override for Foo has to throw away the reference to this before invoking FooStatic.) You can use Charset to encode a CharSequence to a byte array:private static byte[] encodeUtf8(CharSequence cs) { ByteBuffer bb = Charset.forName("UTF-8").encode(CharBuffer.wrap(cs)); byte[] result = new byte[bb.remaining()]; bb.get(result); return result;}If, instead of OutputStream, you're using an instance of WritableByteChannel, its write method takes ByteBuffer directly, so you don't even need to copy the byte buffer to a byte array first. unquote is only useful in the context of quasiquote, and quasiquote can be implemented as a macro (that uses quote behind the scenes). So there's no need to have an unquote primitive; the quasiquote macro simply deals with unquote symbols as they are found.(quasiquote is the Scheme name for the backtick quote. Thus:`(foo bar ,baz)is read in as(quasiquote (foo bar (unquote baz)))in Scheme.)Here's a very simple Scheme quasiquote macro (it only handles lists, unlike standard quasiquote which also handles vectors and other data types):(define-syntax quasiquote (syntax-rules (unquote unquote-splicing) ((quasiquote (unquote datum)) datum) ((quasiquote ((unquote-splicing datum) . next)) (append datum (quasiquote next))) ((quasiquote (datum . next)) (cons (quasiquote datum) (quasiquote next))) ((quasiquote datum) (quote datum))))Equivalent version using all the standard reader abbreviations:(define-syntax quasiquote (syntax-rules (unquote unquote-splicing) (`,datum datum) (`(,@datum . next) (append datum `next)) (`(datum . next) (cons `datum `next)) (`datum 'datum))) Another instance where explicit destructor calls are used is with objects that were manually constructed using placement new.Say you were trying to use a malloc/free-compatible API (e.g., for interaction with C clients that allow specifying custom C-style allocators):void* buf = malloc(sizeof (MyType));if (buf) { MyType* foo = new (buf) MyType; // ... foo-&gt;~MyType(); free(buf);}(Though, in this instance, it's better to just use a shared_ptr or unique_ptr with a custom deleter.) Array elements are always mutable. There is no way to make them final, sorry.As an aside, it is for this reason that EnumType.values() (where EnumType is an enum type) will always defensively copy the internal values array before returning, because there is no way to make the internal values array immutable. If you want to return the map entry (i.e., both the key and value), then just use std::pair&lt;int, std::string&gt; as the return type, as other answers mentioned.If you want to just return the key, return it-&gt;first (and use int as the return type). If you want to return just the value, return it-&gt;second (and use std::string as the return type). A better approach is this:function ($team1, $team2) { if ($team1-&gt;points != $team2-&gt;points) { return $team1-&gt;points &gt; $team2-&gt;points ? 1 : -1; } $diff1 = $team1-&gt;goalsFor - $team1-&gt;goalsAgainst; $diff2 = $team2-&gt;goalsFor - $team2-&gt;goalsAgainst; if ($diff1 != $diff2) { return $diff1 &gt; $diff2 ? 1 : -1; } return 0;}Or, in Java (using Guava), I'd write it like this:public int compare(Team team1, Team team2) { return ComparisonChain.start() .compare(team1.getPoints(), team2.getPoints) .compare(team1.getGoalsFor() - team1.getGoalsAgainst(), team2.getGoalsFor() - team2.getGoalsAgainst()) .result();}Clearly, PHP doesn't have ComparisonChain, but it shouldn't be hard to implement. hlt does not reboot; that's not what it's for. It pauses the processor until an interrupt arrives, and since you've disabled interrupts, it will just sit there doing nothing forever.As to why the emulator consumes 100% CPU, that's probably due to the way the emulator is implemented. On (some versions of) Linux, hlt is used to idle the processor until the next timeslice, so of course it doesn't make the processor busy-wait. :-) If you have no uncommitted changes, you can run these commands (in this sequence):git reset .git checkout . This is because of the way two's-complement number systems work. Integer.MIN_VALUE corresponds to 0x80000000. The standard way to negate it is to take its ones' complement (0x7FFFFFFF in this case) and add 1, and in this case it would overflow back to 0x80000000. You need to implement your test and otherTest methods as Runnable implementations. Like so:private static class Test implements Runnable { @Override public void run() { try { Thread.sleep((long) (Math.random()*1000)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return; } System.out.println("test"); }}private static class OtherTest implements Runnable { @Override public void run() { try { Thread.sleep((long) (Math.random()*1000)); } catch (InterruptedException e) { Thread.currentThread().interrupt(); return; } System.out.println("Othertest"); }}public static void main(String args[]) { new Thread(new Test()).start(); new Thread(new Test()).start(); new Thread(new OtherTest()).start(); new Thread(new Test()).start(); new Thread(new OtherTest()).start(); new Thread(new Test()).start(); new Thread(new Test()).start(); new Thread(new Test()).start();}You could, of course, try to reduce the duplication a little:private enum Runnables implements Runnable { TEST { @Override public void run() { if (!sleep()) return; System.out.println("test"); } }, OTHER_TEST { @Override public void run() { if (!sleep()) return; System.out.println("Othertest"); } }; static boolean sleep() { try { Thread.sleep((long) (Math.random()*1000)); return true; } catch (InterruptedException e) { Thread.currentThread().interrupt(); return false; } }}public static void main(String args[]) { new Thread(Runnables.TEST).start(); new Thread(Runnables.TEST).start(); new Thread(Runnables.OTHER_TEST).start(); new Thread(Runnables.TEST).start(); new Thread(Runnables.OTHER_TEST).start(); new Thread(Runnables.TEST).start(); new Thread(Runnables.TEST).start(); new Thread(Runnables.TEST).start();} You should be storing shared_ptr&lt;Plant&gt; in your vector, not just Plant. With what you're currently doing, you're getting slicing, which means that you're not actually storing Broccolis, only the Plant portions thereof (and a cast to Broccoli, as you suggested at the end of your post, will not work). Here's a very simple implementation, which will give you an idea of where to start. :-)import java.io.PrintStream;import java.util.Collections;import java.util.Map;import java.util.Scanner;import java.util.TreeMap;import java.util.regex.Pattern;public class PathWalker { public static class Node { private final Map&lt;String, Node&gt; children = new TreeMap&lt;&gt;(); public Node getChild(String name) { if (children.containsKey(name)) return children.get(name); Node result = new Node(); children.put(name, result); return result; } public Map&lt;String, Node&gt; getChildren() { return Collections.unmodifiableMap(children); } } private final Node root = new Node(); private static final Pattern PATH_SEPARATOR = Pattern.compile("\\\\"); public void addPath(String path) { String[] names = PATH_SEPARATOR.split(path); Node node = root; for (String name : names) node = node.getChild(name); } private static void printHtml(Node node, PrintStream out) { Map&lt;String, Node&gt; children = node.getChildren(); if (children.isEmpty()) return; out.println("&lt;ul&gt;"); for (Map.Entry&lt;String, Node&gt; child : children.entrySet()) { out.print("&lt;li&gt;"); out.print(child.getKey()); printHtml(child.getValue(), out); out.println("&lt;/li&gt;"); } out.println("&lt;/ul&gt;"); } public void printHtml(PrintStream out) { printHtml(root, out); } public static void main(String[] args) { PathWalker self = new PathWalker(); Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) self.addPath(scanner.nextLine()); self.printHtml(System.out); }}Originally, I thought about making separate classes for directories and regular files, but I felt in this case that, since all you wanted to do is to print the names, that using a unified node class makes the code simpler to work with, not least because you can avoid having to implement the visitor pattern.The output isn't formatted in any particular nice way. So that's something you can tweak the code on, if you want; alternatively, you can run the output through HTML Tidy if you want something nicer-looking.I chose to use TreeMap, so the directory entries are lexicographically ordered. If you want to use insertion order instead, just change to use LinkedHashMap. For a completely different approach, this uses an explicit do loop to do the summing. It avoids using expt (by design).(define (zeno n) (do ((n n (- n 1)) (sum 0 (+ sum frac)) (frac 1/2 (/ frac 2))) ((zero? n) sum)))It may or may not be more readable when written into its equivalent named let form:(define (zeno n) (let loop ((n n) (sum 0) (frac 1/2)) (if (zero? n) sum (loop (- n 1) (+ sum frac) (/ frac 2)))))For an even more completely different approach, you can use SRFI 41 streams:(define zeno (let ((frac-stream (stream-iterate (cut / &lt;&gt; 2) 1/2))) (lambda (n) (stream-fold + 0 (stream-take n frac-stream)))))(The above snippet also requires SRFI 26 to be loaded, in addition to SRFI 41.)An even even more completely different approach: just use the closed-form solution! (Thanks, WorBlux.)(define (zeno n) (- 1 (/ (expt 2 n)))) Vectors are not resizeable. So a vector-append! that extends a vector's size is not possible. You don't have to fork the repo. You just have to clone it. You can always push your clone to a newly-created project later on, if needed.But yes, this sort of thing has happened before, with all of why the lucky stiff's projects. Variant of Óscar López's solution that doesn't use any parsing (as the question requested):public class BigNum { public static void main(String[] args) { int[] nums = {1, 7, 12, 16, 3, 8}; System.out.println(concatNums(nums)); } public static long concatNums(int[] nums) { long result = 0; long multiplier = 1; for (int i = nums.length; i &gt; 0; --i) { int num = nums[i - 1]; while (num != 0) { result += multiplier * (num % 10); num /= 10; multiplier *= 10; } } return result; }}This won't work correctly if the array contains a 0. If that's important, let me know and I'll tweak the algorithm to accommodate it. The main problem in your code was that you were trying to make multiple passes through the stream. (Each call to stream-length is one pass, and each of your calls to for/sum (or stream-fold, for that matter) is another pass.) This means that you had to materialise the whole stream without allowing the earlier stream elements to be garbage-collected.Here's a modification of your code to make only one pass. Note that I made num-prospects to be 8,000,000 in my version, since even the multi-pass version didn't run out of memory on my system with only 800,000:#lang racket(require srfi/41)(define (make-prospects src num) (stream-take num (apply stream-constant src)))(define (calc-stats prospects) (define default (const '(0 . 0))) (define ht (for/fold ([ht #hash()]) ([p (in-stream prospects)]) (hash-update ht (vector-ref p 0) (λ (v) (cons (add1 (car v)) (+ (cdr v) (vector-ref p 1)))) default))) (define stats-a (hash-ref ht "a" default)) (define stats-b (hash-ref ht "b" default)) (list (car stats-a) (car stats-b) (cdr stats-a) (cdr stats-b)));================================; Main;================================(define num-prospects 8000000)(define raw-prospects '(#("a" 2 2 5 4 5 6 2 4 2 45 6 2 4 5 6 3 4 5 2) #("b" 1 3 5 2 4 3 2 4 5 34 3 4 5 3 2 4 5 6 3)))(calc-stats (make-prospects raw-prospects num-prospects))I should clarify that the use of srfi/41 is simply to enable writing a more-efficient version of make-prospects (though, the reference implementation of stream-constant isn't very efficient, but still more efficient than what your prospects stream generator did); calc-stats doesn't use it. You can call ResultSet.getMetaData to get the ResultSet's metadata. That contains a ResultSetMetaData.getColumnCount method that tells you how many columns the ResultSet has. Sure:List&lt;String&gt; list = Arrays.asList("foo", "bar", "baz");String[] array = list.toArray(new String[0]);array[0] = "qux";System.out.println(list.get(0)); // still "foo" You can use $() to interpolate the output of a command. So, you could use kill -9 $(grep -hP '^\d+$' $(ls -lad /dir/*/pid | grep -P '/dir/\d+/pid' | awk '{ print $9 }')) if you wanted to. Not universal at all. Chicken, for example, will not allow you to evaluate an unquoted vector.#;1&gt; #(1 2 3)Error: illegal non-atomic object: #(1 2 3)#;1&gt; '#(1 2 3)#(1 2 3) In order for definitions to be usable during the macro definition phase, use for-syntax:(require (for-syntax "exceptions.rkt")) If you wanted to "store the boolean result in a register", you'd need separate instructions for &lt;, &lt;=, &gt;, &gt;=, etc. You'd also need one set for signed comparison and another for unsigned comparison.In the x86 instruction set, there is one instruction for all of these, cmp (which sets a bunch of flags), then you use the appropriate jxx or setxx instruction to look at the flags that interest you (e.g., for the conditional jumps, you use jb, jbe/jna, ja, jae/jnb for unsigned ("below"/"above"), and jl, jle/jng, jg, jge/jnl for signed ("less"/"greater")).Another feature of this approach is that you can actually check the flags after you do a mutation operation, like carrying additions or borrowing subtractions. Example (assume esi points to a 128-bit number that's being added to another 128-bit quantity that edi points to):add [edi], [esi]adc [edi+4], [esi+4]adc [edi+8], [esi+8]adc [edi+12], [esi+12]jc overflowThat's just 5 instructions (well, hypothetically; in reality, x86 instructions can't have both operands be addresses, one has to be a register, which means that loading that register will take more instructions). Using a "boolean result in a register" approach sounds like it'd be more complicated (but I guess not by much, if you're using an instruction set that allows a three-way addition). The two methods are running in a worker thread, but sequentially. So, analyzeHTML is called first, within a worker thread, then when it's done, download is called in that same thread. It rounds up to the nearest multiple of 16. Presumably, this is to fix a size for allocating the buffer for the basename, whatever it is. :-)However, if that were what it's for, i.e., deciding how big of a buffer to allocate, then this is not a good strategy. Ideally, you want to expand by a factor of 2 or at least 1.5 each time. The line(swap! (box (Sr i)) (box (Sr j)))won't do what you expect. It doesn't magically make (Sr i) and (Sr j) mutable references. The swap! procedure swaps the contents of the boxes---but the boxes contain (Sr i) and (Sr j) by value, not by reference.What you need to do is to amend your swap! procedure to use unsafe-bytes-set! instead.Here's some code to demonstrate my point:#lang racket(require racket/unsafe/ops)(define (box-swap! x y) (define tmp (unbox x)) (set-box! x (unbox y)) (set-box! y tmp))(define (wrong-swap! bs x y) (box-swap! (box (unsafe-bytes-ref bs x)) (box (unsafe-bytes-ref bs y))))(define (right-swap! bs x y) (define tmp (unsafe-bytes-ref bs x)) (unsafe-bytes-set! bs x (unsafe-bytes-ref bs y)) (unsafe-bytes-set! bs y tmp))Example:&gt; (define bs (bytes 1 2 3 4 5 6))&gt; bs#"\1\2\3\4\5\6"&gt; (wrong-swap! bs 0 5)&gt; bs#"\1\2\3\4\5\6"&gt; (right-swap! bs 0 5)&gt; bs#"\6\2\3\4\5\1" According to the colour preferences, it indicates code that the tests didn't cover: In the same spirit as Óscar López's answer, here's another stream-based implementation:(#%require srfi/41)(define (sum-first-n-evens n) (stream-fold + 0 (stream-take n (stream-from 0 2)))) Yes, let binds a value to the given identifier, and its value doesn't change unless you use set! on it.So you can do this:(let ((x (- (* 2 (random)) 1)) (y (- (* 2 (random)) 1))) (sqrt (+ (* x x) (* y y))))Of course, I find it easier to define a hypot function for what you're doing (corresponding to C's hypot function):(define (hypot x y) (sqrt (+ (* x x) (* y y))))(hypot (- (* 2 (random)) 1) (- (* 2 (random)) 1))Now you don't need to use let at all!In case the connection isn't immediately obvious, the way let works behind the scenes is to create a function (with pretty much the same contents as hypot, in this case), and just calls that function with the values you're binding. So, the two snippets of code above are effectively identical (except that the latter one also adds a top-level binding for hypot). Your parentheses are all messed up, and your argument order for &lt; is wrong. Here's how the code should look like after it's corrected:(define (monte-carlo-sampling n) (let ((x (- (* 2 (random)) 1)) (y (- (* 2 (random)) 1))) (cond ((= n 0) 0) (else (cond ((&lt; (sqrt (+ (square x) (square y))) 1) (+ 1 (monte-carlo-sampling (- n 1)))) (else (monte-carlo-sampling (- n 1))))))))This returns the number of hits. You'd have to convert the number of hits into a pi estimate using an outer function, such as:(define (estimate-pi n) (* 4 (/ (monte-carlo-sampling n) n)))Here's how I'd write the whole thing, if it were up to me:(define (estimate-pi n) (let loop ((i 0) (hits 0)) (cond ((&gt;= i n) (* 4 (/ hits n))) ((&lt;= (hypot (sub1 (* 2 (random))) (sub1 (* 2 (random)))) 1) (loop (add1 i) (add1 hits))) (else (loop (add1 i) hits)))))(Tested on Racket, using the definition of hypot I gave in my last answer. If you're not using Racket, you have to change add1 and sub1 to something appropriate.) Okay, so you have two iter calls, and you have to decide which values to put into them:For the outer iter call, you have to decide what the initial value for a and result is.For the initial value of result, think about what your function should return if a were greater than b to begin with.For the inner iter call, you have to decide what the next value for a and result will be.For the next value of result, you should add in the current number to the previous result.I hope this helps. Try this:(define abc "abc")(foo abc)You will see very different results between the two versions. I have several suggestions for you:It's probably better to use a parameter instead of a variable, for "global" stuff like your indentation level, since the original value is restored for you at the end of the parameterize expression.All those raise-syntax-error checks you have in your macro are totally superfluous: syntax-case already provides guards (also known as fenders) that allow you to do any validation of macro "arguments" necessary:(define-syntax (define-func stx) (syntax-case stx () [(_ (func-name args ...) body1 body2 ...) (andmap identifier? (syntax-&gt;list #'(func-name args ...))) #'(define (func-name args ...) (log-debug (format "Function-name ~a:" 'func-name) (list args ...)) body1 body2 ...)]))I've also fixed up your code in several places, as you can see above:I used (_ ...) instead of (define-func ...), since in syntax-case (unlike syntax-rules), the latter will actually bind a pattern variable called define-func, which will affect any recursive macro calls you may want to do (I'll grant that you don't have one here, but it's a good habit to have anyway).Rather than completely flatten the #'(args ...) in the guard, I just turned it into a list of syntax objects so you can test using identifier?. This is more intention-revealing than testing using symbol?, and allows us to also test func-name in the same expression.You don't need to use (syntax-e #'func-name) inside the expanded code! Just quote it. "If a tree falls in a forest and no one is around to hear it, does it make a sound?"It's not valid to use define in any context where a return value could meaningfully be obtained. So it's moot whether it has a return value or not; you'll never be able to observe it. Assuming that your memory-mapped file has exactly the same alignment and padding as the type of your uAudioInfo.Pitchmarks[0] (presumably a struct of some kind), you can just use one single memcpy to copy the whole lot, rather than memcpying individual fields like you're currently doing. In the specific case of folding or, you should use ormap. You can pass in identity (or even values ) as the function to use with ormap.&gt; (ormap identity '(#f #f #f #f #t))#t&gt; (ormap identity '(#f #f #f #f #f))#fIn general, you can only fold functions, not macros, and or is a macro because it has short-circuiting behaviour. Here's a skeletal solution:(define (sum-of-three-dice) (define (one-die) &lt;???&gt;) (+ &lt;???&gt; &lt;???&gt; &lt;???&gt;))It's really straightforward, if you think about it.... Make a shell script named, say, summarise_accounts.sh:#!/bin/bashexec paste -d'|' &lt;(grep value:ACCOUNT_NO "$1") &lt;(grep value:bill_ref_no "$1") &lt;(grep value:bill_ref_resets "$1")Make it executable (chmod +x summarise_accounts.sh), then run it like so:./summarise_accounts.sh logs.txt &gt;account_summary.txtYou can, of course, change the file names on the command line. I can't speak about lambdas in C++11, but I know that part of the rationale for adding lambdas to Java 8 is to enable transparent concurrency support out of the box. How? It provides a (lazy) Stream interface where you can switch between parallel and sequential processing simply by calling parallel and sequential (these methods return new streams, and do not have side effects on existing streams).If you look at the methods in Stream, you'll quickly notice that without a lambda facility, they would be an extreme pain to use. Have a look at some examples of what you can do with streams in combination with lambdas.It should be possible to implement a similar library for C++11, if there isn't already such a library. Syntax parameters are not the only way to implement the macro you have in mind. A simpler (IMO) way is to just use datum-&gt;syntax to inject the identifier it:(define-syntax (λλ stx) (syntax-case stx () ((_ body ...) (with-syntax ((it (datum-&gt;syntax stx 'it))) #'(λ (it) body ...)))))To use your example:(define my-negative? (λλ (&lt; it 0)))(my-negative? -1) ;; =&gt; #t The actual hex digits are being interpreted in a big-endian way, but the code looks like it's endianness-neutral, and should work regardless of your computer's endianness. Access checks for reflection happen when the "accessible object" (method, constructor, field, etc.) is accessed. In this case, your field is being written to from a class that is allowed to access it, so it works.(As an aside: This is distinctly different from Java 7 method handles, where the access check happens when the method handle is created, rather than when it's used. You can use method handles to grant extra access to a method you have access to, by passing it to other code that don't normally have such access.) Here's one way to do it:(define (min4 a b c d) (define (min2 x y) (if (&lt; x y) x y)) (min2 (min2 a b) (min2 c d)))Another way to do it, if you don't want to use an internal function:(define (min4 a b c d) (let ((min-ab (if (&lt; a b) a b)) (min-cd (if (&lt; c d) c d))) (if (&lt; min-ab min-cd) min-ab min-cd))) Data literals, like '(()), are meant to be read-only, and modifying it using set-car! or set-cdr! has undefined behaviour. For predictable behaviour, use the (cons '() '()) version if you want to use set-car! or set-cdr! on it.In particular, cons creates a new cons cell, whereas a data literal usually won't.Still, for the purposes of implementing dup, why are you using set-car! and set-cdr! anyway? Just use cons directly: (define (dup x) (cons (car x) (cdr x))) As other answers have mentioned, you cannot have a macro expand into more than one value, and have that spliced into the calling context. But you can do something similar using quasiquotation.Assuming your macro is adapted to return a list instead, you can do this (for your given example):`(1 ,@(foo 2 3) 4)Example (tested in Racket):&gt; `(1 ,@(map sqrt '(2 3)) 4)'(1 1.4142135623730951 1.7320508075688772 4) From what I can tell, you use bind if the function you're calling has already been declared in a header file you've previously #included (including anything automatically included by chicken.h, which all Chicken programs include). If the function you're calling is not already declared, then you need to use bind* to emit a declaration also.So, this would work (math.h is already included by chicken.h):(use bind extras)(bind "double cbrt(double)")(format #t "cbrt(~a) = ~a~%" 27 (cbrt 27)) (value.present? ? value : self[:value]) == CONSTANTEven better:(value.presence || self[:value]) == CONSTANTThat then DRYs up the value. :-) Because sometimes you need to create an overloaded operator where your class type is on the right-hand-side. This must be implemented as a free function. Classic example:ostream&amp; operator&lt;&lt;(ostream&amp; str, my_type const&amp; my){ // print out `my` into `str`---requires `friend` if using // private members of `my_type` return str;} Actually, the straightforward solution I can think of uses map, not local. Now, of course, if you're using a student language that doesn't support map, that's a different story. Anyway, here's a skeletal solution for you:(define (at-0 funcs) (map (lambda &lt;???&gt; (&lt;???&gt; &lt;???&gt;)) funcs)) You can indeed write such a macro, if you can guarantee that the variable you're updating is always the first operand:(define-syntax foo (syntax-rules () ((foo (op var arg ...)) (set! var (op var arg ...))))) Here's a Racket-only solution:(define (count-fewer-or-equal f m) (count (lambda (i) (&lt;= 1 (f i) m)) (range 1 100))) examine.dic["1"] and examine.see do indeed have different locations, even if the former's initial value is copied from the latter.With your case of using an array, you're not changing the value of examine.see: you're instead changing examine.see[0], which is changing the content of the array it points to (which is aliased to examine.dic["1"]). Yes, you can return multiple values using the values procedure, and you can pass arbitrary arguments to a procedure using apply. But your course may not have taught those concepts yet. :-) So much wheel reinvention. Just use SRFI 1!(require srfi/1)(define (fun4 lst) (every eq? lst (circular-list 'a 'b)))(This operates under the assumption that (a b a) should be valid rather than invalid.) Try this:s|base_url = '.*?',|base_url = 'https://www.example.com/',|g; You can use Guava's TreeMultimap to create an ordered multimap. This orders the values within the same key, but if you need to have iteration ordered by values, then the best you can do is swap the key and value (and forego the ability to look up by key). Here's a straightforward solution:(define (seconds lst) (map cadr lst))In general, when you want to transform every element of a list, map is the way to go. Well, if your example is the only use of a lambda, then obviously it's redundant. But there are many other applications of lambda outside of define, such as this:(map (lambda (x y) (sqrt (+ (* x x) (* y y)))) '(3 6 9) '(4 8 12)) (define my-list (call-with-input-file "file-that-contains-list.txt" read)) last returns the last cons cell in the list, not its value. You need to use (car (last x)) instead. Your code has a couple of instances of (cdr '(binaryList)), which doesn't do what you expect. Perhaps you meant to use (cdr binaryList) instead. Anyway, your base case is a little funky too: I think your base case should be the empty list, and have it return 0 in that case:(define (addBinary binaryList) (cond ((null? binaryList) 0) (else (+ (binaryToDecimal (car binaryList)) (addBinary (cdr binaryList)))))) Does the command-line adb work? If not, chances are you haven't set up your udev rules correctly. Your current user must have full permissions to the USB device your phone is on.Here's how my /etc/udev/rules.d/51-android.rules is set up:# Nexus 4SUBSYSTEM=="usb", ATTR{idVendor}=="18d1", ATTR{idProduct}=="4ee2", MODE="0660", GROUP="plugdev"# Galaxy NexusSUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6860", MODE="0660", GROUP="plugdev"You will need to add the correct vendor/product IDs for your specific phone, of course. And add yourself to the plugdev group.Then, you need to run sudo service udev reload to apply the rule changes. You should be good to go after that. Here's Guile's implementation of define-macro. Note that it's implemented entirely with syntax-case:(define-syntax define-macro (lambda (x) "Define a defmacro." (syntax-case x () ((_ (macro . args) doc body1 body ...) (string? (syntax-&gt;datum #'doc)) #'(define-macro macro doc (lambda args body1 body ...))) ((_ (macro . args) body ...) #'(define-macro macro #f (lambda args body ...))) ((_ macro transformer) #'(define-macro macro #f transformer)) ((_ macro doc transformer) (or (string? (syntax-&gt;datum #'doc)) (not (syntax-&gt;datum #'doc))) #'(define-syntax macro (lambda (y) doc #((macro-type . defmacro) (defmacro-args args)) (syntax-case y () ((_ . args) (let ((v (syntax-&gt;datum #'args))) (datum-&gt;syntax y (apply transformer v)))))))))))Guile has special support for Common Lisp-style docstrings, so if your Scheme implementation doesn't use docstrings, your define-macro implementation could be even simpler:(define-syntax define-macro (lambda (x) (syntax-case x () ((_ (macro . args) body ...) #'(define-macro macro (lambda args body ...))) ((_ macro transformer) #'(define-syntax macro (lambda (y) (syntax-case y () ((_ . args) (let ((v (syntax-&gt;datum #'args))) (datum-&gt;syntax y (apply transformer v))))))))))) This is a feature, not a bug. Crashes usually are not intentional, and it would be a huge inconvenience to the user to have to log into everything all over again.Crashing is not the same as exiting. If you want to restart the browser, quit it the normal way, not by killing it. eqv? basically does an identity comparison, except that in the case of numbers and characters, then the value is compared instead. This is why two characters with value 955 compare the same.What do I mean by identity? Consider this:(define a (number-&gt;string 955))(define b (number-&gt;string 955))(string-set! a 0 #\0)(printf "a = ~s, b = ~s, (eqv? a b) = ~a~%" a b (eqv? a b))You'll notice that only a's string is altered, not b's string. That's because they are different string objects.The opposite scenario is when aliasing is involved:(define a (number-&gt;string 955))(define b a)(string-set! a 0 #\0)(printf "a = ~s, b = ~s, (eqv? a b) = ~a~%" a b (eqv? a b))Here, a and b point to the same string object, and the effect of the string-set! is visible in both places. That reminds me of a conversation we had on our work IM today, where one of my coworkers commented that this appears in the Sidekiq source:def self.❨╯°□°❩╯︵┻━┻ puts "Calm down, bro"endThe latest versions of the Scheme standards support Unicode, too, and in fact, the following code works in Racket and Guile (and probably most other Scheme implementations too):(define (❨╯°□°❩╯︵┻━┻) (display "Calm down, bro") (newline))And this Common Lisp version worked when tested with SBCL:(defun ❨╯°□°❩╯︵┻━┻ () (format t "Calm down, bro~%")) In the recently-ratified R7RS, open-input-string is provided directly. (Thanks to Sylwester for reminding me to look beyond R5RS. :-))In R5RS, a pure Scheme implementation of string ports is not trivial, as it requires you to redefine all the standard I/O functions. See SRFI 6 for a reference implementation.It really is better if your implementation supports string ports directly. Here's one implementation:(define (decrement-alist-values alist keys) (map (lambda (ass) (if (member (car ass) keys) (list (car ass) (- (cadr ass) 1)) ass)) alist))Example:&gt; (decrement-alist-values '((1 3) (2 2) (3 3) (4 5) (5 1)) '(1 3 4))((1 2) (2 2) (3 2) (4 4) (5 1))Joshua Taylor mentioned that my version technically didn't update the list via mutation. That is a fair point, so here is a mutating version:(define (decrement-alist-values! alist keys) (for-each (lambda (ass) (when (member (car ass) keys) (set-car! (cdr ass) (- (cadr ass) 1)))) alist))Example:&gt; (define a `(,(list 1 3) ,(list 2 2) ,(list 3 3) ,(list 4 5) ,(list 5 1)))&gt; (decrement-alist-values! a '(1 3 4))&gt; a((1 2) (2 2) (3 2) (4 4) (5 1)) Yes. Do the (game (- choices-left 1)) recursion inside the cond branches where you want to reloop:(define guess-my-number (lambda () (letrec ([my-number (random 100)] [choices-left 7] [game (lambda (choices-left) (if (&gt; choices-left 0) (let ([user-guess (read)]) (cond [(&gt; user-guess my-number) (display "That was too high!") (game (- choices-left 1))] [(&lt; user-guess my-number) (display "That was too small!") (game (- choices-left 1))] [(= user-guess my-number) (display "YOU GUESSED!")])) (display "Here ends the game!!")))]) (game choices-left)))) Basically, make-country-mp returns a function object (a closure, in this case, which remembers the values for gdp, area, and population that were passed into the make-country-mp call), which you can call with one argument. The argument is matched against the symbols gdp, area, population, pop-density, gdp-per-capita, and is-bigger, and the appropriate result is returned in each case.If you know case, you may find that easier to read:(define (make-country-mp gdp area population) (lambda (msg) (case msg ((gdp) gdp) ((area) area) ((population) population) ((pop-density) (/ population area)) ((gdp-per-capita) (/ gdp population)) ((is-bigger) (lambda (rhs) (&gt; area (rhs 'area)))) (else (error "invalid option" msg))))) I can see two potential issues that can cause problems:If cAngle is an integer type, then the cAngle / 180 will be a truncating division. You will want to change that to cAngle / 180.0 instead.You should use M_PI instead of 3.14; it's much more precise. Use funcall:(funcall f (car l)) The key to this is that out in this case is a continuation. Continuations, unlike procedures, do not return once invoked.So, the two expressions in let are executed sequentially: first, (lm (car l) out), then (lm (cdr l) out). Because out is a continuation, and it's invoked when an atom is encountered, the (lm (car l) out) will not return if an atom is encountered in the (car l). So the (lm (cdr l) out) will only happen if there are no atoms in (car l)---which is the case for your example of (() a). Here's my implementation:(define (reduce f x) (define (inner x) (if (list? x) (f (map inner x)) x)) (inner x))Examples:&gt; (reduce (lambda (x) `(list ,@x)) '(3 7 9 z s (3 (78 2 3))))(list 3 7 9 z s (list 3 (list 78 2 3)))&gt; (reduce cdr '(3 7 9 z s (3 (78 2 3))))(7 9 z s ((2 3)))Here's a version that doesn't use map directly, but basically reimplements map (albeit using a hardcoded transformer):(define (reduce f x) (define (transform lst) (if (null? lst) '() (cons (process (car lst)) (transform (cdr lst))))) (define (process x) (if (list? x) (f (transform x)) x)) (process x)) Stack is a really old class from before Java 1.2 (and the Java Collections Framework). I suggest, if you can, that you switch to using Deque, which as you say already has all the functionality you need. define is a syntax, not a first-class object. You cannot refer to it as an object.As Justin said, you can create a macro. But note that Lisp-style defun has different syntax to Scheme-style define, and your macro should take that into account:(define-syntax-rule (defun name params body ...) (define (name . params) body ...)) Here's one way you can approach it: when you recurse into sublists, process the return values as if they were elements of the outer list also. Example (in Scheme, which is my "native language"; requires SRFI 26):(define (min-max x (min #f) (max #f)) (cond ((null? x) (if min (values min max) (values))) ((cons? x) (call-with-values (cut min-max (car x) min max) (cut min-max (cdr x) &lt;...&gt;))) (else (values (if (and min (&lt; min x)) min x) (if (and max (&gt; max x)) max x)))))And here's a direct Common Lisp translation of same, by which I mean that it's not idiomatic CL at all, but presented for CL programmers unfamiliar with Scheme to get an idea of what the Scheme code does. In particular, the Scheme requirement for proper tail recursion still holds, even though CL does not provide that.(defun min-max (x &amp;optional min max) (cond ((null x) (if min (values min max) (values))) ((consp x) (multiple-value-call #'min-max (cdr x) (min-max (car x) min max))) (t (values (if (and min (&lt; min x)) min x) (if (and max (&gt; max x)) max x))))) The other answers are correct, but I want to point out that this isn't a special syntax, but rather a specific case of a more general syntax involving a rest parameter.Consider the following functions:(lambda () ...)(lambda (first) ...)(lambda (first second) ...)(lambda (first second third) ...)These functions take 0, 1, 2, and 3 arguments, respectively.Now consider these functions:(lambda rest ...)(lambda (first . rest) ...)(lambda (first second . rest) ...)(lambda (first second third . rest) ...)These functions take at least 0, 1, 2, and 3 arguments, respectively. Any further arguments are collected into a list and bound to rest, in these cases.The first set of functions use proper lists as their lambda lists. The second set of functions use improper lists as their lambda lists. So what's the distinction between the two? A proper list is simply a list that has () as its final cdr, and an improper list is a list that has something else as its final cdr. It's that simple.To give greater visual symmetry between the two sets of functions, the first set of functions could be written this way:(lambda () ...)(lambda (first . ()) ...)(lambda (first second . ()) ...)(lambda (first second third . ()) ...)The list (first second third) is exactly the same as (first second third . ()). Once these expressions are read in, there is no way to distinguish between the two. Most Scheme implementations do not support references to lexical variables in their eval. As a special case, Guile has local-eval in its (ice-9 local-eval) module, which does support lexical variables. What the quoted portion means is that an immutable class can choose to intern its instances. This is easy to implement via Guava's Interner, for example:public class MyImmutableClass { private static final Interner&lt;MyImmutableClass&gt; INTERN_POOL = Interners.newWeakInterner(); private final String foo; private final int bar; private MyImmutableClass(String foo, int bar) { this.foo = foo; this.bar = bar; } public static MyImmutableClass of(String foo, int bar) { return INTERN_POOL.intern(new MyImmutableClass(foo, bar)); } @Override public int hashCode() { return Objects.hashCode(foo, bar); } @Override public boolean equals(Object o) { if (o == this) return true; // fast path for interned instances if (o instanceof MyImmutableClass) { MyImmutableClass rhs = (MyImmutableClass) o; return Objects.equal(foo, rhs.foo) &amp;&amp; bar == rhs.bar; } return false; }}Here, the constructor is made private: all instances have to be through the MyImmutableClass.of() factory method, which uses the Interner to ensure that if the new instance is equals() to an existing instance, the existing instance is returned instead.Interning can only be used for immutable objects, by which I mean objects whose observable state (i.e., the behaviour of all its externally-accessible methods, in particular equals() and hashCode()) does not change for the objects' lifetimes. If you intern mutable objects, the behaviour will be wrong when an instance is modified.As many other people have already stated, you should carefully choose which objects to intern, even if they're immutable. Only do it if the set of interned values is small relative to the number of duplicates you are likely to have. For example, it's not worth interning Integer generally, because there are over 4 billion possible values. But it is worth interning the most commonly-used Integer values, and in fact, Integer.valueOf() interns values between -128 and 127. On the other hand, enums are great to intern (and they are interned, by definition) because the set of possible values is small.For most classes in general, you'd have to do heap analysis, such as by using jhat (or, to plug my own project, fasthat), to decide if there are enough duplicates to warrant interning. In other cases, just keep it simple and don't intern. So, the result of (cons 'quote '(a)) is (quote a) (the datum, not the code expression). Hence the result of 'a is correct. To elaborate:(cons 'quote '(a)) conses together the datums quote and (a), resulting in the datum (quote . (a)), which is the same as the datum (quote a) (that is, a list containing two symbols, quote and a).Remember, for a list like (foo bar baz), it's the same as (foo . (bar baz)), (foo . (bar . (baz))), etc. So (quote a) is really the same as (quote . (a)).Since 'a is a reader shorthand for (quote a), your implementation's writer chose to print it out as 'a rather than (quote a). But both are correct.But in your post, you mentioned your expectation: (cons 'quote '(a)) ---> (quote a) ---> aThe first part of that is correct. (cons 'quote '(a)) does evaluate to (quote a). But now, that is a datum, not a code expression, so it won't get evaluated again. So it will not become a unless you explicitly called eval on it. System.nanotime returns a high-resolution clock value from your system. It does not have any kind of defined interpretation other than that if you take the difference between the return value from two separate calls to System.nanotime, you will get an approximate number of nanoseconds that elapsed between those calls.So the number of digits is not fixed, because there is no specific format for System.nanotime's value, and there is no meaningful way to interpret it. Only use the difference between two calls to System.nanotime. As uselpa said, Scheme has built-in complex numbers. The functions you mentioned are provided as follows:make-rectangularreal-partimag-part+*magnitudeAs for the second part of your question, what is z? It's hard to answer this without knowing what you're wanting. That happens because the standard output stream is buffered, which means that things that are printed to it do not actually write to the display straight away. You need to call (finish-output) before (read) in each instance to ensure that anything that's been buffered is written first. stosb stores a single byte. In x86, an address is a dword, so you needed to use stosd instead. (Remember that stosb and lodsb write to/read from %al, and stosd and lodsd write to/read from %eax.)Also, your $4 was initially stored in %esi, but that was later overwritten by the movl %eax, %esi instruction. You should use std::transform to apply the conversion to every element.vector&lt;double&gt; doubleVector;doubleVector.reserve(stringVector.size());transform(stringVector.begin(), stringVector.end(), back_inserter(doubleVector), [](string const&amp; val) {return stod(val);});As Zac Howland points out, here's another approach to this, which involves initialising a vector with default-constructed elements first, and then simply filling the vector with the correct values afterwards:vector&lt;double&gt; doubleVector(stringVector.size());transform(stringVector.begin(), stringVector.end(), doubleVector.begin(), [](string const&amp; val) {return stod(val);});The advantage of this approach is that the vector is sized exactly once, rather than continuously growing. The disadvantage is that vector elements have to be default-constructed first, and then be reassigned with the correct value afterwards. This tradeoff is worth it for element types that satisfy all of the following:can be default-constructedare cheap to default-constructcan be assigned with a value of the same typeare cheap to assignIn this instance, double fulfils all four requirements, and so the latter approach is better. For other types in general, and in particular when writing a function template to do this, your default implementation should use the former approach. Shell scripts need a shell-bang line in it in order to be run via execve or anything that uses it, such as run-program. So you should use this as your file's content:#!/bin/shexec /Applications/Safari.app/Contents/MacOS/Safari #'(var var2 var3 ...) is indeed not a list. It's a syntax object that wraps a list. You should use syntax-&gt;list to extract out the items into a list, thus your guard should look like:(all-ids? (syntax-&gt;list #'(var var2 var3 ...))) The right-hand side of and and or are tail expressions (see R5RS section 3.5), so you can safely use those for iterative purposes. The main stumbling block for your implementation is that your merge function didn't correctly implement the merge algorithm. In the merge algorithm:You have two pointers, which initially point to the start of the left-hand and right-hand lists.If both pointers are at the end of their respective lists, you're done.If either pointer is at the end of its respective list, output the remaining elements of the other list. Done.At this point, both pointers point to an element. If the right-hand element is less than the left-hand element, output the right-hand element, and advance the right pointer. Otherwise, output the left-hand element, and advance the left pointer. Go to step 2.My merge-into! function below implements such an approach.Aside from that, the other main biggie is that your split function is trying to build vectors piecemeal, and sadly, that is a slow process: it has to copy all the elements into a new vector each time. It's not like cons! With vectors, don't be hesitant to use vector-set!; any immutable update of vectors is going to be slow and inefficient, so just bite the bullet and make it mutable. :-)For reference, I wrote a new implementation from scratch (in Racket):(define (split-halves vec) (vector-split-at vec (quotient (vector-length vec) 2)))(define (merge lhs rhs) (define result (make-vector (+ (vector-length lhs) (vector-length rhs)))) (merge-into! result lhs rhs))(define (merge-into! result lhs rhs) (let loop ((i 0) (j 0) (k 0)) (define (take-left) (vector-set! result k (vector-ref lhs i)) (loop (add1 i) j (add1 k))) (define (take-right) (vector-set! result k (vector-ref rhs j)) (loop i (add1 j) (add1 k))) (cond ((= k (vector-length result)) result) ((= i (vector-length lhs)) (take-right)) ((= j (vector-length rhs)) (take-left)) ((&lt; (vector-ref rhs j) (vector-ref lhs i)) (take-right)) (else (take-left)))))(define (mergesort vec) (case (vector-length vec) ((0 1) vec) (else (let-values (((lhs rhs) (split-halves vec))) (merge (mergesort lhs) (mergesort rhs))))))The merge-into! function allows a mutating version of mergesort to be easily written:(define (mergesort! vec) (case (vector-length vec) ((0 1) vec) (else (let-values (((lhs rhs) (split-halves vec))) (mergesort! lhs) (mergesort! rhs) (merge-into! vec lhs rhs)))))If you don't use Racket, you may need these following additional definitions (which require SRFI 43; see bottom of post if you don't have that):(define (vector-split-at vec pos) (values (vector-copy vec 0 pos) (vector-copy vec pos (vector-length vec))))(define (add1 x) (+ x 1))let-values is defined in SRFI 11. If you don't have that, here's a version of mergesort that uses call-with-values:(define (mergesort vec) (case (vector-length vec) ((0 1) vec) (else (call-with-values (lambda () (split-halves vec)) (lambda (lhs rhs) (merge (mergesort lhs) (mergesort rhs)))))))vector-copy is defined in SRFI 43. If you don't have that, here's a simplified version of that:(define (vector-copy vec start end) (define result (make-vector (- end start))) (do ((i start (+ i 1)) (j 0 (+ j 1))) ((&gt;= i end) result) (vector-set! result j (vector-ref vec i)))) vec1 is aliased to vec, which is why changing the contents of one affects the other. But if you change the initial insert-h call to use (insert-h (vector-copy vec) '()) instead, it will dealias the two, since vec1 will then be a fresh copy. Make your init function return (list '() '()) instead of '(() ()). This will cause it to return a new list each time it's called.Literal data, like '(() ()), is immutable. That means that trying to mutate it using set-car! has undefined behaviour. The reason for this is that implementations are allowed to return the same instance of the literal data each time it's evaluated, so in this case, with your original code, each call to init was actually returning the same list. Here's my implementation of power set (though I only tested it using standard Racket language, not Beginning Student):(define (powerset lst) (if (null? lst) '(()) (append-map (lambda (x) (list x (cons (car lst) x))) (powerset (cdr lst)))))(Thanks to samth for reminding me that flatmap is called append-map in Racket!) You are executing it. However, since you're doing nothing with the return value of (fact 5), it just gets thrown away.Perhaps you should try (display (fact 5)) instead. Unfortunately, value-i3 doesn't work because (operator-i nexp) returns a symbol, not a procedure object. Notice the difference between '+ and +?There's not really an easy way to get around that (if we rule out eval, which is gross and disrecommended), other than using an alist to link the symbol with the procedure (or using case or cond as mentioned in Sylwester's answer):(define symbol-&gt;procedure (let ((opmap `((+ ,+) (x ,x) (^ ,^)))) (lambda (x) (cond ((assq x opmap) =&gt; cadr) (else #f)))))Then use symbol-&gt;procedure the same way as Sylwester's answer.If you find quasiquotes too difficult to read, you can use list and cons directly;(define symbol-&gt;procedure (let ((opmap (list (cons '+ +) (cons 'x x) (cons '^ ^)))) (lambda (x) (cond ((assq x opmap) =&gt; cdr) (else #f)))))The OP asked for more information about assq and the like, so I thought I'd update the post directly. Basically, (assoc key alist) returns the first item in alist whose car is equal? to key, or #f otherwise; assq and assv are similar to assoc but use eq? and eqv? as the comparison operator. So, here's a sample implementation (with R7RS/SRFI-1 semantics):(define (find pred lst) (cond ((null? lst) #f) ((pred (car lst)) (car lst)) (else (find pred (cdr lst)))))(define assoc (case-lambda ((key alist equal?) (find (lambda (x) (equal? key (car x))) alist)) ((key alist) (assoc key alist equal?))))(define (assq key alist) (assoc key alist eq?))(define (assv key alist) (assoc key alist eqv?)) The type of it should be set&lt;string&gt;::const_iterator or set&lt;string&gt;::iterator, not set&lt;string&gt;.If you're using C++11, you can just use auto. :-)Also, as a matter of style, prefer to return your messageToPrint by value, rather than using an out parameter. Consider using format:(format t "x^~a : ~a" 2 2)(If you want to print a newline, use ~% in the format string.) Macros are expanded at compile time, thus something like (begin exps ... (forloop (+ start 1) stop exps ...)) will expand forloop again and again, regardless of what the value of (+ start 1) is (which is evaluated at runtime).Perhaps the best you can do, at least with syntax-rules, is to use the macro to capture only the expressions to run, and use non-macro code to deal with the looping:(define-syntax forloop (syntax-rules () ((forloop start stop exps ...) (let ((j stop)) (let loop ((i start)) (when (&lt;= i j) exps ... (loop (+ i 1))))))))You can also use a do loop:(define-syntax forloop (syntax-rules () ((forloop start stop exps ...) (let ((j stop)) (do ((i start (+ i 1))) ((&gt; i j)) exps ...))))) I think it would be less confusing if you used external representation instead of code snippet. Then you can do away with all the quoting.Basically, the external representation of a dotted pair is (foo . bar), where foo is in the car slot and bar is in the cdr slot of the pair.On top of that, you have lists. There are three kinds of lists: proper, improper, and circular.A proper list is either:The empty-list or end-of-list special object, (), orA dotted pair with the cdr slot set to another proper list.Example: (1 2 3 4) (which is the same as (1 2 3 4 . ()))An improper list is either:An object that is neither a dotted pair nor the empty-list () object, orA dotted pair with the cdr slot set to another improper list.Example: (1 2 3 . 4)A circular list is:A dotted pair where, when chasing down the successive cdrs, you never ever reach a non-dotted-pair object.Examples: #0=(1 2 3 4 . #0#), (1 2 . #1=(3 4 . #1#)) Because it's possible for new enum elements to be added in future. If your enum-using class doesn't get recompiled, then your code would no longer be correct. This heads off that possibility.As everybody else has said, just add a default clause to deal with that case, probably by throwing an AssertionError. foo1 is also equivalent to the following:(define foo1 (let () (define (bar n) (+ n n)) (bar 1)))Is that more acceptable-looking to you? Here's a working implementation of symbol-map-function:(require (for-syntax racket/list))(define-syntax (symbol-map-function stx) (define (id-&gt;keyword id) (datum-&gt;syntax id (string-&gt;keyword (symbol-&gt;string (syntax-e id))))) (syntax-case stx () ((_ id ...) (andmap identifier? (syntax-&gt;list #'(id ...))) (with-syntax ((lambda-list (append-map (lambda (id) (list (id-&gt;keyword id) id)) (syntax-&gt;list #'(id ...))))) #'(lambda lambda-list (make-hash `((id . ,id) ...)))))))I wish I know a better way to assemble the lambda list than using append-map; improvements welcome. :-) MSVCRT, like everything compiled with Visual C++, exports cdecl functions using an underscore prefix. For your own libraries, you can override this behaviour, but since MSVCRT is not your library, you can't change that.You really are going to have to make your assembly calls use the underscore name. But nasm has an option, --prefix, which makes this easier: --prefix _. (Thanks to Frank Kotler for mentioning this.) You cannot use %d to print a long long. You'd have to use %lld. (So use "\n%d %d | %lld %lld | %d %d" for your format string.)In particular, it's apparent that in the "52 0 | 52 0", the first 52 0 is a.rez, and the second 52 0 is b.rez (each of these, being a long long, is apparently (judging from the output) pushing two words to the stack). a.tonum and b.tonum are not printed at all.To understand why this is happening, let me explain what Jonathan and I are trying to say. When you invoke a variadic function like printf (which is declared as something like printf(const char *format, ...), the compiler has no way to validate the correct argument types for the ... at compile-time. So there's a procedure for deciding what to push on the stack in that case, which can roughly be summarised as: if it's int or promotable to int, it gets pushed as an int; if it's double or promotable to double, it gets pushed as a double; otherwise, it gets pushed as is.When implementing a variadic function like printf, you need some way to access the ... items. The way to do so is to use a va_list, which is declared in &lt;stdarg.h&gt;. Here's some pseudocode which shows how it'd be used:int printf(const char *format, ...){ va_list ap; va_start(ap, format); while (/* we find the next format marker */) { if (/* %d, %i, %c */) { int val = va_arg(ap, int); /* print out val as decimal or (for %c) char */ } else if (/* %u, %x, %X, %o */) { unsigned int val = va_arg(ap, unsigned int); /* print out val as decimal, hex, or octal */ } else if (/* %ld, %li */) { long val = va_arg(ap, long); /* print out val as decimal */ } else if (/* %lu, %lx, %lX, %lo */) { unsigned long val = va_arg(ap, unsigned long); /* print out val as decimal, hex, or octal */ } else if (/* %lld, %lli */) { long long val = va_arg(ap, long long); /* print out val as decimal */ } else if (/* %llu, %llx, %llX, %llo */) { unsigned long long val = va_arg(ap, unsigned long long); /* print out val as decimal, hex, or octal */ } else if (/* %s */) { const char *val = va_arg(ap, const char *); /* print out val as null-terminated string */ } /* other types */ } va_end(ap); return /* ... */;}Notice that each time you want to pick off a ... argument, you'd do so using va_arg, and you'd have to specify the type to pick off. It is up to you to pick off the correct type. If the type is incorrect, you have a type-punning situation, which in most cases has undefined behaviour (meaning that the program can do anything it likes, including crashing or worse).In your particular computer, it seems like when you passed a long long, it pushed a 64-bit quantity to the stack, but because you used a %d format specifier, it used the va_arg(ap, int) version, which only grabbed a 32-bit quantity. That means that the other half of the 64-bit word was still unread, which the subsequent %d then proceeded to read. This is why, by the time the format string was finished, it never got around to processing the values of a.tonum and b.tonum that you passed.Whereas, had you correctly used %lld, it would have used va_arg(ap, long long), and would have correctly read in the whole 64-bit quantity. If what you're passing to string-&gt;variable-name is always a string literal (i.e., not a variable that contains a string), you can do that using a syntax-case macro that transforms the string literal to an identifier:(define-syntax string-&gt;variable-name (lambda (stx) (syntax-case stx () ((_ str) (string? (syntax-&gt;datum #'str)) (datum-&gt;syntax #'str (string-&gt;symbol (syntax-&gt;datum #'str)))))))and conversely, a variable-name-&gt;string macro could look like this:(define-syntax variable-name-&gt;string (lambda (stx) (syntax-case stx () ((_ id) (identifier? #'id) (datum-&gt;syntax #'id (symbol-&gt;string (syntax-&gt;datum #'id)))))))However, remember: this will only work if you are working with string (in case of string-&gt;variable-name) or identifier (in case of variable-name-&gt;string) literals.If, on the other hand, you want the ability to reflect on names in your current Scheme environment, this is not supported by standard Scheme. Some implementations, like Guile or Racket, do have this capability.Here's a Guile example:&gt; (module-define! (current-module) 'foo 12)&gt; foo12&gt; (define varname 'bar)&gt; (module-define! (current-module) varname 42)&gt; bar42and a Racket example:&gt; (namespace-set-variable-value! 'foo 12)&gt; foo12&gt; (define varname 'bar)&gt; (namespace-set-variable-value! varname 42)&gt; bar42 There is no standard Scheme way to do what you're seeking to do. However, some Scheme implementations provide (implementation-specific) ways to access module/top-level variables. (These don't provide access to lexical (local) variables, only top-level ones.)Here's how you might do this in Guile:(use-modules (srfi srfi-26))(define (foovals lst) (map (cut module-ref (current-module) &lt;&gt;) lst))Note that module-ref and current-module are Guile-specific and will not work in other Scheme implementations. Use string-contains from SRFI 13:&gt; (require srfi/13)&gt; (string-contains "this is an example" "example")11&gt; (string-contains "this is an example" "hexample")#f You need to use (or implement yourself, if this is for a course and your assignment requires you to implement everything by hand) take, drop, and append.(take lst n) returns the first n elements of lst. For example, (take '(1 2 3 4 5) 3) returns (1 2 3).(drop lst n) returns everything after the first n elements of lst. For example, (drop '(1 2 3 4 5) 3) returns (4 5).(append lst1 lst2) returns a list that contains all the elements of lst1, followed by all the elements of lst2. For example, (append '(4 5) '(1 2 3)) returns (4 5 1 2 3).Once you have these functions at hand, implementing a rotation function is trivial:(define (rotate lst n) (let ((n (modulo n (length lst)))) (append (drop lst n) (take lst n)))) SRFI 1 has a list-tabulate function that can build a list from calling a given function, with arguments 0 through (- n 1). However, it does not guarantee the order of execution (in fact, many implementations start from (- n 1) and go down), so it's not ideal for calling read with.In Racket, you can do this:(for/list ((i 10)) (read))to call read 10 times and collect the result of each; and it would be done left-to-right. But since you tagged your question for Guile, we need to do something different.Luckily, Guile has SRFI 42, which enables you to do:(list-ec (: i 10) (read)) Short answer: you must use en_IN.UTF-8 as your encoding if you want to use Indian English. Don't forget to run sudo locale-gen en_IN if you haven't already.Long answer: I finally got around to installing Ubuntu 12.04.3, so I could test this out. When I tested it, it seems that the locale must include the encoding, otherwise it fails:$ for LANG in en_{IN,US}{,.UTF-8,.ISO-8859-1}; do echo LANG=$LANG; guile &lt;/dev/null; doneLANG=en_INBacktrace:In ice-9/boot-9.scm: 149: 2 [catch #t #&lt;catch-closure 224b4e0&gt; ...] 157: 1 [#&lt;procedure 21e90f0 ()&gt;]In unknown file: ?: 0 [catch-closure]ERROR: In procedure catch-closure:ERROR: Throw to key `decoding-error' with args `("scm_from_stringn" "input locale conversion error" 22 #vu8(103 117 105 108 101))'.LANG=en_IN.UTF-8GNU Guile 2.0.5-deb+1-1Copyright (C) 1995-2012 Free Software Foundation, Inc.Guile comes with ABSOLUTELY NO WARRANTY; for details type `,show w'.This program is free software, and you are welcome to redistribute itunder certain conditions; type `,show c' for details.Enter `,help' for help.LANG=en_IN.ISO-8859-1warning: failed to install locale: Invalid argumentGNU Guile 2.0.5-deb+1-1Copyright (C) 1995-2012 Free Software Foundation, Inc.Guile comes with ABSOLUTELY NO WARRANTY; for details type `,show w'.This program is free software, and you are welcome to redistribute itunder certain conditions; type `,show c' for details.Enter `,help' for help.LANG=en_USBacktrace:In ice-9/boot-9.scm: 149: 2 [catch #t #&lt;catch-closure 1def1c0&gt; ...] 157: 1 [#&lt;procedure 1d8d0f0 ()&gt;]In unknown file: ?: 0 [catch-closure]ERROR: In procedure catch-closure:ERROR: Throw to key `decoding-error' with args `("scm_from_stringn" "input locale conversion error" 22 #vu8(103 117 105 108 101))'.LANG=en_US.UTF-8GNU Guile 2.0.5-deb+1-1Copyright (C) 1995-2012 Free Software Foundation, Inc.Guile comes with ABSOLUTELY NO WARRANTY; for details type `,show w'.This program is free software, and you are welcome to redistribute itunder certain conditions; type `,show c' for details.Enter `,help' for help.LANG=en_US.ISO-8859-1warning: failed to install locale: Invalid argumentGNU Guile 2.0.5-deb+1-1Copyright (C) 1995-2012 Free Software Foundation, Inc.Guile comes with ABSOLUTELY NO WARRANTY; for details type `,show w'.This program is free software, and you are welcome to redistribute itunder certain conditions; type `,show c' for details.Enter `,help' for help. For classes with that many construction parameters, I'd suggest you use the builder pattern. This pattern basically uses a separate builder class that holds all the construction parameters, which are then all passed to your real class's constructor.Using the builder pattern, you can establish the default parameter values inside your builder, so your calling code can still stay simple if it only needs to override one or two parameters.(If you used real class and parameter names in your question, I could have written a sample builder to demonstrate the point, but hopefully reading about the builder pattern would give you an idea to work with.) As implied by Mat's comment, * does not match anything that starts with a .. This is how the shell works (and nothing to do with git). You can test this by running echo * in your shell.To match dotfiles, you'd have to use .[!.]*. (Test it using echo .[!.]*.) Using simply .* would also match . and .., which you don't want to do with git add. You had a typo: in the second block, you wrote test1 = true, but it should be test2 = true. It sounds like there is no Data::getValue(int, int) const function. You should either change your existing getValue function to be const (note, the const has to come after the closing bracket), or add a const overload. String#to_f converts, say, "0.7" to 0.7. It does not convert "enquire_balance_outstanding_score" to 0.7; in other words, to_f does not resolve variable values. The other answers are all great, but there are many ways to skin this problem, so here's another. :-) Since your string is space-separated, and your shell's default separator (IFS) includes space, you can take advantage of this:mystr="http://example.com http://example2.com"set -- $mystrfoo=$1 # http://example.combar=$2 # http://example2.com(The -- after set isn't strictly required in this instance, but it prevents some stupid things from happening in case your string happened to start with a dash for some reason.) su will only ask for the root password if it's not already being run as root. sudo su runs su as root, by definition.If you set up a user in sudoers without a command whitelist, you are giving that user free access to run anything as root. Don't be surprised for them to get a root shell without the root password. Also, restricting su via a command blacklist won't help either; there are many other ways to get a root shell. Whitelisting is your only defence.(Blacklisting == user can do everything except X, Y, and Z. Whitelisting == user can only do X, Y, and Z.) A define outside of the top-level is called an internal definition. Internal definitions do not create top/module-level bindings; instead, they're syntactic sugar for an equivalent letrec* expression. That means that the bindings created by the internal definitions are visible only within the lambda/scope where the internal definitions live; in your case, that means they are visible only within the (let () ...).In particular, this means that you cannot conditionally define variables the way you were trying to do in your cond. Remember that (since you're already using an imperative programming style) you can just create top-level bindings set initially to #f (or some other blank value, though #f is customary), and then conditionally set! them to the values you want.Beyond that, there are many other things wrong with your code. For example:Don't compare numbers using eq?, use =.Don't use parentheses around the else; that's invalid.Inside the else branch, you had a number of define forms that are invalid. Remember you cannot conditionally define new variables.Your genSuccessors has way too many cond expressions. You want to have one single cond expression with many branches within it. Also you need to break up your branch conditions into multiple lines for easier reading. (cond ((write? p gs) 10) (else 0)) You are misusing quasiquoting; it doesn't do what you expect. In particular, it isn't a substitute for eval. The (lambda () ,qqx) you have creates a function that always fails when called, because unquote cannot be used outside of a quasiquote form.The best way to implement the functionality you want is as a macro:(define-syntax-rule (error-or-not expr ...) (catch #t (lambda () expr ... #f) (const #t)))Example:(error-or-not (/ 1 0)) ; =&gt; #t(error-or-not (/ 1 1)) ; =&gt; #fGuile 1.8-compatible version:(use-syntax (ice-9 syncase))(define-syntax error-or-not (syntax-rules () ((_ expr ...) (catch #t (lambda () expr ... #f) (lambda _ #t))))) Yes, Java 5 introduced enums, which are resistant to having additional instances created via serialisation, etc.The standard way to create a singleton in Java 5+ is to use a one-constant enum. Since your ArrayList contents are sorted, you should use Collections.binarySearch to locate your item. This will make each search O(log n) instead of O(n).This function return the index of the item, if found, or else the ones' complement of its insertion position. So, for your purposes, you can do this:int lowerBound(List&lt;Integer&gt; list, int item) { int result = Collections.binarySearch(list, item); return result &gt;= 0 ? result : ~result;} Your list invocations are wrong. You should use, for example, something like this:(cons (list (+ (car xy) 2) (- (cadr xy) 1)) successors) The key insight is that it is returning empty for the base case. That's because the reverse of an empty string is an empty string.The recursive cases actually work on that assumption. In words, here's how your reverse function works:If the given word is empty, return empty.Otherwise, take the last letter from the word, and join that with the reverse of the remainder of the word.Example. Let's say we're reversing "Devin":The word "Devin" isn't empty, so we will join "n" with the reverse of "Devi".The word "Devi" isn't empty, so we will join "i" with the reverse of "Dev".The word "Dev" isn't empty, so we will join "v" with the reverse of "De".The word "De" isn't empty, so we will join "e" with the reverse of "D".The word "D" isn't empty, so we will join "D" with the reverse of "".The word "" is empty, so we return "".Here, we return "D" joined with "", which is "D".Here, we return "e" joined with "D", which is "eD".Here, we return "v" joined with "eD", which is "veD".Here, we return "i" joined with "veD", which is "iveD".Here, we return "n" joined with "iveD", which is "niveD". This is the same as:if x &gt; 5 puts "This is true"elsif puts "Not true - Why no condition?"else puts "and this?"endThe puts in your elsif returns nil, which is a false value, so the else is triggered. IFS is used when you're reading several variables with read:$ echo foo:bar:baz | (IFS=: read FOO BAR BAZ; echo $FOO; echo $BAR; echo $BAZ)foobarbazWhereas, the -d option specifies what your line separator for read is; read won't read beyond a single line:$ echo foo:bar:baz%baz:qux:quux% | while IFS=: read -d% FOO BAR BAZ; do echo ---; echo $FOO; echo $BAR; echo $BAZ; done---foobarbaz---bazquxquux Your innermost if should use v for the else branch, not 0. Thus:(if (x (car poly)) (cons (car poly) v) v) Yes. You didn't follow their build instructions correctly. :-) In particular, you need to specify link dependencies after the dependent objects. Try this instead:gcc -o guile-test `pkg-config guile-1.8 --cflags` guile-test.c `pkg-config guile-1.8 --libs`In particular, the libraries need to be listed after all the objects that use them, such as guile-test.c.(By the way, this isn't Guile-specific. The standard linker always expects this ordering.) Because your base case is still followed by the printing and recursion. It didn't return straight afterwards.Perhaps you wanted this:(defun test (a) (if (null a) 0 (progn (if (listp (car a)) (print "a") (print "b")) (test (cdr a))))) To hack a Mark Twain misquote to pieces: The reports of call/cc's capabilities are greatly exaggerated.More specifically, call/cc captures call state, not program state. That means that it captures information about where the flow of code goes when the continuation is invoked. It does not capture information on variables, and in particular, if your get-token saves its iteration state by set!ting a variable, that is not going to be restored when you invoke your continuation.In fact, your expression of (call/cc (lambda (k) (let ((token (get-token))) (k token)))) should behave identically to simply (get-token); there should not be any observable differences between the two expressions. Actually, both styles are fine. In fact, some people prefer to use internal definitions.Also, the latter doesn't necessarily "modify the procedure application frame directly", either; internal definitions are treated the same as a letrec (for R5RS-compliant systems) or letrec* (for R6RS- and R7RS-compliant systems). Thus, your second example is really the same as:(define (foo x) (letrec* ((a ...) (b ...)) ...))In fact, to use an example, Racket rewrites internal definitions to their equivalent letrec* expressions and there is thus no difference in performance (beyond whatever difference there is between let and letrec*, of course). Your C# translation looks like it's doing the right thing for the most part, because the first block matches. What doesn't match is the last block, and that's because the Java code is zero-padding the last block to fill it out, whereas your C# code doesn't do that, so it'd use PKCS #5 padding by default.PKCS #5 padding is much better than zero-padding, of course, but since the latter is what the Java code used, you'd have to do the same thing. (That means, call swEncrypt.Write((byte) 0) a few more times until the byte count is a multiple of 16.)There's yet another subtlety. The Java code translates the string to bytes using String.getBytes(), which uses the "default encoding" of the Java runtime. This means that if your string contains non-ASCII characters, you'd run into interoperability issues. Best practice is to use UTF-8, but seeing as you can't change the Java code, I guess there's not much you can do about that. The Ruby installed by rvm isn't in your PATH. That message you saw at the bottom was the system telling you it couldn't find any Ruby version. Be sure that rvm is setting your PATH up correctly. To get correct phasing, your next-prime needs to defined within the macro output. Here's one way to go about it (tested with Racket):(define-syntax do-primes (syntax-rules () ((do-primes (p lo hi) (binding ...) (test res ...) exp ...) (do-primes (p lo) (binding ...) ((or test (&lt; hi p)) res ...) exp ...)) ((do-primes (p lo) (binding ...) (test res ...) exp ...) (let () (define (prime? n) ...) (define (next-prime n) ...) (do ((p (next-prime (- lo 1)) (next-prime p)) binding ...) (test res ...) exp ...))) ((do-primes (p) (binding ...) (test res ...) exp ...) (do-primes (p 2) (binding ...) (test res ...) exp ...))))This way, this defines the prime? and next-prime in the most local scope possible, while not having tons of duplicate code in your macro definition (since the 1- and 3-argument forms are simply rewritten to use the 2-argument form). C is an imperative language.An imperative language specifies how to do what you want. A declarative language specifies what you want, but not how to do it; the language works out how to do it. Prolog is an example of a declarative language. It's very hard to write a module that's compatible with both Gambit and Racket.There are indeed ways you can test for a specific implementation and define things conditionally. There are, in fact, two systems for doing this: SRFI 0 and SRFI 7. Most implementations support one or the other. Not very many support both.Gambit supports SRFI 0. Racket supports SRFI 7. You accidentally wrote a space within the 1- (which is a function for subtracting 1 from the given number). Remove that space (that is, use (1- n) instead of (1 - n)) and try again.Also, Emacs Lisp doesn't have return-from. Just say intermediate instead of (return-from tailfact intermediate). You do have to move the tailfact call within the if expression though, as the else clause.Oh, in my testing, I found another point of difference between Common Lisp and Emacs Lisp: the latter doesn't support a default value for optional arguments, and it always uses nil. So here's one way to port your code to elisp:(defun tailfact (n &amp;optional intermediate) (let ((intermediate (or intermediate 1))) (if (= n 1) intermediate (tailfact (1- n) (* n intermediate)))))However, let me be the first to agree with Rainer's comment. If you're learning from Common Lisp resources, you really should be using a Common Lisp implementation. I've heard that SLIME is an awesome Emacs mode for integrating with major CL implementations, including SBCL (which is probably one of the most commonly-used CL implementations). The internal definition must be within the lambda. So try this:(define func1 (lambda (y) (define nest-func (lambda (x) (+ x x))) (+ y (nest-func y))))Or, did you only want to invoke the inner lambda once? Then use let:(define func1 (let ((nest-func (lambda (x) (+ x x)))) (lambda (y) (+ y (nest-func y))))) Use this:msg = msg.replace("+", "###%SUM%###");Calling msg.replace doesn't alter the string itself. You actually have to store the result somewhere. Use std::pair&lt;int, int&gt; instead of std::pair&lt;const int&amp;, const int&amp;&gt;.const int&amp; is a reference (as opposed to value). Since i has the same location each time, and it's possible for the same temporary location to be used for the i+1, that means you could be using the same pair each time. Read the documentation on the number format supported by parseDouble. The f and d are instances of FloatTypeSuffix. If the only thing your TreeNode occupies is memory, you don't need to release them when exiting your program. However, if it contains, say, a buffered writing file stream, and you don't release that, there may be data still remaining in the buffer that won't get written to disk. And then you will have data loss. :-)P.S. I need to add, this strategy of letting the OS free everything for you only applies if your program is short-lived, and you have no "trash" objects (i.e., you need to retain references to all created objects for the program's lifetime). If it's long-lived (but you have no trash objects), just use static memory, and don't do any dynamic allocation. If you have trash objects, you need to free them. No questions asked. :-) This worked for me:public class ArrayHeap&lt;E&gt; implements PriQue&lt;E&gt; { private static class Entry&lt;E&gt; { int pri; E data; // ... public E getData() { return data; } } Entry&lt;E&gt;[] heap; int cnt; public ArrayHeap(int size) { heap = (Entry&lt;E&gt;[])new Entry&lt;?&gt;[size]; // or: heap = new Entry[size]; cnt = 0; } public E remove() { E tmp = heap[--cnt].getData(); return tmp; } // ...}The key is that Entry is changed to become a static nested class, rather than a non-static inner class (which would still be dependent on your outer class's type parameters). Then you can actually create an array of Entry&lt;?&gt;, and do a cast from that. The syntax of define is:(define &lt;variable&gt; &lt;expression&gt;)A variable is a special kind of identifier, and the format of identifiers is described here. As you can see from the description, #t (and more generally, anything that starts with a #) is not an identifier. It appears that std::basic_string::back is new in C++11. So unless you compile in C++11 mode (using -std=c++11 for gcc, for example), it's not going to compile. Here's the complete test code I used:#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;int main() { std::vector&lt;std::string&gt; strings; strings.push_back("test"); std::cout &lt;&lt; strings[0].back() &lt;&lt; '\n';}So, you'd have to configure your Eclipse to use C++11 mode, also. Internal definitions are defined (har har) by R5RS to use letrec, and by R6RS and R7RS to use letrec*. The behaviour you're describing is exactly what letrec* is.However, there are cases where you want to use the outer bindings, and you don't want the inner bindings to shadow them during their definitions. In this case, let and let* are more appropriate than letrec and letrec*.What do I mean by this? Here's one way that let provides outer scoping that letrec doesn't:(let ((x 1) (y 2)) (let ((x (+ x y)) (y (- x y))) (format #t "x = ~a, y = ~a~%" x y)))Here, in the (+ x y) and (- x y) expressions, we are using the outer bindings of x and y. Thus the inner x will be 3, and the inner y will be -1.Using let* is similar except that the bindings are sequential:(let ((x 1) (y 2)) (let* ((x (+ x y)) (y (- x y))) (format #t "x = ~a, y = ~a~%" x y)))Here, the inner x is evaluated the same as for the let case, but the inner y's definition will use the inner x instead of the outer x (but it still uses the outer y, as the inner y hasn't been bound yet). Thus the inner x will be 3, and the inner y will be 1.When using letrec and letrec*, all the outer bindings will be shadowed by the inner bindings of the same name, and you do not have access to the outer x or y in those cases. This property is what allows their use for self-referential functions and/or data structures.letrec and letrec* are similar, except that for letrec, the values are all evaluated first, then bound to the variables at the end, simultaneously; whereas for letrec*, the values for each variable are evaluated and bound sequentially from left to right.To demonstrate the four let types, I wrote a little Racket macro that allows you to test the behaviour of each:#lang racket(define-syntax test-let (syntax-rules () ((_ let) (let ((x "outer x") (y "outer y") (p (lambda (x y label) (printf "~a: x = ~s, y = ~s~%" label x y)))) (let ((before (p x y "before")) (x (begin (p x y "during x") "inner x")) (between (p x y "between")) (y (begin (p x y "during y") "inner y")) (after (p x y "after"))) (p x y "body"))))))And the test results:&gt; (test-let let)before: x = "outer x", y = "outer y"during x: x = "outer x", y = "outer y"between: x = "outer x", y = "outer y"during y: x = "outer x", y = "outer y"after: x = "outer x", y = "outer y"body: x = "inner x", y = "inner y"&gt; (test-let let*)before: x = "outer x", y = "outer y"during x: x = "outer x", y = "outer y"between: x = "inner x", y = "outer y"during y: x = "inner x", y = "outer y"after: x = "inner x", y = "inner y"body: x = "inner x", y = "inner y"&gt; (require rnrs/base-6)&gt; (test-let letrec)before: x = #&lt;undefined&gt;, y = #&lt;undefined&gt;during x: x = #&lt;undefined&gt;, y = #&lt;undefined&gt;between: x = #&lt;undefined&gt;, y = #&lt;undefined&gt;during y: x = #&lt;undefined&gt;, y = #&lt;undefined&gt;after: x = #&lt;undefined&gt;, y = #&lt;undefined&gt;body: x = "inner x", y = "inner y"&gt; (require rnrs/base-6)&gt; (test-let letrec*)before: x = #&lt;undefined&gt;, y = #&lt;undefined&gt;during x: x = #&lt;undefined&gt;, y = #&lt;undefined&gt;between: x = "inner x", y = #&lt;undefined&gt;during y: x = "inner x", y = #&lt;undefined&gt;after: x = "inner x", y = "inner y"body: x = "inner x", y = "inner y"Hopefully this will make the differences between the let types pretty obvious. :-) There is a better way, just (require srfi/1) and use reduce and reduce-right. :-D So, your function needs to return two lists, right? Your base case needs to return two empty lists, and then in your recursive cases, you fill in the relevant one depending. Here's some skeletal code (fill in the &lt;???&gt;):(define (odds-and-evens lst) (if (null? lst) (values '() '()) (let-values (((odds evens) (odds-and-evens (cdr lst)))) (cond ((odd? (car lst)) (values (cons &lt;???&gt; &lt;???&gt;) &lt;???&gt;)) ((even? (car lst)) (values &lt;???&gt; (cons &lt;???&gt; &lt;???&gt;))) (else (values odds evens)))))) Your platform uses signed chars, which gets promoted to int with sign extension when you call printf. To fix this, in your printf line, use (unsigned char) str[i], thus:printf(" %.2x\n\n", (unsigned char) str[i]); Let's assume this definition of let* (I'm trying to make this as simple as possible, so it's not as "industrial-strength" as Racket's that Asumu Takikawa linked to):(define-syntax let* (syntax-rules () ;; base case ((_ () body ...) (let () body ...)) ;; recursive case ((_ (binding next ...) body ...) (let (binding) (let* (next ...) body ...)))))Scheme has a concept called hygiene, which says that any free identifiers (i.e., identifiers that are not defined within the macro) in a macro will be bound to its value as of the macro's definition. In the case of the above let* macro, the free identifiers are let and let*, since they're not bound elsewhere (as binding, next, and body are) in the macro.That means that within that macro, let and let* will have the values that were there at the time of the macro's definition, and user code (that surround the use of the macro) will not have an effect on the values of let and let* that are used.One way to implement this hygiene is via renaming. So, with renaming, the above macro could be renamed as follows:(define-syntax let* ;; bind g1 to current let, g2 to current let* (syntax-rules () ((_ () g3 ...) (g1 () g3 ...)) ((_ (g4 g5 ...) g6 ...) (g1 (g4) (g2 (g5 ...) g6 ...)))))Here, the g1 through g6 are generated temporary symbols, usually known as "gensyms" (after the Lisp function gensym, which creates such things). Notice that, because of the renaming, user code cannot affect the definition of let and let* within the macro, and also the macro's binding of binding, next, and body do not affect any user code that may use such identifiers within the body of the let*.Footnote (in case your student wants a more in-depth treatment of this): For many Scheme implementations, gensyms are uninterned (they are not entered into the symbol pool, unlike ordinary symbols, which are all interned). Then, even if the user happens to correctly "guess" the identifiers generated by the renaming procedure (e.g., even if they happen to use g1, g2, etc. in the example above), they won't actually collide with the identifiers that the macro actually uses.However, standard Scheme does not talk about uninterned symbols, and in the context of standard Scheme, all symbols are interned, and thus it's perfectly valid for a Scheme implementation to use interned symbols exclusively, even for gensyms. In such cases, it is possible to create ways to break hygiene by colliding with the renamed symbols. Here's how it would look like with accumulator:(define (alignment-score s1 s2) (define min-length (min (string-length s1) (string-length s2))) (let loop ((score 0) (index 0)) (if (= index min-length) score (loop (+ score (scorer (string-ref s1 index) (string-ref s2 index))) (+ index 1)))))In this case, score is the accumulator, which starts as 0. We also have an index (also starting as 0) that keeps track of which position in the string to grab. The base case, when we reach the end of either string, is to return the accumulated score so far. In the first expression, * is bound to the original value of +, and + is bound to the original value of *. Thus (+ 3 (* 4 5)) would be equivalent to (* 3 (+ 4 5)) with the original bindings. That is the same as the infix expression 3 * (4 + 5), which is of course 27.In the second expression, + is bound to the original value of * and * is unchanged. Thus (+ 3 (* 4 5)) would be equivalent to (* 3 (* 4 5)) with the original bindings, which is the same as the infix expression 3 * (4 * 5), which is 60.The most important note here is that let does parallel binding. That means in an expression like (let ((+ *) (* +)) ...), the original values of * and + are taken first, and then + and * are bound simultaneously. That is why the new * has the old value of +, not its new value.I recently wrote a post about the differences between the various let forms. Note the difference between let and let*, in particular. Here's my version of the solution:(define (oddatom? lst) (let recur ((odd #f) (x lst)) (cond ((null? x) odd) ((pair? x) (recur (recur odd (car x)) (cdr x))) (else (not odd))))) No, swapping the car and cdr won't work. But you can swap the #f and #t.Also, while the list you gave has 4 elements, what the function does is actually traverse into sublists and count the atoms, so you're really looking at 8 atoms. Here's a straightforward translation to a do loop:(define (foo x y z) (do ((result 0 (+ result i)) (i x (+ i z))) ((&gt;= i y) result)))However, many Schemers find do loops to be distasteful. So here's an identical loop that uses named let, which is in fact what the do is likely to expand to:(define (foo x y z) (let loop ((result 0) (i x)) (if (&gt;= i y) result (loop (+ result i) (+ i z)))))which is likely to expand to:(define (foo x y z) ((rec (loop result i) (if (&gt;= i y) result (loop (+ result i) (+ i z)))) 0 x))which then expands to:(define (foo x y z) ((letrec ((loop (lambda (result i) (if (&gt;= i y) result (loop (+ result i) (+ i z)))))) loop) 0 x))Yay macros! Choose the version you like best; most Schemers I know prefer the second one. Procedure bodies have an implicit begin. Thus(lambda () (foo) (bar))is treated as if the same as(lambda () (begin (foo) (bar)))See Sequencing in the Racket guide for more details. Here's my solution:(define (execute expr) (lambda (x) (let recur ((expr expr)) (case expr ((x) x) ((+) +) ((-) -) ((*) *) ((/) /) (else (if (list? expr) (apply (recur (car expr)) (map recur (cdr expr))) expr))))))Example usage:&gt; (define foo (execute '(* (+ 1 x) (- x (* 2 3)))))&gt; (foo 42)=&gt; 1548 Yes, you can do this, by passing in a custom entry-reader parameter to unzip-entry. Here's an example of how to do it:(define (unzip-entry-&gt;bytes path zipdir entry) (call-with-output-bytes (lambda (out) (unzip-entry path zipdir entry (lambda (name dir? in) (copy-port in out)))))) Based on your current attempt, here's a corrected version (with corrected indentation, as a bonus :-)):(defun pred (x l) (cond ((null (cdr l)) (car l)) ((eq (cadr l) x) (car l)) (t (pred x (cdr l)))))Are you sure you want to return the last element of the list if your expected element isn't found? It seems...strange, I'd have thought nil is a better return value.Update: the OP wanted to implement both successor and predecessor functions. Here's how I'd implement them, in Scheme. (Sorry, not doing your homework for you, but if you know how to translate Scheme into Common Lisp, your life would be easier.)(define (succ x lst) (cond ((memv x lst) =&gt; (lambda (mem) (and (pair? (cdr mem)) (cadr mem)))) (else #f)))(define (pred x lst) (let loop ((prev #f) (rest lst)) (cond ((null? rest) #f) ((eqv? (car rest) x) prev) (else (loop (car rest) (cdr rest))))))and while memv is built-in to Scheme, you could implement it yourself quite simply:(define (memv x lst) (let loop ((rest lst)) (cond ((null? rest) #f) ((eqv? (car rest) x) rest) (else (loop (cdr rest))))))In particular, note the similarity between memv and pred. "If the constructor's declaring class is an inner class in a non-static context, the first argument to the constructor needs to be the enclosing instance; see section 15.9.3 of The Java™ Language Specification."That means you can never construct an inner class using Class.newInstance; instead, you must use the constructor that takes a single Outer instance. Here's some example code that demonstrates its use:class Outer { class Inner { @Override public String toString() { return String.format("#&lt;Inner[%h] outer=%s&gt;", this, Outer.this); } } @Override public String toString() { return String.format("#&lt;Outer[%h]&gt;", this); } public Inner newInner() { return new Inner(); } public Inner newInnerReflect() throws Exception { return Inner.class.getDeclaredConstructor(Outer.class).newInstance(this); } public static void main(String[] args) throws Exception { Outer outer = new Outer(); System.out.println(outer); System.out.println(outer.newInner()); System.out.println(outer.newInnerReflect()); System.out.println(outer.new Inner()); System.out.println(Inner.class.getDeclaredConstructor(Outer.class).newInstance(outer)); }}(Note that in standard Java terminology, an inner class is always non-static. A static member class is called a nested class.) You cannot use set! for this. You need to use set-car! on the cons cell you're changing. Here's how you might write it:(define (map! f lst) (let loop ((rest lst)) (unless (null? rest) (set-car! rest (f (car rest))) (loop (cdr rest)))))If you have SRFI 1, it's even easier (if we ignore for a moment that SRFI 1 already defines map! ;-)):(define (map! f lst) (pair-for-each (lambda (pair) (set-car! pair (f (car pair)))) lst)) I'm going to answer your original question, not your current one, which is just one possible solution approach.There are a number of ways to solve this. One way, like you mentioned in this question, is to convert the incoming list of numbers into strings, then concatenating them:(require srfi/13)(define (number-concatenate nums) (string-&gt;number (string-concatenate (map number-&gt;string nums))))Here's another approach, that does not involve conversion to strings first:(require srfi/1 srfi/26)(define (number-concatenate nums) (define (expand num) (if (&lt; num 10) (list num) (unfold-right zero? (cut modulo &lt;&gt; 10) (cut quotient &lt;&gt; 10) num))) (fold (lambda (num result) (fold (lambda (digit result) (+ digit (* result 10))) result (expand num))) 0 nums)) In R6RS, there is no sure way to determine if two procedures are equivalent; even an expression like (let ((p (lambda () 42))) (eqv? p p)) is not guaranteed to be true.R7RS addresses that by using the concept of "location tags", where each lambda expression generates a unique location tag. Then eqv? works for procedures by comparing location tags: thus, (let ((p (lambda () 42))) (eqv? p p)) is true, and (eqv? (lambda () 42) (lambda () 42)) is false.There is no reliable way to get the source of a procedure (many implementations macro-expand and compile the procedures, discarding the original source), and even if you could, you could not use it to compare if two procedures are "equal", because of closures (and that two procedures could have the same "source" but have their free variables bound to different things). For example, consider the two expressions (let ((x 1)) (lambda () x)) and (let ((x 2)) (lambda () x)). They have the same "source", but nobody in their right mind would claim that they are equivalent in any way. ((lambda (x) ((lambda (x y) (* x y 24)) (+ 5 25) (* 5 x))) 30) Use (string-&gt;number "#e6119726089.12814713") to parse the number as exact. This works for at least Racket and Guile. It may not work correctly on other Scheme implementations, however; they are at liberty to parse as inexact first, then convert.Here's a portable implementation of the string-&gt;exact function that the OP asked for. I've manually tested it with a range of inputs, but you should do your own testing to ensure it fits your needs:(define (string-&gt;exact str) (define zero (char-&gt;integer #\0)) (let loop ((result #f) (factor 1) (seen-dot? #f) (digits (string-&gt;list str))) (if (null? digits) (and result (/ result factor)) (let ((cur (car digits)) (next (cdr digits))) (cond ((and (not result) (not seen-dot?) (char=? cur #\-)) (loop result (- factor) seen-dot? next)) ((and (not seen-dot?) (char=? cur #\.)) (loop result factor #t next)) ((char&lt;=? #\0 cur #\9) (loop (+ (* (or result 0) 10) (- (char-&gt;integer cur) zero)) (if seen-dot? (* factor 10) factor) seen-dot? next)) (else #f)))))) One fundamental principle of security is that you aim to minimise the number of things that need to be hidden, so that there are fewer things that could potentially be compromised.In the case of Unix passwords, the algorithm and salt do not need to be hidden, so they are not. The security of the salt lies in its uniqueness, not its secrecy, and if you use a hashing algorithm that is slow to run (bcrypt and scrypt are recommended for this), it will make bulk password-guessing less feasible, if users choose long passwords.You could theoretically argue that if you "chop out" the algorithm identifier, the system could just go through and attempt the password for each supported algorithm. However, this introduces a new weakness: suppose you encrypted a user's password using algorithm 1, but chopped out the algorithm identifier. What if an attacker used an incorrect password, that is invalid for algorithm 1 (obviously), but happened to validate correctly for algorithm 2? You've just allowed the attacker to get in using a wrong password. By fixing the specific algorithm in use, the attacker would not get that opportunity. If I understand your question correctly, here's one way you can implement func:(define (func f n lst) (do ((n n (sub1 n)) (lst lst (map f lst))) ((zero? n) lst)))Example usage:&gt; (func (lambda (x) (* x 2)) 3 '(3 5 1))=&gt; (24 40 8) let is actually a macro. You cannot define this as a procedure. Since you're using Racket, try this:(define-syntax-rule (mylet x a body) ((lambda (x) body) a))That looks almost like your original code, but using define-syntax-rule instead of define. ;-) That define-syntax-rule is actually a shortcut for the following full macro:(define-syntax mylet (syntax-rules () ((_ x a body) ((lambda (x) body) a))))Indeed, you can even define the "standard" let macro (minus named let) this way:(define-syntax-rule (let ((id val) ...) body ...) ((lambda (id ...) body ...) val ...))Note the use of the ellipses (...). This allows zero or more forms; in this case, it allows let to contain multiple body forms. C and C++ are case-sensitive. You declared a TCPechoed with lowercase E, but your actual function is called TCPEchoed with uppercase E. You need to fix one or the other. Definitions affect the current module only (and, if you export your definition, then any other modules that import your module). You can always import Racket's built-in functions under a different name, if you want to use car in your module for something else. For example:(require (only-in racket/base (car racket-car)))Now, you can use racket-car to refer to the built-in car function. Sylwester's answer is correct, but I wanted to make a bigger point: unless your Scheme implementation doesn't provide a hygienic procedural macro system, there is no good reason to use define-macro.For anaphoric macros, such as the one you want to write, it's best to use syntax parameters, if you're using a Scheme implementation that supports it, such as Racket or Guile. Here's a Racket example:#lang racket(provide slambda self)(require racket/stxparam srfi/31)(define-syntax-parameter self (lambda (stx) (raise-syntax-error 'self "Can only be used inside slambda")))(define-syntax slambda (syntax-rules () ((_ params body ...) (rec (ohai . params) (syntax-parameterize ((self (make-rename-transformer #'ohai))) body ...)))))Of course, as you can see in my example, I used rec. In the general case where you want to make self-referential procedures, it's best to use rec for that; you simply specify the name you want to refer to the procedure by (rather than using a hardcoded self). Since rec is not anaphoric, its definition is much simpler:(define-syntax rec (syntax-rules () ((_ (id . params) body ...) (rec id (lambda params body ...))) ((_ id value) (letrec ((id value)) id))))You would use it like this (in this case, I use recur as the self-reference; of course, you can choose any name you like):(define nested-length (rec (recur x) (cond ((null? x) 0) ((pair? x) (+ (recur (car x)) (recur (cdr x)))) (else 1)))) Yes, you might actually want to extend the define form to provide capabilities that the standard define doesn't. An example is providing decorators (thanks to uselpa's answer for inspiration):(require (only-in racket/base (define basic-define)))(define-syntax wrap-decorators (syntax-rules () ((_ () value) value) ((_ (decorator next ...) value) (decorator (wrap-decorators (next ...) value)))))(define-syntax define (syntax-rules (@) ((_ (@ decorator ...) (id . params) body ...) (define (@ decorator ...) id (lambda params body ...))) ((_ (@ decorator ...) id value) (define id (wrap-decorators (decorator ...) value))) ((_ other ...) (basic-define other ...))))(define (trace label) (lambda (f) (lambda args (dynamic-wind (thunk (eprintf "enter ~a: ~s~%" label args)) (thunk (apply f args)) (thunk (eprintf "exit ~a: ~s~%" label args))))))Now you can use it this way:(define (@ (trace 'hypot)) (hypot x y) (sqrt (+ (sqr x) (sqr y))))This causes the hypot function to be wrapped with trace so when you call it, tracing happens:&gt; (hypot 3 4)enter hypot: (3 4)exit hypot: (3 4)5Or, using uselpa's memoize function, you can use:(define (@ memoize) (fib n) (if (&lt; n 2) n (+ (fib (sub1 n)) (fib (- n 2)))))and get a speedy memoised fib function. You can even trace and memoise it, showing only the actual (cache miss) invocations:(define (@ (trace 'fib) memoize) (fib n) (if (&lt; n 2) n (+ (fib (sub1 n)) (fib (- n 2)))))Notice, in my macro, that I imported Racket's define as basic-define, so that my redefined define could delegate to it. Here's how you might write such a function:(define (c?r cmds) (lambda (lst) (let recur ((cmds (string-&gt;list cmds))) (if (null? cmds) lst (case (car cmds) ((#\a) (car (recur (cdr cmds)))) ((#\d) (cdr (recur (cdr cmds)))) (else (recur (cdr cmds))))))))Note that I'm using d to signify cdr, not r (which makes no sense, to me). You can also write this more succinctly using string-fold-right (requires SRFI 13):(define (c?r cmds) (lambda (lst) (string-fold-right (lambda (cmd x) (case cmd ((#\a) (car x)) ((#\d) (cdr x)) (else x))) lst cmds))) Here's my solution, which is similar to Óscar's solution but centralises the update of the longest/winning result in one place:(define (longest-run lst) (let loop ((result #f) (cur #f) (count 0) (longest 0) (lst lst)) (cond ((&gt; count longest) (loop cur cur count count lst)) ((null? lst) result) ((eqv? (car lst) cur) (loop result cur (+ count 1) longest (cdr lst))) (else (loop result (car lst) 1 longest (cdr lst))))))I think my solution is shorter, cleaner, and less repetitive, but Óscar's solution has the advantage of updating the variables fewer times: his solution only updates the variables at the end of a run, whereas mine updates the variables whenever the current length is longer than the longest length seen so far. Let's actually macroexpand the two implementations and see how they differ:* (macroexpand '(once-only (foo bar) (+ foo bar)))(LET ((#:G619 (GENSYM)) (#:G620 (GENSYM))) `(LET ((,#:G619 ,FOO) (,#:G620 ,BAR)) ,(LET ((FOO #:G619) (BAR #:G620)) (+ FOO BAR))))* (macroexpand '(my-once-only (foo bar) (+ foo bar)))(LIST 'LET (LIST (LIST '#:G621 FOO) (LIST '#:G622 BAR)) (LET ((FOO '#:G621) (BAR '#:G622)) (+ FOO BAR)))Let's rewrite your macroexpansion to something easier for a Lisper to read:`(LET ((#:G621 ,FOO) (#:G622 ,BAR)) ,(LET ((FOO '#:G621) (BAR '#:G622)) (+ FOO BAR)))Notice that your version lacks the indirection with the additional gensym. That means each invocation of your outer macro (the one that is using my-once-only) is using the same symbols each time. If your macro calls nest (e.g., you use your outer macro inside the body of another use of the outer macro), the symbols will collide. It's incorrect. Let's try again.(car '((a b) c d)) is the datum (a b).(cdr '((e) f)) (which is the same as (cdr '((e) . (f)))) is the datum (f), which means (list (cdr '((e) f))) is the datum ((f)).Thus, (cons (car l1) (list (cdr l2))) is the same as (cons '(a b) '((f))), which is the datum ((a b) . ((f))), which is the same as ((a b) (f)). Here's a powerset function that returns the items in the correct order, without sorting. It requires Racket and uses its queues to implement breadth-first processing:(require srfi/1 data/queue)(define (powerset items) (define fifo (make-queue)) (enqueue! fifo (cons '() items)) (let loop ((result '())) (if (queue-empty? fifo) (reverse result) (let* ((head-entry (dequeue! fifo)) (subset (car head-entry)) (rest-items (cdr head-entry))) (pair-for-each (lambda (next-items) (enqueue! fifo (cons (cons (car next-items) subset) (cdr next-items)))) rest-items) (loop (cons (reverse subset) result))))))We maintain a FIFO queue of pairs, each consisting of a subset (in reversed order) and a list of items not included in it, starting with an empty subset so all the original items are still not included in it.For each such pair, we collect the subset into the result list, and also extend the queue by extending this subset by each item from the not-included items. Processing stops when the queue is empty. Because we extend subsets each time by one element only, and in order, the result is ordered too. You forgot to prepend your dir to your de-&gt;d_name when stating. You're still in your original directory, as you haven't chdired elsewhere. Because you're trying to copy stuff to a null pointer. That's not the valid location of a buffer. Yes, there is a better way. You should use list, rather than quoting:(define list-of-funs (list sqr dbl add-5))The reason for this is that '(sqr dbl add-5) produces a list of symbols, whereas (list sqr dbl add-5) produces a list of procedure objects. You can invoke procedure objects. You cannot invoke symbols.You can access the functions individually, by using first, second, or third (from SRFI 1) to pick elements out of the list, e.g.,((first list-of-funs) 49) ; =&gt; 7Or else you might decide you want to map through them, or whatever. e.g.,(define (square-double-and-add5 x) (map (lambda (f) (f x)) list-of-funs)) Pairs, vectors, and strings are mutable. Hence, the identity (or location) of such objects matter.Procedures are immutable, so they can be copied or coalesced arbitrarily with no apparent difference in behaviour. In practice, that means that some optimising compilers can inline them, effectively making them "multiple copies". R6RS, in particular, says that for an expression like(let ((p (lambda (x) x))) (eqv? p p))the result is not guaranteed to be true, since it could have been inlined as (eqv? (lambda (x) x) (lambda (x) x)).R7RS's notion of location tags is to give assurance that that expression does indeed result in true, even if an implementation does inlining. Notice how your garnolaf? and ronugor? procedures are written? Now write something similar for ronulaf. That's it! Here's my implementation of the count-leaves function:(define (count-leaves tree) (if (null? (cdr tree)) 1 (let loop ((count 0) (children (cdr tree))) (if (null? children) count (loop (+ count (count-leaves (car children))) (cdr children))))))Or, if you're allowed to use map in your assignment, it can be much shorter:(define (count-leaves tree) (if (null? (cdr tree)) 1 (apply + (map count-leaves (cdr tree)))))Tests (tested under Racket):&gt; (count-leaves tree)5&gt; (count-leaves (second tree))3&gt; (count-leaves (third tree))1&gt; (count-leaves (fourth tree))1 Istvan's answer is correct, but basically, the difference between your code and your textbook's is the difference between let and let*. Basically, let* is a nested series of lets, and in fact, a typical definition of let* is as follows:(define-syntax let* (syntax-rules () ;; if no bindings, same as let ((let* () body ...) (let () body ...)) ;; otherwise, take one binding, then nest the rest ((let* (binding next ...) body ...) (let (binding) (let* (next ...) body ...))))) If setLocation has a method lock, I do think the inner lock is redundant. Probably, the method lock should not be there.However, getLocation does need a lock, for memory visibility purposes. In particular, if getLocation were not synchronized, then updates done to location by setLocation may not be visible to a different thread, and getLocation could return a previous value for location. C has no strings; it has character pointers, and == simply compares the pointers. Use strcmp or strcasecmp (if your system has that) to compare strings. Note that strcmp returns 0 when the strings compare equally.Also, avoid using gets. If a user enters a string longer than 4 characters (in your case), other parts of your memory will start getting scribbled on. Instead, prefer to use fgets, which allows you to specify the size of your input buffer. Many GitHub projects use Travis (or other CI) integration to run builds across all branches, including pull requests. So the pull request is just a nice git-integrated way to submit patches to a project. I see it as a "bug report with patches" option, compared to a plain "bug report". Rather than creating arrays dynamically, consider creating vectors instead:std::vector&lt;byte&gt; test{0x00, 0x01, 0x02, 0x03};(Requires C++11.) You can get at a pointer to the bytes by using &amp;test[0]. It's not enough to create the first swapped pair. You also need to recurse into the rest of the pairs and swap them too. Here's a modified version of your code:(define (odwroc-alfabet list) (let loop ((list list)) (if (pair? list) (cons (cons (cdar list) (caar list)) (loop (cdr list))) list)))Of course, loop is a misnomer here since you're actually recursing rather than looping. tl;dr: Change your new MersenneTwister() to new MersenneTwister(new Date()) instead.Pseudo-random number generators use a seed to determine the sequence of numbers that come out. Generators will set a seed by default if you don't set one. Some generators use a different seed by default each time, such as by using your computer's clock, or by reading from /dev/urandom. Others will use a fixed seed by default.It sounds like your generator is using a fixed seed by default (MersenneTwister()'s documentation says "Constructs and returns a random number generator with a default seed, which is a constant" [emphasis in original]). This will, of course, result in the same stream of numbers.You should use either the MersenneTwister(Date) constructor (just use new MersenneTwister(new Date())), or the MersenneTwister(int) one (though that seems less ideal, since int is only 32 bits wide). Uses SRFI 1:(define (number-of-lists lst) (if (list? lst) (count list? lst) 0)) Preprocessor definitions have to use valid identifiers. Dots are not valid in identifiers.There is also a convention that preprocessor definitions (especially preprocessor macros) use all-uppercase names, to distinguish them from non-preprocessor identifiers. (It's not a hard-and-fast rule, though; for example, errno is usually a macro, but it's not uppercase.) (define (product-of-positives lst) (foldl * 1 (filter (lambda (x) (and (number? x) (positive? x))) lst))) (define (map-if mapper pred lst) (map (lambda (x) (if (pred x) (mapper x) x)) lst)) You can always use or to specify a default value:(or (for/or ...) -1) The inner lock serves no function, in this case. Java uses recursive mutexes, so a thread that holds a lock on a given mutex can lock it again, and a lock count is kept. Only when the last synchronized block is exited, is the mutex actually unlocked. No, there is no standard way to obtain a FILE* from an IOStreams stream, nor vice versa. Just change the &amp;#163; in your code to $ instead. You can do something somewhat similar to what you're asking by using a LEFT JOIN instead of an INNER JOIN. Excessive use of set! indicates an imperative style of programming, which is usually discouraged in Scheme. Here's a Racket-specific implementation of sum-of-divisors that does not use set! at all.(define (sum-of-divisors n) (define-values (q r) (integer-sqrt/remainder n)) (for/fold ((sum (if (and (zero? r) (&gt; q 1)) (add1 q) 1))) ((i (in-range 2 q)) #:when (zero? (modulo n i))) (+ sum i (quotient n i))))Equivalent version in standard R6RS/R7RS Scheme, if you're not using Racket:(define (sum-of-divisors n) (define-values (q r) (exact-integer-sqrt n)) (let loop ((sum (if (and (zero? r) (&gt; q 1)) (+ q 1) 1)) (i 2)) (cond ((&gt;= i q) sum) ((zero? (modulo n i)) (loop (+ sum i (quotient n i)) (+ i 1))) (else (loop sum (+ i 1))))))Note that this is not equivalent to the set!-based version you have. What this code actually does is create an inner function, loop, that gets tail-called with new arguments each time.Now, we can define amicable? and perfect? accordingly:(define (amicable? n) (define sum (sum-of-divisors n)) (and (not (= n sum)) (= n (sum-of-divisors sum))))(define (perfect? n) (= n (sum-of-divisors n)))If you really want to test two numbers to see if they are an amicable pair, you can do this:(define (amicable-pair? a b) (and (not (= a b)) (= a (sum-of-divisors b)) (= b (sum-of-divisors a))))Update for OP's new question about how to use this to find amicable pairs between m and n. First, let's define a variant of amicable? that returns a number's amicable "peer":(define (amicable-peer n) (define sum (sum-of-divisors n)) (and (not (= n sum)) (= n (sum-of-divisors sum)) sum))If you're using Racket, use this:(define (amicable-pairs-between m n) (for*/list ((i (in-range m (add1 n))) (peer (in-value (amicable-peer i))) #:when (and peer (&lt;= m peer n) (&lt; i peer))) (cons i peer)))If you're not using Racket, use this:(define (amicable-pairs-between m n) (let loop ((result '()) (i n)) (if (&lt; i m) result (let ((peer (amicable-peer i))) (if (and peer (&lt;= m peer n) (&lt; i peer)) (loop (cons (cons i peer) result) (- i 1)) (loop result (- i 1)))))))The way this works, is that because lists are built from right-to-left, I've decided to count downward from n through to m, keeping only numbers that have an amicable peer, and where the peer is within range. The (&lt; i peer) check is to ensure that the amicable pair only appears once in the results.Example:&gt; (amicable-pairs-between 0 10000)((220 . 284) (1184 . 1210) (2620 . 2924) (5020 . 5564) (6232 . 6368))More OP updates (wherein he asked what the difference between a recursive version and an accumulative version is). The version of amicable-pairs-between I wrote above is accumulative. A recursive version would look like this:(define (amicable-pairs-between m n) (let recur ((i m)) (if (&gt; i n) '() (let ((peer (amicable-peer i))) (if (and peer (&lt;= m peer n) (&lt; i peer)) (cons (cons i peer) (recur (+ i 1))) (recur (+ i 1)))))))Note that there is no result accumulator this time. However, it's not tail-recursive any more. The macro expander used in SISC, psyntax, supports a different way to do inner ellipses, by using the ... macro. You can write this by applying the ... macro to each inner ellipses you want to use:(define-syntax define-quotation-macros (syntax-rules () ((_ (macro-name head-symbol) ...) (begin (define-syntax macro-name (syntax-rules () ((_ x (... ...)) '(head-symbol x (... ...))))) ...))))or you can apply it to an outer form where all the ellipses within are supposed to be inner:(define-syntax define-quotation-macros (syntax-rules () ((_ (macro-name head-symbol) ...) (begin (define-syntax macro-name (... (syntax-rules () ((_ x ...) '(head-symbol x ...))))) ...)))) Here's a very simple example:(require json)(define x (string-&gt;jsexpr "{\"foo\": \"bar\", \"bar\": \"baz\"}"))(for (((key val) (in-hash x))) (printf "~a = ~a~%" key val))Here's how you can use it with a JSON-based API:(require net/http-client json)(define-values (status header response) (http-sendrecv "httpbin.org" "/ip" #:ssl? 'tls))(define data (read-json response))(printf "My IP address is ~a~%" (hash-ref data 'origin))At the OP's request, here's how you can create a JSON value from a structure type:(require json)(struct person (first-name last-name age country))(define (person-&gt;jsexpr p) (hasheq 'first-name (person-first-name p) 'last-name (person-last-name p) 'age (person-age p) 'country (person-country p)))(define cky (person "Chris" "Jester-Young" 33 "New Zealand"))(jsexpr-&gt;string (person-&gt;jsexpr cky)) Try running stty erase ^H. This will make your terminal treat ^H as backspace. Java is always pass-by-value. However, when you pass a reference to a function, you could alter the object that the reference points to. However, if you change the reference inside the function, that doesn't affect the caller. racket -r test.scmIf test.scm is a module, then instead of -r (--script), use -u (--require-script). You can find out more information by running racket --help. Because list(set, get, setmean, getmean) won't tag the list elements with the correct names. Here's an example of the difference between tagged and untagged lists:&gt; list(1, 2, 3)[[1]][1] 1[[2]][1] 2[[3]][1] 3&gt; list(foo=1, bar=2, baz=3)$foo[1] 1$bar[1] 2$baz[1] 3Note that in the context of argument lists, = is used to supply named arguments, it does not do any assignments (unlike &lt;-). Thus list(foo=1, bar=2, baz=3) is very different from list(foo&lt;-1, bar&lt;-2, baz&lt;-3). Perl version:perl -lne '$occ{0+$_}++; END {print "$_ $occ{$_}" for sort {$a &lt;=&gt; $b} keys %occ}' &lt; numbers.txt The syntax for passing arguments to the base class is as follows:Dreptunghi::Dreptunghi(double h, double v) : Forma(h, v) {}The way you wrote it, it'd instead try to create an instance of Forma, which of course isn't allowed. 50 and 99 are not procedures. Therefore, it's invalid to evaluate (50) and (99). Using name.getExtendedState()|JFrame.MAXIMIZED_BOTH means that you're adding MAXIMIZED_BOTH to the existing extended state. If you say only JFrame.MAXIMIZED_BOTH, that means you're replacing the extended state with only that bit, and throwing away anything in the current extended state. I wrote an implementation today. Alas, R5RS has neither bytevectors nor binary I/O, so this uses the R7RS APIs for bytevectors and binary I/O. It should be easy to bridge those APIs to your Scheme implementation's native APIs (for example, I actually tested my implementation on Racket and Guile).A few notes:This code assumes case-sensitivity. This is the default for R7RS, but not R5RS, so if you're using an R5RS implementation, beware.It requires SRFIs 1, 26, 43, and 60.I emphasise elegance and clarity over speed. In fact, the code is quite slow.Contrary to what my profile says, I'm only licensing this code under the Apache Licence 2.0 (in addition to the standard Stack Overflow licence of CC BY-SA 3.0), and not under CC0 or anything resembling public domain.Anyway, without further ado, here it is (also available as a Gist):;;; Auxiliary definitions to avoid having to use giant tables of constants.(define primes80 '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409))(define (sqrt x) (fold (lambda (_ y) (/ (+ (/ x y) y) 2)) 4 (iota 7)))(define (cbrt x) (fold (lambda (_ y) (/ (+ (/ x y y) y y) 3)) 4 (iota 8)))(define (frac x scale base) (bitwise-and (floor (* x (arithmetic-shift 1 scale))) (- (arithmetic-shift 1 base) 1)));;; The actual initialisation and constant values.(define sha1-init '(#x67452301 #xefcdab89 #x98badcfe #x10325476 #xc3d2e1f0))(define sha2-init (map (lambda (x) (frac (sqrt x) 64 64)) (take primes80 16)))(define-values (sha512-init sha384-init) (split-at sha2-init 8))(define sha256-init (map (cut arithmetic-shift &lt;&gt; -32) sha512-init))(define sha224-init (map (cut frac &lt;&gt; 0 32) sha384-init))(define sha1-const (map (lambda (x) (frac (sqrt x) 30 32)) '(2 3 5 10)))(define sha512-const (map (lambda (x) (frac (cbrt x) 64 64)) primes80))(define sha256-const (map (cut arithmetic-shift &lt;&gt; -32) (take sha512-const 64)));;; Utility functions used by the compression and driver functions.(define (u32+ . xs) (bitwise-and (apply + xs) #xffffffff))(define (u64+ . xs) (bitwise-and (apply + xs) #xffffffffffffffff))(define (bitwise-majority x y z) (bitwise-xor (bitwise-and x y) (bitwise-and x z) (bitwise-and y z)))(define (bytevector-be-ref bv base n) (let loop ((res 0) (i 0)) (if (&lt; i n) (loop (+ (arithmetic-shift res 8) (bytevector-u8-ref bv (+ base i))) (+ i 1)) res)))(define (bytevector-u64-ref bv i) (bytevector-be-ref bv (arithmetic-shift i 3) 8))(define (bytevector-u32-ref bv i) (bytevector-be-ref bv (arithmetic-shift i 2) 4))(define (bytevector-be-set! bv base n val) (let loop ((i n) (val val)) (when (positive? i) (bytevector-u8-set! bv (+ base i -1) (bitwise-and val 255)) (loop (- i 1) (arithmetic-shift val -8)))))(define (md-pad! bv offset count counter-size) (define block-size (bytevector-length bv)) (unless (negative? offset) (bytevector-u8-set! bv offset #x80)) (let loop ((i (+ offset 1))) (when (&lt; i block-size) (bytevector-u8-set! bv i 0) (loop (+ i 1)))) (when count (bytevector-be-set! bv (- block-size counter-size) counter-size (arithmetic-shift count 3))))(define (hash-state-&gt;bytevector hs trunc word-size) (define result (make-bytevector (* trunc word-size))) (for-each (lambda (h i) (bytevector-be-set! result i word-size h)) hs (iota trunc 0 word-size)) result);;; The compression functions.(define (sha2-compress K Σ0 Σ1 σ0 σ1 mod+ getter hs) (define W (vector-&gt;list (apply vector-unfold (lambda (_ a b c d e f g h i j k l m n o p) (values a b c d e f g h i j k l m n o p (mod+ a (σ0 b) j (σ1 o)))) (length K) (list-tabulate 16 getter)))) (define (loop k w a b c d e f g h) (if (null? k) (map mod+ hs (list a b c d e f g h)) (let ((T1 (mod+ h (Σ1 e) (bitwise-if e f g) (car k) (car w))) (T2 (mod+ (Σ0 a) (bitwise-majority a b c)))) (loop (cdr k) (cdr w) (mod+ T1 T2) a b c (mod+ d T1) e f g)))) (apply loop K W hs))(define (sha512-compress bv hs) (define (rotr x y) (rotate-bit-field x (- y) 0 64)) (define (shr x y) (arithmetic-shift x (- y))) (sha2-compress sha512-const (lambda (x) (bitwise-xor (rotr x 28) (rotr x 34) (rotr x 39))) (lambda (x) (bitwise-xor (rotr x 14) (rotr x 18) (rotr x 41))) (lambda (x) (bitwise-xor (rotr x 1) (rotr x 8) (shr x 7))) (lambda (x) (bitwise-xor (rotr x 19) (rotr x 61) (shr x 6))) u64+ (cut bytevector-u64-ref bv &lt;&gt;) hs))(define (sha256-compress bv hs) (define (rotr x y) (rotate-bit-field x (- y) 0 32)) (define (shr x y) (arithmetic-shift x (- y))) (sha2-compress sha256-const (lambda (x) (bitwise-xor (rotr x 2) (rotr x 13) (rotr x 22))) (lambda (x) (bitwise-xor (rotr x 6) (rotr x 11) (rotr x 25))) (lambda (x) (bitwise-xor (rotr x 7) (rotr x 18) (shr x 3))) (lambda (x) (bitwise-xor (rotr x 17) (rotr x 19) (shr x 10))) u32+ (cut bytevector-u32-ref bv &lt;&gt;) hs))(define (sha1-compress bv hs) (define (getter x) (bytevector-u32-ref bv x)) (define (rotl x y) (rotate-bit-field x y 0 32)) (define W (vector-&gt;list (apply vector-unfold (lambda (_ a b c d e f g h i j k l m n o p) (values a b c d e f g h i j k l m n o p (rotl (bitwise-xor a c i n) 1))) 80 (list-tabulate 16 getter)))) (define (outer f k w a b c d e) (if (null? k) (map u32+ hs (list a b c d e)) (let inner ((i 0) (w w) (a a) (b b) (c c) (d d) (e e)) (if (&lt; i 20) (let ((T (u32+ (rotl a 5) ((car f) b c d) e (car k) (car w)))) (inner (+ i 1) (cdr w) T a (rotl b 30) c d)) (outer (cdr f) (cdr k) w a b c d e))))) (apply outer (list bitwise-if bitwise-xor bitwise-majority bitwise-xor) sha1-const W hs));;; The Merkle-Damgård "driver" function.(define (md-loop init compress block-size trunc word-size counter-size in) (define leftover (- block-size counter-size)) (define bv (make-bytevector block-size)) (define pad! (cut md-pad! bv &lt;&gt; &lt;&gt; counter-size)) (define hs-&gt;bv (cut hash-state-&gt;bytevector &lt;&gt; trunc word-size)) (let loop ((count 0) (hs init)) (define read-size (read-bytevector! bv in)) (cond ((eof-object? read-size) (pad! 0 count) (hs-&gt;bv (compress bv hs))) ((= read-size block-size) (loop (+ count read-size) (compress bv hs))) ((&lt; read-size leftover) (pad! read-size (+ count read-size)) (hs-&gt;bv (compress bv hs))) (else (pad! read-size #f) (let ((pen (compress bv hs))) (pad! -1 (+ count read-size)) (hs-&gt;bv (compress bv pen)))))));;; SHA-512/t stuff.(define sha512/t-init (map (cut bitwise-xor &lt;&gt; #xa5a5a5a5a5a5a5a5) sha512-init))(define (make-sha512/t-init t) (define key (string-&gt;utf8 (string-append "SHA-512/" (number-&gt;string t)))) (define size (bytevector-length key)) (define bv (make-bytevector 128)) (bytevector-copy! bv 0 key) (md-pad! bv size size 16) (sha512-compress bv sha512/t-init))(define (make-sha512/t t) (define init (make-sha512/t-init t)) (define words (arithmetic-shift t -6)) (if (zero? (bitwise-and t 63)) (cut md-loop init sha512-compress 128 words 8 16 &lt;&gt;) (lambda (in) (bytevector-copy (md-loop init sha512-compress 128 (ceiling words) 8 16 in) 0 (arithmetic-shift t -3)))));;; Public entry points.(define sha1 (cut md-loop sha1-init sha1-compress 64 5 4 8 &lt;&gt;))(define sha224 (cut md-loop sha224-init sha256-compress 64 7 4 8 &lt;&gt;))(define sha256 (cut md-loop sha256-init sha256-compress 64 8 4 8 &lt;&gt;))(define sha384 (cut md-loop sha384-init sha512-compress 128 6 8 16 &lt;&gt;))(define sha512 (cut md-loop sha512-init sha512-compress 128 8 8 16 &lt;&gt;))(define sha512/256 (make-sha512/t 256))(define sha512/224 (make-sha512/t 224))I implemented all the algorithms in FIPS 180-4, but you can strip out whatever you don't need.As mentioned before, I tested this on Racket; the definitions I added to bridge to Racket's APIs are as follows:#lang racket(require (only-in srfi/1 iota) (only-in srfi/26 cut) (only-in srfi/43 vector-unfold) (only-in srfi/60 bitwise-if rotate-bit-field) (rename-in racket/base [build-list list-tabulate] [bytes-copy! bytevector-copy!] [bytes-length bytevector-length] [bytes-ref bytevector-u8-ref] [bytes-set! bytevector-u8-set!] [foldl fold] [make-bytes make-bytevector] [read-bytes! read-bytevector!] [string-&gt;bytes/utf-8 string-&gt;utf8] [subbytes bytevector-copy]))And here are the definitions for Guile (requires version 2.0.11 or above):(use-modules (srfi srfi-1) (srfi srfi-26) (srfi srfi-43) (srfi srfi-60) (rnrs bytevectors) (ice-9 binary-ports))(define* (bytevector-copy bv #:optional (start 0) (end (bytevector-length bv))) (define copy (make-bytevector (- end start))) (bytevector-copy! copy 0 bv start end) copy)(define* (bytevector-copy! to at from #:optional (start 0) (end (bytevector-length from))) ((@ (rnrs bytevectors) bytevector-copy!) from start to at (- end start)))(define* (read-bytevector! bv #:optional (port (current-input-port)) (start 0) (end (bytevector-length bv))) (get-bytevector-n! port bv start (- end start)))It should be easy to make something similar for your chosen implementation.I also have a function that prints out the output as a hex string, for ready comparison with various command-line SHA-1 and SHA-2 utilities (e.g., sha1sum, sha256sum, sha512sum, etc.):(define (hex bv) (define out (open-output-string)) (do ((i 0 (+ i 1))) ((&gt;= i (bytevector-length bv)) (get-output-string out)) (let-values (((q r) (truncate/ (bytevector-u8-ref bv i) 16))) (display (number-&gt;string q 16) out) (display (number-&gt;string r 16) out)))) Do you have execute permission to /home/bernd/dir? Read permission only allows you to list the directory without necessarily being able to access any of its contents.(On the other hand, execute permission without read permission lets you access the contents but makes the directory unlistable (readdir would fail).) The problem is that your compare function is non-static. You either need to make it a free function, or else make it static. The way I'd implement something like this is to store the aspect ratios (1:144, 2:72, 3:48, 4:36, etc.) into a sorted array. Then for each incoming image, calculate its aspect ratio, then find the nearest desired ratio using binary search.Even better, store the log of the aspect ratios, and do the binary search using the log of the image's aspect ratio. Here's an implementation of Cons that has a decent print syntax built-in (including support for improper lists), and is enumerable:class Cons include Enumerable attr_accessor :car, :cdr class &lt;&lt; self alias [] new end def initialize(car, cdr) self.car = car self.cdr = cdr end def each_pair return to_enum(:each_pair) unless block_given? cell = self while cell.is_a? Cons yield cell.car, cell.cdr cell = cell.cdr end end def each return to_enum unless block_given? each_pair { |car,| yield car } end def print sb = '(' each_pair do |car, cdr| sb &lt;&lt; yield(car) case cdr when Cons sb &lt;&lt; ' ' when nil else sb &lt;&lt; ' . ' &lt;&lt; yield(cdr) end end sb &lt;&lt; ')' end def to_s print &amp;:to_s end def inspect print &amp;:inspect endendOh, and here's an easy way to create a list (similar to the list function found in both Common Lisp and Scheme):def list(*items) items.reverse_each.reduce(nil) { |result, item| Cons[item, result] }endExamples:irb(main):001:0&gt; a = Cons[1, Cons[2, Cons[3, nil]]]=&gt; (1 2 3)irb(main):002:0&gt; b = Cons[1, Cons[2, Cons[3, 4]]]=&gt; (1 2 3 . 4)irb(main):003:0&gt; a.to_a=&gt; [1, 2, 3]irb(main):004:0&gt; a.map(&amp;Math.method(:sqrt))=&gt; [1.0, 1.4142135623730951, 1.7320508075688772]irb(main):005:0&gt; list(1, 2, 3, 4, 5)=&gt; (1 2 3 4 5)Update: A user wrote me asking how to (among other things) append cons-based lists. As a Schemer, I like to treat cons cells as immutable, so the standard approach for appending is to cons each element, right-to-left, from the left-hand list onto the right-hand list. Here's how I would implement it.First, let's define a reduce_right method. (Technically, this is a right fold, not a right reduce, but Ruby prefers the term "reduce" rather than "fold", so that's what I'll use here.) We'll reopen both NilClass and Cons to make this work:class NilClass def reduce_right(init) init endendclass Cons def reduce_right(init, &amp;block) block.call(cdr.reduce_right(init, &amp;block), car) endendThen, append is as simple as using reduce_right:def append(lhs, rhs) lhs.reduce_right(rhs) { |result, item| Cons[item, result] }endThis allows you to append two lists, but usually, it's more handy to allow appending any number of lists (and this is what Scheme's append allows):def append(*lists) lists.reverse_each.reduce do |result, list| list.reduce_right(result) { |cur, item| Cons[item, cur] } endendNotice that in both cases, the rightmost "list" is not required to be a proper list, and you can create improper lists by putting something that's not a cons cell there:irb(main):001:0&gt; append(list(1, 2, 3), list(4, 5))=&gt; (1 2 3 4 5)irb(main):002:0&gt; append(list(1, 2, 3), list(4, 5), 6)=&gt; (1 2 3 4 5 . 6)irb(main):003:0&gt; append(list(1, 2, 3), list(4, 5), list(6))=&gt; (1 2 3 4 5 6)(Non-rightmost lists must be proper lists.) You are missing some parentheses. Here's a fixed version of the code:(define (make-monitored f) (define (monitor count) (define (how-many-calls) count) (define (reset-count) (set! count 0)) (define (dispatch param) (cond ((eq? param 'how-many-calls) (how-many-calls)) ((eq? param 'reset-count) (reset-count)) (else (begin (set! count (+ count 1)) (f param))))) dispatch) (monitor 0)) You can use:((Predicate&lt;String&gt;) e -&gt; e.equals("1")).or(e -&gt; e.equals("2"))but it's not very elegant. If you're specifying the conditions in-line, just use one lambda:e -&gt; e.equals("1") || e.equals("2") Your code started x at 0. That means, your code will try to run 6008 % 0, which causes the division by zero error.Change int x = 0 to int x = 1 to fix that. Don't do that.Racket does provide parallelism via futures and places, but they do not provide (unrestricted) shared memory spaces. If you want to send data from one thread to another, use a place channel.As Greg Hendershott points out, you can send a shared vector via a place channel, which provides a shared space to use. (But that's not the same thing as sharing all the memory references, which is what someone familiar with, say, Java-style threading might expect. And the latter is what my "don't do that" refers to.)If you really want to use pthread-like threading, Guile does provide them, but then you won't be using Racket any more. ;-) In Java 7 and 8, surely you should just use Integer.compare. Then you can totally avoid any boxing whatsoever. Simple! In this case, you should install the libmad-devel package. In general, for a library named foo, you should install the libfoo-devel package. Enums are for concepts that have a fixed set of values. A good example of enum is the months in a year. In the Gregorian calendar, there are twelve months, and you can create a month enum thusly:enum Month { JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER}You can imbue individual members with specific behaviour, for example, we can give a numberOfDays property:enum Month { JANUARY(31), FEBRUARY(28), MARCH(31), APRIL(30), MAY(31), JUNE(30), JULY(31), AUGUST(31), SEPTEMBER(30), OCTOBER(31), NOVEMBER(30), DECEMBER(31); private final int numberOfDays; Month(int numberOfDays) { this.numberOfDays = numberOfDays; } public int getNumberOfDays() { return numberOfDays; }}However, you'll notice that February doesn't have 28 day every year. Instead, you'll need to give it even more special behaviour. So, then, you create a class body for FEBRUARY to do so:enum Month { JANUARY(31), FEBRUARY(28) { @Override public int getNumberOfDays(int year) { return isLeapYear(year) ? 29 : 28; } private boolean isLeapYear(int year) { return year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0); } }, MARCH(31), APRIL(30), MAY(31), JUNE(30), JULY(31), AUGUST(31), SEPTEMBER(30), OCTOBER(31), NOVEMBER(30), DECEMBER(31); private final int numberOfDays; Month(int numberOfDays) { this.numberOfDays = numberOfDays; } public int getNumberOfDays(int year) { return numberOfDays; }} When you enter "No", which is not a valid integer, your cin stream is in an error state after the cin &gt;&gt; n expression. Therefore, no further input will work, and in particular, your getline will not try to read a line. From reading the EventBus source code, it seems that Guava 14 onwards does sufficient locking to avoid this problem, whereas Guava 13 and below does not do any locking. Can you use a newer version of Guava?(It's clear from the error message that you're not on the latest Guava, as Guava 16 onwards calls handlers "subscribers" instead.) That kind of ambiguity is resolved at the caller side by using casts. In this case, you'd cast the array to (Object) first, to have it be treated as a varargs argument. e.g., to pass the array as one argument:callLater(myObj, "myMeth", (Object) new String[] {"A", "B"});To pass two arguments:callLater(myObj, "myMeth", (Object[]) new String[] {"A", "B"});or simply:callLater(myObj, "myMeth", "A", "B"); To debug an OutOfMemoryError, invoke the JVM with the -XX:+HeapDumpOnOutOfMemoryError option, which will cause a heap dump to be written out when an OutOfMemoryError occurs. Then use a tool like VisualVM, jhat, or fasthat to look at the heap dump.You can also generate a heap dump manually at any time by using jmap with the -dump option.Disclosure: I'm the maintainer of fasthat, which is a fork of jhat. Scheme uses eager evaluation. That means that all arguments to a function call are evaluated before the function is entered. Thus, since your delay was a function, expressions passed to delay get evaluated first.To get around this, make delay a macro, as does anything that uses it (like cons-stream). Here's a reformulation of your delay and cons-stream as macros:(define-syntax delay (syntax-rules () ((_ exp) (lambda () exp))))(define-syntax cons-stream (syntax-rules () ((_ a b) (cons a (delay b))))) typedef defines the right-hand side, not the left-hand side. In this case, the types being defined are LONGLONG and ULONGLONG, not double. Sure, use ssh's tunnelling feature. Assuming you want to tunnel over port 10022 (any port number is okay as long as it's not used on your local machine, and it's 1024 or greater):ssh -L10022:192.168.1.2:22 user1@10.6.47.102ssh -p10022 user2@127.0.0.1These two commands must be run in separate sessions (both from machine A), since the first connection must remain active in order for the second one to work. Actually, especially in Java 7 onwards, even your second method is not going to work. (See below for why.) Anyway, the reason is that maps must have distinct keys, and when you are using your value as key, two equal values would be treated as equal keys.The proper fix, by the way, is to sort by value, then by key:int compare = map.get(k1).compareTo(map.get(k2));if (compare == 0) { compare = k1.compareTo(k2);}return compare;Proper comparators must follow three rules:compare(a, a) == 0 for all values of a.signum(compare(a, b)) == -signum(compare(b, a)) for all values of a and b.if signum(compare(a, b)) == signum(compare(b, c)), then signum(compare(a, c)) must also have the same value, for all values of a, b, and c. Base class methods cannot access subclass fields (at least, without using reflection). Full stop.Also, fields do not participate in overriding, unlike methods. gets reads in the whole line. If you want to process multiple elements from it, you need to split on that line, or perform regex matches on it, etc. In your case:p, q = gets.split.map(&amp;:to_i)BTW, in your code, the chomp calls are superfluous, since to_i will work correctly whether the string ends with a newline or not. The correct content type for XHTML is application/xhtml+xml. But really, unless you need XML compliance, there is a pretty standard way to parse HTML, and there're many HTML parsers you can choose from, and both compress pretty well.So, in other words, many sites don't believe that XHTML adds enough value to use it. Just use std::not1(std::ptr_fun(space)). std::not1 is declared in &lt;functional&gt;.(There is also a std::not2 for use with binary predicates; std::not1 is for unary predicates.) To be able to use an external pointer as a Callback, you type-pun the way C programmers do: with unions.public static class WindowProcUnion extends Union { public Pointer ptr; public WinUser.WindowProc wndProc; public WindowProcUnion(Pointer ptr) { this.ptr = ptr; setType("ptr"); write(); setType("wndProc"); read(); }}You can now read the wndProc field and get back a usable window procedure callback.For this use case, DefWindowProc is actually exported via the User32 class, so you can just create a callback to invoke it directly:public static class DefWindowProc implements WinUser.WindowProc { @Override public LRESULT callback(WinDef.HWND hWnd, int uMsg, WinDef.WPARAM wParam, WinDef.LPARAM lParam) { return User32.INSTANCE.DefWindowProc(hWnd, uMsg, wParam, lParam); }}Have a look at the Win32WindowDemo class for an example of a window procedure that delegates to DefWindowProc. Your syntax for cond is wrong. Here's the same code with a corrected syntax:(define (inv curstate x y) (cond ((= y 1) curstate) ((even? y) (inv (square curstate) x (/ y 2))) (else (inv (* x curstate) x (- y 1))))) moveSmile(Math.ceil((215 - distance) / 15)); Downloads are network-bound, not CPU-bound. So theoretically, using multiple threads will not make it faster.On the one hand, if your program downloads using synchronous (blocking) I/O, then multiple threads simply enables less blocking to occur. In general, on the other hand, it is more sensible to just use a single thread with asynchronous I/O.On the gripping hand, asynchronous I/O is trickier to code correctly than synchronous I/O (which is straightforward). So the developers may have just decided to favour ease of programming over pure performance. (Or they may favour compatibility with older Java platforms: real async I/O is only available with NIO2 (which came with Java 7).) Python is indentation-sensitive. You had your print_factors_list recursive call at the outermost indentation level, thus it's outside of the for loop. This is different behaviour from your Java code. The Exp, Log, etc. classes store no state. The reason their value methods are not static is to fulfil the UnivariateFunction interface. So, yes, you can safely reuse the objects.One of the nice things about the UnivariateFunction interface is that you can write a function that takes such an object, and the user can parameterise your function by passing in an appropriate function object. This concept is called higher-order functions (if you come from the FP camp, as I do) or strategy pattern (if you come from the OOP camp). Your syntax for cond is wrong. Here is the same code with the correct syntax:(define (test a b c) (cond ((and (&lt; a b) (&lt; a c)) (+ (* b b) (* c c))) ((and (&lt; b a) (&lt; b c)) (+ (* a a) (* c c))) (else (+ (* b b) (* c c)))))However, your code is still wrong. Can you see why? (Hint: what does the else branch signify, and what expression should be there?) Since it's a template that's parameterised on the function object's class, yes, it should work with all callable objects. The basic solution to this is to implement iota and map, and combine the two:iota generates a list of numbers given the start, stop, and stepmap invokes a given function on all the elements of the given list, and returns a new list containing the returned valuesYou have to write those functions, but once you have, your seq function is a simple matter of piecing the two together. (define two-to-the-factorial (compose two-to-the factorial)) For object monitors protected by synchronized, no, it either successfully locks or it blocks indefinitely waiting for a lock.If you're using a ReentrantLock or the like, you have more options:You can wait indefinitely, just like object monitors, by calling lock.You can wait for a limited amount of time by calling tryLock with a timeout value.You can immediately return if the lock is unavailable by calling tryLock with no arguments. I am not a lawyer.If you use any GPL code or resources, you need to release your whole program using a GPL-compatible licence. The GPL is, of course, a GPL-compatible licence, but it is not the only GPL-compatible licence; other examples include the Apache Licence 2.0 and the X11 ("MIT") Licence. Remember that + and - have the same precedence, so they are evaluated left-to-right (+ and - are both left-associative operators). So, 90 - 9 + 10 = 81 + 10 = 91. You should use \(.*\) instead of (.*).sed uses Basic Regular Expressions (BRE) by default, which uses \( and \) for group capturing, not just ( and ) as used in Extended Regular Expressions (ERE). Since your expression used (.*) instead of \(.*\), it is not recognised as a group capture, and thus nothing is captured for use with \1.Some sed implementations, such as the ones provided by GNU and BSD, do have an extension for specifying the use of ERE, but it is not specified by POSIX, and you cannot use it if you want to be portable. The best way to enable run.cpp to refer to things defined in config.cpp is to create a config.h (or config.hpp) header file. That way, changes to config.cpp is easier to keep in sync, you only have to update config.h.Anyway, to answer your questions:In the first case, the static actually makes your variable invisible to other translation units. This is how static works for top-level variables.In the second case, you still need a declaration that config_id is inside the app namespace:namespace app { extern int config_id;} If you need a unique identifier, just go with UUIDs. Don't try to cook up your own UUID-equivalent using timestamps. Here's how you might do hostname tagging within a single function:def tag_hostname(obj, hostname) obj.singleton_class.class_exec(hostname) do |hostname| define_method :hostname, -&gt; { hostname } endendExample usage:Foo = Class.newBar = Class.newtag_hostname Foo, 'foo.example.com'tag_hostname Bar, 'bar.example.com'Foo.hostname # =&gt; 'foo.example.com'Bar.hostname # =&gt; 'bar.example.com'Or perhaps you're trying to work with Foo::HOSTNAME instead? Then it's even easier, just use Module#const_set.To answer the original question, you can bind the x to a function scope. Like so:def constantly(x) -&gt;(*) { x }endExample usage:&gt; a = constantly(42)&gt; a.call=&gt; 42&gt; a.call(1, 2, 3)=&gt; 42(By the way, the name constantly is from Common Lisp.) You have to use capturing groups:str.replaceAll("(\\d+)\\.(\\d+)", "$1,$2") Interface methods are all public, even if the public keyword is not present. Classes that implement the interface must make all their implemented methods public, and the public keyword must be present. Yes. Guava has a Multiset type you should use for this.Multiset&lt;String&gt; bag = LinkedHashMultiset.create();Collections.addAll(bag, "a", "a", "a", "b", "b", "c", "d");for (Multiset.Entry&lt;String&gt; entry : bag.entrySet()) { System.out.println(entry.getElement() + " : " + entry.getCount());}Choose the right Multiset implementation depending on which iteration order you want:For ordering by first insertion, use LinkedHashMultiset (as in my example above).For ordering by natural order, or by a specific comparator, use TreeMultiset.If you don't care about the order, use HashMultiset.Obviously, these map to the same decisions you'd make for choosing a Map implementation. You can't add a newline after the XML declaration automatically, but if you can deal with removing the XML declaration entirely, you can add this line just after your Transformer serializer = ... line:serializer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes"); The difference is that the first one contains a hash, and the second one contains an array. So you should do something like this instead:cmd = {}cmd['param1'] = Param.newcmd['param2'] = Param.newcmd['param3'] = Param.newOj.dump("command" =&gt; cmd)Indeed, hashes can't have duplicate key names. It sounds like your API isn't using proper JSON? Ruby programmers typically use class &lt;&lt; self inside a class body to open up the class object's eigenclass, like so:class Foo class &lt;&lt; self # ... endendHowever, I seldom see this equivalent form (assume that Foo is already defined to be a class):class &lt;&lt; Foo # ...endIs there a reason for preferring the first style to the second? You can forward-declare structs and classes. So:struct Sales_data;std::istream&amp; read(std::istream&amp; is, Sales_data&amp; item);then everything else. You haven't initialised the contents of those buffers you newed up. They can contain anything whatsoever. If both of the buffers you allocated both happened to start with '\0', then strcmp would indeed say they are equal (since they are both considered zero-length strings).Also, I agree with everything in Praetorian's comment, especially about the Rule of Three. The first piece of code looks at the third component of each string, after splitting by dots, then turns them into integers, and compares them.In your case, though, since the third component is x, which is not a number, this won't work. If you want to compare the first two components, you'd have to do something like:String[] parts1 = s1.split("\\.");String[] parts2 = s2.split("\\.");int comparison = Integer.compare(Integer.parseInt(parts1[0]), Integer.parseInt(parts2[0]));if (comparison == 0) { comparison = Integer.compare(Integer.parseInt(parts1[1]), Integer.parseInt(parts2[1]));}return comparison;If you're using Guava, then do this:String[] parts1 = s1.split("\\.");String[] parts2 = s2.split("\\.");return ComparisonChain.start() .compare(Integer.parseInt(parts1[0]), Integer.parseInt(parts2[0])) .compare(Integer.parseInt(parts1[1]), Integer.parseInt(parts2[1])) .result(); Your mutex in ThreadPool::threadLoop is a local variable. That means that different threads are locking on different mutexes. This is invalid: condition variables are tied to a specific mutex and you must acquire a lock for that mutex before waiting on the condition.You should declare a _mutex (or, even better, use the mutex_ naming convention: underscore-prefix identifiers are mostly reserved) member variable in your ThreadPool class, and always lock on that. Just trust, by default. Only check for types if you must fail-fast.In languages like JS (and Ruby and Python and similar dynamically-typed languages), duck typing is really common. By explicitly checking for type, your functions become less general and thus less useful.By way of example, many of the standard JS functions in Array.prototype, while designed to work for Array instances, are intentionally coded to allow any object that supports the same operations as an array to be passed in, even if not actually an Array. (Search for the phrase "intentionally generic" in the ECMA-262 standard.) The self refers to the receiver of the new_map! method. When you pass a block, it gets turned into a Proc and bound to the block variable. Then, the expression self.map(&amp;block) sends that proc as a block to the map call. The confusion you're experiencing is not unique. It's just notation, that is all, and until you learn to see that notation, everything is confusing.First, let's start with proper lists. These are lists that end with an empty list:(cons 1 (cons 2 (cons 3 '()))); =&gt; (1 2 3)This list, (1 2 3), is actually a shorthand for (1 2 3 . ()): basically a list where the last cons points to an empty list.Now, if we substitute the () with 4, let's see what we get:(cons 1 (cons 2 (cons 3 4))); =&gt; (1 2 3 . 4)Notice, it's not so different from (1 2 3 . ()), is it?Of course, both of these are shorthands for the much longer forms of (1 . (2 . (3 . ()))) and (1 . (2 . (3 . 4))), respectively. Don't write (#f), it should be #f. You do not want to use CustomEqualsStrategy.INSTANCE. Using new CustomEqualsStrategy() is correct and should be preferred unless you have very good reasons for doing otherwise.Since CustomEqualsStrategy extends JAXBEqualsStrategy, that means that unless you define your own INSTANCE field inside CustomEqualsStrategy, CustomEqualsStrategy.INSTANCE is the same as JAXBEqualsStrategy.INSTANCE, which means that you would be using an instance of JAXBEqualsStrategy after all.Plus, using an INSTANCE field like that effectively signals that your class is meant to be used as a singleton, and thus has to be stateless. Most classes are not stateless, and even for classes that are, many such classes don't need to be used in a singleton style.In short, really just stick with new CustomEqualsStrategy(). The code will have fewer surprises and you'll be happier for it. (Also, from reading the code for JAXBEqualsStrategy, perhaps you should be extending DefaultEqualsStrategy instead.) I don't know anything about Arabic, so this answer focuses on Chinese only.Technically, if you are using a representation like UTF-8, more bytes are required to represent a Chinese character (3 or 4 bytes, depending on whether the character is in BMP) than for an ASCII character (1 byte). However, a single Chinese character often expresses what a whole word in English does. So in the end, your text can end up shorter, even when using UTF-8 encoding.When using other encodings, the space advantages of ASCII characters are even less. In UTF-16, each ASCII character takes 2 bytes, and a Chinese character takes 2 or 4 bytes (depending on whether it's in BMP). So if most of your Chinese text is in BMP, it has even more space advantage over English. :-) And of course, in UTF-32, every character takes 4 bytes, BMP or no.Note that, no matter what encoding is used for persistent storage, many programming languages will use UTF-32 across the board, especially if random access to characters within a string is desired. That means ASCII characters confer no space advantages whatsoever within the process memory for those programming languages. For numbers, ++i is exactly identical to i += 1, and i++ is similar to tmp = i, i += 1, tmp (assuming C semantics for ,). So don't worry which operator you're using, in such cases.For C++ class objects that have user-defined operators for ++ and +=, the performance is, of course, dependent on the specifics of the operators' implementations. Note that in C++ code, + is usually defined in terms of += (and postincrement is usually defined in terms of preincrement), so prefer to use += and preincrement ++ unless you need to do a nondestructive addition or use the original value before incrementing, respectively.Sample implementation of + in C++ (note that lhs is passed by value so that it is copied, so that the += does not change the original object):Foo operator+(Foo lhs, Foo const&amp; rhs){ return lhs += rhs;}Sample implementation of postincrement in C++:Foo Foo::operator++(int){ Foo orig(*this); ++*this; return orig;} You should use:printf("A/C is %s\n", result);Your result is actually declared with the wrong type; it should be char const *.Even better (as mentioned in Ed's comment), you shouldn't be using printf for this. Do this instead:std::cout &lt;&lt; "A/C is " &lt;&lt; result &lt;&lt; "\n"; The "standard" native-interop system for Java is JNA. It's been around for a long time, is well-supported, and pretty much handles most any native-invocation scenario you would want. Of course, it supports loading dynamic libraries too.You should consider using JNA for your project, or failing that, looking to see how it decides what the correct dynamic library extension is. hwnd's answer is indeed the most concise way to do it. However, especially if the pattern is to be matched many, many times, I'd like to suggest an alternative that is faster. Yes, it's called precompiling the pattern! (In contrast, String#replaceAll recompiles the pattern on each invocation.)private static final Pattern LINE_END_SPACES = Pattern.compile(" +$", Pattern.MULTILINE);public static String stripLineEndSpaces(String str) { return LINE_END_SPACES.matcher(str).replaceAll("");}Yes, it looks more clunky, and that's because Java doesn't have regexp literals. I wish it did, but then people will want JSON literals, XML literals (think E4X), XPath expression literals, printf format string literals, SQL statement literals, etc., and then people will be asking when the madness will stop. :-) No. accept can only be called on a listening socket on the same system.However, you can set up machine A to forward all the data to machine B, by connecting to it separately. xinetd provides a port-forwarding feature, for example (though to the best of my knowledge, xinetd is Unix-only). "Tail position" is always relative to some outer expression. For example, consider this:(define (norm . args) (define (sum-of-squares sum args) (if (null? args) sum (let ((arg (car args))) (sum-of-squares (+ sum (* arg arg)) (cdr args))))) (sqrt (sum-of-squares 0 args)))The recursive call to sum-of-squares is indeed in tail position relative to sum-of-squares. But is it in tail position relative to norm? No, because the return value from sum-of-squares is sent to sqrt, not directly to norm's caller.The key to analysing whether an expression A is in tail position relative to outer expression B, is to see whether A's return value is directly returned by B, without any further processing.In your case, with your expression (f (+ 1 2) (begin (define x 4) x) 5) (which isn't actually valid, by the way: perhaps you meant (f (+ 1 2) (let () (define x 4) x) 5) instead), none of the subexpressions (+ 1 2), (let () (define x 4) x), and 5 are in tail position with respect to f, since their values have to be collected first, and then passed to f (which is a tail call). You can use this:(for*/list ([who (list foo bar)] [what '(get-val get-norm)]) (dynamic-send who what))The reason for that is that '(foo bar) is a list containing two symbols, foo and bar, and not a list containing the values of the variables foo and bar; you have to use (list foo bar) for that.Also, in order to be able to send to a method name that's in a variable, as opposed to naming the method directly, you have to use dynamic-send instead.Notice that my code does not use eval, and neither should you. Most of the time, you never need to use eval, and it's best avoided whenever possible. Are you running your program in the Racket REPL? If so, the first (read-line) call always returns an empty string on the first call. You can replicate this by running (list (read-line) (read-line)) in the REPL.Read this thread for more details: http://lists.racket-lang.org/users/archive/2011-January/043731.html. In summary:obj.class returns the class object of obj.All class objects are of type Class, and in particular, cls.class is Class for any class cls.Class is itself a class object. So are Module, Object, etc. First-class classes is one of Ruby's great features (and many languages do not have it). toRealPath is for resolving symbolic links. Windows shortcuts are not symbolic links. You will have to open the .lnk file and read its contents to figure out where it points to. Symbols can serve the purpose of an enumerated type, but symbols aren't really an enumerated type, unless you consider the set of all possible symbols (and, assuming that symbols can be infinitely long, then there are an infinite number of possible symbols) to be an enumeration.The advantage of symbols, and the main way in which it's similar to enumerations, is that symbols are interned. So if you write 'foo in one source file and 'foo in another, they both evaluate to identical symbols (they will have the same object identity). This makes them ideal for use as hash keys, case expressions, etc. The %s format specifier is for null-terminated strings only (which have type char*), not single characters (char). For single characters, use %c. The main reason you can use SwingUtilities.invokeLater is that the EDT has a task queue that its processing loop picks off and runs tasks from, and invokeLater simply posts the given task to that queue.Most threads do not have a processing loop or a task queue, though, so you can't post tasks to arbitrary threads. You can code in such a loop for your threads, of course. Another alternative is Perl, which can be useful if you're not super-familiar with awk.#!/usr/bin/perl -anF,use strict;our %names;BEGIN { while (&lt;ARGV&gt;) { chomp; $names{$_} = 1; }}print if $names{$F[0]};To run (assume you named this file filter.pl):perl filter.pl female.names.txt &lt; records.txt Hash tables are implemented using buckets that contain linked lists. So iterating is easy:See if the current node has a next pointer. If so, go to that.If the current node has no next pointer, go to the next bucket that has a node.If there is no such node, then you're done iterating.(Find the first node by finding the first bucket with a node in it.)Intuitively, since iterating through the whole hash table using the above algorithm is O(n), it would appear that each "next" operation is amortised constant time. The reason you're required to extend Serializable (or Externalizable) is to ensure that you're only serialising classes that are designed for serialisation. You certainly don't want to serialise classes that aren't designed for it, because then their format would be quite fragile; the smallest change to the class would break your deserialisation.One could argue that the same fragility applies to classes marked Serializable, but you're supposed to think about serial form stability when marking a class as Serializable (or else explicitly disavow any stability, as Guava does). You can't run Ubuntu binaries on Mint like that; binaries are generally not binary-compatible between distributions. Can you find a Mint build? If not, you'll have to build it yourself. By design, executors run in a non-daemon thread by default. This means that you need some way to tell the executor to terminate, or else your program won't exit.You need to think about under which conditions you'd want your program to exit. Then, under such conditions, arrange for the executor to shut down. For general searching, you can use vector-index from SRFI 43 to search for the index of a matching object.assv and the like are for searching an association list (alist) for the given key. Vectors are almost never used for the same purpose as alists, not least because they're unresizeable. So naturally, there would be no assv analogue for vector. java.exe is the Java launcher. It's a very small program that loads jvm.dll, and uses JNI (Java Native Interface, an interface inside jvm.dll that is used to connect C and Java code) to start up the JVM.The difference between the client and server versions is in the warmup time and optimisation strategy (client takes less time to start up than server, but performs less optimisations). So -server is generally better for long-running processes, where the longer startup time is amortised, and -client is generally better for short-lived ones. Does your TestClass or any of its superclasses have a @Test annotation on it? If a class has such an annotation, all public methods are considered test methods. In Windows, the proper way to run a daemon is as a service. You can use procrun (part of Apache Commons Daemon) to install your Java program as a Windows service. Racket doesn't have "statements", so the concept of newlines ending "statements" is nonsensical.If your motivation is to reduce or do away with parentheses, I encourage you to use a "standard alternative" reader like sweet-expressions, rather than making something home-grown. Here is another approach to the problem. It uses an accumulator instead of append when handling pairs, to eliminate the repeated copying of list structure over and over again which is done by append:(define (flat-filter pred x) (let recur ((x x) (initial '())) (cond ((null? x) initial) ((pair? x) (recur (car x) (recur (cdr x) initial))) ((pred x) (cons x initial)) ;; the one CONS call per element added (else initial))))This is probably a more advanced solution than Óscar López's, but it easily allows abstracting out into a folding function (argument order deliberately chosen to mirror that of fold and fold-right that are provided with most Scheme implementations as part of SRFI 1):(define (flat-fold-right func initial x) (cond ((null? x) initial) ((pair? x) (flat-fold-right func (flat-fold-right func initial (cdr x)) (car x))) (else (func x initial)))) ;; the one call to FUNC per element of input(define (flat-filter pred x) (flat-fold-right (lambda (elem res) (if (pred elem) (cons elem res) res)) '() x))Bonus freebies:(define (flat-map func x) (flat-fold-right (lambda (elem res) (cons (func elem) res)) '() x))(define (flatten x) (flat-fold-right cons '() x)) You can use Perl:perl -pe 's/\*\n//g' FileVault 2 is completely transparent, and will not affect the operation of any user-level program. I know this, because I've used it on my computer for a long time, and I know that git works without any issues. :-) The two macros are different when dealing with threaded forms that take further arguments. Try these for size:(macroexpand '(-&gt;&gt; 1 (a b) (c d e) (f g h i)))(macroexpand '(-&gt; 1 (a b) (c d e) (f g h i))) You can't capture local bindings with syntax-rules. You can use syntax-case for that, though:(define-syntax fi (lambda (stx) (syntax-case stx () ((_ a b) (with-syntax ((p (datum-&gt;syntax stx #'p))) #'(if p a b))))))However, using datum-&gt;syntax to capture identifiers of a fixed name like this is not ideal. If you're using Racket, it's better to use syntax parameters for this.For Scheme implementations that don't have syntax-case but have explicit renaming, you might write the macro this way:(define-syntax fi (er-macro-transformer (lambda (exp rename compare) `(,(rename 'if) p ,(cadr exp) ,(caddr exp)))))Some people find it simpler, but the onus is on you to rename everything that you're not intentionally capturing. In this case, we're explicitly renaming if; for most other macros that use lambda, let, etc., those all must be renamed. All the modification methods (add, set, remove, clear, etc.) are guarded by locks. That's how you have the correct write ordering. However, because of the copy-on-write, that means that each of the backing arrays is effectively immutable, which means that read-only operations don't need locking. (The field holding the backing array is volatile, so you still get the correct happens-before behaviour.) Without resorting to reflection, here's one way to do it:(define (modify-stats mods base) (define (get-fields obj) (map (lambda (getter) (getter obj)) (list stats-str stats-con stats-dex stats-int stats-wis stats-cha))) (apply stats (map + (get-fields mods) (get-fields base))))Loath as I am to suggest using macros to improve performance, this macro generates exactly the same code as the OP's first version:(require (for-syntax racket/syntax))(define modify-stats (let-syntax ((bump (lambda (stx) (define (bump-attr attr) (with-syntax ((getter (format-id attr "stats-~a" attr #:source attr))) #'(+ (getter mods) (getter base)))) (syntax-case stx () ((_ attr ...) (with-syntax (((bumped ...) (map bump-attr (syntax-&gt;list #'(attr ...))))) #'(lambda (mods base) (stats bumped ...)))))))) (bump str con dex int wis cha))) What Matt McNabb and Brian Bi said, but also, this is For Your Own Good™. You shouldn't cast the pointer, but should keep it as void*. That way, you won't accidentally use it as the target type without constructing it first (by using a placement new). e.g.,void* p = ::operator new(sizeof (MyClass));MyClass* pmc = new (p) MyClass; The problem isn't that the pointer wasn't initialised to null; in fact, the git_repository_init documentation does not say that it has to be initialised to anything at all. The problem is that it's an out parameter, and your function declaration didn't specify so.Here's some code I tested with (on Ubuntu 14.04) that worked for me:&gt; (require ffi/unsafe ffi/unsafe/define) &gt; (define-ffi-definer define-libgit (ffi-lib "libgit2"))&gt; (define _git_repository-ptr (_cpointer/null 'git_repository)) &gt; (define-libgit git_repository_init (_fun (repo : (_ptr o _git_repository-ptr)) _string _bool -&gt; (rc : _int) -&gt; (values repo rc)))&gt; (git_repository_init "/tmp/repo" #f)#&lt;cpointer:git_repository&gt;0See the documentation for _ptr on how to specify an out parameter. (You can use it to specify in/out parameters too, but those are generally rare.)(Of course, you'll eventually want to massage your FFI so that instead of returning two values like in my example, you'll instead simply check the return code for an error, raising a proper Racket error as appropriate, and return just the repository pointer if successful.) You can read about the R7RS process on the R7RS working group wiki. R7RS-large is listed under the "Working Group 2" section of the front page.In particular, look through the StandardDocket and ConsentDocket sections. Standard docket is for stuff that's under discussion (and eventual voting). Consent docket is for generally-uncontroversial stuff that's likely to get into R7RS-large without having to be voted on.There is no firm timeline that I am aware of (though I'm not part of the working group and do not speak for them). The standard docket is quite long, though, and they will have to process through most/all of it before you have anything that you can call R7RS-large. For a sneaky solution, you can use regular expressions to crop off everything before the dot:(define (fraction-only num) (string-&gt;number (regexp-replace #rx".*(\\..*)" (number-&gt;string num) "\\1"))) The most direct answer to your question is to use list-&gt;set.The most elegant answer (in my opinion) is to use for/set:(define (random-string-set items len) (for/set ((i (in-range items))) (build-string len (thunk* (integer-&gt;char (+ (char-&gt;integer #\a) (random 26))))))) If your Scheme implementation supports records (SRFI 9) or structs, it's often better to use that rather than just cons cells or vectors. (Though, records and structs usually use vectors behind the scenes, but that's an implementation detail.) Here's my implementation, with some bits replaced with &lt;???&gt; so you can fill them in yourself:(define (cube-root n) (define (helper lo hi) (define mid &lt;???&gt;) (define cube-mid &lt;???&gt;) (cond ((&lt; (abs (- cube-mid n)) &lt;???&gt;) mid) (&lt;???&gt; (helper lo mid)) (else (helper mid hi)))) (if (negative? n) (helper &lt;???&gt; &lt;???&gt;) (helper &lt;???&gt; &lt;???&gt;))) This is a known bug with Pango. Depending on whether you're using the 64-bit or 32-bit version of Racket, download the updated libraries:64-bit32-bitYou will need to grab all the libraries that contain pango in the name (libpango, libpangocairo, and libpangoft2) and overwrite the files in /Applications/Racket v6.1/lib. Okay, so in the examples, count('lo') counts all the characters that are either l or o, and count('lo', 'o') counts all the characters that are "either l or o" and "is o", that is, it's the same as count('o').In the third example, count('hello', '^l') means count characters that are "either h, e, l, l, or o" and "not l", that is, it's the same as count('heo').The intersection property is especially useful when used with complementary ranges. For example, count('j-t', '^lp') counts all the letters that are between j and t, except for l and p. Here is the long form:((1 . ((2 . ()) . ())) . (3 . (((4 . ()) . ()) . ())))Writing a function to print the long form is simple:If the input is a pair, print the following:"(" or #\(The car of the pair" . "The cdr of the pair")" or #\)Otherwise, print the item as is. cond clauses have the following form:(&lt;test&gt; &lt;result&gt; ...)In this case, the &lt;test&gt; is (cond [(even? x) (&lt; 20 x)] [else (even? x)]) and the &lt;result&gt; is (cond [(odd? x) 'day] [else 'night]).The overall code, if I read it correctly, is the same as(define (question x) (cond ((and (even? x) (&lt; 20 x)) 'night) (else 'goodbye))) Macro patterns are not evaluated. In particular, 'as is not a symbol. It is simply the list (quote as). ('as evaluates to a symbol, but it isn't by itself a symbol.) Thus, your macro is really the same as:(define-syntax for (syntax-rules () ((_ list (quote as) element body ...) (map (lambda (element) body ...) list))))where quote and as are pattern variables that can match anything whatsoever.As mentioned in uselpa's answer, the correct way to require the use of as exactly as written is to use the literal list:(define-syntax for (syntax-rules (as) ((_ list as element body ...) (map (lambda (element) body ...) list))))Or, if you're really sadistic and want to make the user quote the as, do this:(define-syntax for (syntax-rules (quote as) ((_ list 'as element body ...) (map (lambda (element) body ...) list))))(Yes, you can even change the literal list to be 'as instead of (quote as) as I have it, but that just makes your macro unreadable. Don't do that. :-P) Here's one possible solution (I have changed the output format a little to make the solution easier to code). append-map is defined in SRFI 1.(define (depths x) (cond ((list? x) (append-map (lambda (y) (map (lambda (z) (cons (car z) (+ (cdr z) 1))) (depths y))) x)) (else `((,x . 0)))))(I write the code as a seasoned Schemer would write it, not as someone would write a homework assignment. If that's your situation, try to understand what my code does, then reformulate it into something homework-acceptable.) Based on your previous question, you're going about it in a totally imperative way (and incorrect, of course, otherwise you wouldn't be asking this question), which is not how Scheme likes to work. Here's a functional (but not iterative) way to write the function:(define (f n) (if (&lt; n 4) n (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))) (* 4 (f (- n 4))))))Now, let's see how one might write this iteratively. First, let's see how an iterative Fibonacci function is written:(define (fib n) (let loop ((i 0) (a 0) (b 1)) (if (&gt;= i n) a (loop (+ i 1) b (+ a b)))))This does the same thing as the following JavaScript:fib = function (n) { return (function loop(i, a, b) { return i &gt;= n ? a : loop(i + 1, b, a + b); })(0, 0, 1);};Notice how i, a, and b actually get updated. We use tail-recursion to update the values, not by reassignment/mutation (i.e., not using = in JS or set! in Scheme). I recently wrote an answer about why tail-recursion is so important in Scheme.So, you would do something similar with your function:(define (f n) (let loop ((i 0) (a 0) (b 1) (c 2) (d 3)) (if (&gt;= i n) a (loop (+ i 1) b c d (+ d c c b b b a a a a))))) R7RS, section 6.2.5 (Syntax of numerical constants): There are two notations provided for non-real complex numbers: the rectangular notation a+bi, where a is the real part and b is the imaginary part; and the polar notation r@θ, where r is the magnitude and θ is the phase (angle) in radians. These are related by the equation a + b i = r cos θ + (r sin θ)i. All of a, b, r, and θ are real numbers.I can't find the equivalent text in R5RS, though. :-( Yes, rsync provides the --usermap and --groupmap options to allow you to customise how these are mapped at the remote end.For your particular use case, where all files are to be mapped to the same user/group combo, you can use the --chown option, which is a shortcut for the above. The second form is better, since there is less code duplication. '5' is a character. '53' is not a character.Or, to look at it in terms of strings, "5" is a string with one character in it ('5'), and "53" is a string with two characters in it ('5', '3'). The reason the if is inside the let is that the val you've created with the let is only valid within the let; once you exit the let, val doesn't exist any more.let is syntactic sugar for creating and instantly calling a lambda expression, so your let expression is basically the same as:((lambda (val) (if (numberp val) val (ask-number))) (read)) Like Rptx's comment says, find-divisor' is not a valid identifier, since ' is not a valid identifier character. If you really want to use it, you must escape the identifier, using something like |find-divisor'|.But it's better just to stick to characters that are valid for use with identifiers. Heck, just use a smart quote (e.g., find-divisor’) or prime (e.g., find-divisor′), if you want something that looks like find-divisor'. I won't vouch for the readability of any code that uses smart quotes, though. :-P You need to edit your .git/config file to update your origin remote, to no longer use port 8888.You can also use git remote set-url, but then you'd have to know the full correct URL. Your use of if is incorrect; only the last if actually does anything. (To help prevent these kinds of errors, Racket bans the use of one-armed if expressions.) Perhaps you would like to use cond instead?(define (det? xs) (cond ((in? 'a xs) #t) ((in? 'an xs) #t) ((in? 'the xs) #t) (else #f)))This macro-expands to the following ifs:(if (in? 'a xs) #t (if (in? 'an xs) #t (if (in? 'the xs) #t #f)))Notice how that's different from your series of if expressions. The whole point of LinkedHashMap is to have a separate linked list of nodes (only; the buckets themselves are not linked) to iterate through, so that you could have a predictable iteration order. So yes, LinkedHashMap can be faster to iterate through.To answer your question about "though both were implemented using the same buckets concept": HashMap has only a hash table, whereas a LinkedHashMap has both a hash table and a linked list; by-key lookups use the hash table and iterations use the linked list.The tradeoff with LinkedHashMap is that you have to keep an extra linked list (in addition to the hash table, which both HashMap and LinkedHashMap have), which is extra space usage. A function shape is basically what its inputs and outputs look like, in terms of the type parameters:A unary function takes one input and returns one output [T&rarr;R]A binary function takes two inputs and returns one output [(T,U)&rarr;R]A ternary function takes three inputs and returns one output [(T,U,V)&rarr;R]A supplier (also known as a nullary function) takes no input and returns one output [()&rarr;R]A consumer takes one input and doesn't return any output [T&rarr;()]A unary predicate takes one input and returns one output of boolean type [T&rarr;bool]A binary predicate takes two inputs and returns one output of boolean type [(T,U)&rarr;bool]A unary operator takes one input and returns one output of the same type [T&rarr;T]A binary operator takes two inputs of the same type and returns one output of the same type [(T,T)&rarr;T]There are many other shapes, but those are common ones. Okay, I finally got it working on my Ubuntu 14.04 system. I used --prefix=/usr/local so here's the Guile command I had to use:LD_LIBRARY_PATH=/usr/local/lib/guile-gnome-2 guile -L /usr/local/share/guile-gnome-2Since (from your comments) it appears you're using --prefix=/usr, you'd probably have to use:LD_LIBRARY_PATH=/usr/lib/guile-gnome-2 guile -L /usr/share/guile-gnome-2 For other Scheme implementations that use SRFI 41 streams, those streams also fully memoise all the materialised elements.In fact, in my Guile port of SRFI 41 (which has been in Guile since 2.0.9), the default printer for streams will print out all the elements so materialised (and nothing that isn't):scheme@(guile-user)&gt; ,use (srfi srfi-41)scheme@(guile-user)&gt; (define str (stream-from 0))scheme@(guile-user)&gt; (stream-ref str 4)$1 = 4scheme@(guile-user)&gt; str$2 = #&lt;stream ? ? ? ? 4 ...&gt;Any of the elements that aren't being printed out as ? or ... have already been memoised and won't be recomputed. (If you're curious about how to implement such a printer, here's the Guile version.) You didn't check whether word was null before you called strcpy on it.Also, your loop condition, sentence != NULL, will never be false. sentence isn't reassigned to anything that could be null. Perhaps you should be testing word != NULL? When you add a new property to Sub.prototype, you wouldn't want it to affect Base.prototype, would you? That would be pretty broken. :-)Using the new Base() approach means that any changes you make to Sub.prototype won't "leak through" to Base.prototype. Here's a generic version that allows lists, symbols, strings, and chars. Note that I did not write loops manually (since doing so is painful for me, when map is so readily available); you are welcome to do that yourself.This version uses SRFI 13 (for string-map) and SRFI 26 (for cut). (If you are writing the loops manually, and expanding the cut by hand, then you will be able to use this in plain Scheme.)(require srfi/13 srfi/26) ;; for Racket(define (caesar x shift) (cond ((char? x) (caesar-char x shift)) ((string? x) (caesar-string x shift)) ((symbol? x) (caesar-symbol x shift)) ((list? x) (caesar-list x shift)) (else (error "Unknown type" x))))(define (caesar-char ch shift) (if (char-alphabetic? ch) (let* ((ord (char-&gt;integer ch)) (lower (modulo ord 32)) (upper (- ord lower))) (integer-&gt;char (+ upper (modulo (+ lower shift) 26)))) ch))(define (caesar-string str shift) (string-map (cut caesar-char &lt;&gt; shift) str))(define (caesar-symbol sym shift) (string-&gt;symbol (caesar-string (symbol-&gt;string sym) shift)))(define (caesar-list lst shift) (map (cut caesar &lt;&gt; shift) lst))Example:&gt; (caesar '(T H E F O X) 4)'(X L I J S B)&gt; (caesar '(X L I J S B) 22)'(T H E F O X) Normally, insertions into a tree-based map (like std::map) requires a O(log n) lookup to find the correct insertion point. If the correct insertion point is adjacent to your provided hint, you can save the O(log n) lookup and the operation is O(1) instead.The usual use case for this is for inserting an item when no existing item for the given key exists. Then, rather than using .find() (which returns .end() if the item is not found), you use .lower_bound() to find the existing key (which returns an iterator to the insertion point, if the key isn't found). Then if the key doesn't exist, you use that iterator for hinted insertion. Well, inside your while loop, you never set total to a new value. So your loop will continue to test against the old value, and thus will never end. Oh, you're trying to rename the files? You can't use sed for that; that changes the contents of the files, without renaming them. Here's how I might do the renaming:for a in Dog_1*.csv; do mv "$a" "Dog_2${a#Dog_1}"done No, HashMaps do not evict elements automatically. If the buckets get too full, the buckets are expanded and all the elements are rehashed automatically. What you're seeing is called a named let. (I wrote a blog post about how named let works, if you're curious.) The code you have is exactly the same as:(define (binary-search value vector) (define (helper low high) (if (&lt; high low) #f (let ((middle (quotient (+ low high) 2))) (cond ((&gt; (vector-ref vector middle) value) (helper low (- middle 1))) ((&lt; (vector-ref vector middle) value) (helper (+ middle 1) high)) (else middle))))) (helper 0 (- (vector-length vector) 1)))In other words, it is tail-recursing, on helper rather than on binary-search. But tail recursion is happening.Some people think of tail-recursion like goto, but I don't consider that a helpful comparison. The only thing in common between the two is that you can implement loops with tail recursion, much like you can do with goto. But the similarities end there: tail-recursion is a special kind of recursion (where the current call frame is replaced with the tail call), but it's still recursion; goto jumps to an arbitrary point in the code, but it's a totally imperative operation with no relation to recursion. You can't use (same-parity a . (cdr b)) (since that would be read in as (same-parity a cdr b)), but you can use (apply same-parity a (cdr b)). That's how you "splat" a list into arguments.However, the "inner procedure" approach you had is generally more efficient, as there is less list copying going on. Edit: Here's an Intermediate Student solution (Leushenko's solution works in Intermediate Student too, serendipitously; they posted their solution before the OP's question change, too):(define (boolean-&gt;integer b) (sub1 (length (memv b '(#t #f)))))Note that in Intermediate Student, only memv has the standard Scheme behaviour. memq and member return booleans, for odd reasons.Previous answers below are for standard Scheme (with SRFI 1, in the case of the count solution).Óscar López's answer is correct, of course, but or and and are actually macros that eventually expand to if. So if those are unacceptable, we can exploit the read syntax instead:(define (boolean-&gt;integer b) (define (char-offset x) (- (char-&gt;integer x) (char-&gt;integer #\f))) (define out (open-output-string)) (write b out) (/ (char-offset (string-ref (get-output-string out) 1)) (char-offset #\t)))Other shorter, but cheating (in terms of actually doing branching behind the scenes) answers:(define (boolean-&gt;integer b) (count values (list b))Or, inspired by Leushenko's answer:(define (boolean-&gt;integer b) (case b ((#f) 0) ((#t) 1))) (merge-sort (lambda (a b) (define (get-age x) (cdr (assq 'age x))) (&gt; (get-age a) (get-age b))) (list *Mark* *Judith* *Elliot*)) That is wholly controlled by your DrRacket language settings. For example, if you chose Lazy Racket by using #lang lazy (and "Determine language from source"), the default output style is print. But if you chose Lazy Racket" from the Other Languages section of the languages menu, then the default output style is Constructor.As uselpa said, click Show Details to see the output style in effect.By the way, "Determine language from source" is almost always preferred over other ways to select a language. You could do it with a circular list. Like so:(defun sin-mac (x series n plus-minus) (cond ((zerop series) 0) (t (funcall (car plus-minus) (/ (power x n) (factorial n)) (sin-mac x (1- series) (+ n 2) (cdr plus-minus))))))(sin-mac x series 1 '#0=(+ - . #0#))Or even better, wrap up the initial arguments using labels:(defun sin-mac (x series) (labels ((recur (series n plus-minus) (cond ((zerop series) 0) (t (funcall (car plus-minus) (/ (power x n) (factorial n)) (recur (1- series) (+ n 2) (cdr plus-minus))))))) (recur series 1 '#0=(+ - . #0#)))) Your helper-2 function is wrong in two places:You should be using a two-armed if, so that it functions as an if/else.You have too many parentheses around the (car list).Here's the fixed version:(defun helper-2 (list) (if (null (first (rest list))) 0 (+ (distance (car list) (first (rest list))) (helper-2 (rest list))))) Please cut and paste the code in my previous answer and use it verbatim. Here, you've actually made some changes to the code to make it incorrect: instead of your original one-armed if, you've made it even worse, a zero-armed if.A correctly-formatted two-armed if expression looks like this (noting that expr1 and expr2 are supposed to be flush with (indented to the same level as) test):(if test expr1 expr2)This means that if test evaluates to a truthy value (anything other than nil), then expr1 is evaluated, and its value is the value of the if expression; otherwise expr2 is used instead. In the code snippet I had, test is (null (first (rest list))), expr1 is 0, and expr2 is (+ (distance (car list) (first (rest list))) (helper-2 (rest list))).The other nice thing about using my code snippet directly is that it's already formatted correctly for standard Lisp style, which makes it much more pleasant for other Lisp programmers to read. In the Java conventions, classes are named LikeThis. So for the remainder of this answer, I will refer to your class as FootballClub.First, you have to write a comparator class. The following snippet presumes you'll be putting the class inside another class. If it's going to be a top-level class, remove static from the first line.static class DescendingByPointsComparator implements Comparator&lt;FootballClub&gt; { @Override public int compare(FootballClub lhs, FootballClub rhs) { return Integer.compare(rhs.getPoints(), lhs.getPoints()); }}Here, I assumed that your FootballClub class has a getPoints() method, which returns an int, and that you're using Java 7 or newer.Now, to use it:Collections.sort(newClub, new DescendingByPointsComparator()); key returns zero all the time because you defined it that way. You had:(define (key w) keyhelper w 0)thus, it evaluates keyhelper (discarding its value), then w (discarding its value), then 0 (returning its value). So the answer is always 0.You should instead define it this way:(define (key w) (keyhelper w 0))Notice the extra parentheses.Also, the base-case value for keyhelper is wrong. It shouldn't be '(), it should be i. sds's answer is correct for Common Lisp. I'm more familiar with Scheme, so I decided to write a version for Scheme that adds support for partial application. Basically, it's a generalised composition where if you pass a function, it gets called, and if you pass a non-function, it gets wrapped with a function wrapper and gets called anyway. That's a mouthful, so I'll explain in the examples below.Here's the function (requires SRFI 26):(define (wrap x) (cut values x &lt;...&gt;))(define (call-compose . args) (cond ((null? args) (values)) ((procedure? (car args)) (call-with-values (cut apply call-compose (cdr args)) (car args))) (else (apply call-compose (wrap (car args)) (cdr args)))))Sure enough, if you call it using your test functions, you get:&gt; (call-compose (lambda (x) (+ x 1)) (lambda (x) (* x 2)) 1)3You can even do stuff like (which is like your example above except that the arguments to + and * are swapped):&gt; (call-compose + 1 * 2 1)3(This is the same as (+ 1 (* 2 1)).)The rest of this post goes off the deep end. It may not make sense if you're new to Scheme. :-)The key part of the magic is the function wrapper, wrap. This takes any value and returns a function that takes any number of arguments, and returns the value with those arguments added (as multiple values). Example:&gt; (define wrap1 (wrap 1))&gt; (wrap1 2 3 4)1234So with an expression like (call-compose + 1 * 2 1), that is the same as (call-compose + (wrap 1) * (wrap 2) (wrap 1)), which translates to (mv + (mv (wrap 1) (mv * (mv (wrap 2) (mv (wrap 1)))))) (where mv is a macro that provides the same functionality as Common Lisp's multiple-value-call).You can use wrap with function objects too. This allows you to pass function objects to higher-order functions. e.g.,&gt; (call-compose map (wrap +) '(1 2 3) '(4 5 6))(5 7 9)For even more fun, I've also extended compose to have the same behaviour:(define (compose . args) (cond ((null? args) values) ((procedure? (car args)) (lambda xs (call-with-values (cut apply (apply compose (cdr args)) xs) (car args)))) (else (apply compose (wrap (car args)) (cdr args))))) Most Scheme implementations provide records via SRFI 9. So in your case, you can define a recipe record type like so:(define-record-type &lt;recipe&gt; (recipe salt sauce) recipe? (salt recipe-salt) (sauce recipe-sauce))Then you can use it like this:&gt; (define salty-ketchup (recipe 5 "ketchup"))&gt; (recipe-salt salty-ketchup)5&gt; (recipe-sauce salty-ketchup)"ketchup"If you're using Racket, there's an even simpler syntax for defining structs.(struct recipe (salt sauce)) The list (x y z . rest) does not have a dot symbol in it. It's actually an improper list, made this way: (cons 'x (cons 'y (cons 'z 'rest))).To test for an improper list, you can do something like this:(define (improper-list? x) (cond ((null? x) #f) ((pair? x) (improper-list? (cdr x))) (else #t))) Most answers here address this question in very dry, technical terms. I'd like to address this in terms that normal human beings can understand.Imagine that you are trying to slice up pizzas. You have a robotic pizza cutter that can cut pizza slices exactly in half. It can halve a whole pizza, or it can halve an existing slice, but in any case, the halving is always exact.That pizza cutter has very fine movements, and if you start with a whole pizza, then halve that, and continue halving the smallest slice each time, you can do the halving 53 times before the slice is too small for even its high-precision abilities. At that point, you can no longer halve that very thin slice, but must either include or exclude it as is.Now, how would you piece all the slices in such a way that would add up to one-tenth (0.1) or one-fifth (0.2) of a pizza? Really think about it, and try working it out. You can even try to use a real pizza, if you have a mythical precision pizza cutter at hand. :-)Most experienced programmers, of course, know the real answer, which is that there is no way to piece together an exact tenth or fifth of the pizza using those slices, no matter how finely you slice them. You can do a pretty good approximation, and if you add up the approximation of 0.1 with the approximation of 0.2, you get a pretty good approximation of 0.3, but it's still just that, an approximation.For double-precision numbers (which is the precision that allows you to halve your pizza 53 times), the numbers immediately less and greater than 0.1 are 0.09999999999999999167332731531132594682276248931884765625 and 0.1000000000000000055511151231257827021181583404541015625. The latter is quite a bit closer to 0.1 than the former, so a numeric parser will, given an input of 0.1, favour the latter.(The difference between those two numbers is the "smallest slice" that we must decide to either include, which introduces an upward bias, or exclude, which introduces a downward bias. The technical term for that smallest slice is an ulp.)In the case of 0.2, the numbers are all the same, just scaled up by a factor of 2. Again, we favour the value that's slightly higher than 0.2.Notice that in both cases, the approximations for 0.1 and 0.2 have a slight upward bias. If we add enough of these biases in, they will push the number further and further away from what we want, and in fact, in the case of 0.1 + 0.2, the bias is high enough that the resulting number is no longer the closest number to 0.3.In particular, 0.1 + 0.2 is really 0.1000000000000000055511151231257827021181583404541015625 + 0.200000000000000011102230246251565404236316680908203125 = 0.3000000000000000444089209850062616169452667236328125, whereas the number closest to 0.3 is actually 0.299999999999999988897769753748434595763683319091796875.P.S. Some programming languages also provide pizza cutters that can split slices into exact tenths. Although such pizza cutters are uncommon, if you do have access to one, you should use it when it's important to be able to get exactly one-tenth or one-fifth of a slice.(Originally posted on Quora.) {{ignored} ignored} is Racket's printer output for the mutable version of ((ignored) ignored). Let's use the normal cons cells version to answer this.With ((ignored) ignored), the car of that is (ignored) and not ignored, so your comparison would indeed be false. But you can get ignored two ways: 1. using caar ((car (car x))), or 2. using cadr ((car (cdr x))). It releases the current reference. Other references are not affected. You need to make your default_hasher use const for its parameter, since HashFunction specified so. Besides, it's the sensible thing to do, in the name of const-correctness. Your definition of top-votes-for is wrong. Here's a skeletal version of a corrected solution:(define (top-votes-for cand alov) (cond ((empty? alov) 0) ((string=? (vote-choice1 &lt;???&gt;) cand) (add1 &lt;???&gt;)) (else (top-votes-for cand (rest alov)))))I've actually given you most of a solution. The rest of it should be easy to figure out, if you understand the code above. The two datums ((1 . 2) 3 . 4) and ((1 . 2) . (3 . 4)) are exactly the same. So don't worry, you've got it right. You can't use flet for recursive functions, you have to use labels instead. Here's a skeletal solution:(define (xor . vals) (define (inner vals) (cond ((null? vals) &lt;???&gt;) ((null? (cdr vals)) &lt;???&gt;) ;; optional optimisation ((car vals) (not &lt;???&gt;)) (else &lt;???&gt;))) (inner vals))Figure out what all the &lt;???&gt; are. At the Java level, there are two ways to list directories. You can use File.list or File.listFiles, or you can use Files.newDirectoryStream.At the Kawa level, having briefly grepped through the source, it doesn't seem to use any of those interfaces. So it doesn't look like there's a built-in way to list directories in Kawa. You would need to use Kawa's Java method invocation features to invoke one of the above interfaces. template &lt;class M&gt;void add_maps(M const&amp; source, M&amp; dest){ for (auto const&amp; entry : source) dest[entry.first] += entry.second;} Any time you want N random numbers from a set without duplication, consider shuffling that set and then picking the first N elements. Then you don't have to keep track of which items have already been seen. The expression 10 ? 0 ? 5 : 11 : 12 is parsed this way: 10 ? (0 ? 5 : 11) : 12. So this means that in the first test, since 10 is true, it will evaluate 0 ? 5 : 11, which evaluates to 11 since 0 is false. It sounds like there are two filters that turned it that way:lay's => lay&amp;apos;s (this is turning the &apos; into its XML entity, &amp;apos;). Other entities include &amp;amp; for &amp;, &amp;lt; for &lt;, &amp;gt; for &gt;, and &amp;quot; for &quot;.stripping out all non-alphabetic characters, leaving you with layaposs.I've once had a site turn my last name into Jesteroemminusy. Seriously, no kidding. Basically, the hyphen in my last name got turned into "oemminus", and then the rest of my last name, after the Y, got truncated. Here's a version for Racket (sorry, I'm not a Common Lisper, so can't help there):(define (count-alist alist) (define ht (for/fold ((ht (hash))) ((ass (in-list alist))) (hash-update ht (cdr ass) (curry + (car ass)) 0))) (for/list (((key val) (in-hash ht))) (cons val key)))Let's break the problem down in English:To collect up the actual counts of your "three numbers", build a hash table using the "three numbers" as the key, and 0 as the default value.For each item in your incoming list, you'd add the count to the value, then update the hash table with that new value.Then iterate through your hash table to build your result list. Racket has many languages. Which language are you using? If you're using, say, Beginning Student, it does not have any support for any higher-order functions, since beginners are not expected to know about those yet.The standard Racket language (#lang racket) does have map built-in, of course. In fact, Intermediate Student and Advanced Student do, too. '(x y z) is a list containing three symbols, x, y, and z. It's the same as (list 'x 'y 'z).What you need to use, instead, is (list x y z).The reason using '(4 10 2) (for example) works is that numbers are "self-evaluating". That means (list '4 '10 '2) is the same as (list 4 10 2). Here's a definition of daily-to that seems to make sense off the top of my head. It is not tested.(define (daily-to city alof) (map flight-to (filter (lambda (flight) (and (string=? city (flight-from flight)) (string=? "daily" (flight-frequency flight)))) alof))) -1 is a sentinel value. That is, it's an invalid value for your program's purpose, and in particular, it's not the value of anything returned by (int) (Math.random() * 101) (which, BTW, generates a number between 0 and 100, not 1 and 100).One way to avoid the "double duty" of guess is to change the loop to unconditionally loop, and then use break to break out of the loop if the guess is correct. Like so:while (true) { System.out.print("\nEnter your guess: "); int guess = input.nextInt(); if (guess == number) { System.out.println("you are correct, the number is " + number); break; } else if (guess &gt; number) { System.out.println("your guess is too high"); } else { System.out.println("your guess is too low"); }}(Notice that I've added braces to your if block so that there can be multiple statements in the branches.) This is probably the cleanest way to do it. In a vast majority of cases where one encounters a "not a procedure" error, it's usually caused by having too many parentheses, or trying to use parentheses for "grouping" (you have to use begin for that instead). In your case, your code should be:(if (zero? (check-ans quest_num 1)) (begin (send frame-ops-correct center 'both) (send frame-ops-correct show #t)) (begin (send frame-ops-wrong center 'both) (send frame-ops-wrong show #t)))Notice how I added begin to both branches of the if. Also, don't use eq? with numbers; use eqv? instead. But since we're comparing with zero, I changed your code to use zero? instead. Your base case should be to check for an empty list. An empty list still tests true for list?. So the first condition should instead be (null? alist). The short answer is that the node-jsmin2 module has a bug in it, introduced since revision 7d5f486f46b453d738057e97060e4805846bf4af.In that revision, fputs was modified to call stream.write(str) instead of stream(str), and stdout was modified to be an object containing write and writeFromIndex methods—but stderr was not similarly modified. (That commit, BTW, means that the defaults for stdout and stderr, namely console.log and console.error, are no longer suitable. This has been alluded to in the TODO.md change in that commit.)Here's a quick "fix" (I contemplated sending a pull request, but decided against it):diff --git a/lib/jsmin.js b/lib/jsmin.jsindex 439957b..c6f9331 100644--- a/lib/jsmin.js+++ b/lib/jsmin.js@@ -68,9 +68,11 @@ function jsmin(input) { output += char; } },- 'stderr': function (err) {- // Add the error to output- options.error += err;+ 'stderr': {+ 'write': function (err) {+ // Add the error to output+ options.error += err;+ } }, 'exit': function (code) { // Throw the collective error Jens's answer is correct, that / is short for "with". This has been enshrined in the R6RS and R7RS Scheme standards, where call/cc is the short name for call-with-current-continuation. (R5RS mentions it, but did not formally standardise the name the way R6RS and R7RS did.) It is an infinite loop. However, in most Scheme implementations, top-level forms are evaluated in prompts.If you put your expressions inside a (let () ...), say, you'll definitely see the infinite loop in effect. To implement a reverse function, you need to use an accumulator. Here is how you might implement this (in this case, tail is the accumulator):(defun revappend (list tail) (cond ((null list) tail) (t (revappend (cdr list) (cons (car list) tail)))))Then, implement reverse in terms of revappend:(defun reverse (list) (revappend list nil)) I haven't read HtDP, however, I think they're using and instead of begin because some of the student languages do not provide begin.In Scheme, the only false value is #f, and in particular, many "side-effecting" procedures return "an unspecified value"¹ which is invariably a true value, so you can effectively sequence them using and. This contrasts with Common Lisp, where side-effecting procedures usually return nil, which is a false value.¹ Most Scheme implementations will return the same kind of unspecified value consistently: in Racket, it uses (void), and in most other implementations that don't have (void), it's whatever (cond) returns. You technically "can", by introducing an accumulator that acts as a stack. Your function would only be done when the stack is empty.However, this has the same memory usage requirements as using the function call stack (i.e., non-tail recursion), so usually you don't gain anything by doing that. The (k k1) would return k1 as the return value of the outer call/cc. Then when you invoke k1 (as part of (... (lambda (x) 5))), that returns 5 as the return value of the inner call/cc, which is then returned (as a normal return this time) as the return value of the outer call/cc.Sorry, that was quite a mouthful. :-) A continuation is a procedure (in the sense that it's callable and returns true for procedure?), albeit a special one that does not return to the caller of the continuation.The value(s) you call the continuation with will become the return value(s) of the call/cc invocation that created it.Example:&gt; (define $k #f)&gt; (call-with-values (lambda () (call/cc (lambda (k) (set! $k k)))) (case-lambda (() "Zero values") ((x) "One value") ((x y) "Two values") ((x y z) "Three values")))"One value"&gt; (procedure? $k)#t&gt; ($k)"Zero values"&gt; ($k 1)"One value"&gt; ($k 1 2)"Two values"&gt; ($k 1 2 3)"Three values"&gt; ($k 1 2 3 4)#&lt;case-lambda-procedure&gt;: arity mismatch; the expected number of arguments does not match the given number Guava's Ordering#reverse method has never been final in any Guava release. It's only been final in a very, very old version of Google Collections: https://code.google.com/p/google-collections/source/diff?r=98&amp;old=92&amp;path=/trunk/src/com/google/common/collect/Ordering.javaSo you should look for google-collect*.jar in your classpath and get rid of it. It really has no purpose for existence any more. Here's how I'd write test-and-do:(defun test-and-do (lst pred fun) (mapcar (lambda (x) (if (funcall pred x) (funcall fun x) x)) lst))find-and-do can be implemented in terms of test-and-do:(defun find-and-do (lst val fun) (test-and-do lst (lambda (x) (equal val x)) fun)) for-each evaluates the given function on the list elements left-to-right, and discards the return value of the function. It's ideal for doing side-effecting things to each element of the list.map evaluates the given function on the list elements in no specific order (though most implementations will use either right-to-left or left-to-right), and saves the return value of the function to return to the caller. It's ideal for doing pure-functional processing on each element of the list.If the return value of map is not going to get used, it is better to use for-each instead. That way, it doesn't have to bother collecting the return values from the function calls.(Aside: in Clojure, the return value of map is a lazy sequence, which means the given function is only invoked for the elements being materialised.)Technical implementation details. A simplified one-list version of for-each is usually implemented like this:(define (for-each func lst) (let loop ((rest lst)) (unless (null? rest) (func (car rest)) (loop (cdr rest)))))Really straightforward, and guarantees left-to-right order. Contrast with a simplified one-list version of map:(define (map func lst) (let recur ((rest lst)) (if (null? rest) '() (cons (func (car rest)) (recur (cdr rest))))))In Scheme, the evaluation order for function arguments is not specified. So for an expression like (foo (bar) (baz) (qux)), the calls to bar, baz, and qux can occur in any order, but they will all complete before foo is called.In this case, the (func (car rest)) can happen first, or it may happen after (recur (cdr rest)). It's not guaranteed either way. This is why people say that map does not guarantee an evaluation order. Probably because you're using a restricted sublanguage that offers only limited functionality. What Scheme implementation are you using, and are you in some kind of restricted module that doesn't import the standard Scheme procedures?modulo is indeed a standard part of Scheme and is included in any standard Scheme system. (It is, however, not a "keyword", in either the "reserved word" sense (Scheme has no reserved words), nor the named parameters sense (where keywords look like #:this).) You are indeed passing the arguments wrong. You need to pass each argument as a string in the command array. e.g.,command = new String[arguments.length + 2];command[0] = "C:\\Python27\\python.exe";command[1] = "C:\\xampp\\htdocs\\development\\" + fileName;System.arraycopy(arguments, 0, command, 2, arguments.length); That seems to be a keyboard configuration issue at your end, so I can't help with that. However, I can say that in Racket, [] and {} are treated the same as (), so you can just use round brackets throughout. arrayYear[i] = 30 - 0.45 * i;Or, for more accuracy:arrayYear[i] = 30 - 45 * i / 100.0; The Racket definition of cond is in collects/racket/private/cond.rkt. It's written using low-level syntax object operations, not using either syntax-rules nor syntax-case, so unless you know syntax objects very well, it won't be readable to you.As an alternative starting place for your customised cond, one definition of cond is the reference implementation given in SRFI 61. It is succinct and is one of the best implementations of cond I've seen:(define-syntax cond (syntax-rules (=&gt; else) ((cond (else else1 else2 ...)) ;; The (if #t (begin ...)) wrapper ensures that there may be no ;; internal definitions in the body of the clause. R5RS mandates ;; this in text (by referring to each subform of the clauses as ;; &lt;expression&gt;) but not in its reference implementation of cond, ;; which just expands to (begin ...) with no (if #t ...) wrapper. (if #t (begin else1 else2 ...))) ((cond (test =&gt; receiver) more-clause ...) (let ((t test)) (cond/maybe-more t (receiver t) more-clause ...))) ((cond (generator guard =&gt; receiver) more-clause ...) (call-with-values (lambda () generator) (lambda t (cond/maybe-more (apply guard t) (apply receiver t) more-clause ...)))) ((cond (test) more-clause ...) (let ((t test)) (cond/maybe-more t t more-clause ...))) ((cond (test body1 body2 ...) more-clause ...) (cond/maybe-more test (begin body1 body2 ...) more-clause ...))))(define-syntax cond/maybe-more (syntax-rules () ((cond/maybe-more test consequent) (if test consequent)) ((cond/maybe-more test consequent clause ...) (if test consequent (cond clause ...)))))(As molbdnilo says, though, please call your version something other than cond to avoid confusion.) When you have two statements in a single line, you need to put a ; between the two. Thus: puts "The item is #{item}"; puts item + 1. A decent compiler will optimise the first version into the second one.Without optimisation, the first version contains a branch (Jxx instruction in x86 assembly), which is slow:cmp ecx, 5 ; assume ecx contains the value of xjle 1f ; assume x is signedmov eax, 1ret1:xor eax, eaxretThe second version translates to a SETxx instruction in x86, which does not involve a branch, and would be faster:xor eax, eaxcmp ecx, 5setg alret As Brian Goetz (project lead for Java lambdas) says, "Lambda expressions have no intrinsic type" (which applies to method references too). This is why you need to cast (or assign) to type Function before its methods become available.The reason Eclipse shows different error messages from the JDK compiler (javac) is that Eclipse uses its own Java compiler, called ecj, which is a totally different program from javac. This is, BTW, why Eclipse can run on the JRE, without needing a full JDK install. Floating-point numbers are not exact, and comparisons using == will often fail. You should instead take the absolute difference between the two numbers and make sure it's very small:private static boolean closeEnough(double a, double b) { return Math.abs(a - b) &lt; 0x1p-32;}You can use a different threshold from 0x1p-32 if you want. Specs are tests, which sit in the spec directory. Application code lives in the app directory, and does not use anything in spec. So you can safely remove that class without affecting the application. Your Test1.reflect uses a different instance of TestJava from the secret in main. (Notice there are two places where new TestJava() is called.) So calling secret.increment() won't affect the instance of TestJava used by Test1.reflect.But if you did this:public class Test1 { public void reflect(TestJava instance) throws IllegalAccessException, InvocationTargetException { // Everything in your original method minus the first line } // ...}and then used the following in main:secret.increment();newHacker.reflect(secret);then things should behave as you expect. Putting an element into a new array does not clone that element. So any changes to that element will still affect the original. You have to call cloneNode on the element in order to clone it. Do that at the time of adding to the array:listOfRelatedLines.add((Element) elOrderLine.cloneNode(true)); Non-static methods have the receiver (this) object as an implicit first argument. Therefore, Class::nonStaticMethod has one more argument than you might expect.Java Language Specification Section 15.13.1, Compile-Time Declaration of a Method Reference:  Second, given a targeted function type with n parameters, a set of potentially applicable methods is identified:  If the method reference expression has the form ReferenceType :: [TypeArguments] Identifier, the potentially applicable methods are the member methods of the type to search that have an appropriate name (given by Identifier), accessibility, arity (n or n-1), and type argument arity (derived from [TypeArguments]), as specified in §15.12.2.1. Two different arities, n and n-1, are considered, to account for the possibility that this form refers to either a static method or an instance method.   Scheme macros are hygienic. The genv you defined in get-global-environment is not the same as the genv in your _def-initial (which uses whatever genv was there when _def-initial was defined, which in this case would be the top-level one, which as you pointed out does not exist).In order to make your macro work, you must adapt _fill-global-env, _def-primitive, and _def-initial to all take a genv parameter, so that _def-initial uses that genv instead of the top-level one. You are correct that it should be true—iff the two strings are the same. But they're not. One is NDT_NT and the other is NDC_NT. Lists are not arrays, in that lists are not random-access. The Scheme analogue for arrays is vectors.When you create a vector, you state upfront how large your vector will be (explicitly as an argument to make-vector, or implicitly based on how many arguments you call vector with, or implicitly, if you're using list-&gt;vector, based on the size of the list you're copying from). You can then read (vector-ref) and write (vector-set!) individual elements based on index.Vectors cannot be resized; if you need a new size, you need to create a new vector and copy elements to it using vector-copy (if you're creating the new vector at the same time) or vector-copy! (if you're copying into a vector you created yourself).In contrast, lists are simply zero or more cons cells that are chained together in a specific way, eventually pointing to the empty list. In particular, the empty list () is a list, and any cons cell where the cdr points to a list is a list. Because you have to chase down cons cells, there is no random access: to reach the nth element of a list, it takes time proportional to n (list indexing is O(n)).In contrast, it takes roughly the same amount of time (if we ignore things like cache locality) to access any element of a vector (vector indexing is O(1)). R6RS has exact-integer-sqrt. It returns two values, the square root and the remainder. You can discard the second value if you want.Implementations are allowed (but not required) to consider (* 0 x) (multiplying anything by an exact zero) to be exact zero for any x. See the R6RS description of the * procedure. Your function shouldn't even do any string copying. It should just do an in-place replacement:void removeSpace(char* s){ for (char* s2 = s; *s2; ++s2) { if (*s2 != ' ') *s++ = *s2; } *s = 0;}Even terser:void removeSpace(char* s){ char* s2 = s; do { if (*s2 != ' ') *s++ = *s2; } while (*s2++);} The first one is a procedure that returns a procedure. The second one is a procedure that returns the number 2.In particular, the first one is equivalent to the following:(define procedure1 (lambda () (lambda () 2))) If you maintain start and end pointers, you can still use the CPU stack. Yes, you do have to move items from time to time, but not every single time: only when you hit the top of the stack. Because you're maintaining start and end pointers, you don't have to shift by one every time, but can shift by, say, 16, and then you can insert 15 more items before having to shift again.For bonus points, make the shift quantity exponential (you'd have to use a third register for keeping the shift quantity), so that the first time you shift 16, the next time you shift 32, etc. Here's a method that totally uses higher-order functions (foldr, append-map, and map; now also with compose1, curry, and curryr):(define (cartesian-product . lists) (foldr (lambda (a b) (append-map (compose1 (curryr map b) (curry cons)) a)) '(()) lists))Pardon the terrible parameter names. One day I'll come up with something good. :-) Do not do non-UI work in the EDT. Always do stuff like reading from sockets, etc., from a separate thread. There are two ways to do this:Have the non-EDT thread notify the EDT of updates, when they come in, using either SwingUtilities.invokeLater or SwingUtilities.invokeAndWait. This is probably the best way to go for socket-polling.Launch the non-EDT activity using SwingWorker. I personally consider SwingWorker to only be appropriate in response to some action by the user. It actually does correspond to a daylight savings change. In Morocco, daylight savings is suspended during Ramadan. See http://www.timeanddate.com/news/time/egypt-morocco-dst-ramadan-2014.html for more information.The timezone data entry for 2014 is as follows:Rule Morocco 2014 only - Jun 28 3:00 0 -Rule Morocco 2014 only - Aug 2 2:00 1:00 S In this case, it means the same as(cond (result (second result)) (else ...))In general, a cond clause of(foo =&gt; bar)means that if foo evaluates to a truthy value, then its value is saved, and passed as an argument to bar (which should evaluate to a procedure that takes one argument). A full solution to both issues could be done using Perl:$ perl -pe 's/\n//;s/^[\s\d]+/\n/a;' file一项庄严肃穆富历史意义的仪式标志中华人民共和国对香港恢复行使主权。英国皇储威尔斯亲王与中华人民共和国国家主席江泽民均在仪式上致辞，仪式於六月三十日午夜至七月一日凌晨举行，并向全世界直播。仪式在香港会议展览中心新翼大厅举行，约四千名嘉宾出席，包括来自四十多个国家和国际性组织的外交部长和知名人士，以及约四百名各国传媒代表。but with two caveats:A blank line is inserted into the beginning.The final newline is removed.If you can live with those two limitations, then the solution above will work. The way it works is as follows:First, it remove the newline from the end of the line.Then, if the line begins with a sequence of spaces and digits (the /a modifier makes the \d and \s match ASCII digits and spaces only), replace that with a newline. (build-list 5 (lambda (i) (make-string (add1 i) #\a))) Sure. Here's an adapted version of your code:(define (split ls) (if (or (null? ls) (null? (cdr ls))) (list ls '()) (let ((next (split (cddr ls)))) (list (cons (car ls) (car next)) (cons (cadr ls) (cadr next)))))) Here's how you do it without pointers (live demo):#include "point.h"#include "vector.h"#include &lt;iostream&gt;int main(){ Point p(3, 3); Vector v(2, -4); Point p2(p.X - v.X, p.Y - v.Y); std::cout &lt;&lt; "Point p: (" &lt;&lt; p.X &lt;&lt; "," &lt;&lt; p.Y &lt;&lt; ")\n"; std::cout &lt;&lt; "Vector v: (" &lt;&lt; v.X &lt;&lt; "," &lt;&lt; v.Y &lt;&lt; ")\n"; std::cout &lt;&lt; "Point p2: (" &lt;&lt; p2.X &lt;&lt; "," &lt;&lt; p2.Y &lt;&lt; ")\n";}Also, you can actually create custom output formatters for your types by defining operator&lt;&lt;, to simply printing (live demo):std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Point const&amp; p){ return os &lt;&lt; '(' &lt;&lt; p.X &lt;&lt; ',' &lt;&lt; p.Y &lt;&lt; ')';}std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Vector const&amp; v){ return os &lt;&lt; '(' &lt;&lt; v.X &lt;&lt; ',' &lt;&lt; v.Y &lt;&lt; ')';}int main() { Point p(3, 3); Vector v(2, -4); Point p2(p.X - v.X, p.Y - v.Y); std::cout &lt;&lt; "Point p: " &lt;&lt; p &lt;&lt; '\n'; std::cout &lt;&lt; "Vector v: " &lt;&lt; v &lt;&lt; '\n'; std::cout &lt;&lt; "Point p2: " &lt;&lt; p2 &lt;&lt; '\n';} The reason you're seeing what you're seeing is that loop and jecxz† are both short jump instructions. The C loop you had does not use loop; it uses jcc for branching (which has both short and near forms).You can still use full assembly if you want. You just can't use loop: mov ecx, cnt jmp ATESTAL1: /* fun happens here */ATEST: dec ecx jns AL1In technical terms‡:Short jumps use a signed 1-byte offset (from the next instruction), which provides a range of [-128, 128) (as you've already figured out).Near jumps use a signed 2-byte (in 16-bit mode) or 4-byte (in 32-bit and 64-bit modes) offset, which provide a range of [-32768, 32768) and [-2147483648, 2147483648), respectively.In 16-bit and 32-bit modes, this means that near jumps can access any location in the current code segment.† Note that jecxz is not technically a jcc instruction; it's outside the jcc opcode range, it doesn't check flags, and it has no corresponding cmovcc or setcc form.‡ For completeness, jmp (but not jcc) also support near indirect jumps, far jumps, and far indirect jumps. SELECT l.name FROM students l JOIN students r ON l.name = r.name WHERE l.language = 'java' AND r.language = 'c'; Instead of:LPBYTE installLocation;LPDWORD bufferSize = (unsigned long*)8192;it should really be:BYTE installLocation[8192];DWORD bufferSize = sizeof installLocation;then bufferSize should be changed to &amp;bufferSize in the RegQueryValueEx call.Further, the returned data is not guaranteed to be null-terminated. So you need to deal with that too:if (bufferSize &amp;&amp; !installLocation[bufferSize - 1]) --bufferSize;return string(installLocation, bufferSize); Executable files contain a number of sections. Each of these sections is aligned to, if I remember correctly, 512 bytes. The result of (-circle- 3) is the same as this:(lambda (method-name) (cond ((eq? method-name 'area) area) (else (error '-circle- "Method not found: ~s" method-name))))with area set to (lambda () (* pi 3 3)). That means that the return value of ((-circle- 3) 'area) is also (lambda () (* pi 3 3)).A call to (call (-circle- 3) 'area) has the same effect as (apply ((-circle- 3) 'area) '()) (since the rest arguments, args, is empty), which is the same as evaluating (((-circle- 3) 'area)), which we know is the same as ((lambda () (* pi 3 3))), which evaluates to (* pi 3 3).Note: (call (-circle- 3) 'area) is not the same as (call -circle- 3 'area). The correct solution is to use cond's =&gt; form:(cond ((regexp-match #rx"start" "startofstring") =&gt; (lambda (match) (set! lst (cons match lst)))) ...)(Note that I renamed your list variable to lst to avoid shadowing the built-in list procedure.)If you have many patterns, and the same action for multiple patterns, you should extract out the common code into a separate procedure:(define (push! match) (set! lst (cons match lst)))(cond ((regexp-match #rx"start" str) =&gt; push!) ((regexp-match #rx"blah" str) =&gt; push!) ...)While the above works, I want to suggest that you don't use set!, since it's not very functional. The standard Scheme way to build up a list from a loop is to use a named let, like so:(let loop ((result '()) (strs strs)) (define (next match) (loop (cons match result) (cdr strs))) (if (null? strs) result (let ((str (car strs))) (cond ((regexp-match #rx"start" str) =&gt; next) ...))) You actually need to specify "/path/to/executable" twice. The first one is the program to execute, and the second one is the argv[0] for the new process. No. (CoffeeScript works the same way, too.) This is a feature, not a bug. Explicitly return undefined if you really care. Because of this code:(vector (vector-set! (level-entities current) 0 (random-posn 1)) (vector-set! (level-entities current) 1 (random-posn 1)) (vector-set! (level-entities current) 2 (random-posn 1)) (vector-set! (level-entities current) 3 (make-posn (posn-x (vector-ref (level-entities current) 3)) (- (posn-y (vector-ref (level-entities current) 3)) GRAVITY))))That is not the correct way to initialise a vector. What you probably wanted was this:(vector (random-posn 1) (random-posn 1) (random-posn 1) (let ((current-posn (vector-ref (level-entities current) 3))) (make-posn (posn-x current-posn) (- (posn-y current-posn) GRAVITY)))) There are two ways your function can fall off the end without returning:When last&gt;=first &amp;&amp; in_special(first) is true.When is_function(seg[first]) is true. Yeah, your function has a slight issue with it: :-)You're recursing into threes instead of cubes.You're trying to call cons with one argument (it requires two).You're not changing the value of lst in the recursion, so, since the base case returns lst, you'll always get the initial lst value you passed in.Here's a fixed version:(defun cubes (dec lst) (if (zerop dec) lst (cubes (1- dec) (cons (* dec dec dec) lst)))) I think you're overthinking it. Here's my implementation of expand-let:(define (expand-let form) (define bindings (car form)) `((lambda ,(map car bindings) ,@(cdr form)) ,@(map cadr bindings))) You use a loop, of course. ;-) Here's my implementation:(define (curry-n f n) (let loop ((n n) (args '())) (if (zero? n) (apply f (reverse args)) (lambda (x) (loop (- n 1) (cons x args))))))Here's a more general implementation that allows the curried functions to take any number of arguments, not just 1:(define (curry-n f n) (let loop ((n n) (args '())) (if (zero? n) (apply f (reverse args)) (lambda xs (let retry ((rem (- n (length xs))) (xs xs)) (if (negative? rem) (retry 0 (take xs n)) (loop rem (append-reverse xs args))))))))(take and append-reverse are from SRFI 1.) Here's a pretty simple implementation:(define (signum n) (or (and (zero? n) 0) (and (positive? n) 1) (and (negative? n) -1)))Edit: I wrote my answer before I read Sylwester's post, but you should definitely read it for the theory of how this construction works. list-ref is easy to write as a tail-recursive function:(define (list-ref lst n) (if (zero? n) (car lst) (list-ref (cdr lst) (- n 1))))Update: Your solution must follow the template, you say? Here's a hacky way to do it, but unlike Óscar's solution, it does not use set!. But it's still ugly:(define list-ref (lambda (ls n) (letrec ((nth-cdr (lambda (n) (if (number? n) (nth-cdr (cons ls n)) (let ((ls (car n)) (n (cdr n))) (if (zero? n) ls (nth-cdr (cons (cdr ls) (- n 1))))))))) (car (nth-cdr n))))) Here's a different, hopefully less-tricky, implementation. (It's O(n), but it requires both of the incoming lists to be sorted; in comparison, Óscar's implementation does not required sorted lists, but it's O(n²).)(define (diff lhs rhs) (let loop ((result '()) (lhs lhs) (rhs rhs)) (cond ((null? lhs) (append-reverse result rhs)) ((null? rhs) (append-reverse result lhs)) (else (let ((a (car lhs)) (b (car rhs))) (cond ((&lt; a b) (loop (cons a result) (cdr lhs) rhs)) ((&lt; b a) (loop (cons b result) lhs (cdr rhs))) (else (loop result (cdr lhs) (cdr rhs)))))))))Example:&gt; (diff '(3 6 7) '(1 4 6 7))(1 3 4)append-reverse is from SRFI 1, so in Racket you have to (require srfi/1). It's best to use (read) to read numbers, assuming you can rely on sane input (i.e., if it's actually going to be numbers and not garbage or, worse, massive S-expressions). Thus your code would be:(displayln (+ (read) (read))) Racket provides comprehensions, which really should be the thing to use.(define (port-&gt;list port) (for/list ((c (in-port read-char port))) c))In so saying, Racket already provides its own port-&gt;list and your version would actually conflict with it. Or, if you're merging two sorted lists and need to maintain the ordering in the result list:(require srfi/1)(define (merge-sorted-lists lhs rhs #:order (lt? &lt;)) (let loop ((result '()) (lhs lhs) (rhs rhs)) (cond ((null? lhs) (append-reverse result rhs)) ((null? rhs) (append-reverse result lhs)) ((lt? (car rhs) (car lhs)) (loop (cons (car rhs) result) lhs (cdr rhs))) (else (loop (cons (car lhs) result) (cdr lhs) rhs)))))Examples:&gt; (merge-sorted-lists '(1 3 5 7) '(2 4 6 8))'(1 2 3 4 5 6 7 8)&gt; (merge-sorted-lists '(7 5 3 1) '(8 6 4 2) #:order &gt;)'(8 7 6 5 4 3 2 1) Here's a shell script that generates most of the lines in your post:prev=minimfor i in '' $(seq 2 4); do cur=equil$i printf 'pmemd.cuda -O -i ../in/%s.in -o %s.out -p ./protein.parm7 -c %s.restrt -r %s.restrt -x %s.nc -ref %s.restrt\n' $cur $cur $prev $cur $cur $prev prev=$curdonefor i in $(seq 5); do cur=equil5_$i printf 'pmemd.cuda -O -i ../in/equil5.in -o %s.out -p ./protein.parm7 -c %s.restrt -r %s.restrt -x equil5.nc -ref %s.restrt\n' $cur $prev $cur $prev prev=$curdoneThis generates:pmemd.cuda -O -i ../in/equil.in -o equil.out -p ./protein.parm7 -c minim.restrt -r equil.restrt -x equil.nc -ref minim.restrtpmemd.cuda -O -i ../in/equil2.in -o equil2.out -p ./protein.parm7 -c equil.restrt -r equil2.restrt -x equil2.nc -ref equil.restrtpmemd.cuda -O -i ../in/equil3.in -o equil3.out -p ./protein.parm7 -c equil2.restrt -r equil3.restrt -x equil3.nc -ref equil2.restrtpmemd.cuda -O -i ../in/equil4.in -o equil4.out -p ./protein.parm7 -c equil3.restrt -r equil4.restrt -x equil4.nc -ref equil3.restrtpmemd.cuda -O -i ../in/equil5.in -o equil5_1.out -p ./protein.parm7 -c equil4.restrt -r equil5_1.restrt -x equil5.nc -ref equil4.restrtpmemd.cuda -O -i ../in/equil5.in -o equil5_2.out -p ./protein.parm7 -c equil5_1.restrt -r equil5_2.restrt -x equil5.nc -ref equil5_1.restrtpmemd.cuda -O -i ../in/equil5.in -o equil5_3.out -p ./protein.parm7 -c equil5_2.restrt -r equil5_3.restrt -x equil5.nc -ref equil5_2.restrtpmemd.cuda -O -i ../in/equil5.in -o equil5_4.out -p ./protein.parm7 -c equil5_3.restrt -r equil5_4.restrt -x equil5.nc -ref equil5_3.restrtpmemd.cuda -O -i ../in/equil5.in -o equil5_5.out -p ./protein.parm7 -c equil5_4.restrt -r equil5_5.restrt -x equil5.nc -ref equil5_4.restrt The most straightforward solution is to use the closed form:(define (sum-of-squares n) (* 1/6 n (+ n 1) (+ n n 1)))Credit: WolframAlpha They're not "broken" lists; they're actually known as improper lists (as opposed to nil-terminated lists, which are proper lists). Many list functions, such as length and butlast that you just named, expect proper lists, and listp returns true only for proper lists.Improper lists are used in association lists (where the associations are often not proper; though the alist itself must be proper).If you want to make an improper list proper, you have two options:Remove the "improper" element.Treat the improper element as the last element of the proper list.Here's a procedure I wrote called properise which will do the former:(defun properise (x) (let ((r nil)) (while (consp x) (push (pop x) r)) (nreverse r)))(If you want the latter behaviour, add (unless (null x) (push x r)) just before the nreverse line.) Use this:(nsubst 'or 'and line) Here's my implementation. Note that you need to load SRFI 1, which provides unfold-right:(define letters "ABCDEFGHIJKLMNOPQRSTUVWXYZ")(define (number-&gt;letters num) (unfold-right negative? (lambda (i) (string-ref letters (remainder i 26))) (lambda (i) (- (quotient i 26) 1)) num))(define (number-&gt;tag num) (list-&gt;string (cons #\M (number-&gt;letters num))))Examples:&gt; (number-&gt;tag 0)"MA"&gt; (number-&gt;tag 18277)"MZZZ"&gt; (number-&gt;tag 18278)"MAAAA"The OP asked for an explanation of what the code does. So, with the understanding that the OP already understands the algorithm (since they linked to it already), what's basically left is the unfold operation.Fold and unfold are a bit lengthy to explain and I don't want to derail this post by explaining them, but it's possible to "expand" the unfold into the equivalent loop (using the same variable names as the SRFI 1 reference implementation of unfold-right) to express what's going on:(define (number-&gt;letters num) (let lp ((seed num) (ans '())) (if (negative? seed) ans (lp (- (quotient seed 26) 1) (cons (string-ref letters (remainder seed 26)) ans)))))Basically, it builds a list, from right to left, using (string-ref letters (remainder seed 26)) each iteration (where seed is num in the initial iteration). seed's value is then updated to (- (quotient seed 26) 1) for the next iteration. The list stops when (negative? seed) is true.You might then ask why one would use an unfold instead of the loop. Basically, in functional programming, when a "concept" can be expressed in higher-level terms (e.g., for-each, map, filter, fold, or unfold), using those terms helps other programmers understand what the code does. It's a bit like "design patterns" (as commonly used in object-oriented programming), within a functional programming context. :-) (use-modules (srfi srfi-1)) is indeed the correct way to import SRFI 1, in top-level programs and in the REPL.However, based on your previous question, I believe you may actually be writing a module instead, in which case the syntax is a little different. You'd use #:use-module (srfi srfi-1) inside your define-module. Example:(define-module (my module) #:use-module (srfi srfi-1) ;; rest of the module declaration here ) Scott's answer is correct, but I want to pitch in with another perspective.Scheme culture cares a great deal about functional programming. Functional code should not care about ordering of operations. This is, in fact, why an expression like (foo (bar) (baz (qux))) does not say anything about which order those functions will be run, except that:qux will be run before baz is runboth bar and baz will be run before foo is runIn particular, qux can be run before or after bar, and even a sequence like qux → bar → baz → foo is valid.For a similar reason, let should be used by default; it signals to the reader that the usual functional assumptions apply, that the bindings can be evaluated in any order. let* should only be used to alert the reader to the unusual behaviour of having bindings depend on previous ones in the same let* form. Here's my version:(define (likenate lst) (cond ((empty? (rest lst)) lst) (else (list* (first lst) 'like (likenate (rest lst)))))) Here's my version (note that I've changed it to return the result as a single dotted pair, rather than a list with two elements†):(define (min/max lst) (if (empty? lst) #f (let ((next (min/max (cdr lst)))) (define cur (car lst)) (if (not next) (cons cur cur) (cons (min (car next) cur) (max (cdr next) cur))))))Example:&gt; (min/max '(3 1 4 1 5 9))(1 . 9)† If you really want to use a list of two elements, change all the cons to list, and change the (cdr next) to (cadr next). There is no single canonical meaning for the word "thunk". In this instance, I think it simply refers to a function object. Personally, I don't use the word "thunk" in that way, but like I said, there's no commonly-agreed meaning for that word. You didn't reset the value of cols in the outer loop. So the second time through the outer loop, the inner loop never gets run at all. Also consider using a for loop:for (int rows = 0; rows &lt; numRows; ++rows) { // ... for (int cols = 0; cols &lt; numCols; ++cols) { // ... }} Your let* form is missing the body (the code that uses the bindings). Even if the body simply returns mst, like so:(let* ((ll (ListLink x y)) (in (cog-incoming-set ll)) (mst (get-mst-node in))) mst) I've just tested on my Trusty Tahr system. It blows up, just as on Red Hat. So it doesn't "work on Ubuntu".To verify we're both getting the same results, here's the output of various commands I've used: cky@sunflower:~/tmp$ g++ -O2 -Wall -o test test.cccky@sunflower:~/tmp$ ./testterminate called after throwing an instance of 'std::ios_base::failure' what(): basic_filebuf::underflow error reading the fileAborted (core dumped)cky@sunflower:~/tmp$ gcc -vUsing built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/4.8/lto-wrapperTarget: x86_64-linux-gnuConfigured with: ../src/configure -v --with-pkgversion='Ubuntu 4.8.2-19ubuntu1' --with-bugurl=file:///usr/share/doc/gcc-4.8/README.Bugs --enable-languages=c,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.8 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.8 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-gnu-unique-object --disable-libmudflap --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-4.8-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-4.8-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnuThread model: posixgcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) cky@sunflower:~/tmp$ dpkg -l libstdc++\*Desired=Unknown/Install/Remove/Purge/Hold| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)||/ Name Version Architecture Description+++-======================================-========================-========================-==================================================================================ii libstdc++-4.8-dev:amd64 4.8.2-19ubuntu1 amd64 GNU Standard C++ Library v3 (development files)un libstdc++-4.8-doc &lt;none&gt; &lt;none&gt; (no description available)un libstdc++-dev &lt;none&gt; &lt;none&gt; (no description available)un libstdc++2.10-dev &lt;none&gt; &lt;none&gt; (no description available)un libstdc++2.8-dev &lt;none&gt; &lt;none&gt; (no description available)un libstdc++2.9-dev &lt;none&gt; &lt;none&gt; (no description available)un libstdc++2.9-glibc2.1-dev &lt;none&gt; &lt;none&gt; (no description available)un libstdc++3.0-dev &lt;none&gt; &lt;none&gt; (no description available)ii libstdc++6:amd64 4.8.2-19ubuntu1 amd64 GNU Standard C++ Library v3un libstdc++6-4.8-dbg &lt;none&gt; &lt;none&gt; (no description available) Here's my version "without a helper function". It does use two nested loops, though:(define (sublist? needle haystack) (if (null? needle) #t (let ((first (car needle))) (let outer ((cur haystack)) (define (next) (outer (cdr cur))) (cond ((null? cur) #f) ((eqv? (car cur) first) (let inner ((lhs (cdr needle)) (rhs (cdr cur))) (cond ((null? lhs) #t) ((null? rhs) (next)) ((eqv? (car lhs) (car rhs)) (inner (cdr lhs) (cdr rhs))) (else (next))))) (else (next))))))) decode-1 actually refers to the decode parameter tree (in (decode-1 (cdr bits) tree)), not just to current-branch. So they're not "the same arguments". (In technical terms, decode-1 is a closure.)If decode-1 made no reference to tree (or to any outer variables, in general), then yes, you could recurse into decode directly and not need the internal procedure.By the way, the "define a procedure and call it" idiom is so common, Scheme provides a "named let" syntax for writing it more nicely:(define (decode bits tree) (let decode-1 ((bits bits) (current-branch tree)) (if (null? bits) '() (let ((next-branch (choose-branch (car bits) current-branch))) (if (leaf? next-branch) (cons (symbol-leaf next-branch) (decode-1 (cdr bits) tree)) (decode-1 (cdr bits) next-branch)))))) For cons, there is no difference between your two versions.For variadic procedures like +, the difference between + and (lambda (x y) (+ x y)) is that the latter constrains the procedure to being called with two arguments only. In Guile, you can use unspecified? to test for an unspecified value. So, you can write a filter function, say null-or-unspecified?, as follows:(define (null-or-unspecified? x) (or (null? x) (unspecified? x))) 1e16 is, in Scheme terms, an inexact number (or in more practical terms, a floating-point number). For (double-precision) floating point numbers above 253 (9007199254740992), the ulp is greater than 1, which means changes by 1 are too small to be represented.†10000000000000000, on the other hand, is an integer. If you do (- 10000000000000000 1), you will indeed get back 999999999999999. In Scheme, you can also write #e1e16 to represent the same quantity; the #e prefix makes the number exact (in Scheme terms; in practical terms, it means either an integer or rational).† Try evaluating (+ 9007199254740992.0 1) and (- 9007199254740992.0 1), then try evaluating (+ 9007199254740992 1) and (- 9007199254740992 1) for contrast with integers. You forgot to call reduct again after adding. Here's the fixed version:(define (reduct n) (if (&lt; n 10) n (reduct (+ (modulo n 10) (reduct (quotient n 10))))))Note that the inner reduct recursion is actually redundant and can be removed, leaving:(define (reduct n) (if (&lt; n 10) n (reduct (+ (modulo n 10) (quotient n 10)))))or, if you want to only divide once (and get the modulo too), you can use the R7RS floor/ procedure:(define (reduct n) (if (&lt; n 10) n (reduct (call-with-values (lambda () (floor/ n 10)) +))))(This is, by the way, a pure loop. A Ruby version could look like:def reduct(n) n = n % 10 + n / 10 while n &gt;= 10 nendor (for the one-division-only approach)def reduct(n) n = n.divmod(10).reduce(:+) while n &gt;= 10 nendexcept that it uses mutation unlike the Scheme version.)However, as my comment already says, the result will always be the same as doing (modulo n 9) (except that 0 should become 9, so (+ (modulo (- n 1) 9) 1) is probably more correct), so if you're doing this for numerological purposes or otherwise not a homework which requires you to do it the "hard way", just use that. Here's my version:#lang htdp/isl(define (list-prefix? lhs rhs) (or (empty? lhs) (and (not (empty? rhs)) (eqv? (first lhs) (first rhs)) (list-prefix? (rest lhs) (rest rhs)))))(define (list-overlap lhs rhs) (if (list-prefix? lhs rhs) rhs (cons (first lhs) (list-overlap (rest lhs) rhs))))Note that list-prefix? returns true if lhs is empty, so it is an adequate base case. This works in #lang racket.(define pal '(Transparent Blue DarkGray White Green DarkGreen))(apply above (map (lambda (row) (apply beside (map (lambda (col) (square 4 'solid (list-ref pal col))) row))) allig))(Notice that I added Transparent to the front of pal so that I don't have to shift the index by 1.)It also works for #lang htdp/isl+ (but for some reason, it shows the struct instead of displaying the image directly). Of course, the reason why Alexis King was asking whether you were using ISL+ vs plain ISL is that the lambda expressions I used above are forbidden in plain ISL.Here's a version that works in plain ISL:(define pal '(Transparent Blue DarkGray White Green DarkGreen))(define (make-pixel col) (square 4 'solid (list-ref pal col)))(define (make-row row) (apply beside (map make-pixel row)))(apply above (map make-row allig)) Here's my implementation of the macro that generates the functions you initially listed:(defmacro defchord (name steps) `(defun ,name (foo scale) ,(concatenate 'string "Generates a " (symbol-name name) " on scale-step FOO of scale SCALE") (list ,.(mapcar (lambda (i) `(%part (+ foo ,i) scale)) steps))))Some examples:&gt; (macroexpand-1 '(defchord triad (-1 1 3)))(DEFUN TRIAD (FOO SCALE) "Generates a TRIAD on scale-step FOO of scale SCALE" (LIST (%PART (+ FOO -1) SCALE) (%PART (+ FOO 1) SCALE) (%PART (+ FOO 3) SCALE)))&gt; (macroexpand-1 '(defchord quad (-1 1 3 5)))(DEFUN QUAD (FOO SCALE) "Generates a QUAD on scale-step FOO of scale SCALE" (LIST (%PART (+ FOO -1) SCALE) (%PART (+ FOO 1) SCALE) (%PART (+ FOO 3) SCALE) (%PART (+ FOO 5) SCALE)))That looks like a pretty good match for the functions you listed, I think. :-) Your render-line expression has to be inside the local form, not after it. Also, all your defines should be inside one subform in the local, not each in its own subform. So, it should look like:(local [(define (last p) ...) (define (render-line im p q) ...) (define (connect-dots p) ...)] (render-line ...)) It is much simpler than that.(define (append-test lhs rhs) (if (empty? lhs) rhs (cons (first lhs) (append-test (rest lhs) rhs)))) That's because you cannot just use "another set of parentheses" to make a list.Here's an expression that creates a list containing the numbers 1, 2, 3, 4.(list 1 2 3 4)However, you cannot use (1 2 3 4) or even ((1 2 3 4)) to express that. You'd have to create a separate procedure to extract the count. Here's how you might do it:(define (make-counter) (let ((count 0)) (values (lambda () (set! count (+ count 1)) count) (lambda () count))))Here, we are returning two procedures: the first one is exactly the same as before, and the second one returns the count directly.Usage example:&gt; (define-values (inc-count get-count) (make-counter))&gt; (inc-count)1&gt; (inc-count)2&gt; (inc-count)3&gt; (get-count)3Note that this is different from extracting the value of a closed-over variable in a given procedure's lexical environment, which is what I believe your question is asking about. There is no standard way in Scheme to achieve such a thing. Your property lists are not meant to be evaluated. They're meant to be read in and processed. Your processing function can then pick out symbols like fact and is-a and connected and handle them appropriately.But, since you're not evaluating them, you should not define procedures (or macros!) for fact, is-a, or connected. In Scheme, the conventional placeholder for "invalid" is #f, the false object. You can test for it using not.(There is a null? procedure in Scheme that checks whether the object is the empty list, (). However, that should only be used for list contexts, and not as an "invalid" placeholder. Note that not only returns true for #f, and null? only returns true for (); be careful not to mix the two up.) You had too many parentheses. It should be (case mes ...), not (case (mes) ...). It's not like a C-style switch. :-) Here's how I'd do it with iterate:(define (replicateone n lst) (iterate (lambda (x) (cons (first lst) x)) n (rest lst)))Here's "an" implementation of iterate that doesn't use direct recursion and does run correctly with ISL+, but, it's (intentionally) obfuscated. You'll have fun trying to figure out how it works. ;-)(define (iterate f n x) (foldl (compose f second list) x (make-list n #f))) In any sensible implementation of Scheme, since conses are so common, they're implemented as some kind of double-word structure. In such implementations, car, cdr, set-car!, and set-cdr! are all constant-time.As Alexis King commented, you'd have to have a pretty perverse implementation for it not to be constant time. (e.g., if cons cells were implemented as alists.) Here's a skeletal solution. Replace all the &lt;???&gt; with appropriate items.(define (index-of lst x) (cond ((null? lst) &lt;???&gt;) ((eq? &lt;???&gt; x) &lt;???&gt;) (else (+ (index-of &lt;???&gt; x) 1)))) Internal definitions can only be at the beginning of a procedure (or implicit-procedure contexts, like let bodies). In any case, they're syntactic sugar for letrec* forms, and you can always rewrite in terms of that. I'd use this:(defun count-suit (suit hand) (length (remove-if-not (lambda (card) (equal suit (suit card))) hand)))Alternatively, this is okay too:(defun count-suit (suit hand) (length (remove-if-not (lambda (card) (equal suit (suit card))) hand)))Note that the remove-if-not is only one-space indented from the length, since length is not a body-containing form. Read Riastradh's Lisp Style Rules for more guidance. Change the (eq? (user-attribute 'gem) 1) to this, instead:(&gt;= (user-attribute 'gem) 1)By the way, don't use eq? to compare numbers. Use = or (if you need to compare against generic objects) eqv?.The OP asked how to suppress the bribe message if there are no gems. Here's how it might be done (I'm going for minimal changes to existing code, not for best style):((equal? cmd 'bribe) (if (get-area-item rid 'guard) (if (&gt;= (user-attribute 'gem) 1) (begin (hash-table-set! areasdb rid (replace-area-item (get-area rid) 'guard '(guard #f))) (user-add-value 'gem -1) (describe 'bribe)) (describe 'bribe-no-gem)) (describe 'bribe-blank)))By the way, if the only reason you're using (describe 'bribe-blank) is because if requires an else branch, you can use when instead, like so:((equal? cmd 'bribe) (when (get-area-item rid 'guard) (if (&gt;= (user-attribute 'gem) 1) (begin (hash-table-set! areasdb rid (replace-area-item (get-area rid) 'guard '(guard #f))) (user-add-value 'gem -1) (describe 'bribe)) (describe 'bribe-no-gem)))) The OP wants to be able to pass fewer arguments than there are parameters. In this specific case, it's best to use keyword (named) arguments. Here's how you might do this (in Racket syntax):(define (total-bills #:ones (ones 0) #:fives (fives 0) #:tens (tens 0) #:twenties (twenties 0) #:fifties (fifties 0) #:hundreds (hundreds 0)) (+ ones (* fives 5) (* tens 10) (* twenties 20) (* fifties 50) (* hundreds 100)))(The 0 after each of the variable names are the default values, that is, what the value would be if you don't specify it.)Example usage:&gt; (total-bills #:ones 3 #:fives 1 #:tens 2 #:hundreds 2)228 You forgot to write an apply in your function. Don't worry, I make this mistake all the time, which was why I spotted it instantly. ;-)Basically, you need to use (apply aux (map cdr args)). Otherwise, your aux is being recursed into with one argument only.Oh, and you also need to use (ormap null? args) instead of just (null? args), since the base case is that all your given lists are exhausted, not that you have no given lists. This has to do with the default behaviour of Racket's printer (which is used by the REPL for output; it's different from display). Run this, then try again:(print-as-expression #f)As for (eval ''1), this has to do with the fact that ''1 is the same as (quote (quote 1)), which evaluates to (quote 1), which when passed to eval then results in 1. The precision is fixed, which is exactly 53 binary digits for double-precision (or 52 if we exclude the implicit leading 1). This comes out to about 15 decimal digits.The OP asked me to elaborate on why having exactly 53 binary digits means "about" 15 decimal digits.To understand this intuitively, let's consider a less-precise floating-point format: instead of a 52-bit mantissa like double-precision numbers have, we're just going to use a 4-bit mantissa.So, each number will look like: (-1)s &times; 2yyy &times; 1.xxxx (where s is the sign bit, yyy is the exponent, and 1.xxxx is the normalised mantissa). For the immediate discussion, we'll focus only on the mantissa and not the sign or exponent.Here's a table of what 1.xxxx looks like for all xxxx values (all rounding is half-to-even, just like how the default floating-point rounding mode works): xxxx | 1.xxxx | value | 2dd | 3dd --------+----------+----------+-------+-------- 0000 | 1.0000 | 1.0 | 1.0 | 1.00 0001 | 1.0001 | 1.0625 | 1.1 | 1.06 0010 | 1.0010 | 1.125 | 1.1 | 1.12 0011 | 1.0011 | 1.1875 | 1.2 | 1.19 0100 | 1.0100 | 1.25 | 1.2 | 1.25 0101 | 1.0101 | 1.3125 | 1.3 | 1.31 0110 | 1.0110 | 1.375 | 1.4 | 1.38 0111 | 1.0111 | 1.4375 | 1.4 | 1.44 1000 | 1.1000 | 1.5 | 1.5 | 1.50 1001 | 1.1001 | 1.5625 | 1.6 | 1.56 1010 | 1.1010 | 1.625 | 1.6 | 1.62 1011 | 1.1011 | 1.6875 | 1.7 | 1.69 1100 | 1.1100 | 1.75 | 1.8 | 1.75 1101 | 1.1101 | 1.8125 | 1.8 | 1.81 1110 | 1.1110 | 1.875 | 1.9 | 1.88 1111 | 1.1111 | 1.9375 | 1.9 | 1.94How many decimal digits do you say that provides? You could say 2, in that each value in the two-decimal-digit range is covered, albeit not uniquely; or you could say 3, which covers all unique values, but do not provide coverage for all values in the three-decimal-digit range.For the sake of argument, we'll say it has 2 decimal digits: the decimal precision will be the number of digits where all values of those decimal digits could be represented.Okay, then, so what happens if we halve all the numbers (so we're using yyy = -1)? xxxx | 1.xxxx | value | 1dd | 2dd --------+----------+-----------+-------+-------- 0000 | 1.0000 | 0.5 | 0.5 | 0.50 0001 | 1.0001 | 0.53125 | 0.5 | 0.53 0010 | 1.0010 | 0.5625 | 0.6 | 0.56 0011 | 1.0011 | 0.59375 | 0.6 | 0.59 0100 | 1.0100 | 0.625 | 0.6 | 0.62 0101 | 1.0101 | 0.65625 | 0.7 | 0.66 0110 | 1.0110 | 0.6875 | 0.7 | 0.69 0111 | 1.0111 | 0.71875 | 0.7 | 0.72 1000 | 1.1000 | 0.75 | 0.8 | 0.75 1001 | 1.1001 | 0.78125 | 0.8 | 0.78 1010 | 1.1010 | 0.8125 | 0.8 | 0.81 1011 | 1.1011 | 0.84375 | 0.8 | 0.84 1100 | 1.1100 | 0.875 | 0.9 | 0.88 1101 | 1.1101 | 0.90625 | 0.9 | 0.91 1110 | 1.1110 | 0.9375 | 0.9 | 0.94 1111 | 1.1111 | 0.96875 | 1. | 0.97By the same criteria as before, we're now dealing with 1 decimal digit. So you can see how, depending on the exponent, you can have more or less decimal digits, because binary and decimal floating-point numbers do not map cleanly to each other.The same argument applies to double-precision floating point numbers (with the 52-bit mantissa), only in that case you're getting either 15 or 16 decimal digits depending on the exponent. If you are using tcp-listen directly (meaning that you handle all the low-level socket stuff yourself, and manually handle HTTP too), you need to call it with the reuse? parameter set to #t.If you are using the web-server module, it already sets reuse? to #t so it should already work. Macros are compile-time, not run-time. So you won't be able to query whether container is a table or pair or what not at macro-expansion time. You'd have to use a procedure to do that.So, why not just use a procedure? Your problem description pretty much describes what's required:(define (shape=? shape1 shape2) (or (and (triangle? shape1) (triangle? shape2)) (and (rectangle? shape1) (rectangle? shape2)))) It's really just a preference on the part of the X-expression designers, probably to mirror let's syntax (which also uses proper lists only).With (list symbol string), you'd represent &lt;a href="http://stackoverflow.com/"&gt;Stack Overflow&lt;/a&gt; as:(a ((href "http://stackoverflow.com/")) "Stack Overflow")whereas with (cons symbol string), it'd be:(a ((href . "http://stackoverflow.com/")) "Stack Overflow")Some would consider the "dot" an ugly thing to see. Unless you want to use Church numerals or the like, at some point you're going to have to get into the hardware arithmetic instructions (add, sub, mul, div) one way or another.If going down the hardware instructions route, then depending on your Lisp implementation, it may be implemented using C code (especially for an interpreter-based implementation), or those instructions may be emitted directly (for a JIT compiler-based implementation).If you're trying to be as first-principles as possible, you can implement multiplication and division using addition and subtraction instructions (in a pinch, you can implement them the same way you were taught to in school, though you're using word-sized digits—that is, for a 32-bit machine, each digit is base-4294967296 instead of base-10). file: URLs can reference JavaScript code. That JavaScript code could set cookies, which other file: JS code (even if from a different file) can access, due to them being considered the "same origin". Clojure has a threading operator, -&gt;, which does what you expect:(-&gt; thing (thing-operation1 extra-arg1) (thing-operation2 extra-arg2) (thing-operation3 extra-arg3))You can implement this easily as a macro in other Lisp dialects. Greg Hendershott's rackjure library has a ~&gt; form that does the same thing in Racket, for example.The -&gt; (or ~&gt; in rackjure) macro splices the result in as the first argument of each subform. If you want to splice the result in as the last argument instead, there's a -&gt;&gt; macro (~&gt;&gt; in rackjure). Chicken requires the syntax-case egg to be loaded in order to support syntax-case. However, ideone does not have that egg installed, so you can't use it there.So, in order to test on ideone, you're going to have to convert your macro to an explicit-renaming one. You're reading too much into it. :-) If it points into the box anywhere, assume it's a pointer to that cons cell. You cannot specifically point to the car or cdr portion of it. Sure, you don't need to use transpose at all:def swingers(pairs) gents = pairs.map(&amp;:first) ladies = pairs.map(&amp;:last) gents.shuffle.zip(ladies.shuffle)end The basic idea behind a named let is that it allows you to create an internal function, that can call itself, and invoke it automatically. So your code is equivalent to:(define (number-&gt;list n) (define (loop n acc) (if (&lt; n 10) (cons n acc) (loop (quotient n 10) (cons (remainder n 10) acc)))) (loop n '()))Hopefully, that is easier for you to read and understand.You might, then, ask why people tend to use a named let rather than defining an internal function and invoking it. It's the same rationale people have for using (unnamed) let: it turns a two-step process (define a function and invoke it) into one single, convenient form.It's called a loop because the function calls itself in tail position. This is known as tail recursion. With tail recursion, the recursive call returns directly to your caller, so there's no need to keep the current call frame around. You can do tail recursion as many times as you like without causing a stack overflow. In that way, it works exactly like a loop.If you'd like more information about named let and how it works, I wrote a blog post about it. (You don't need to read it to understand this answer, though. It's just there if you're curious.) Currently, your prime-pairs function always returns one value: either an empty list, or the prime pairs. Using map, there is no way to avoid the empty lists, without doing further filtering on the result of the map.One alternative is to return a list of results, and use append-map instead of map. Change your prime-pairs to return either an empty list, or a singleton list containing your prime pairs; this simulates returning zero or one value, rather than always one value. Like so:(cond ((zero? n) (if (null? acc) '() (list acc))) ...)Now, use append-map:(append-map prime-pairs primes-list-split)and you should have the results you seek. (See my forked gist for full code.) The code you linked to prints the prime numbers, but does not store them or return them in any way. To store them, you should use the accumulator technique like you have in sieve-to-list. Anyway, here's a fixed version (I took the opportunity to clean the code up a lot, too):(define (prime-sieve n) (define vec (make-vector (+ n 1) #t)) (let loop ((p 3) ; Maintains invariant p = 2j + 1 (q 4) ; Maintains invariant q = 2j + 2jj (j 1) (result '(2))) (define (lp result) (loop (+ p 2) (+ q p p 2) (+ j 1) result)) (define (eradicate!) (do ((q q (+ q p))) ((&gt; q n)) (vector-set! vec q #f))) (cond ((&gt; j n) (reverse result)) ((vector-ref vec j) (eradicate!) (lp (cons p result))) (else (lp result)))))This returns a list, not a vector. That's because the results are built incrementally, which lists are good for and vectors are not.I validated the above code by comparing the results against my implementation of the Sieve of Eratosthenes.Do you use Racket? I noticed you used add1 in your code. If so, here's the same algorithm, but using for comprehensions in Racket, which is more concise and easy to read:(define (prime-sieve n) (define vec (make-vector (add1 n) #t)) (define (eradicate! p q) (do ((q q (+ q p))) ((&gt; q n)) (vector-set! vec q #f))) (cons 2 (for/list ((j (in-range 1 (add1 n))) #:when (vector-ref vec j)) (define p (+ j j 1)) (eradicate! p (* 2 j (add1 j))) p)))In this version, p and q are calculated afresh from j each time rather than be accumulated, but I don't think that's a huge problem. In Scheme, most of the time you'll probably want to use the default "current" ports for input and output. On most Unix systems, the default current input port is linked to stdin and the default current output port is linked to stdout.With that in mind, reading in two numbers and writing out their product is basically:(display (* (read) (read)))Now, if you want to use actual input and output files, like you mentioned in your question, then you can either wrap with with-input-from-file/with-output-to-file (which temporarily changes the current input and output port):(with-input-from-file "data.inp" (lambda () (with-output-to-file "result.out" (lambda () (display (* (read) (read)))))))or you can explicitly specify ports, and leave the current/default input and output ports unchanged:(call-with-input-file "data.inp" (lambda (in) (call-with-output-file "result.out" (lambda (out) (display (* (read in) (read in)) out))))) The second argument to foldl and foldr is always init. Your provided function must always take 2 arguments if you're passing in a single list, and the second argument to that function is the accumulated value (init initially, then the return value of the previous call to your function).(In your earlier examples of using +, you can think of it as being the same as (lambda (a b) (+ a b)). In this case, a is the list element, and b is the accumulated value.)When you're calling foldl or foldr with N lists, then your provided function must take N+1 arguments; the first N arguments correspond to the next element from each list, and the last argument is the accumulated value (init initially, then the return value of the previous call to your function).Would it help your understanding if I provided (my own) implementations of foldl and foldr? Here they are:(define foldl (case-lambda ;; one list [(func init lst) (let loop ([result init] [rest lst]) (if (null? rest) result (loop (func (car rest) result) (cdr rest))))] ;; multiple lists [(func init list1 . list2+) (let loop ([result init] [rests (cons list1 list2+)]) (if (ormap null? rests) result (loop (apply func (append (map car rests) (list result))) (map cdr rests))))]))(define foldr (case-lambda ;; one list [(func init lst) (let recur ([rest lst]) (if (null? rest) init (func (car rest) (recur (cdr rest)))))] ;; multiple lists [(func init list1 . list2+) (let recur ([rests (cons list1 list2+)]) (if (ormap null? rests) init (apply func (append (map car rests) (list (recur (map cdr rests)))))))])) SICP says: Cons-stream is a special form defined so that(cons-stream &lt;a&gt; &lt;b&gt;) is equivalent to(cons &lt;a&gt; (delay &lt;b&gt;))It also adds: Although stream-car and stream-cdr can be defined as procedures, cons-stream must be a special form. If cons-stream were a procedure, then, according to our model of evaluation, evaluating (cons-stream &lt;a&gt; &lt;b&gt;) would automatically cause &lt;b&gt; to be evaluated, which is precisely what we do not want to happen. For the same reason, delay must be a special form, though force can be an ordinary procedure.By definition, a special form is not a procedure or function. So, your definition of cons-stream is incorrect.It's usually implemented as a macro:(define-syntax cons-stream (syntax-rules () ((cons-stream a b) (cons a (delay b)))))Indeed, you can define new-if as a macro and it'd work correctly too:(define-syntax new-if (syntax-rules () ((new-if predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause))))) As the error message says, static cannot be applied to top-level templates. In fact, the most recent commit to the code explicitly removed the static (via the STATIC_TPL macro) on clang and on gcc 4.3 and above.tl;dr: Update your code to the latest version of ReZound. You may have to get the code from Subversion trunk. line, = plt.plot(t, s, lw=2) means that plt.plot returns a list or a tuple of one element, and you are extracting that element (which is assigned to line). @ndn's comment is correct. However, personally, rather than reading in the whole file, I'd process it line by line (I took the liberty to tidy up your regexes, too):#!/usr/bin/perl -p$_ = '' if /^A[FG]\d{5}$/ || /^[A-Z]\d{4}$/ || /^\d{4}[A-Z]$/;or#!/usr/bin/perl -nprint unless /^A[FG]\d{5}$/ || /^[A-Z]\d{4}$/ || /^\d{4}[A-Z]$/;(In both cases, specify your input file on the command line. Read up the perlrun manual page on how the -p and -n options work.) The Eclipse indentation is correct. Preprocessor directives should be on the leftmost column, regardless of the indentation of the surrounding code. Yes, you can use interfaces as the type argument to a linked list.You should define enough methods in the interface to be able to handle all the useful functionality for your MCQs and TrueFalses, without having to downcast. In the first case, code outside the add function cannot touch the counter. They could separately create a counter variable, but it would be a different variable from the counter used by add, and wouldn't affect the operation of add.In the second case, any code that touched the global counter would be able to affect add's operation. You should use raise instead of abort. abort terminates your program, by design, whereas raise throws an exception that is caught by IRB's evaluator. @HyperZ's answer is correct. However, extensive use of set! is not generally considered idiomatic Scheme, so I want to show a different way to go about it. I'll use the same algorithm, just reformulated in idiomatic Racket:(define (factors dividend) (if (= dividend 1) '() (let loop ((divisor 2)) (define-values (q r) (quotient/remainder dividend divisor)) (if (zero? r) (cons divisor (factors q)) (loop (add1 divisor))))))This should be pretty straightforward to read:If the dividend is 1, return an empty list.Otherwise, look for a suitable divisor, starting with 2:Get the quotient and remainder from dividing the dividend by the divisor.If the remainder is zero, the result is the divisor, plus the factors of the quotient.Otherwise, add 1 to the divisor, and try again.You can actually make the code even more readable by using a for/first comprehension instead of a manual inner loop:(define (factors dividend) (if (= dividend 1) '() (for/first ((divisor (in-naturals 2)) #:when (zero? (remainder dividend divisor))) (cons divisor (factors (quotient dividend divisor)))))) Use the csv module:irb(main):001:0&gt; require 'csv'=&gt; trueirb(main):002:0&gt; CSV.parse_line('a,b,c,"x,y,z"')=&gt; ["a", "b", "c", "x,y,z"] I'll assume that stdin, in this case, is a pipe.†You can't rewind a pipe. What you need to do is to copy the pipe's data into a regular file, then use that file as stdin for the two processes you're calling.(You can also copy into a memory buffer, and then use a pipe to send the contents to the two processes.)Update: here's a simple Ruby script that checks whether stdin is a regular file, and if not, it creates a temp file and copies stdin to it first, then rebinds stdin to the temp file. Then it runs each argument as a command:#!/usr/bin/rubyrequire 'tempfile'unless File.file?($stdin) Tempfile.open('stdin') do |temp| IO.copy_stream($stdin, temp) $stdin.reopen(temp) temp.unlink endendARGV.each do |arg| $stdin.rewind system argendExample usage (assuming the file is named multiwrite in the current directory):$ echo foo | ./multiwrite cat 'tr a-z A-Z' 'tr a-z n-za-m'fooFOOsbb† If it's a regular file, then the solution is easy: call the first process, then rewind, then call the second process. The way you're invoking map won't have the desired effect. Giving the list of (list v w) means that your function is called twice, once with v, once with w (no matter how many items each of those lists have).Instead, do this:(define (dot-product v w) (apply + (map * v w)))Here, you are passing two lists to map, which means it will call your function (* in this case) with two arguments: one for each list given. The zip gem does not restore permissions by default. You must set the restore_permissions attribute to true on the ZipFile object before extracting its entries. So, use this:Zip::ZipFile.open(file_path) do |zip_file| zip_file.restore_permissions = true zip_file.each do |f| # ... endendThere is also a restore_ownership attribute you can set, if you want to restore ownership too. Scheme uses lexical scoping, so of course that code always returns lexical. However, in a Lisp system that uses dynamic scoping, scope would indeed be dynamic inside that (let ((scope 'dynamic)) ...) expression….In order to understand that, you have to understand how dynamic scoping is implemented. Think of each variable as having a stack of values.† So, when the lambda expression was being evaluated, the value lexical has been pushed to scope's value stack (via the let). When the let block is exited, the value is popped off. Later, the second let block pushes the value dynamic to scope's value stack, which is what your function then sees.† I highly appreciate the explanation from the Emacs Lisp manual about how dynamic bindings work in terms of a stack. It's helped me really understand the concept in concrete terms. You need to use (apply #'lstbuilder (cdr args)) in order to "splat" the list's contents as the function call arguments. @Tunaki's comment is probably on the money. If your n is larger than Integer.MAX_VALUE / 5, then it's possible for k to reach a value greater than Integer.MAX_VALUE / 5, then after multiplying by 5, it overflows and becomes a small number again, so your program never terminates.Whereas, if k is a long, then it doesn't matter if its value is larger than Integer.MAX_VALUE / 5; as long as it's smaller than Long.MAX_VALUE / 5 (which it's guaranteed to be, since n is an int and ints never reach values close enough), the overflow won't occur. If a function's parameter is unused, you don't have to give it a name. In this case, these functions are virtual, meaning they're expected to be overridden by a derived class, which may use these parameters in the overridden function definitions.const IContact* = 0 means an unused parameter of type "pointer to const IContact" whose value is not required to be specified by the caller, and null is used if the caller omits its value.const QVariant&amp; is an unused parameter of type "reference to const QVariant". The caller must still specify its value, however. You need to NUL-terminate your output string. :-( That also means your call to calloc (you really should just use malloc, though) should specify plain_len + 1, not just plain_len. Aws::S3::Types::Bucket is not the same as Aws::S3::Bucket. Only the latter has #presigned_post. It appears that Aws::S3::Client#list_buckets returns information about buckets, not the bucket objects (which you have to create yourself).Have you tried:bucket = Aws::S3::Bucket.new('mybucket', client: s3) If I read your question correctly, use this:mv src/*[A-Z]* target/ Here's a straightforward translation of your formula to Racket:(define (F n m l f g) (for/sum ([i (in-range 1 (add1 n))]) (- (f (expt m i)) (g (for/product ([j (in-list l)]) (expt j i)))))) In the case of System.out.println, it takes Object, which both Comparable&lt;T&gt; and T satisfy (since all objects are instances of Object), so you could have written for (Object foo : biz) and it'd have worked in this case.In the general case, choose the most general type that works for the operations you need to invoke. Java does not have a way to require an overridden method to call up to its superclass implementation. Nor (again in contrast to constructors) can you stop it from being called more than once. You need to invoke awaitTermination on the executor object, in order to wait for the executor to finish shutting down. The simplest way to write it is:(list 'lambda (list 'x))If you really must use the append approach mentioned in your question, then one possible solution is:(append (list 'lambda) (list (list 'x))) and and or do evaluate their last expression in tail position. This is guaranteed by the Scheme standard; see, e.g., http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.20.nor, on the other hand, has to negate the result of or. By definition, that means that the result of or is not evaluated in tail position, since it has to be passed to not before going back to the caller. This defines a variadic procedure (a procedure that can take different numbers of arguments) of at least zero arguments. All the arguments are bundled up into a list called args, in this case.Here's another example of a variadic procedure (this one requires at least one argument), which returns the minimum value of all the arguments passed in:(define (min arg1 . rest) (let loop ((val arg1) (rest rest)) (if (null? rest) val (let ((next (car rest))) (loop (if (&lt; next val) next val) (cdr rest)))))) You should define an error block:error do env['sinatra.error'].messageendSee http://www.sinatrarb.com/intro.html#Error for more details, including how to set up different error handlers for different exception types, HTTP status codes, etc. Here's one possible implementation of Employee:(define (Employee name position salary) (list (box name) (box position) (box salary)))I'll let you define the rest of the functions. They should be straightforward (hint: combine get-val or set-val! with first, second, or third). You have a typo: your inner loop should use a[j] = 0; instead of a[i] = 0;.(Also, since your array contains 0 or 1 only, it's better to use to use a bool[] instead of int[].) You're setting the value of @possessions and @tasks in the wrong place. They should be set inside an instance method (whether initialize or something else), not in the class body itself. Using your Rakefile, I've managed to get this to work (I have Rake 0.9.6; apparently newer Rake versions may have issues?):rake schedule:create_recurring -- -c1 -e42 --from_date=fooThis outputs:options {:calendar_id=&gt;"1", :event_id=&gt;"42", :from_date=&gt;"foo"} Your Team class does not have an attribute for getting the @team instance variable.† So the only way you can extract its value is by using instance_variable_get:irb(main):029:0&gt; team = Team.new=&gt; #&lt;Team:0x007fff4323fd58 @team=[]&gt;irb(main):030:0&gt; team.instance_variable_get(:@team)=&gt; []Please don't use instance_variable_get for actual production code though; it's a code smell. But for the purposes of inspecting instance variables in IRB, it's okay.† You'd normally define one using either attr_accessor :team (read/write) or attr_reader :team (read-only) inside the class definition. (map (lambda (lst) (cons x lst)) list-of-lists)Since you're using Racket, you can use curry for something even shorter:(map (curry cons x) list-of-lists) In my testing, the separator character is actually an &amp;nbsp; (non-breaking space), not a real space. The best to use is:for (auto&amp;&amp; entry : map) You can use GetProcAddress in C++ and invoke directly with that. That's similar to what P/Invoke does.The use of an import library is to enable the standard linker to work (whereas P/Invoke and GetProcAddress bypass the linker). That's because in your while loop, the k++ only happens in the else case. In your for loop, the k++ always happens each loop. (Style nit: your design class should be named Design.)In your main method, you hadn't created a new Design object yet. You can only access type for a Design instance. I believe in not reinventing perfectly good wheels, so here's a macro for transforming your switch into the equivalent case, with a slight change to use default instead of 'default. (I apologise to soegaard, for not knowing how to use syntax-parse yet, so I'll just stick with traditional syntax-case instead. ;-))(define-syntax (switch stx) (define (transform-clause cl) (syntax-case cl (default) ((default expr) #'(else expr)) ((val ... expr) #'((val ...) expr)))) (define (transform-clauses cls) (syntax-case cls () ((cl) (with-syntax ((case-clause (transform-clause #'cl))) #'(case-clause))) ((cl rest ...) (with-syntax ((case-clause (transform-clause #'cl)) ((case-rest ...) (transform-clauses #'(rest ...)))) #'(case-clause case-rest ...))))) (syntax-case stx () ((_ x clause ...) (with-syntax (((case-clause ...) (transform-clauses #'(clause ...)))) #'(case x case-clause ...)))))The downside of using this switch macro, as opposed to using case, is that you lose the ability to distinguish between using default to match the symbol default, vs as the catch-all. So using case is still better. :-)(case x ((3) (displayln "x is 3")) ((4) (displayln "x is 4")) ((5) (displayln "x is 5")) (else (displayln "none of the above"))) I'm going to reformulate your function a little bit, based on two insights:Scheme lists are not random-access, so using list indices is not a good way to go. (In particular, list-ref and list-set! are both O(n) operations.)Using extensive mutation is not very Schemey either. In fact, some implementations, like Racket, have immutable lists.Here's how I might rewrite the function using the same algorithm (note that your sort is not easy to implement without mutation (in contrast, you can implement mergesort without any mutation), so my version still has some mutation, but not as much as yours ;-)):(define (sort! lst) (let outer ((lhs lst)) (unless (null? lhs) (let inner ((rhs (cdr lhs))) (if (null? rhs) (outer (cdr lhs)) (let ((a (car lhs)) (b (car rhs))) (when (&gt; a b) (set-car! lhs b) (set-car! rhs a)) (inner (cdr rhs))))))))Note that using this inner/outer loop structure is cleaner than the cond you had, so my version doesn't use cond at all.Example usage (tested on Guile):&gt; (define lst (list 3 1 4 1 5 9)) ; important: **not** '(3 1 4 1 5 9)&gt; (sort! lst)&gt; lst(1 1 3 4 5 9)If you want to use a random-access data structure, that's called vector in Scheme. Here's the same algorithm for vectors:(define (sort! vec) (let outer ((i 0)) (unless (&gt;= i (vector-length vec)) (let inner ((j (+ i 1))) (if (&gt;= j (vector-length vec)) (outer (+ i 1)) (let ((a (vector-ref vec i)) (b (vector-ref vec j))) (when (&gt; a b) (vector-set! vec i b) (vector-set! vec j a)) (inner (+ j 1))))))))Note that I use i and j for the left-hand and right-hand vector indices, instead of the lhs and rhs left-hand and right-hand "cursors" that I used for the list version.Example usage (tested on Racket):&gt; (define vec (vector 3 1 4 1 5 9))&gt; (sort! vec)&gt; vec#(1 1 3 4 5 9) Yes, just use (random). Example usages:&gt; (random)0.9007041222291202&gt; (random)0.6808167485543256 You can implement this series as a SRFI 41 stream!(require srfi/41)(define negatives (stream-cons -1 (stream-map sub1 negatives)))(define terms (stream-cons 1 (stream-map / terms (stream-cdr negatives))))(define series (stream-cons 1 (stream-map + series (stream-cdr terms))))Example usage:&gt; (stream-&gt;list 10 series)(1 1/2 2/3 5/8 19/30 91/144 177/280 3641/5760 28673/45360 28319/44800)Don't like streams? I like soegaard's answer, except that it has to recompute the factorial each time! I wish for/sum has the ability to hold "state" values the way for/fold does. Here's an implementation using for/fold:(define (factorial-series n) (define-values (sum _) (for/fold ((sum 0) (value 1)) ((i (in-range -2 (- -3 n) -1))) (values (+ sum value) (/ value i)))) sum)Example usage:&gt; (map factorial-series (range 10))(1 1/2 2/3 5/8 19/30 91/144 177/280 3641/5760 28673/45360 28319/44800) SRFI 41 ((require srfi/41)) provides stream-iterate directly.You can use Óscar's examples and substitute stream-iterate wherever you see iterate, without having to define your own iterate. In addition, you can simulate Clojure's parameter destructuring using match-lambda:(require srfi/41)(define fib (stream-map first (stream-iterate (match-lambda ((list a b) (list b (+ a b)))) '(0 1))))(stream-&gt;list 10 fib) ; =&gt; (0 1 1 2 3 5 8 13 21 34) The Scheme standards define six trigonometric functions: sin, cos, tan, asin, acos, and atan. In particular, atan can be called with either 1 or 2 arguments, and the 2-argument version is equivalent to atan2 in other languages.sin, cos and tan all take radian arguments. asin, acos, and atan all return radian values.All serious math libraries (for any programming language), including the one that Scheme provides, use radians for their trigonometric functions.Mathematically, radian is the one true correct unit of measure for angles. :-) Anyway, this is why documentation usually doesn't explicitly spell this out; it is such an overwhelmingly common expectation that it's redundant, as using any other unit is a pretty serious WTF.Racket's documentation spells this out more explicitly because it's used widely in educational settings where radian-as-fundamental-unit-of-angle-measure may not have been taught yet. Based on soegaard's idea to use eager comprehensions, here's an in-nest-sequence sequence generator (also available on Code Review and as a Gist):#lang racket(require (for-syntax unstable/syntax))(provide (rename-out [*in-nest-sequence in-nest-sequence]))(define in-nest-sequence (case-lambda [(func init) (make-do-sequence (thunk (values identity func init #f #f #f)))] [(func . inits) (make-do-sequence (thunk (values (curry apply values) (lambda (args) (call-with-values (thunk (apply func args)) list)) inits #f #f #f)))]))(define-sequence-syntax *in-nest-sequence (lambda () #'in-nest-sequence) (lambda (stx) (syntax-case stx () [[(x ...) (_ func init ...)] (unless (= (syntax-length #'(x ...)) (syntax-length #'(init ...))) (raise-syntax-error 'in-nest-sequence (format "~a values required" (syntax-length #'(x ...))) stx #'(init ...))) (with-syntax ([for-arity (syntax-length #'(init ...))] [(value ...) (generate-temporaries #'(init ...))] [(y ...) (generate-temporaries #'(init ...))]) #'[(x ...) (:do-in ([(f) func]) (unless (procedure-arity-includes? f for-arity) (raise-arity-error f (procedure-arity f) init ...)) ([value init] ...) #t ([(x ...) (values value ...)] [(y ...) (f value ...)]) #t #t (y ...))])])))Sequences generated by in-nest-sequence do not terminate, so you will want to pair it with either a sequence that does, or a #:break or similar termination condition. For example (using the powers-of-two example in Óscar's answer):;; first ten powers of 2(for/list ((_ (in-range 10)) (x (in-nest-sequence (curry * 2) 1))) x); =&gt; (1 2 4 8 16 32 64 128 256 512);; powers of 2 above 10,000 and below 1,000,000(for/list ((x (in-nest-sequence (curry * 2) 1)) #:when (&gt; x 10000) #:break (&gt; x 1000000)) x); =&gt; (16384 32768 65536 131072 262144 524288);; first power of 2 above 10,000,000(for/first ((x (in-nest-sequence (curry * 2) 1)) #:when (&gt; x 10000000)) x); =&gt; 16777216And here's the Fibonacci sequence example:;; first ten Fibonacci numbers(for/list ((_ (in-range 10)) ((x y) (in-nest-sequence (lambda (a b) (values b (+ a b))) 0 1))) x); =&gt; (0 1 1 2 3 5 8 13 21 34);; first Fibonacci number above 10,000,000(for/first (((x y) (in-nest-sequence (lambda (a b) (values b (+ a b))) 0 1)) #:when (&gt; x 10000000)) x); =&gt; 14930352 Easy, just change the ((not (pair? seq)) 1) to ((not (pair? seq)) 0). Racket has a built-in stream-cons, which you're accidentally calling, instead of cons-stream as you intended to use. Another approach, similar to Óscar's answer in that both are O(n). This one works for any sequences, including lists and vectors!(define (second-lowest seq) (define-values (_ x) (for/fold ((a #f) (b #f)) ((x seq)) (cond ((&lt; x (or a (add1 x))) (values x a)) ((&lt; x (or b (add1 x))) (values a x)) (else (values a b))))) x) If your function just prints the stream contents, and doesn't need to build a string (like Óscar's answer), here's my take on it (uses SRFI 41 streams):(define (print-first-n stream n) (stream-for-each (lambda (delim item) (display delim) (display item)) (stream-cons "" (stream-constant ", ")) (stream-take n stream)))Example:&gt; (define natural (stream-cons 1 (stream-map (lambda (x) (+ x 1)) natural)))&gt; (print-first-n natural 10)1, 2, 3, 4, 5, 6, 7, 8, 9, 10To output to a string (like Óscar's answer), just wrap the whole thing in a string port:(define (print-first-n stream n) (call-with-output-string (lambda (out) (stream-for-each (lambda (delim item) (display delim out) (display item out)) (stream-cons "" (stream-constant ", ")) (stream-take n stream))))) I whipped up a quick solution:(define (tree-&gt;list tree) (let recur ((x tree) (acc '())) (if (null? x) acc (recur (cadr x) (cons (car x) (recur (caddr x) acc))))))Example:&gt; (tree-&gt;list '(16 (8 (2 () ()) (10 () ())) (20 (18 () ()) (30 () ()))))(2 8 10 16 18 20 30)The way this works is that I have an accumulator (acc) which starts as an empty list. Then the recursive function (recur) checks if the current element is empty: if so, then don't change the accumulator; otherwise, recurse into the right-hand branch, then add the current element to the result, then recurse into the left-hand branch with that.cons builds lists right-to-left, hence the recursion into the right-hand branch before the left-hand branch. (Otherwise, the list will come out reversed.) If I were you, I would not convert the string to a list and back. I would just play with the string directly. Here's the solution approach I have in mind:Downcase the string.Find the longest run of initial consonants in the string.If the consonant run is empty, then simply append "yay" to the end of the string.Otherwise, take the substring after the consonant run, then append the consonant run and "ay".If the original string started with an uppercase letter, then titlecase the resulting string. (This means that if the original word were in all-caps, this will do the wrong thing. Too bad. Less shouting for the win.)Here's the code (requires SRFIs 13 and 14):(define vowels (char-set #\a #\e #\i #\o #\u))(define (pig-latin word) (define downcased (string-downcase word)) (define index (string-index downcased vowels)) (define result (if (zero? (or index 0)) (string-append downcased "yay") (string-append (substring downcased index) (substring downcased 0 index) "ay"))) (if (and (not (zero? (string-length word))) (char-upper-case? (string-ref word 0))) (string-titlecase result) result)) (define (slow-popcount n) (do ((n n (quotient n 2)) (count 0 (+ count (modulo n 2)))) ((zero? n) count))) Sadly, grepping through the SCM documentation and sources, it looks like there is no Scheme-level threading library available for SCM.You get to use Guile. :-P (Disclosure: I'm a Guile committer.) To call testFunc, you must use (testFunc arg1 arg2). You must not use (testFunc(arg1 arg2)). Scheme is parenthesis-sensitive; you must not add (or remove) extra parentheses.Likewise, to bunch up the results, you need to use (cons item rest), and not just (item rest).Have you considered using just (map min list1 list2)? It is meaningless. The type of RVO you mentioned is called named RVO (NRVO), and most compilers implement it.Regardless, in C++11, vector has move constructors, so even if NRVO didn't apply, it'd still be moved, not copied. Oops, you're not using the isCopy argument correctly. It should be:jboolean isCopy;jshort* targetArray = env-&gt;GetShortArrayElements(javaArray, &amp;isCopy);That is, isCopy is an "out parameter" (to use C# lingo).If you don't care whether the targetArray is aliased to javaArray, you can also pass nullptr instead, like so:jshort* targetArray = env-&gt;GetShortArrayElements(javaArray, nullptr); If you look at the fold-unit function, you'll see the calls to c1 and c2:(c1 (unit-name u) ; n (fn-for-kind (unit-kind u)) ; x (fn-for-lou (unit-subs u))) ; z(c2 (fn-for-unit (first lou)) ; y (fn-for-lou (rest lou))) ; zIn the case of count-departments, we don't care about the unit name, we just add (in (+ x z) and (+ y z)) the numbers returned by for each unit such that the number is 0 for Faculty (b1), 0 for University (b2), 1 for Department (b3), 0 for Division (b4), using the initial value of 0 (b5). If you think this through, you can see why this returns a count of departments. The canonical C++ way to do what you want to do is to use a std::vector (or std::array if the number of elements is known at compile time). C++ does not use VLAs, as noted in M.M's answer.If the character pointers involved are not going to be dangling (e.g., in your argv case), you can do this:std::vector&lt;char*&gt; f(int n, char** arr){ std::vector&lt;char*&gt; tmp; tmp.reserve(n); for (int i = 0; i &lt; n; ++i) tmp.push_back(arr[i]); return tmp;}If the pointers will dangle, it's better to create std::string objects:std::vector&lt;std::string&gt; f(int n, char** arr){ std::vector&lt;std::string&gt; tmp; tmp.reserve(n); for (int i = 0; i &lt; n; ++i) tmp.emplace_back(arr[i]); return tmp;}(emplace_back is new to C++11. In older C++ versions, you can just use push_back.) Yes, you can create an equals method for your class. For example:public final class Person { private final String name; private final int age; private final int birthMonth; public Person(String name, int age, int birthMonth) { this.name = Objects.requireNonNull(name); this.age = age; this.birthMonth = birthMonth; } @Override public boolean equals(Object o) { if (o instanceof Person) { Person rhs = (Person) o; return name.equals(rhs.name) &amp;&amp; age == rhs.age &amp;&amp; birthMonth == rhs.birthMonth; } return false; } // Any time you override `equals`, you must make a matching `hashCode`. // This implementation of `hashCode` is low-quality, but demonstrates // the idea. @Override public int hashCode() { return name.hashCode() ^ age ^ birthMonth; }} Just add more add instructions:add eax, 300add eax, 400add eax, 500You also have to print out the result somehow, before your exit line. Paths (the bit after the host name) in URLs are case-sensitive. You can use a URL with France.png if you want, as long as you name the file France.png when you upload it to the server. As alluded to in your comment, you defined your own version of stream-cons. This version of stream-cons produces a stream-like object that is not compatible with Racket streams. (That is, stream? returns false for your faux-streams.)If you want to create your own faux-streams, you will need to create your own stream-empty?, stream?, and other stream-related procedures, that work with your streams rather than standard Racket streams. Looks like you're using chicken-iup. Looking at its web page, it looks like it's designed to work with mingw, and not mingw-w64. The "incompatible" libraries are probably because mingw-w64 is designed to link in 64-bit libraries, but the chicken-iup libraries were 32-bit.If you want to use mingw-w64, you probably have to compile CHICKEN yourself. Your new-if is a procedure. Procedure arguments are evaluated before being passed to the procedure. Therefore, your recursive sqrt-iter call is going to be evaluated fully before new-if is called. As Robert Harvey commented, this results in infinite recursion.Your new-if needs to be a macro to function correctly. Something like:(define-syntax new-if (syntax-rules () ((_ predicate then-clause else-clause) (cond (predicate then-clause) (else else-clause))))) Then use: (cons - (cons 'a (cons 3 '()))). That is, don't quote the -. That will use the - procedure rather than symbol.&gt; ((car (cons - (cons 'a (cons 3 '())))) 5 3)2This can be written as a quasiquoted list, as a shorthand:†&gt; ((car `(,- a 3)) 5 3)2† In a quasiquoted datum—that is, using a backquote instead of a quote—anything with a comma in front is unquoted. (A quasiquote with no commas inside is the same as a quote.) All user-defined functions are lambda (or case-lambda) expressions, including the powerset function you're defining. There is no way to avoid it. However, you can hide the lambda identifier by using internal definitions (it's still a lambda behind the scenes!†).With this in mind, here's an implementation (requires Racket or SRFI 1):(define (powerset lst) (define (make-pair x) (list x (cons (car lst) x))) (if (null? lst) '(()) (append-map make-pair (powerset (cdr lst)))))If you're trying to avoid append-map or higher-order functions in general, you could jump through a few hoops to do the same thing:(define (powerset lst) (define (inner next) (if (null? next) '() (cons (car next) (cons (cons (car lst) (car next)) (inner (cdr next)))))) (if (null? lst) '(()) (inner (powerset (cdr lst)))))† An expression like(define (foo bar) baz)is actually expanded into the following equivalent expression:(define foo (lambda (bar) baz)) Mutex is short for mutual exclusion. That means that when one thread takes the job and locks its mutex, other threads are not supposed to touch it, and are in fact supposed to be blocked until the mutex is released (by the thread that locked it).Since you seem to want to operate on the job with multiple threads simultaneously, I have no idea what you're trying to do with the mutex. Until you clarify your use case, I can't suggest a proper alternative for you. :-( Since you're dealing with a small number of values, and since the performance benefits of symbols are evident from your testing, just go with symbols.BTW, you can use map(&amp;:to_sym) instead of map {|x| x.to_sym}. Are you using SRFI 69? Look into hash-table-update!. I like Michael's answer. Here's another alternative: build an array of substrings from right to left, then call Array#join on it. If you have many substrings, this approach is likely to be faster than the String#prepend approach. The procedure for converting a floating-point ("inexact") number to a non-floating-point ("exact") number is inexact-&gt;exact (or exact in R6RS and R7RS).&gt; (inexact-&gt;exact 415458.0)415458 First, create my-library/lang/reader.rkt with the following:#lang s-exp syntax/module-readermy-libraryThen, add the following to my-library.rkt:(provide (all-from-out racket/base))You can read about syntax/module-reader for more details on how to use it. No, you can't just mutate the key in a map or set; that would break future lookups in the map/set.You should use an immutable sorting key for the map, and when updating your objects, remove the item from the map first, then put it back into the map afterwards with the updated sorting key. C strings need to be null-terminated. In order for your program to work correctly, you need to use:char passphrase[] = {'P','R','O','G','\0'}; uselpa's answer has the correct idea. Here's an alternative implementation of the same idea using syntax-case, which is (IMHO) more readable, with slightly better error checking (if extraneous subforms are passed, for example):(define-syntax (if-debug stx) (syntax-case stx () ((_ debug-expr non-debug-expr) (if DEBUGGING #'debug-expr #'non-debug-expr)))) The idiomatic Scheme way to write this function is to use recursion:(define (primes-range from to n) (cond ((&gt;= from to) '()) ((&lt;= n 0) '()) ((prime? from) (cons from (primes-range (+ from 1) to (- n 1)))) (else (primes-range (+ from 1) to n))))You can easily spell this out in English:Base cases:A prime range where the from is equal or greater to to is empty.A prime range where n is 0 or less is empty.Recursive cases:If from is a prime, then the prime range is from, prepended to the result of calling primes-range starting from (+ from 1) and with (- n 1) elements.Otherwise, the result is calling primes-range starting from (+ from 1) (still with n elements). Scheme does not specify specific memory management strategies or layouts. In particular, it is possible to implement Scheme to allocate all call frames on the heap and not use a call stack. In fact, using the heap for call frames makes it easier to implement continuations.Your add_func (which I'll hereafter refer to as add-func in line with the conventional Scheme naming style) is not defined correctly. I presumed that you meant this instead:(define (add-func x) (lambda (y) (+ x y)))Although Scheme does not specify how things are stored in memory, the procedure returned by add-func is most likely stored in the heap, and not associated with any particular call frame. If you're using a LoadingCache, easy: just make your CacheLoader throw an exception if the loaded-in object is too big.If you're using a non-loading cache, then no. There is no facility to veto cache updates. To directly answer your question, you can pass #'(signals ...) (in place of your existing #'signals) to the inner syntax-parse invocation.As a proof of concept, I wrote a syntax-case version of your macro (since I don't know syntax-parse yet). You should be able to adapt the same technique to syntax-parse easily:(define-syntax (define-something outerstx) (define (make-name paramstx) (datum-&gt;syntax outerstx (string-&gt;symbol (apply string-append (map symbol-&gt;string (syntax-&gt;datum paramstx)))))) (define (make-names innerstx) (syntax-case innerstx () (() #'()) (((param ...) rest ...) (with-syntax ((name (make-name #'(param ...))) ((next ...) (make-names #'(rest ...)))) #'(name next ...))))) (syntax-case outerstx () ((_ ((param ...) body ...) ...) (with-syntax (((name ...) (make-names #'((param ...) ...)))) #'(define-values (name ...) (values (lambda (param ...) body ...) ...)))))) def traverse_recurse(root, options) return unless root options[:preorder].call(root.val) if options[:preorder] traverse_recurse(root.left, options) options[:inorder].call(root.val) if options[:inorder] traverse_recurse(root.right, options) options[:postorder].call(root.val) if options[:postorder]enddef traverse_collect(root, type) result = [] traverse_recurse(root, type =&gt; lambda { |val| result.push(val) }) resultenddef preorder_traverse(root) traverse_collect(root, :preorder)enddef inorder_traverse(root) traverse_collect(root, :inorder)enddef postorder_traverse(root) traverse_collect(root, :postorder)end You should not use raw types like ArrayList&lt;ArrayList&gt; but use fully "cooked" types such as ArrayList&lt;ArrayList&lt;String&gt;&gt; (or even better, List&lt;List&lt;String&gt;&gt;).Likewise, instead of HashMap&lt;Integer, ArrayList&gt;, use HashMap&lt;Integer, ArrayList&lt;ArrayList&lt;String&gt;&gt;&gt; (or even better, Map&lt;Integer, List&lt;List&lt;String&gt;&gt;&gt;).If you make these changes, your map.get(1).get(0).get(0) expression will compile correctly. If your program is spending a lot of CPU time in garbage collection, that means that your heap is getting full. Usually this means one of two things:You need to allocate more heap to your program (via -Xmx).Your program is leaking memory.Try the former first. Allocate an insane amount of memory to your program (16GB or more, in your case, based on the graphs I'm looking at). See if you still have the same symptoms.If the symptoms go away, then your program just needed more memory. Otherwise, you have a memory leak. In this case, you need to do some memory profiling. In the JVM, the way this is usually done is to use jmap to generate a heap dump, then use a heap dump analyser (such as jhat or VisualVM) to look at it.(Fair disclosure: I'm the creator of a jhat fork called fasthat.) Yes. Without using a using, if your code throws an exception for any reason before reaching your explicit Dispose call, your object will not get disposed. When you compile with -c, it generates an object (.o) file, not an executable. You need to compile it without -c in order to make an executable file.Larger C++ programs will have more than one .cpp file; for each .cpp file, you would compile using -c to generate their respective .o file. Then you would link these .o files (running g++ without -c) to generate the final executable. If you're using Java 8, you can write this as a one-liner:public static WaterBody mostPowerful(WaterBody[] waterBodies) { return Arrays.stream(waterBodies) .max(Comparator.comparingDouble(WaterBody::getElectricPower)) .orElseThrow(NoSuchElementException::new);}The orElseThrow(NoSuchElementException::new) causes a NoSuchElementException to be thrown if the incoming array is empty (and thus there is no maximum value). If you want to return null instead, use orElse(null). I'd probably use this:public Book(String bookTitle, Map&lt;Integer, String&gt; authors, String bookType, String bookStyle, String isbn, int numberOfPages) throws InvalidDataException { setBookTitle(bookTitle); setAuthors(authors); setType(bookType); setStyle(bookStyle); setISBN(isbn); setNumberOfPages(numberOfPages);}public Book(String bookTitle, Map&lt;Integer, String&gt; authors, String bookType) throws InvalidDataException { this(bookTitle, authors, bookType, null, null, null);}@Overridepublic String toString() { String result = String.format("Book: %s Author(s): %s Genre: %s", getBookTitle(), loopAuthors(), bookType); if (getBookStyle() == null &amp;&amp; getISBN() == null &amp;&amp; getNumberOfPages() == null) return result; return String.format("%s Book Style: %s ISBN-10: %s Number of Pages: %s", result, getBookStyle(), getISBN(), getNumberOfPages());}That way, you don't need a "fully-constructed" flag (seeing as the additional fields have setters and could be called later); the fields are just checked at toString time. Also, I took the liberty of changing your toString method to use String.format, and to be less repetitious. You did violate ODR by defining (as opposed to just declaring) firstname and resultName in the header. What you need to do, to declare them, is to list them as extern in the header file:extern ofstream firstname;extern string resultName;and have the definition (without extern) in the .cpp file.BTW, headers should not use using namespace. Explicitly qualify everything in your header, instead. To solve this, you need to use a recursive function, using labels:(defun make-up-counter () (labels ((new () (let ((n 0)) (lambda (&amp;optional copy) (if copy (new) (incf n)))))) (new)))You can even make it copy the current counter value when copy is true:(defun make-up-counter () (labels ((new (n) (lambda (&amp;optional copy) (if copy (new n) (incf n))))) (new 0)))For the best of both worlds, you can make it create a counter with a specified value if copy is numeric, otherwise just copy the counter value if truthy, else increment:(defun make-up-counter () (labels ((new (n) (lambda (&amp;optional copy) (cond ((numberp copy) (new copy)) (copy (new n)) (t (incf n)))))) (new 0))) PrintStream.println has an overload that takes an Object argument. You can make your println do the same. You had ncount pointing to a db instead of dw or dd, which is why you can't use inc dword ptr [ncount] or inc word ptr [ncount]. You can use inc byte ptr [ncount], though.Alternatively, widen ncount to a dw and use word ptr, or to dd and use dword ptr. Do not use void* for implementing a pimpl, or for much of anything for that matter. It provides no benefits; and has the potential problem where if you static_cast to the wrong type for some reason, you will have undefined behaviour.It's easy to forward-declare your implementation class, as you have in your first example. That is the correct way to implement a pimpl. At the (= nth 1) condition, you skipped the element but did not reset the nth back up to 5 (or whatever the initial value was). That means it stayed at 1 and skipped every element afterwards.To solve this, you will need an inner function that keeps a counter, while still letting you hold on to the initial n. Here's my solution (I chose to count up to n rather than down from n):(define (ndelete lst n) (let recur ((i 1) (rest lst)) (cond ((null? rest) '()) ((= i n) (recur 1 (cdr rest))) (else (cons (car rest) (recur (+ i 1) (cdr rest))))))) This post is about x86 only. Interrupts may work differently in other architectures.There are two kinds of interrupts: hardware interrupts and software interrupts. Hardware interrupts are generated by hardware on your system: for example, the timer, devices (e.g., keyboard input), etc. Software interrupts are generated by code via the int instruction.In both cases, your operating system kernel has to install interrupt handlers that get called when an interrupt is triggered. An interrupt handler for the timer might cause the kernel to task-switch. A software interrupt would usually be for making system calls, as an entry point for user-level code to request functionality from the kernel (e.g., to open a file or read from a file descriptor); interrupts 0x21 (for DOS) and 0x80 (for Unix) are examples of system-call software interrupts.To answer the question, a hardware interrupt would get the attention of the CPU, so to speak, but ultimately the OS kernel has to know what to do with it too, by installing a useful interrupt handler. #include &lt;iomanip&gt;#include &lt;iostream&gt;int main(){ auto balance = 0.0; for (auto i = 0; i &lt; 120; ++i) balance = balance * (1 + 0.075/12) + 100; std::cout &lt;&lt; std::setprecision(7) &lt;&lt; balance &lt;&lt; '\n';} $? is the return code from the last run process. 0 means no error happened. Other values represent some kind of unusual condition.Values 128 and above usually represent some kind of signal. 147 - 128 = 19, which means the program received signal 19 (SIGSTOP on Linux). Now, normally pressing ^Z sends SIGTSTP (a different signal from SIGSTOP), which probably meant that top caught that signal, did some (probably terminal-related) cleanup, and reissued SIGSTOP to actually suspend the program.top also caught SIGINT (which is normally issued after pressing ^C), to do cleanup and exit cleanly (with exit value 0).You can run kill -l to see what all the signal numbers are for the current platform. Note that the numbers are different for different platforms; for example, SIGSTOP is 17 on Darwin and 19 on Linux. &lt;div className="panel-body"&gt; {this.props.children}&lt;/div&gt; You cannot compare strings using ==, but have to use the String.equals method instead. So you'd use something like f_wordcolor[cnt1].equals("BLACK").But even better, use a HashMap to contain the mapping, instead of a giant nest of if/elses:private static final Map&lt;String, Integer&gt; COLORMAP = new HashMap&lt;&gt;();static { COLORMAP.put("BLACK", 0); COLORMAP.put("BROWN", 1); COLORMAP.put("RED", 2); COLORMAP.put("ORANGE", 3); COLORMAP.put("YELLOW", 4); COLORMAP.put("GREEN", 5); COLORMAP.put("BLUE", 6); COLORMAP.put("VIOLET", 7); COLORMAP.put("GREY", 8); COLORMAP.put("WHITE", 9);}/* ... */f_resist[cnt1] = COLORMAP.get(f_wordcolor[cnt1]); With two small changes to your code, I got something to work:I changed return l1 l2 to (return l1 l2) in the first cond branch.I changed con to cons in the bottom line.Good luck! Actually, I believe you've already got the answer you need—you've already got a way to add one dot. That means you have a way to take a black sky—an image—and add a white dot to create a new image. Now, all you need to do is to take that image, and add another white dot to it (using the same approach as you did to add your first white dot), and so on and so forth.That is what is meant by "recursive way" (as mentioned in your question title).Your code (thanks for posting it!) lacks a base case for the recursion. That is why it never exits.Here's a fixed (I hope) version of the code (not tested, but hopefully gets the right idea across):(define (draw-cloudy-sky num-clouds width height) (cond ((zero? num-clouds) (rectangle width height "solid" "skyblue")) (else (place-image (circle 10 "solid" "grey") (random width) (random height) (draw-cloudy-sky (sub1 num-clouds) width height)))) The telling lines from your log are these:configure:44552: checking for libltdlconfigure:44574: gcc -o conftest -g -O2 -I/home/redacted/local/include -L/home/redacted/local/lib conftest.c /home/redacted/local/lib/libltdl.so -L/usr/lib /usr/lib/libdl.so -Wl,-rpath -Wl,/home/redacted/local/lib -Wl,-rpath -Wl,/usr/lib &gt;&amp;5/usr/lib/libdl.so: could not read symbols: File in wrong formatcollect2: ld returned 1 exit statusThat is the only place in your config.log that mentions /usr/lib/libdl.so. My hunch is that your local copy of libtool is misconfigured. There's no reference implementation, but a portable implementation used by many Scheme systems is psyntax. You had too many parentheses. It should be:(defun foo (x y) (format t "X: ~a~%" x) (format t "Y: ~a~%" y))In all Lisp dialects, parentheses are syntactically significant. You cannot add or subtract them willy-nilly. uselpa's answer is correct.† I wanted to expand on what a quoted datum is, a little further, though.As you know, all Scheme programs are internally read in as a syntax tree. In Racket, in particular, you use the read-syntax procedure to do it:&gt; (define stx (with-input-from-string "(foo bar)" read-syntax))&gt; stx#&lt;syntax::1 (foo bar)&gt;You can convert a syntax tree to a datum using syntax-&gt;datum:&gt; (syntax-&gt;datum stx)'(foo bar)quote is a special form, and what it does is return the quoted portion of the syntax tree as a datum. This is why, for many Scheme implementations, your x procedure returns the same object each time: it's returning the same portion of the syntax tree as a datum. (This is an implementation detail, and Scheme implementations are not required to have this behaviour, but it helps explain why you see what you see.)And as uselpa's answer says, list creates a fresh list each time, if the list is non-empty. That's why the result of two separate non-empty invocations of list will always be distinct when compared with eq?.(In Scheme, the empty list is required to be represented as a singleton object. So (eq? '() '()) is guaranteed to be true, as is (eq? (list) '()), (eq? (cdr (list 'foo)) (list)), etc.)† I would not use the phrasing "undefined behaviour" for comparing literals because that's easily confused with the C and C++ meaning of UB, which is nasal demons, and although the result of comparing literals may not be what you expect, it would not cause your program to crash, etc. Modifying literals is nasal demons, of course. It's easy to write one:(define (assoc-all key alist) (filter (lambda (a) (equal? key (car a))) alist)) Use string interpolation; it will make your code much more readable:my_host_shell.inline = "vagrant ssh #{node.vm.hostname} -c \"/usr/sbin/cli -f /tmp/#{script[:script_name]}\"" It sounds like you should run your program as a daemon. Apache Commons Daemon has a jsvc tool that will do that for your program.Note that your program has to be modified to either implement the Daemon interface or implement the init, start, stop, and destroy methods listed on the jsvc page. You can look up the value of a namespace variable using namespace-variable-value. And since your namespace-symbols-set just uses the current namespace, which is also the default namespace for namespace-variable-value, using it is very simple.For example, to invoke the procedure associated with the first item in the list returned by your module-bindings procedure:((namespace-variable-value (car (module-bindings))))Alternatively, specify your preferred namespace as the fourth argument of the namespace-variable-value call. It's "iterative" because it's tail-recursive. That is, it recurses only in tail position (i.e., the code returns to the caller immediately after the recursion, with no other work, so it's safe to just replace the current call frame with the recursive call's).In languages like Scheme, which enforces "proper tail calls", tail recursion is effectively a goto. As Alexis's comment says, in Scheme, loops are written using tail recursion, since Scheme does not have a goto. You have too many parentheses after the else.For what it's worth, almost all instances of "foo is not a procedure" errors I see on Stack Overflow are caused by extraneous parentheses. name, username = /^(.*?)\s*\((.*)\)$/.match('Adam Nguyen (adamnguyen)').captures Are you building a list piecemeal, an item at a time? If so, the idiomatic way to do this is to build the list backward, using cons, and then reversing the final result:(define (map-using-cons-and-reverse f lst) (let loop ((result '()) (rest lst)) (if (null? rest) (reverse result) (loop (cons (f (car rest)) (cdr rest))))))Alternatively, if your list-building is amenable to a "right-fold" recursive approach, that is also idiomatic:(define (map-using-recursion f lst) (let recur ((rest lst)) (if (null? rest) '() (cons (f (car rest)) (recur (cdr rest))))))The above code snippets are just for illustrating the solution approach to take in the general case; for things that are directly implementable using fold, like map, using fold is more idiomatic:(define (map-using-cons-and-reverse f lst) (reverse (foldl (lambda (item result) (cons (f item) result)) '() lst)))(define (map-using-recursion f lst) (foldr (lambda (item result) (cons (f item) result)) '() lst)) It's just a shorthand (longhand ;-)) for the following:(let ((smallest-in-rest (inf (rest l)))) (cond [(&lt; (first l) smallest-in-rest) (first l)] [else smallest-in-rest]))The let should make it clear that we're just storing the result of the (inf (rest l)) so that it only has to be written once in the code, rather than once for each branch of the cond. I haven't studied your code in detail, but I noticed one thing. You had a parameter named cond for both your main function as well as the outer loop. This will shadow the built-in cond macro, which you tried to use in your inner loop.In fact, that alone would explain why your (second-break-cont state) is always called. The cond expression is no longer a macro invocation, but a normal function call, so all expressions inside are evaluated.You should call your parameter something other than cond. Array is not "much like a pointer". Arrays can decay to pointers, but in a non-decaying context, it's still an array with a known size. You should be using itinerary_file.write and itinerary_file.close, not file_name.write and file_name.close.Also, open(file_name, "a") and not open('file_name', "a"), unless you're trying to open a file named file_name instead of itinerary.txt. Your Employee[] employeeInfo = new Employee[9]; creates an array that can hold 9 Employee objects, but each element is initially null. You will need to fill each with a new Employee object. Inside your for loop, do this at the top:employeeInfo[i] = new Employee();You also need to move the break out of the for loop, to the bottom of the case. Otherwise, your program will only input one person's data, not nine people's. Here's how I would write the function in Racket:(define (make-qr-codes texts) (for ((text (in-list texts)) (count (in-naturals))) (qr-code text (format "stringQR~a.png" count))))But, if you're trying to see how to fix your version, here's how I would do it:(define (addqrlist lst) (let loop ((rest lst) (count 0)) (unless (null? rest) (makeQRForMe (car rest) (format "stringQR~a" count)) (loop (cdr rest) (add1 count)))))(Your version mixes the use of car and rest, instead of car and cdr or first and rest. I changed it to use car and cdr consistently. Also, it's more readable to use format instead of string-append plus number-&gt;string.) Your third cond branch condition should be (f (car l) (cadr l)), not (lambda () ...). The lambda expression returns a procedure (which is not invoked), and since all procedures are truthy, the fourth (else) branch is never reached.That is, ((lambda ()(f (car l) (cadr l))) (cons (car l) (sort-f (cdr l) f)))should be((f (car l) (cadr l)) (cons (car l) (sort-f (cdr l) f))) You can always use(if (ordered (car lst)) ...)In Scheme, the only false value is #f. Everything else is considered true. n and m are (I presume) numbers, not procedures. You can't call them. And yet, when you say (n) and (m), that's exactly what you're trying to do. It's equivalent to the expressions n() and m() in JavaScript.Remember, in Scheme, (foo bar baz) is equivalent to the likes of foo(bar, baz) in JS, and (foo) is equivalent to foo(), and ((foo)) is equivalent to foo()(). You cannot add parentheses willy-nilly. You had too many parentheses in the recursive call. Consider the following:(is-word-in-list (x (cdr lst))) is equivalent to isWordInList(x(cdr(lst))) in JavaScript syntax(is-word-in-list x (cdr lst)) is equivalent to isWordInList(x, cdr(lst)) in JavaScript syntaxSee the difference? You have:(print (car (list)))This is invoking the list function, and not using your list parameter. (list) always returns an empty list. (Common Lisp is a "Lisp-2", which means that list in a function-call context refers to a different thing from list in a variable-access context.)To fix, change your code to use:(print (car list))instead. I wrote a post about how let is transformed into lambda behind the scenes, which you may find helpful.According to the expansion described in my post, your code would expand into:((rec (splice l m r) (append (map (lambda (x) (cons m x)) (perm (append l r))) (if (null? r) '() (splice (cons m l) (car r) (cdr r))))) '() (car s) (cdr s))which then expands to:((letrec ((splice (lambda (l m r) (append (map (lambda (x) (cons m x)) (perm (append l r))) (if (null? r) '() (splice (cons m l) (car r) (cdr r))))))) splice) '() (car s) (cdr s)) The easiest way is to use a for comprehension:(for ([item (in-set my-set)]) (displayln item)) You forgot an else in the final clause.Instead, it used list-ref as the condition (which is always truthy, since all procedures are truthy), and evaluated your other two subforms and returned the last one. Hmm. Here's how I'd go about solving this:(define (buildfunc cmds) (define (process cmd value) (cond ((zero? cmd) (* value value)) ((positive? cmd) (+ value cmd)) ((negative? cmd) (* value (- cmd))))) (lambda (n) (foldl process n cmds)))Example usage:&gt; ((buildfunc '(1 0 -2 -3 4)) 4)154Update: you can certainly unroll the foldl into a manual loop, like so:(define (buildfunc cmds) (define (process cmd value) (cond ((zero? cmd) (* value value)) ((positive? cmd) (+ value cmd)) ((negative? cmd) (* value (- cmd))))) (lambda (n) (let loop ((value n) (cmds cmds)) (if (null? cmds) value (loop (process (car cmds) value) (cdr cmds)))))) On Ubuntu, install the libncurses5-dev package to get libncurses.so. (You can discover this by visiting http://packages.debian.org/file:libncurses.so (sadly, this doesn't seem to work for http://packages.ubuntu.com/file:libncurses.so).)You may find other linkage errors if Chez requires other libraries to have development packages installed too. Use the same technique as above. The first branch of your cond in your insertcell function is missing a closing parenthesis. It should be:(defun insertcell (R L) (setq x (list r l)) (cond ((&lt; (car R) (car L)) (setq x (list R L)) (print x) (print (car (car (cdr x))))) ; &lt;- add a closing paren on this line ((&gt; (car R) (car L)) ; &lt;- add a closing paren here too (insertcell R (car (cdr x)))))) On the Mac, the racket executable is /Applications/Racket v6.4/bin/racket (for Racket 6.4, the current version at the time of writing). Unfortunately, it is not possible for shebang lines to refer to interpreters with spaces in the path. So you will need to make a symlink to that. If you want /usr/local/bin/racket to work, then make that a symlink to /Applications/Racket v6.4/bin/racket. append is only for joining two or more lists. Here, though, you're not joining existing lists, but building a list from two elements. For that, use list:(list (car lst) (last lst)) (foldl - 1 '(1 2 3 4 5)) is actually equivalent to (- 5 (- 4 (- 3 (- 2 (- 1 1))))), or, in infix, 5 - (4 - (3 - (2 - (1 - 1)))).Likewise, (foldr - 1 '(1 2 3 4 5)) is actually equivalent to (- 1 (- 2 (- 3 (- 4 (- 5 1))))), or, in infix, 1 - (2 - (3 - (4 - (5 - 1)))). Common Lisp does not have internal define like Scheme does (which is, by the way, syntactic sugar for letrec or letrec*†). The Common Lisp equivalent of letrec is labels, so you can use this:(defun make-cell () (let (local-name) (labels ((local-add-name (name) (setf local-name name)) (me (message) (ecase message (add-name #'local-add-name) (name local-name)))) #'me)))This works as you'd expect (as tested on SBCL):* (defvar *foo* (make-cell))*FOO** (defvar *bar* (make-cell))*BAR** (funcall (funcall *foo* 'add-name) "foo")"foo"* (funcall (funcall *bar* 'add-name) "bar")"bar"* (funcall *foo* 'name)"foo"* (funcall *bar* 'name)"bar"† Here's the letrec version of your code:(define (make-cell) (let ((local-name #f)) (letrec ((local-add-name (lambda (name) (set! local-name name))) (me (lambda (message) (case message ((add-name) local-add-name) ((name) local-name))))) me)))or even:(define (make-cell) (letrec ((local-name #f) (local-add-name (lambda (name) (set! local-name name))) (me (lambda (message) (case message ((add-name) local-add-name) ((name) local-name))))) me)) There's a reason to prefer writing '() to () even if () is self-evaluating. It makes the code easier to read because it's visually obvious that you're dealing with a datum, not an evaluated form.It's similar to the reason to prefer writing '#(foo bar baz (+ 1 2)) to #(foo bar baz (+ 1 2)). Both evaluate to the same thing, but the former makes it visually obvious that the foo, bar, baz, and (+ 1 2) within are not evaluated. (make-vector 4 (make-vector 4 0)) is the same as:(let ((x (make-vector 4 0))) (vector x x x x))That is, (make-vector 4 0) is called only once, and its value is used for all 4 slots of the outer vector.What you need is something like (for/vector ((i 4)) (make-vector 4 0)), which will call (make-vector 4 0) (and create a distinct vector) for each element of the outer vector. Your definition of sqrt will actually cause a stack overflow, because it recurses into itself, not the built-in sqrt. :-PAnyway, in Racket, your definition of sqrt will affect your current module only. It is possible to reimport the built-in sqrt under a different name, and call that from your module-specific sqrt:(require (rename-in racket/base [sqrt racket-sqrt]))(define sqrt (lambda (x) (* 2 (racket-sqrt x))))Note that your code won't affect other modules that don't import your module's sqrt definition; they will continue to use the built-in sqrt. You can get the last character position of a string using string-length (or rather one less than):(string-ref str (sub1 (string-length str)))Note that a character is different from a string of length 1. Thus the correct way to extract a character is with string-ref or the like, rather than substring. To use your example of using (list 1):(define x (let ([tail (list 1)]) (cons tail tail)))An even simpler example:(define x '(())) ; same as: (define x (cons (list) (list)))This relies on the fact that there's only one empty list object (that is, while (eq? (list 1) (list 1)) is always false, (eq? (list) (list)) is always true).On a related note (though somewhat over the top as far as your test goes), did you know you can also make an object x such that (car x) and (cdr x) refer to the same object as x?(define x (call-with-input-string "#0=(#0# . #0#)" read)):-P Here's my version of a syntax-case version of your macro:(define-syntax (lambda-fun stx) (define (count-numeric-literals stx2) (syntax-case stx2 () (num (number? (syntax-&gt;datum #'num)) 1) ((first rest ...) (+ (count-numeric-literals #'first) (count-numeric-literals #'(rest ...)))) (_ 0))) (define (instrument-numeric-literals stx3 n) (syntax-case stx3 () (num (number? (syntax-&gt;datum #'num)) (datum-&gt;syntax #'num (+ (syntax-&gt;datum #'num) n))) ((first rest ...) (with-syntax ((a (instrument-numeric-literals #'first n)) ((b ...) (instrument-numeric-literals #'(rest ...) n))) #'(a b ...))) (x #'x))) (syntax-case stx () ((_ params . body) (let ((count (count-numeric-literals #'body))) (with-syntax ((instrumented (instrument-numeric-literals #'body count))) #'(lambda params . instrumented))))))(define-syntax define-fun (syntax-rules () ((_ (f . params) . body) (define f (lambda-fun params . body))) ((_ . passthrough) (define . passthrough))))This makes use of syntax guards (also known as fenders) to decide whether a syntax datum is numeric or not. For something easier to read, you can use syntax-parse, which allows you to specify syntax classes, like number, instead of using syntax guards:(require (for-syntax syntax/parse))(define-syntax (lambda-fun stx) (define (count-numeric-literals stx2) (syntax-parse stx2 (num:number 1) ((first rest ...) (+ (count-numeric-literals #'first) (count-numeric-literals #'(rest ...)))) (_ 0))) (define (instrument-numeric-literals stx3 n) (syntax-parse stx3 (num:number (datum-&gt;syntax #'num (+ (syntax-&gt;datum #'num) n))) ((first rest ...) (with-syntax ((a (instrument-numeric-literals #'first n)) ((b ...) (instrument-numeric-literals #'(rest ...) n))) #'(a b ...))) (x #'x))) (syntax-parse stx ((_ params . body) (let ((count (count-numeric-literals #'body))) (with-syntax ((instrumented (instrument-numeric-literals #'body count))) #'(lambda params . instrumented))))))Example:&gt; (define-fun (fun) (+ 1 2 3 4))&gt; (fun)26 Why would you allocate MData using new? It's small enough that you can just allocate it in automatic storage, especially since your dataQueue is already defined to hold MData instances by value (and not by pointer). Thus:MData mData{sourceHeight, sourceWidth};dataQueue.push_back(mData); In both Scheme and Common Lisp, #(...) is read syntax for a vector. In this case, it's a vector containing 1 element, the symbol *the-nothing*. Since the question specified that the given stream is infinite:(define (stream-pairs strm) (stream-cons (cons (stream-first strm) (stream-first (stream-rest strm))) (stream-pairs (stream-rest (stream-rest strm)))))(If the stream is not infinite, you need to add an emptiness guard to the front of the function.)Note: If you're using SRFI 41 streams instead of Racket streams, change define to define-stream. In Oracle JDK, the class is called sun.java2d.SunGraphics2D. You can run this program to see what it is in your version of Java:import java.awt.Graphics;import javax.swing.JFrame;public class SwingTest { private static class Frame extends JFrame { @Override public void paint(Graphics g) { super.paint(g); System.out.println(g.getClass().getName()); } } public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); }} This has to do with the way syntax literals work. In particular, a syntax literal is considered matched if:The literal does not have a binding at the point of macro definition, and also does not have a binding at the point of macro usage.The literal has a binding at the point of macro definition, and also has the same binding at the point of macro usage.The define case worked for you because you probably put the define in the same module as the macro. Which means that criterion 2 matched: in has the same binding at both macro definition and usage. But, if you defined the macro in one module (without the define for in), and defined the in in a different module where you are using the macro, things won't work so well. :-)The let case creates a new binding for in. That will never match the binding for in at the top-level macro definition. Try evaluating (square 42). :-) Here's a different solution approach: we tag every returned leaf value with its position in its parent, then filter by the tag:(define (first-values tree) (filter-tag 0 (collect-leaf-values 0 tree)))(define (second-values tree) (filter-tag 1 (collect-leaf-values 0 tree)))Now, the filter-tag and collect-leaf-values functions:(define (filter-tag tag tagged-list) (map cdr (filter (lambda (x) (= (car x) tag)) tagged-list)))(define (leaf? x) (not (pair? x)))(define (collect-leaf-values index tree) (if (leaf? tree) (list (cons index tree)) (append-map collect-leaf-values '(0 1) tree)))SRFI 1 already defines everything necessary at this point. But since you say you're just using plain Scheme, let's define filter and append-map (note that append-map uses any which SRFI 1 also provides—we'll define a simplified version here too):(define (filter pred lst) (cond ((null? lst) '()) ((pred (car lst)) (cons (car lst) (filter pred (cdr lst)))) (else (filter pred (cdr lst)))))(define (any pred lst) (cond ((null? lst) #f) ((pred (car lst)) =&gt; values) (else (any pred (cdr lst)))))(define (append-map func . lists) (let recur ((lists lists)) (if (any null? lists) '() (append (apply func (map car lists)) (recur (map cdr lists)))))) Not tested, but similar idea to what you had:#!/bin/shfile_type() { if [ -f "$1" ]; then echo "file" elif [ -d "$1" ]; then echo "directory" else echo "something else" fi}for i in *; do printf "%s is %s\n" "$i" "$(file_type "$i")"doneThis will display all non-dot files in your current directory. Alternatively, use for i (without the in *) to display all the files listed on the command-line arguments. Short answer: change bl to ebx.Long answer: in x86, the addressing mode you're using is called SIB (scale index base), where the effective address is of the form base + index * scale + displacement, where base and index are general registers like eax, ebx, ecx, or edx, and scale is 1, 2, 4, or 8, and displacement is an immediate number. (Each of these components is optional.)bl isn't one of the registers you can use for the index. Just move the fifties = amount / 50; line after the cin &gt;&gt; amount; line, so that amount has a useful value first. You can use the shebang notation to create a Guile script (the -s is optional in newer versions of Guile):#!/usr/bin/guile -s!#(display "Hello, world!\n")Notice the !# on the second line. Guile treats the #! as the start of a block comment (similar to what #| is in standard Scheme), which has to be terminated using !# (similar to |# in standard Scheme).If you want your script to pass any command-line options to Guile itself, then read about the meta switch. Here's an example of such:#!/usr/bin/guile \-e main -s!#(define (main args) (if (null? (cdr args)) (format #t "Hello, world!~%") (for-each (lambda (name) (format #t "Hello, ~a!~%" name)) (cdr args)))) You cannot mutate literal data, such as '(BUF), and expect sane results. And in your code, the nconc is a mutating operation.In terms of the "why" you're seeing the behaviour you're seeing, it's due to the (setq buf '(BUF)) expression. That sets it to the same object each time, because it's a literal datum—which you're not supposed to mutate with the likes of nconc. If you changed it to (setq buf (list 'BUF)), then it would generate a new object each time, and you can safely nconc that. They are exactly the same. JavaScript strings can be delimited by either single or double quotes. You need to make your factScheme.guile file executable:chmod +x factScheme.guileYour program has other issues: you need to transform the first (non-program-name) argument into a number, and you need to display the result. Thus:(display (factorial (string-&gt;number (cadr args))))P.S. Guile programs typically use a .scm file suffix. This kind of thing would be best served with regular expressions. Racket example:(regexp-match #rx"This (.*) fox is a good (.*) house of legion (.*) town" "This quick brown fox is a good fox in the house of house of legion in our great town")=&gt; ("This quick brown fox is a good fox in the house of house of legion in our great town" "quick brown" "fox in the house of" "in our great")The regexp-match procedure returns a list of capture groups (capture group 0 is the entire input string), or #f if the match failed. pop doesn't do what you think it does. It doesn't modify any lists. It simply rebinds the given variable with the list's cdr.Running (macroexpand '(pop foo)) in Emacs, I get:(car-safe (prog1 foo (setq foo (cdr foo))))Notice the absence of any list-modification functions such as rplaca or rplacd. The general concept is to create a file like .session_aliases which contain your session aliases, then put a line like (notice the spaces around the [, ], and the . before .session_aliases—these are required):[ -f .session_aliases ] &amp;&amp; . .session_aliasesin your .bashrc (or .profile or .bash_profile or whatever). Then you just need to set up a script, run at session logout, which removes .session_aliases.However, a quick search for "xlogout" suggests that there doesn't seem to be a universal script that gets called when you log out of your session. So the answer is going to be display-manager-specific.You didn't mention which display manager you use, so I'm going to assume lightdm (given that that's the standard display manager for Ubuntu and Ubuntu is the most common distribution). You can follow the instructions here to set up a logout script when you end your lightdm session.If you use a different display manager, the procedure will be different. Google is your friend. :-) The displacement is treated as a signed value (yes, two's complement). Also, be sure to wrap around on address overflow. Byte 0x91 is a "smart" opening single quote in Windows-1252 encoding. So it sounds like that's the encoding your file is using, not UTF-8. So, use open(args.csv, 'rU', encoding='windows-1252'). When you use std::vector&lt;long long&gt;(9999999), it has to initialise ~10M long longs. Assuming each long long is 8 bytes long, your program has to zero out 80 MB of memory on the spot. This is not instantaneous.Are you sure you want to use an 80 MB vector? Sounds like a std::unordered_map or std::map (depending on whether you need the keys in order) is a better data structure to use. The code is designed for use as "library code" in a variety of Scheme implementations, including ones where built-in bindings could be redefined. The lets ensure that the original bindings will be used in the library functions, even if the user redefines the top-level bindings later on.For non-library code that you write, you will generally not have to worry about that. Also, if you're using a Scheme implementation with a module system that enforces immutable module bindings (such as Racket), that won't be a concern either. Yes; in fact the standard implementation of reverse is totally tail-recursive.(define (reverse xs) (fold cons '() xs))Don't like using fold? No problem:(define (reverse xs) (do ((result '() (cons (car xs) result)) (xs xs (cdr xs))) ((null? xs) result))) Your numbers variable exists only in the function create_list. You will need to return that variable, and use the return value in your calling code:Thus:def create_list(number_in_list): i = 0 numbers = [] while i &lt; number_in_list: numbers.append(i) i += 1 return numbers # &lt;----And in your main code:numbers = create_list(value) Yes, you must implement deprecated interface methods. However, you are allowed to make them throw UnsupportedOperationException to signal to callers that they're not actually implemented. R is, internally, kind of like Scheme with an S-compatible syntax. A lot of R's internals derive from Scheme concepts, like cons cells and lexical environments.Back in the late 90s, I worked on a new (at the time) serialisation format for R; see my honours project paper, which explains a lot of this. (The email address on that paper isn't valid any more, so don't use that.) Externalizable classes avoid many of the pitfalls of standard Serializable classes, yes. Your class implementation looks fine, at first glance.Thread-safe here means that your code should work properly if multiple threads call writeExternal and readExternal simultaneously (with a different object for each thread). Again, your class implementation doesn't have a problem here. matches always matches the whole input string. If you want to allow substrings to match, use find. The jle in the line after the testl says what happens: if esi is non-positive (0 or less), jump to .L7. You're so close!(define function-3 (lambda (x) (x 3))) Your sub-nat implementation is incorrect and will not type-check. While you can fix that, semantically it's more correct to just use Succ-n in your multiply-nat (just as you do for add-nat), since Succ-n is the Church numeral equivalent of sub1. Here's a corrected (and tested) version of multiply-nat:(define (multiply-nat a b) (cond [(Zero? a) a] [(Zero? b) b] [else (add-nat b (multiply-nat (Succ-n a) b))]))For testing purposes, I also wrote a nat-&gt;number function for converting the Church numerals to actual numerals:(: nat-&gt;number : Nat -&gt; Nonnegative-Integer)(define (nat-&gt;number n) (if (Zero? n) 0 (add1 (nat-&gt;number (Succ-n n))))) Ismail's suggestion of using sort -k is correct. However, I'm often too lazy to learn (or relearn) how -k works, so here's a cheap solution:find . -name 'data*.csv' -print0 | sort -z | xargs -0 wc -lEdit: after some experimentation, I did figure out how -k works:find . -name 'data*.csv' -exec wc -l {} + | sort -k 2 I want to expand on Alexis's excellent answer a bit. Here's an example usage that demonstrates what she means by do being almost identical to your for-loop:(do ([i 0 (add1 i)]) ((&gt;= i 10) i) (println i))This do expression actually expands to the following code:(let loop ([i 0]) (if (&gt;= i 10) i (let () (println i) (loop (add1 i)))))The above version uses a named let, which is considered the conventional way to write loops in Scheme.Racket also provides for comprehensions, also mentioned in Alexis's answer, which are also considered conventional, and here's how it'd look like:(for ([i (in-range 10)]) (println i))(except that this doesn't actually return the final value of i). Femtolisp does provide a do macro. For reference, here's its implementation:(define-macro (do vars test-spec . commands) (let ((loop (gensym)) (test-expr (car test-spec)) (vars (map car vars)) (inits (map cadr vars)) (steps (map (lambda (x) (if (pair? (cddr x)) (caddr x) (car x))) vars))) `(letrec ((,loop (lambda ,vars (if ,test-expr (begin ,@(cdr test-spec)) (begin ,@commands (,loop ,.steps)))))) (,loop ,.inits)))) Most Scheme programmers, including myself, do not like to use define-macro, because it's totally unhygienic. I have no idea why you prefer to use them. With this in mind (that I would not write any define-macro macros myself), I poked around Femtolisp (a Scheme-like implementation that also does not use hygienic macros) for its implementation of cond:(define-macro (cond . clauses) (define (cond-clauses-&gt;if lst) (if (atom? lst) #f (let ((clause (car lst))) (if (or (eq? (car clause) 'else) (eq? (car clause) #t)) (if (null? (cdr clause)) (car clause) (cons 'begin (cdr clause))) (if (null? (cdr clause)) ; test by itself (list 'or (car clause) (cond-clauses-&gt;if (cdr lst))) ; test =&gt; expression (if (eq? (cadr clause) '=&gt;) (if (1arg-lambda? (caddr clause)) ; test =&gt; (lambda (x) ...) (let ((var (caadr (caddr clause)))) `(let ((,var ,(car clause))) (if ,var ,(cons 'begin (cddr (caddr clause))) ,(cond-clauses-&gt;if (cdr lst))))) ; test =&gt; proc (let ((b (gensym))) `(let ((,b ,(car clause))) (if ,b (,(caddr clause) ,b) ,(cond-clauses-&gt;if (cdr lst)))))) (list 'if (car clause) (cons 'begin (cdr clause)) (cond-clauses-&gt;if (cdr lst))))))))) (cond-clauses-&gt;if clauses))Hope it works for you!If what you prefer isn't old-style unhygienic macros, but simply a macro system that lets you play with the incoming form in the raw, many Scheme implementations provide an explicit renaming (ER) macro system, which allows you to manipulate the forms directly and still allow you to maintain hygiene by (as the name implies) explicitly renaming any identifiers that should be protected from shadowing by the macro call site. Here's Chibi Scheme's implementation of cond:(define-syntax cond (er-macro-transformer (lambda (expr rename compare) (if (null? (cdr expr)) (if #f #f) ((lambda (cl) (if (compare (rename 'else) (car cl)) (if (pair? (cddr expr)) (error "non-final else in cond" expr) (cons (rename 'begin) (cdr cl))) (if (if (null? (cdr cl)) #t (compare (rename '=&gt;) (cadr cl))) (list (list (rename 'lambda) (list (rename 'tmp)) (list (rename 'if) (rename 'tmp) (if (null? (cdr cl)) (rename 'tmp) (list (car (cddr cl)) (rename 'tmp))) (cons (rename 'cond) (cddr expr)))) (car cl)) (list (rename 'if) (car cl) (cons (rename 'begin) (cdr cl)) (cons (rename 'cond) (cddr expr)))))) (cadr expr))))))Major Scheme implementations are generally split into two camps in terms of what they use for low-level macros: syntax-case and explicit renaming. Racket, Chez Scheme, Guile, etc. use syntax-case. CHICKEN, MIT Scheme, Chibi Scheme, etc. use explicit renaming. So you won't be able to use the explicit renaming version above in Guile, because it's in the syntax-case camp. Are you trying to create streams? You may wish to consult the (srfi srfi-41) module for an implementation of that. (Disclosure: I wrote the Guile-specific parts of the module code; everything else was ported from the reference implementation.)(use-modules (srfi srfi-41))(define-stream (ints-f n) (stream-cons n (ints-f (1+ n))))Note that define-stream and stream-cons are macros that work together to build the (SRFI 45-style) delay/force behind the scenes.†Usage example:&gt; (stream-&gt;list 10 (ints-f 100))(100 101 102 103 104 105 106 107 108 109)† In particular, your function expands to something like:(define (ints-f n) (lazy (eager (cons (delay n) (lazy (ints-f (1+ n)))))))which you can use using:&gt; (define x (ints-f 100))&gt; (force (car (force x)))100&gt; (force (car (force (cdr (force x)))))101 The count version is probably the most idiomatic (except I'd write it as (count identity items)). Furthermore, the set! version is definitely not idiomatic Racket, and Racket doesn't optimise its use, as you can see from your timing tests.Here are a couple of alternatives for your timing pleasure:Using for comprehensions:(for/sum ((x (in-list items)) #:when x) 1)Manual looping:(let loop ((sum 0) (items items)) (cond ((null? items) sum) ((car items) (loop (add1 sum) (cdr items))) (else (loop sum (cdr items))))) I do miss not having a not= procedure (or ≠ as mentioned in @soegaard's comment), but not for the reasons you think.All the numeric comparison operators are variadic. For example, (&lt; a b c d) is the same as (and (&lt; a b) (&lt; b c) (&lt; c d)). In the case of =, it checks whether all arguments are numerically equal. But there is no procedure to check whether all arguments are all unequal—and that is a different question from whether not all arguments are equal (which is what (not (= a b c d)) checks).Yes, you can simulate that procedure using a fold. But still, meh.Edit: Actually, I just answered my own question in this regard: the reason for the lack of a variadic ≠ procedure is that you can't just implement it using n-1 pairwise comparisons, unlike all the other numeric comparison operators. The straightforward approach of doing n-1 pairwise comparisons would mean that (≠ 1 2 1 2) would return true, and that's not really helpful.I'll leave my original musings in place for context, and for others who wonder similar things. You can still use lists and keep everything functional. :-) Here's my solution:(define (replace-all haystack needles new-needles) (define replace-alist (map cons needles new-needles)) (define (replace-one item) (cond ((assoc item replace-alist) =&gt; cdr) (else item))) (map replace-one haystack))Explanation of the code:First, we build a replacement association list (alist). This is a list of pairs, of which the keys correspond to the needles and the values correspond to new-needles.Then we define a replace-one function that takes an item, and sees if it matches any of the keys in the alist. If so, we return the corresponding value; otherwise, we return the original item.Finally, we map the haystack through replace-one. Yay higher-order functions!Note that this code is O(m*n) where m is the size of haystack and n is the size of needles, which is the same runtime as your version. If needles is large, you will want to use a hashtable instead of an alist, which will amortise the runtime of the function to O(m). You should use:,@(for/list ([i (result-q l)]) `(p ,i))Notice the use of ,@ for splicing unquote, as well as for/list for collecting the results into a list. Assuming the frequencies are all integers:(define (random-item lst) (list-ref lst (random (length lst))))(define (random-item/frequencies lst freqs) (random-item (append-map make-list freqs lst)))If the frequencies involve non-integral quantities, things are a little trickier:(define (random-item/frequencies lst freqs) ; rcfs = reversed cumulative frequencies (define rcfs (foldl (lambda (e r) (cons (+ e (car r)) r)) '(0) freqs)) (define threshold (* (random) (car rcfs))) (for/first ([item (in-list lst)] [cf (in-list (cdr (reverse rcfs)))] #:when (&gt; cf threshold)) item)) Believe it or not, this question is not about custom data types; it's only a framing device, to get students to think about recursion.Fundamentally, recursion is about breaking down a problem into smaller and smaller pieces, until you have the most basic pieces left. In the case of this type checking function, you're confronted with input like (= (&lt; (+ int int) (quotient int int)) (&gt; int int)) and have to reduce it to an output like bool.The way to break it down is to consider that big input like the above as the equivalent of (= A B), where A is (&lt; (+ int int) (quotient int int)), and B is (&gt; int int).Then you break A down into (&lt; C D), where C is (+ int int) and D is (quotient int int). Then you apply the rules as given in the question. In particular, the following rules apply:C = (+ int int) ⇒ intD = (quotient int int) ⇒ intA = (&lt; C D) ⇒ (&lt; int int) ⇒ boolB = (&gt; int int) ⇒ bool(= A B) ⇒ (= bool bool) ⇒ boolSee the steps in reducing the problem smaller and smaller until you get to the most basic pieces (int, real, bool)? That's recursion in a nutshell.I hope this helps you get started on solving the problem. I presume you mean (define one 1) rather than one = 1.In this context, one is an identifier (and not a symbol). An identifier refers to a value, and in this case, the one identifier has the value 1. (Numbers are not symbols or identifiers, by the way.) But it does not always have to be the case. Consider the following:(define one 1)(define (my-function one) (display one))(my-function 42)Although my-function contains the expression (display one), the expression (my-function 42) will actually print 42, because the one here refers to my-function's parameter, not to the top-level one.pi and e are also identifiers, and can be bound to any value. You can, of course, use the following definitions to give them the values you're expecting:(define pi (acos -1))(define e (exp 1))  If n is negative, the nth element from the end is returned.This mimics Ruby-style array index semantics, and can be useful for less verbose code when you need to index from the right-hand side. If you're allowed to use the srfi/1 version of map (which allows uneven input lists, unlike the racket/base version), then it's really easy:(require srfi/1)(define (arithmetic-sequence? lst) (apply = (map - lst (cdr lst))))If you're only able to use racket/list functions, then you'd have to do some list trimming:(define (arithmetic-sequence? lst) (apply = (map - (drop-right lst 1) (cdr lst)))) Racket provides the R6RS division operators via the rnrs/base-6 library, so you can do:(require rnrs/base-6)(mod 370.25 360)&gt; 10.25 This is my implementation of an iterative expmod:(define (expmod base exp mod) (let loop ((base base) (exp exp) (result 1)) (cond ((zero? exp) result) ((odd? exp) (loop base (sub1 exp) (modulo (* result base) mod))) (else (loop (modulo (sqr base) mod) (quotient exp 2) result)))))Tested in Racket with your sample input. You'll need to replace sub1 and sqr with suitable implementations if you're not using Racket.Note that, while you do have to square the base for an even exponent, you can actually mod the result of that, as you can see in my code. So it doesn't get too massive. The sane way to implement - is by using case-lambda, so that the unary, binary, and variadic cases can be handled separately:(define - (case-lambda ((a) (b- 0 a)) ((a b) (b- a b)) ((a b . rest) (apply - (b- a b) rest))))Now, if you don't have case-lambda, then you'll have more work to do:(define (- a . rest) (if (null? rest) (b- 0 a) (let loop ((result a) (rest rest)) (if (null? rest) result (loop (b- result (car rest)) (cdr rest))))))This special-cases unary invocation to negate; otherwise, it iterates, using the first argument as the initial result, and updates the result by subtraction each time. If I understand your question correctly, the environment frames created are as follows:E0 (top-level; context = (define (f a) ...)): f = #&lt;procedure&gt;E1 (parent = E0; context = (f 3)): a = 3E2 (parent = E1; context = (define (g b) ...)): g = #&lt;procedure&gt;E3 (parent = E2; context = (+ a 1)): lhs = 3, rhs = 1E4 (parent = E2; context = inner (g ...)): b = 4E5 (parent = E4; context = (* a b)): lhs = 3, rhs = 4E6 (parent = E2; context = outer (g ...)): b = 12E7 (parent = E6; context = (* a b)): lhs = 3, rhs = 12 Do you know how to use stream-cons? That is probably the easiest way to implement this. Here's my implementation (uses SRFI 41 stream library instead of racket/stream because I'm more familiar with that):(require srfi/41)(define-stream (collapse-spaces strm) (stream-let loop ((was-space #f) (strm strm)) (cond ((stream-null? strm) strm) ((char=? (stream-car strm) #\space) (if was-space (loop #t (stream-cdr strm)) (stream-cons #\space (loop #t (stream-cdr strm))))) (else (stream-cons (stream-car strm) (loop #f (stream-cdr strm)))))))Sample run:&gt; (stream-&gt;list (collapse-spaces (stream #\f #\o #\o #\space #\space #\b #\a #\r)))(#\f #\o #\o #\space #\b #\a #\r) Ruby has support for autovivification for hashes by passing a block to Hash.new:hash = Hash.new { |h, k| h[k] = 42 }hash[:foo] += 1 # =&gt; 43I'd like to implement autovivification for structs, also. This is the best I can come up with:Foo = Struct.new(:bar) do def bar self[:bar] ||= 42 endendfoo = Foo.newfoo.bar += 1 # =&gt; 43and of course, this only autovivifies the named accessor (foo.bar), not the [] form (foo[:bar]). Is there a better way to implement autovivification for structs, in particular one that works robustly for both the foo.bar and foo[:bar] forms? Perhaps you should think about what the flatten function should do, in plain English:Base case: If flattening nil, return an empty list.Base case: If flattening single atoms, return a list containing just that.Recursive case: If flattening pairs, return a list appending the flattening of its car with the flattening of its cdr.Here's how I'd implement the description I just gave:(defun flatten (x) (cond ((null x) x) ((atom x) (list x)) (t (nconc (flatten (car x)) (flatten (cdr x)))))) If you're waiting for a newline character, there's an easy and portable way to do that. Just use getline.If you want to receive other characters without receiving a newline first, then things are less portable. In Unix systems, you'll need to set your terminal to "raw mode". As George's comment mentions, ncurses is an easy way to do this, plus it provides handy functions for drawing things to a specific place in the terminal, receiving arbitrary keys, etc.On Windows, you'll need to use its console interface. This is, of course, not usable outside of Windows.As Neil Butterworth comments, there's also a version of curses that works for Windows, called PDCurses. If you need to write software that works for both Unix and Windows, that's a good option to pursue. Java isn't a functional programming language, and it doesn't provide facilities, such as tail recursion, that would be common in functional programming languages. So I'd say that for Java, prefer iteration in general, but if the iterative solution requires you to (say) manually maintain a stack or something similar, then use recursion. You must actually write such a dynamic escape character parser yourself. Here's a very simple version:char escape(char c){ switch (c) { case 'b': return '\b'; case 't': return '\t'; case 'n': return '\n'; case 'f': return '\f'; case 'r': return '\r'; // Add more cases here default: // perform some error handling} Racket provides a system/exit-code procedure, which is like system but returns the exit code instead of a boolean success indicator. It otherwise behaves exactly like system.In so saying, if all you need to know is whether the command ran successfully, and don't need the actual exit code itself, system is actually sufficient. As the documentation says, it returns true if successful and false otherwise.For example:(with-output-to-string (lambda () (unless (system "ls -la") ;; handle error here ))) That code you have isn't Perl. Here's what might look more like Perl:my $vmVersion = `defaults read '/Applications/VMware Fusion.app/Contents/Info' CFBundleShortVersionString`;if ($vmVersion &gt; 8.4) { print "compliant";} else { print "update required";}Note two things:Version numbers are not floating point numbers. You should really use a semantic version library, such as SemVer, for version comparison.Your messages should probably include newline characters (\n). Without those, when a user runs your program, their prompt will print in a funny location afterwards. :-) Regular expressions do greedy matching (from left to right) by default, backtracking if the greediest match doesn't work. So in the case of \(.*\),\?, the greediest match is to match Hello, to the \(.*\) and nothing to the ,\?.I'm not sure how to do non-greedy matching in basic regular expressions (which is what sed uses). In Perl-style regular expressions (not used by sed), you put a question mark after the matching operator, so you'd use something like (.*?),?.The next best thing you can do is to use something like \([^,]*\),\?, but then it'd stop matching at the first comma it sees. The code snippets below are actual answers, but I did my best to actually explain what's being done so you can disregard the code and write your own thing, if you want to.Converting from the x-graph to the edge-list graph is straightforward. Consider your example: ((x (y z)) (y (z)) (z ())). When you go into the first sublist, you want to generate ((x y) (x z)); when you go into the second sublist, you want to generate ((y z)); and when you go into the third sublist, you want to generate (). You then use append-map to flat-map all those results into a single list.(define (x-graph-&gt;el-graph g) (append-map (lambda (sublist) (define from-node (car sublist)) (define to-nodes (cadr sublist)) (map (lambda (to-node) (list from-node to-node)) to-nodes)) g))Going from edge-list graph to x-graph is probably most easily done using group-by to group the edges by the from-node, then gathering up the to-nodes in each group. However, that will not give you the empty z association (I'll leave that as an exercise for you).(define (el-graph-&gt;x-graph g) (map (lambda (group) (list (caar group) (map cadr group))) (group-by car g eq?))) Consider your input list of (10 (2 (4 (9 (3)) (12 (1 (2))) (16))) (5 (7) (21)) (6)) (called tree in your code).When you recurse with (cdr tree) (as you do in (children elem (cdr tree))), the new tree (in the recursive call) becomes ((2 (4 (9 (3)) (12 (1 (2))) (16))) (5 (7) (21)) (6)). That means (car tree) is (2 (4 (9 (3)) (12 (1 (2))) (16))) (5 (7) (21)) (6). That's not a number.          